---
title: redis.do
description: Redis on the Edge — A fully managed Redis-compatible key-value store running on Cloudflare Workers with native JSON support and time-travel queries.
---

# redis.do

**Redis on the Edge** — A Redis-compatible key-value store that runs entirely on Cloudflare Workers, with native JSON support, time-travel queries, and global distribution.

```typescript
import { Redis } from 'redis.do'

const redis = new Redis('https://your-worker.workers.dev')

// Native JSON - no stringify/parse needed
await redis.set('user:123', { name: 'Alice', age: 30 })
const user = await redis.get('user:123')
console.log(user.name) // 'Alice'
```

<Callout type="info">
Looking for an ioredis-compatible library for testing or migration? See [@dotdo/redis](/docs/integrations/redis/package) for a drop-in replacement.
</Callout>

## Why redis.do?

Traditional Redis requires infrastructure management, connection pooling, and careful regional placement. redis.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** — No servers to manage, no connection limits, no cold starts
- **Global by Default** — Data lives at the edge, close to your users
- **Redis Compatible** — Drop-in replacement for most Redis operations
- **Native JSON** — Store objects directly without serialization overhead
- **Time-Travel** — Query historical values at any point in time
- **Serverless Economics** — Pay only for what you use, scale to zero

## Features

### Core Commands

| Category | Commands |
|----------|----------|
| **Strings** | `GET`, `SET`, `MGET`, `MSET`, `INCR`, `DECR`, `APPEND`, `STRLEN` with full option support (EX, PX, NX, XX) |
| **Hashes** | `HGET`, `HSET`, `HMGET`, `HMSET`, `HGETALL`, `HDEL`, `HINCRBY`, `HSETNX` |
| **Lists** | `LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LRANGE`, `LLEN`, `LINDEX`, `LSET`, `LREM` |
| **Sets** | `SADD`, `SREM`, `SMEMBERS`, `SISMEMBER`, `SCARD`, `SINTER`, `SUNION`, `SDIFF` |
| **Sorted Sets** | `ZADD`, `ZREM`, `ZRANGE`, `ZREVRANGE`, `ZSCORE`, `ZRANK`, `ZCOUNT`, `ZINCRBY` |
| **Keys** | `DEL`, `EXISTS`, `EXPIRE`, `TTL`, `PERSIST`, `KEYS`, `SCAN`, `TYPE`, `RENAME` |
| **Transactions** | `MULTI`, `EXEC`, `DISCARD`, `WATCH`, `PIPELINE` |

### Edge-Native Features

| Feature | Description |
|---------|-------------|
| **Native JSON** | Store and retrieve objects directly without `JSON.stringify` |
| **Time-Travel** | Query values at any historical timestamp |
| **Snapshots** | Create and restore point-in-time snapshots |
| **Pub/Sub** | WebSocket-based real-time messaging |
| **MCP Protocol** | AI agent integration via Model Context Protocol |
| **HTTP API** | REST endpoints for external clients |

### Connectivity

| Feature | Description |
|---------|-------------|
| **HTTP/RPC** | JSON-RPC over HTTP with batching |
| **WebSocket** | Persistent connections for Pub/Sub and real-time |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |

## Installation

```bash
npm install redis.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { RedisEntrypoint, RedisKeyspace } from 'redis.do'

export { RedisKeyspace }
export default RedisEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-redis.do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "REDIS_KEYSPACE", "class_name": "RedisKeyspace" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["RedisKeyspace"] }]
}
```

```bash
npx wrangler deploy
```

### Client Usage

```typescript
import { Redis } from 'redis.do'

const redis = new Redis('https://your-worker.workers.dev')

// Basic operations
await redis.set('key', 'value')
const value = await redis.get('key')

// With expiry
await redis.set('session', { userId: '123' }, { EX: 3600 })

// Native JSON operations
await redis.set('user:123', {
  name: 'Alice',
  email: 'alice@example.com',
  preferences: { theme: 'dark', notifications: true }
})

const user = await redis.get('user:123')
console.log(user.preferences.theme) // 'dark'
```

## Examples

### Native JSON Storage

Unlike traditional Redis, redis.do stores JSON natively:

```typescript
// Traditional Redis requires serialization
await ioredis.set('user', JSON.stringify({ name: 'Alice' }))
const user = JSON.parse(await ioredis.get('user'))

// redis.do handles it natively
await redis.set('user', { name: 'Alice' })
const user = await redis.get('user') // Already an object
```

### Time-Travel Queries

Query values at any point in time:

```typescript
// Set a value
await redis.set('config', { version: 1 })

// Update it
await redis.set('config', { version: 2 })

// Get current value
const current = await redis.get('config') // { version: 2 }

// Get historical value (1 hour ago)
const historical = await redis.getAsOf('config', Date.now() - 3600000)
// { version: 1 }

// Create a snapshot
const snapshotId = await redis.createSnapshot()

// Make more changes
await redis.set('config', { version: 3 })

// Restore to snapshot
await redis.restoreSnapshot(snapshotId)
const restored = await redis.get('config') // { version: 2 }
```

### Real-Time Pub/Sub

WebSocket-based messaging for real-time applications:

```typescript
import { Redis, createSubscriber } from 'redis.do'

// Publisher
const publisher = new Redis(env)
await publisher.publish('notifications', {
  type: 'new-message',
  userId: '123',
  content: 'Hello!'
})

// Subscriber (WebSocket-based)
const subscriber = createSubscriber(env)

subscriber.on('message', (channel, message) => {
  console.log(`[${channel}]`, message)
  // message is already parsed JSON
})

await subscriber.subscribe('notifications')
await subscriber.psubscribe('user:*:events')
```

### Rate Limiting at the Edge

```typescript
import { Redis } from 'redis.do'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const redis = new Redis(env)
    const ip = request.headers.get('CF-Connecting-IP')!

    // Sliding window rate limit
    const key = `rate:${ip}`
    const window = 60 // seconds
    const limit = 100

    const count = await redis.incr(key)
    if (count === 1) {
      await redis.expire(key, window)
    }

    if (count > limit) {
      return new Response('Rate limited', {
        status: 429,
        headers: {
          'Retry-After': String(await redis.ttl(key)),
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': '0',
        }
      })
    }

    return new Response('OK', {
      headers: {
        'X-RateLimit-Limit': String(limit),
        'X-RateLimit-Remaining': String(limit - count),
      }
    })
  }
}
```

### Session Management

```typescript
import { Redis } from 'redis.do'

const redis = new Redis(env)

async function createSession(userId: string): Promise<string> {
  const sessionId = crypto.randomUUID()

  await redis.set(`session:${sessionId}`, {
    userId,
    createdAt: Date.now(),
    lastActivity: Date.now(),
  }, { EX: 86400 }) // 24 hours

  // Track active sessions for user
  await redis.sadd(`user:${userId}:sessions`, sessionId)

  return sessionId
}

async function getSession(sessionId: string) {
  const session = await redis.get(`session:${sessionId}`)
  if (!session) return null

  // Update last activity
  await redis.set(`session:${sessionId}`, {
    ...session,
    lastActivity: Date.now(),
  }, { KEEPTTL: true })

  return session
}

async function destroySession(sessionId: string) {
  const session = await redis.get(`session:${sessionId}`)
  if (session) {
    await redis.srem(`user:${session.userId}:sessions`, sessionId)
    await redis.del(`session:${sessionId}`)
  }
}
```

### Leaderboard with Real-Time Updates

```typescript
import { Redis } from 'redis.do'

const redis = new Redis(env)

async function updateScore(gameId: string, playerId: string, score: number) {
  const key = `leaderboard:${gameId}`

  // Update score (only if higher)
  await redis.zadd(key, { GT: true }, score, playerId)

  // Publish update for real-time listeners
  await redis.publish(`game:${gameId}:scores`, {
    playerId,
    score,
    rank: await redis.zrevrank(key, playerId),
  })
}

async function getLeaderboard(gameId: string, limit = 10) {
  const key = `leaderboard:${gameId}`
  const results = await redis.zrevrange(key, 0, limit - 1, 'WITHSCORES')

  // Parse into structured format
  const leaderboard = []
  for (let i = 0; i < results.length; i += 2) {
    leaderboard.push({
      rank: i / 2 + 1,
      playerId: results[i],
      score: parseFloat(results[i + 1]),
    })
  }
  return leaderboard
}
```

### Distributed Cache with Stale-While-Revalidate

```typescript
import { Redis } from 'redis.do'

const redis = new Redis(env)

interface CacheOptions {
  ttl: number
  staleWhileRevalidate?: number
}

async function cachedFetch<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: CacheOptions
): Promise<T> {
  const cached = await redis.get<{ value: T; fetchedAt: number }>(key)

  if (cached) {
    const age = Date.now() - cached.fetchedAt
    const isStale = age > options.ttl * 1000

    if (!isStale) {
      return cached.value
    }

    // Return stale data while revalidating
    if (options.staleWhileRevalidate && age < (options.ttl + options.staleWhileRevalidate) * 1000) {
      // Revalidate in background (fire and forget)
      fetcher().then(value => {
        redis.set(key, { value, fetchedAt: Date.now() }, { EX: options.ttl + (options.staleWhileRevalidate || 0) })
      })
      return cached.value
    }
  }

  // Cache miss or too stale - fetch fresh data
  const value = await fetcher()
  await redis.set(key, { value, fetchedAt: Date.now() }, {
    EX: options.ttl + (options.staleWhileRevalidate || 0)
  })
  return value
}

// Usage
const user = await cachedFetch(
  `user:${userId}`,
  () => fetchUserFromDatabase(userId),
  { ttl: 60, staleWhileRevalidate: 300 }
)
```

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Client Applications                           │
├─────────────────┬─────────────────┬─────────────────┬───────────────────┤
│   redis.do SDK  │   HTTP/RPC      │   WebSocket     │  Service Binding  │
│   (TypeScript)  │   JSON-RPC      │   Pub/Sub       │  Worker-to-Worker │
├─────────────────┴─────────────────┴─────────────────┴───────────────────┤
│                         redis.do Worker (Edge)                          │
├─────────────────────────────────────────────────────────────────────────┤
│  Command Parser  │  JSON Encoder  │  Time-Travel  │  Pub/Sub Router    │
├─────────────────────────────────────────────────────────────────────────┤
│                      Durable Objects (SQLite Storage)                   │
├──────────────────────────────────────────────────────────────────────────┤
│     RedisKeyspace DO      │            PubSubChannel DO                 │
│   (Key-value storage)     │         (Message routing)                   │
└───────────────────────────┴─────────────────────────────────────────────┘
```

redis.do translates Redis commands to SQLite at runtime:

1. **Command Parsing** — Redis protocol → internal operations
2. **JSON Native** — Objects stored as-is, not stringified
3. **Durable Object Storage** — Each keyspace runs as an isolated Durable Object with SQLite
4. **Edge Execution** — Commands execute at the edge, close to your users
5. **Time-Travel** — All mutations logged for historical queries

## Connectivity Options

### HTTP RPC

```typescript
// Direct HTTP calls
const response = await fetch('https://your-worker.workers.dev/rpc', {
  method: 'POST',
  body: JSON.stringify({
    method: 'get',
    params: ['mykey']
  })
})

// Batch requests
const batch = await fetch('https://your-worker.workers.dev/rpc/batch', {
  method: 'POST',
  body: JSON.stringify([
    { id: '1', method: 'get', params: ['key1'] },
    { id: '2', method: 'set', params: ['key2', 'value2'] },
    { id: '3', method: 'incr', params: ['counter'] }
  ])
})
```

### Service Bindings (Zero Latency)

```typescript
// In your consuming worker
export default {
  async fetch(request: Request, env: Env) {
    const value = await env.REDIS.get('mykey')
    return Response.json({ value })
  }
}
```

### WebSocket for Pub/Sub

```typescript
// Connect to WebSocket endpoint
const ws = new WebSocket('wss://your-worker.workers.dev/pubsub')

ws.onmessage = (event) => {
  const { channel, message } = JSON.parse(event.data)
  console.log(`[${channel}]`, message)
}

// Subscribe to channels
ws.send(JSON.stringify({ type: 'subscribe', channels: ['notifications'] }))
ws.send(JSON.stringify({ type: 'psubscribe', patterns: ['user:*'] }))
```

## Configuration

### Basic Setup

```jsonc
{
  "name": "my-redis",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [
      { "name": "REDIS_KEYSPACE", "class_name": "RedisKeyspace" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["RedisKeyspace"] }
  ]
}
```

### With MCP Protocol

```jsonc
{
  "vars": {
    "MCP_ENABLED": "true"
  },
  "ai": { "binding": "AI" }
}
```

## MCP Protocol (AI Agents)

redis.do includes built-in MCP support for AI agent integration:

```typescript
import { createMcpServer, createAnthropicAdapter } from 'redis.do/mcp'
import Anthropic from '@anthropic-ai/sdk'

const server = createMcpServer({ redis })
const adapter = createAnthropicAdapter({ server })
await adapter.initialize()

const client = new Anthropic()
const response = await client.messages.create({
  model: 'claude-sonnet-4-20250514',
  tools: await adapter.getTools(),
  messages: [{
    role: 'user',
    content: 'Get all sessions for user alice and calculate the average session duration'
  }]
})
```

Available MCP tools:

- `redis_get` - Get value by key
- `redis_set` - Set value with optional expiry
- `redis_keys` - Find keys by pattern
- `redis_hgetall` - Get all hash fields
- `redis_zrange` - Query sorted set ranges

## Development

```bash
# Install dependencies
npm install

# Run tests
npm test

# Build
npm run build

# Local development
npm run dev
```

## Related

- [@dotdo/redis](/docs/integrations/redis/package) - ioredis-compatible library for testing
- [Mongo Integration](/docs/integrations/mongo) - Document database support
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
- [MCP Protocol](/docs/agents/mcp) - AI agent integration
