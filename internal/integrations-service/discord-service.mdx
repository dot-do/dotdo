---
title: discord.do
description: Discord bots on the Edge — A fully managed Discord bot platform running on Cloudflare Workers with persistent state and zero infrastructure.
---

# discord.do

**Discord Bots on the Edge** — A fully managed Discord bot platform that runs entirely on Cloudflare Workers, with persistent state, automatic scaling, and zero infrastructure to manage.

```typescript
import { DiscordBot } from 'discord.do'

export class MyBot extends DiscordBot {
  commands = {
    ping: () => 'Pong!',

    hello: ({ user }) => `Hello, ${user.username}!`,

    stats: async () => {
      const count = await this.storage.get('commandCount') ?? 0
      await this.storage.put('commandCount', count + 1)
      return `Commands run: ${count + 1}`
    }
  }
}
```

<Callout type="info">
Looking for a lightweight package for testing? See [@dotdo/discord](/docs/integrations/discord/package) for a Discord.js-compatible package optimized for edge runtimes.
</Callout>

## Why discord.do?

Traditional Discord bot hosting requires servers, process managers, and careful scaling. discord.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** — No servers to manage, no process managers, no cold starts
- **Global by Default** — Bot runs at the edge, close to Discord's infrastructure
- **Persistent State** — Durable Objects for user preferences, command history, analytics
- **Automatic Scaling** — Handles traffic spikes without configuration
- **Serverless Economics** — Pay only for what you use, scale to zero

## Features

### Core Bot Features

| Feature | Description |
|---------|-------------|
| **Slash Commands** | Declarative command definitions with automatic registration |
| **Message Components** | Buttons, select menus, modals with state management |
| **Embeds** | Rich message formatting with builder patterns |
| **Autocomplete** | Dynamic option suggestions |
| **Context Menus** | User and message context menu commands |

### Platform Features

| Feature | Description |
|---------|-------------|
| **Persistent Storage** | Durable Object-backed state per guild/user |
| **Scheduled Messages** | Cron-triggered messages and reminders |
| **Webhook Management** | Automatic webhook creation and lifecycle |
| **Rate Limiting** | Built-in rate limit handling with queuing |
| **Analytics** | Command usage, response times, error tracking |
| **Multi-Guild** | Isolated state per guild with shared configuration |

### Connectivity

| Feature | Description |
|---------|-------------|
| **Interaction Webhooks** | Primary interaction handling (automatic verification) |
| **Outbound Webhooks** | Send messages to channels without interaction |
| **REST API** | Full Discord API access with rate limiting |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |

## Installation

```bash
npm install discord.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { DiscordBot, DiscordBotEntrypoint } from 'discord.do'

export class MyBot extends DiscordBot {
  // Define slash commands
  commands = {
    ping: () => 'Pong!',

    hello: ({ user, options }) => {
      const name = options.getString('name') ?? user.username
      return `Hello, ${name}!`
    },

    // Async commands with state
    counter: async ({ guild }) => {
      const key = `counter:${guild.id}`
      const count = (await this.storage.get(key) ?? 0) + 1
      await this.storage.put(key, count)
      return `Count: ${count}`
    }
  }

  // Define command metadata
  commandMeta = {
    hello: {
      description: 'Say hello',
      options: [
        { name: 'name', type: 'string', description: 'Name to greet' }
      ]
    }
  }
}

export { MyBot }
export default DiscordBotEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-discord-bot",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "DISCORD_BOT", "class_name": "MyBot" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["MyBot"] }],
  "vars": {
    "DISCORD_PUBLIC_KEY": "your-public-key",
    "DISCORD_CLIENT_ID": "your-client-id"
  }
}
```

```bash
# Set secrets
npx wrangler secret put DISCORD_BOT_TOKEN

# Deploy
npx wrangler deploy

# Register commands
npx discord.do register --global
```

### Configure Discord Application

1. Go to [Discord Developer Portal](https://discord.com/developers/applications)
2. Create or select your application
3. Under "General Information", copy the **Public Key** and **Application ID**
4. Under "Bot", copy the **Bot Token**
5. Under "Installation", set the **Interactions Endpoint URL** to your Worker URL

## Examples

### Stateful Commands

```typescript
import { DiscordBot } from 'discord.do'

export class StatefulBot extends DiscordBot {
  commands = {
    // Track user preferences
    theme: async ({ user, options }) => {
      const theme = options.getString('color')
      if (theme) {
        await this.storage.put(`theme:${user.id}`, theme)
        return `Theme set to ${theme}`
      }
      const current = await this.storage.get(`theme:${user.id}`) ?? 'default'
      return `Current theme: ${current}`
    },

    // Leaderboard with sorted data
    leaderboard: async ({ guild }) => {
      const scores = await this.storage.list({ prefix: `score:${guild.id}:` })
      const sorted = [...scores.entries()]
        .sort(([, a], [, b]) => b - a)
        .slice(0, 10)

      return {
        embeds: [{
          title: 'Leaderboard',
          description: sorted
            .map(([key, score], i) => `${i + 1}. <@${key.split(':')[2]}> - ${score}`)
            .join('\n')
        }]
      }
    }
  }
}
```

### Button Interactions

```typescript
import { DiscordBot, ButtonStyle } from 'discord.do'

export class InteractiveBot extends DiscordBot {
  commands = {
    poll: ({ options }) => {
      const question = options.getString('question', true)
      return {
        content: question,
        components: [{
          type: 1, // Action Row
          components: [
            { type: 2, style: ButtonStyle.Success, label: 'Yes', custom_id: 'poll:yes' },
            { type: 2, style: ButtonStyle.Danger, label: 'No', custom_id: 'poll:no' },
          ]
        }]
      }
    }
  }

  buttons = {
    'poll:yes': async ({ user, message }) => {
      const key = `votes:${message.id}`
      const votes = await this.storage.get(key) ?? { yes: [], no: [] }
      if (!votes.yes.includes(user.id)) {
        votes.yes.push(user.id)
        votes.no = votes.no.filter(id => id !== user.id)
        await this.storage.put(key, votes)
      }
      return {
        type: 'update',
        content: `${message.content}\n\nYes: ${votes.yes.length} | No: ${votes.no.length}`
      }
    },
    'poll:no': async ({ user, message }) => {
      // Similar logic for 'no' votes
    }
  }
}
```

### Modal Forms

```typescript
import { DiscordBot, TextInputStyle } from 'discord.do'

export class FormBot extends DiscordBot {
  commands = {
    feedback: () => ({
      type: 'modal',
      custom_id: 'feedback_form',
      title: 'Submit Feedback',
      components: [
        {
          type: 1,
          components: [{
            type: 4,
            custom_id: 'title',
            label: 'Title',
            style: TextInputStyle.Short,
            required: true,
            max_length: 100
          }]
        },
        {
          type: 1,
          components: [{
            type: 4,
            custom_id: 'description',
            label: 'Description',
            style: TextInputStyle.Paragraph,
            required: true,
            min_length: 10
          }]
        }
      ]
    })
  }

  modals = {
    feedback_form: async ({ user, values }) => {
      const feedback = {
        title: values.title,
        description: values.description,
        userId: user.id,
        timestamp: Date.now()
      }

      await this.storage.put(`feedback:${Date.now()}`, feedback)

      // Notify admin channel
      await this.sendWebhook(env.ADMIN_WEBHOOK, {
        embeds: [{
          title: `New Feedback: ${feedback.title}`,
          description: feedback.description,
          footer: { text: `From ${user.username}` }
        }]
      })

      return { content: 'Thanks for your feedback!', flags: 64 }
    }
  }
}
```

### Scheduled Messages

```typescript
import { DiscordBot } from 'discord.do'

export class ScheduledBot extends DiscordBot {
  commands = {
    remind: async ({ user, options }) => {
      const message = options.getString('message', true)
      const minutes = options.getInteger('minutes', true)

      const reminderId = crypto.randomUUID()
      await this.storage.put(`reminder:${reminderId}`, {
        userId: user.id,
        message,
        triggerAt: Date.now() + minutes * 60000
      })

      // Schedule alarm
      await this.storage.setAlarm(Date.now() + minutes * 60000)

      return `Reminder set for ${minutes} minutes from now!`
    }
  }

  async alarm() {
    const now = Date.now()
    const reminders = await this.storage.list({ prefix: 'reminder:' })

    for (const [key, reminder] of reminders) {
      if (reminder.triggerAt <= now) {
        // Send DM to user
        await this.sendDM(reminder.userId, {
          content: `Reminder: ${reminder.message}`
        })
        await this.storage.delete(key)
      }
    }
  }
}
```

### Autocomplete

```typescript
import { DiscordBot } from 'discord.do'

export class AutocompleteBot extends DiscordBot {
  commands = {
    search: async ({ options }) => {
      const query = options.getString('item', true)
      const item = await this.storage.get(`item:${query}`)
      return item ? `Found: ${item.name}` : 'Item not found'
    }
  }

  commandMeta = {
    search: {
      description: 'Search for an item',
      options: [{
        name: 'item',
        type: 'string',
        description: 'Item to search',
        autocomplete: true
      }]
    }
  }

  autocomplete = {
    'search:item': async ({ value }) => {
      const items = await this.storage.list({ prefix: 'item:' })
      return [...items.entries()]
        .filter(([key, item]) =>
          item.name.toLowerCase().includes(value.toLowerCase())
        )
        .slice(0, 25)
        .map(([key, item]) => ({
          name: item.name,
          value: key.replace('item:', '')
        }))
    }
  }
}
```

## Architecture

```
                                    Discord API
                                        |
                                        v
┌───────────────────────────────────────────────────────────────────────┐
│                         discord.do Worker (Edge)                       │
├───────────────────────────────────────────────────────────────────────┤
│  Interaction Handler  │  Command Router  │  Component Handler          │
├───────────────────────────────────────────────────────────────────────┤
│  Signature Verifier   │  Rate Limiter    │  Analytics Collector        │
├───────────────────────────────────────────────────────────────────────┤
│                       Durable Objects (Per Guild)                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │
│  │   Guild State   │  │   User Prefs    │  │   Command Log   │        │
│  │   (SQLite)      │  │   (SQLite)      │  │   (SQLite)      │        │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘        │
├───────────────────────────────────────────────────────────────────────┤
│              Optional: R2 (Media) │ Vectorize (Search)                 │
└───────────────────────────────────────────────────────────────────────┘
```

discord.do processes Discord interactions at the edge:

1. **Webhook Receipt** — Discord sends interaction to your Worker
2. **Signature Verification** — Automatic cryptographic verification
3. **Command Routing** — Match interaction to handler
4. **State Access** — Durable Object provides per-guild SQLite storage
5. **Response** — Return interaction response to Discord

## Configuration

### Environment Variables

```jsonc
{
  "vars": {
    "DISCORD_PUBLIC_KEY": "your-public-key",
    "DISCORD_CLIENT_ID": "your-client-id",
    "DISCORD_GUILD_ID": "optional-dev-guild-id"
  }
}
```

### Secrets

```bash
# Bot token (required)
npx wrangler secret put DISCORD_BOT_TOKEN

# Optional: webhook for admin notifications
npx wrangler secret put ADMIN_WEBHOOK_URL
```

### With Analytics

```jsonc
{
  "analytics_engine_datasets": [
    { "binding": "ANALYTICS", "dataset": "discord_bot_events" }
  ]
}
```

### With Media Storage

```jsonc
{
  "r2_buckets": [
    { "binding": "MEDIA", "bucket_name": "discord-bot-media" }
  ]
}
```

## CLI Commands

```bash
# Register commands globally
npx discord.do register --global

# Register to development guild (instant)
npx discord.do register --guild <guild-id>

# List registered commands
npx discord.do commands list

# Delete a command
npx discord.do commands delete <command-name>

# Sync permissions
npx discord.do permissions sync

# View analytics
npx discord.do analytics --period 7d
```

## Bot Class API

### Properties

```typescript
class DiscordBot {
  // Durable Object storage
  storage: DurableObjectStorage

  // Environment bindings
  env: Env

  // Current guild ID (if in guild context)
  guildId?: string
}
```

### Methods

```typescript
class DiscordBot {
  // Send message via webhook
  async sendWebhook(url: string, payload: WebhookPayload): Promise<Message>

  // Send DM to user
  async sendDM(userId: string, payload: MessagePayload): Promise<Message>

  // Edit original interaction response
  async editOriginal(token: string, payload: MessagePayload): Promise<Message>

  // Send followup message
  async followup(token: string, payload: MessagePayload): Promise<Message>

  // REST API access
  async rest<T>(method: string, route: string, body?: any): Promise<T>
}
```

### Handler Contexts

```typescript
// Command context
interface CommandContext {
  user: User
  member?: GuildMember
  guild?: Guild
  channel: Channel
  options: OptionAccessor
  token: string
}

// Button context
interface ButtonContext {
  user: User
  member?: GuildMember
  guild?: Guild
  message: Message
  customId: string
  token: string
}

// Modal context
interface ModalContext {
  user: User
  member?: GuildMember
  guild?: Guild
  customId: string
  values: Record<string, string>
  token: string
}
```

## Development

### Local Development

```bash
# Start local dev server
npx wrangler dev

# Use ngrok for Discord webhook testing
ngrok http 8787
# Set the ngrok URL as your Interactions Endpoint in Discord
```

### Testing

```typescript
import { describe, it, expect, vi } from 'vitest'
import { MyBot } from './index'

describe('MyBot', () => {
  it('should respond to ping command', async () => {
    const bot = new MyBot()
    const result = bot.commands.ping()
    expect(result).toBe('Pong!')
  })

  it('should track counter state', async () => {
    const storage = new Map()
    const bot = new MyBot()
    bot.storage = {
      get: (k) => storage.get(k),
      put: (k, v) => storage.set(k, v)
    }

    const ctx = { guild: { id: '123' } }

    expect(await bot.commands.counter(ctx)).toBe('Count: 1')
    expect(await bot.commands.counter(ctx)).toBe('Count: 2')
  })
})
```

## Related

- [@dotdo/discord](/docs/integrations/discord/package) - Lightweight Discord.js-compatible package
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
- [Workflows](/docs/workflows) - Complex multi-step bot flows
- [Slack Integration](/docs/integrations/slack) - Slack bot platform
