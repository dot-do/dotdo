---
title: firebase.do
description: Firebase on the Edge — A fully managed Firebase-compatible database running on Cloudflare Workers with real-time updates and global distribution.
---

# firebase.do

**Firebase on the Edge** — A Firebase-compatible database that runs entirely on Cloudflare Workers, with real-time updates, global distribution, and zero infrastructure to manage.

```typescript
import { initializeApp, getFirestore, collection, addDoc, onSnapshot } from 'firebase.do'

const app = initializeApp({ projectId: 'my-app' })
const db = getFirestore(app)

// It's just Firebase
await addDoc(collection(db, 'users'), { name: 'Alice', email: 'alice@example.com' })

// Real-time updates work globally
onSnapshot(collection(db, 'users'), (snapshot) => {
  console.log('Users:', snapshot.size)
})
```

<Callout type="info">
Looking for an in-memory implementation for testing? See [@dotdo/firebase](/docs/integrations/firebase/package) for a zero-dependency Firebase SDK.
</Callout>

## Why firebase.do?

Traditional Firebase requires Google Cloud infrastructure and has limitations at the edge. firebase.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** - No servers to manage, no connection limits, no cold starts
- **Global by Default** - Data lives at the edge, close to your users in 300+ cities
- **Firebase Compatible** - Drop-in replacement for Firestore and Realtime Database
- **Real-time Native** - Built-in real-time updates via Pusher compat layer
- **Serverless Economics** - Pay only for what you use, scale to zero

## Features

### Firestore

| Feature | Description |
|---------|-------------|
| **CRUD Operations** | `addDoc`, `setDoc`, `getDoc`, `getDocs`, `updateDoc`, `deleteDoc` |
| **Queries** | `where`, `orderBy`, `limit`, `startAt`, `endAt` with 12+ filter operators |
| **Real-time Listeners** | `onSnapshot` for documents and collections with global distribution |
| **Transactions** | `runTransaction` with ACID guarantees |
| **Batch Writes** | `writeBatch` for atomic multi-document operations |
| **Field Values** | `serverTimestamp`, `increment`, `arrayUnion`, `arrayRemove`, `deleteField` |
| **Aggregation** | `getCountFromServer`, `getAggregateFromServer` with `sum`, `average`, `count` |

### Realtime Database

| Feature | Description |
|---------|-------------|
| **CRUD Operations** | `set`, `get`, `update`, `remove`, `push` |
| **Real-time Listeners** | `onValue`, `onChildAdded`, `onChildChanged`, `onChildRemoved`, `onChildMoved` |
| **Queries** | `orderByChild`, `orderByKey`, `orderByValue`, `limitToFirst`, `limitToLast` |
| **Transactions** | `runTransaction` for atomic read-modify-write |
| **Connection State** | `goOnline`, `goOffline` for connection management |

### Edge-Native Features

| Feature | Description |
|---------|-------------|
| **Global Distribution** | Data replicated across Cloudflare's 300+ edge locations |
| **Zero Cold Starts** | Durable Objects maintain warm state |
| **Real-time via Pusher** | Server-side real-time updates using Pusher compat layer |
| **HTTP/RPC** | JSON-RPC over HTTP with batching and request deduplication |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |

## Installation

```bash
npm install firebase.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { FirebaseEntrypoint, FirestoreDO, RealtimeDO } from 'firebase.do'

export { FirestoreDO, RealtimeDO }
export default FirebaseEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-firebase.do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [
      { "name": "FIRESTORE", "class_name": "FirestoreDO" },
      { "name": "REALTIME", "class_name": "RealtimeDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["FirestoreDO", "RealtimeDO"] }
  ]
}
```

```bash
npx wrangler deploy
```

### Local Development

```bash
# Start a local server with SQLite backend
npx firebase.do serve --port 8080

# Use with your app
const app = initializeApp({
  projectId: 'local',
  apiEndpoint: 'http://localhost:8080'
})
```

## Examples

### Firestore CRUD

```typescript
import {
  initializeApp,
  getFirestore,
  collection,
  doc,
  addDoc,
  setDoc,
  getDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
} from 'firebase.do'

const app = initializeApp({ projectId: 'my-app' })
const db = getFirestore(app)

// Add document with auto-generated ID
const docRef = await addDoc(collection(db, 'users'), {
  name: 'Alice',
  email: 'alice@example.com',
  createdAt: new Date(),
})

// Set document with specific ID
await setDoc(doc(db, 'users/bob'), {
  name: 'Bob',
  email: 'bob@example.com',
})

// Query documents
const q = query(
  collection(db, 'users'),
  where('age', '>', 21),
  orderBy('age'),
  limit(10)
)
const snapshot = await getDocs(q)
snapshot.forEach((doc) => {
  console.log(doc.id, '=>', doc.data())
})

// Update document
await updateDoc(doc(db, 'users/alice'), {
  lastLogin: new Date(),
})

// Delete document
await deleteDoc(doc(db, 'users/bob'))
```

### Real-time Listeners

```typescript
import { collection, onSnapshot, addDoc } from 'firebase.do'

// Listen for changes to a collection
const unsubscribe = onSnapshot(
  collection(db, 'messages'),
  (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === 'added') {
        console.log('New message:', change.doc.data())
      }
      if (change.type === 'modified') {
        console.log('Modified message:', change.doc.data())
      }
      if (change.type === 'removed') {
        console.log('Removed message:', change.doc.id)
      }
    })
  }
)

// Changes from anywhere in the world trigger the listener
await addDoc(collection(db, 'messages'), {
  text: 'Hello from the edge!',
  timestamp: new Date(),
})

// Clean up when done
unsubscribe()
```

### Transactions

```typescript
import { doc, setDoc, runTransaction } from 'firebase.do'

// Set up accounts
await setDoc(doc(db, 'accounts/alice'), { balance: 100 })
await setDoc(doc(db, 'accounts/bob'), { balance: 50 })

// Transfer funds atomically
await runTransaction(db, async (transaction) => {
  const aliceRef = doc(db, 'accounts/alice')
  const bobRef = doc(db, 'accounts/bob')

  const aliceSnap = await transaction.get(aliceRef)
  const bobSnap = await transaction.get(bobRef)

  if (!aliceSnap.exists() || !bobSnap.exists()) {
    throw new Error('Account not found')
  }

  const aliceBalance = aliceSnap.data().balance
  const bobBalance = bobSnap.data().balance

  if (aliceBalance < 20) {
    throw new Error('Insufficient funds')
  }

  // Transfer 20 from Alice to Bob
  transaction.update(aliceRef, { balance: aliceBalance - 20 })
  transaction.update(bobRef, { balance: bobBalance + 20 })
})
```

### Batch Writes

```typescript
import { writeBatch, doc, increment } from 'firebase.do'

const batch = writeBatch(db)

// Multiple operations in one atomic batch
batch.set(doc(db, 'users/alice'), { name: 'Alice', role: 'admin' })
batch.set(doc(db, 'users/bob'), { name: 'Bob', role: 'user' })
batch.update(doc(db, 'counters/users'), { count: increment(2) })
batch.delete(doc(db, 'users/charlie'))

// All operations succeed or fail together
await batch.commit()
```

### Realtime Database

```typescript
import {
  initializeApp,
  getDatabase,
  ref,
  set,
  get,
  update,
  push,
  onValue,
  onChildAdded,
} from 'firebase.do'

const app = initializeApp({ projectId: 'my-app' })
const rtdb = getDatabase(app)

// Write data
await set(ref(rtdb, 'users/alice'), {
  name: 'Alice',
  email: 'alice@example.com',
  online: true,
})

// Read data
const snapshot = await get(ref(rtdb, 'users/alice'))
console.log('User:', snapshot.val())

// Push to list with auto-generated key
const newPostRef = push(ref(rtdb, 'posts'))
await set(newPostRef, {
  title: 'My Post',
  content: 'Hello from the edge!',
  timestamp: Date.now(),
})

// Listen for real-time updates
onValue(ref(rtdb, 'users/alice'), (snapshot) => {
  console.log('User updated:', snapshot.val())
})

// Listen for new children
onChildAdded(ref(rtdb, 'posts'), (snapshot) => {
  console.log('New post:', snapshot.key, snapshot.val())
})
```

### Aggregation Queries

```typescript
import {
  collection,
  query,
  where,
  getCountFromServer,
  getAggregateFromServer,
  sum,
  average,
  count,
} from 'firebase.do'

const ordersRef = collection(db, 'orders')

// Count documents matching a query
const activeOrders = query(ordersRef, where('status', '==', 'active'))
const countSnapshot = await getCountFromServer(activeOrders)
console.log('Active orders:', countSnapshot.data().count)

// Multiple aggregations in one query
const statsSnapshot = await getAggregateFromServer(ordersRef, {
  totalRevenue: sum('amount'),
  averageOrder: average('amount'),
  orderCount: count(),
})

const stats = statsSnapshot.data()
console.log('Total revenue:', stats.totalRevenue)
console.log('Average order:', stats.averageOrder)
console.log('Order count:', stats.orderCount)
```

## Architecture

```
+---------------------------------------------------------------------+
|                        Client Applications                           |
+-------------------+-------------------+-------------------+-----------+
|   Firebase SDK    |   HTTP/RPC       |   WebSocket       | Service   |
|   (firebase.do)   |   JSON-RPC       |   Real-time       | Binding   |
+-------------------+-------------------+-------------------+-----------+
                              |
                              v
+---------------------------------------------------------------------+
|                      firebase.do Worker (Edge)                       |
+---------------------------------------------------------------------+
|   Query Translator  |  Transaction Engine  |  Real-time Manager     |
+---------------------------------------------------------------------+
|                    Durable Objects (SQLite Storage)                  |
|            FirestoreDO  |  RealtimeDO  |  AuthDO (Coming Soon)      |
+---------------------------------------------------------------------+
|                         Pusher Compat Layer                          |
|                    (Global Real-time Distribution)                   |
+---------------------------------------------------------------------+
```

firebase.do translates Firebase operations to SQLite at runtime:

1. **Query Translation** - Firebase operators mapped to SQLite SQL with full expression support
2. **Durable Object Storage** - Each project runs as an isolated Durable Object with SQLite
3. **Edge Execution** - Queries execute at the edge, close to your users
4. **Real-time Distribution** - Changes propagate globally via Pusher compat layer

## Connectivity Options

### Firebase SDK

Use the familiar Firebase SDK with firebase.do as the backend:

```typescript
import { initializeApp, getFirestore, collection, addDoc } from 'firebase.do'

const app = initializeApp({
  projectId: 'my-app',
  apiEndpoint: 'https://your-worker.workers.dev',
})
const db = getFirestore(app)

await addDoc(collection(db, 'users'), { name: 'Alice' })
```

### HTTP RPC

```typescript
// Direct HTTP calls
const response = await fetch('https://your-worker.workers.dev/firestore/rpc', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    method: 'addDoc',
    params: {
      collection: 'users',
      data: { name: 'Alice', email: 'alice@example.com' }
    }
  })
})

const result = await response.json()
console.log('Document ID:', result.id)
```

### Service Bindings (Zero Latency)

```typescript
// In your consuming worker
export default {
  async fetch(request: Request, env: Env) {
    const db = env.FIREBASE.getFirestore('my-app')
    const users = await db.collection('users').get()
    return Response.json(users.docs.map(d => d.data()))
  }
}
```

## Configuration

### Basic Setup

```jsonc
// wrangler.jsonc
{
  "name": "my-firebase.do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [
      { "name": "FIRESTORE", "class_name": "FirestoreDO" },
      { "name": "REALTIME", "class_name": "RealtimeDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["FirestoreDO", "RealtimeDO"] }
  ]
}
```

### With Pusher for Real-time

```jsonc
{
  "vars": {
    "PUSHER_APP_ID": "your-app-id",
    "PUSHER_KEY": "your-key",
    "PUSHER_SECRET": "your-secret",
    "PUSHER_CLUSTER": "us2"
  }
}
```

## Real-time Updates

firebase.do uses the Pusher compat layer for real-time updates, enabling server-side real-time that works globally:

```typescript
// Server-side real-time listener
onSnapshot(collection(db, 'notifications'), (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    if (change.type === 'added') {
      sendPushNotification(change.doc.data())
    }
  })
})

// Changes from any edge location trigger listeners everywhere
await addDoc(collection(db, 'notifications'), {
  userId: 'alice',
  message: 'New message!',
  createdAt: new Date(),
})
```

## Local Mode Benefits

- **Zero latency** - No network round-trips
- **No setup** - Works without Firebase project or emulator
- **Predictable** - No external dependencies
- **Testable** - Consistent behavior across test runs
- **Offline** - Works without internet

## Migration from Firebase

### Package Change

```bash
# Keep using firebase SDK syntax
npm install firebase.do
```

### Import Change

```typescript
// Before
import { initializeApp } from 'firebase/app'
import { getFirestore, collection, addDoc } from 'firebase/firestore'
import { getDatabase, ref, set } from 'firebase/database'

// After - same API!
import { initializeApp } from 'firebase.do'
import { getFirestore, collection, addDoc } from 'firebase.do/firestore'
import { getDatabase, ref, set } from 'firebase.do/database'
```

### Code Compatibility

Your existing Firebase code should work unchanged:

```typescript
// This code works with both firebase and firebase.do
const app = initializeApp(config)
const db = getFirestore(app)

const docRef = await addDoc(collection(db, 'users'), {
  name: 'Alice',
  email: 'alice@example.com',
})

const snapshot = await getDoc(docRef)
console.log('User:', snapshot.data())
```

## Related

- [@dotdo/firebase](/docs/integrations/firebase/package) - In-memory Firebase for testing
- [Pusher Integration](/docs/integrations/pusher) - Real-time updates
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
- [Postgres Integration](/docs/integrations/postgres) - SQL database support
