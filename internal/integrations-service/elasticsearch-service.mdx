---
title: elasticsearch.do
description: Elasticsearch on the Edge — A fully managed Elasticsearch-compatible search service running on Cloudflare Workers with vector search and real-time indexing.
---

# elasticsearch.do

**Elasticsearch on the Edge** — An Elasticsearch-compatible search service that runs entirely on Cloudflare Workers, with native vector search, hybrid retrieval, and real-time analytics.

```typescript
import { createClient } from 'elasticsearch.do'

const client = createClient('https://your-worker.workers.dev')

// It's just Elasticsearch
await client.index({
  index: 'products',
  id: '1',
  document: { name: 'MacBook Pro', price: 2499 },
})

const results = await client.search({
  index: 'products',
  query: { match: { name: 'macbook' } },
})
```

<Callout type="info">
Looking for an in-memory implementation for testing? See [@dotdo/elasticsearch](/docs/integrations/elasticsearch/package) for a zero-dependency search engine.
</Callout>

## Why elasticsearch.do?

Traditional Elasticsearch requires JVM infrastructure, cluster management, and careful capacity planning. elasticsearch.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** — No clusters to manage, no JVM tuning, no cold starts
- **Global by Default** — Search indexes live at the edge, close to your users
- **Elasticsearch Compatible** — Drop-in replacement for most Elasticsearch operations
- **AI-Native** — Built-in vector search with Cloudflare Vectorize integration
- **Serverless Economics** — Pay only for what you use, scale to zero

## Features

### Core Search

| Feature | Description |
|---------|-------------|
| **Document Operations** | `index`, `get`, `delete`, `update`, `bulk` with full Elasticsearch API |
| **Query DSL** | `match`, `multi_match`, `bool`, `term`, `range`, `prefix`, `wildcard`, `ids`, `function_score` |
| **Aggregations** | Bucket (terms, histogram, date_histogram, range, filter) + Metric (avg, sum, min, max, stats, percentiles, top_hits) |
| **Highlighting** | Field highlighting with custom pre/post tags |
| **Sorting** | Multi-field sorting with score and field-based ordering |

### Vector & Hybrid Search

| Feature | Description |
|---------|-------------|
| **KNN Search** | k-nearest neighbors with configurable candidates and filtering |
| **Hybrid Search** | Combine BM25 full-text with vector similarity |
| **RRF Ranking** | Reciprocal Rank Fusion for optimal result combination |
| **Auto Embeddings** | Optional automatic embedding generation via Cloudflare AI |
| **Vectorize Integration** | Native Cloudflare Vectorize for scalable vector storage |

### Index Management

| Feature | Description |
|---------|-------------|
| **Index CRUD** | Create, delete, exists, get with mappings and settings |
| **Dynamic Mappings** | Automatic field type detection with explicit override |
| **Index Templates** | Pre-configured mappings for new indexes |
| **Aliases** | Named references for zero-downtime reindexing |
| **Refresh Control** | Immediate or batched refresh for write performance |

### Advanced Features

| Feature | Description |
|---------|-------------|
| **Scroll API** | Efficient pagination for large result sets |
| **Multi-Search** | Batch multiple searches in a single request |
| **Change Webhooks** | Real-time notifications on index changes |
| **HTTP & Service Bindings** | REST API or zero-latency Worker-to-Worker calls |

## Installation

```bash
npm install elasticsearch.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { ElasticsearchEntrypoint, ElasticsearchIndex } from 'elasticsearch.do'

export { ElasticsearchIndex }
export default ElasticsearchEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-elasticsearch.do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "ES_INDEX", "class_name": "ElasticsearchIndex" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["ElasticsearchIndex"] }]
}
```

```bash
npx wrangler deploy
```

### Local Development

```bash
# Start development server
npx wrangler dev

# Or use the standalone CLI
npx elasticsearch.do serve --port 9200
```

## Examples

### Full-Text Search with Highlighting

```typescript
const results = await client.search({
  index: 'articles',
  query: {
    bool: {
      must: [
        { match: { title: 'serverless database' } },
      ],
      filter: [
        { term: { status: 'published' } },
        { range: { publishedAt: { gte: '2024-01-01' } } },
      ],
    },
  },
  highlight: {
    fields: {
      title: { fragment_size: 100 },
      content: { fragment_size: 200, number_of_fragments: 3 },
    },
    pre_tags: ['<mark>'],
    post_tags: ['</mark>'],
  },
  sort: [
    { _score: 'desc' },
    { publishedAt: 'desc' },
  ],
  size: 20,
})
```

### Vector Search with Cloudflare Vectorize

```typescript
// Create index with vector field
await client.indices.create({
  index: 'products',
  mappings: {
    properties: {
      name: { type: 'text' },
      description: { type: 'text' },
      embedding: {
        type: 'dense_vector',
        dims: 1024,
        index: true,
        similarity: 'cosine',
      },
    },
  },
})

// Index with embeddings
await client.index({
  index: 'products',
  id: '1',
  document: {
    name: 'MacBook Pro',
    description: 'Professional laptop for developers',
    embedding: await getEmbedding('Professional laptop for developers'),
  },
})

// Semantic search
const results = await client.search({
  index: 'products',
  knn: {
    field: 'embedding',
    query_vector: await getEmbedding('laptop for coding'),
    k: 10,
    num_candidates: 100,
  },
})
```

### Hybrid Search (BM25 + Vector)

```typescript
const results = await client.search({
  index: 'products',
  query: {
    bool: {
      must: [
        { match: { description: 'laptop professional' } },
      ],
      filter: [
        { term: { category: 'electronics' } },
        { range: { price: { lte: 3000 } } },
      ],
    },
  },
  knn: {
    field: 'embedding',
    query_vector: queryVector,
    k: 50,
    num_candidates: 200,
  },
  rank: {
    rrf: {
      window_size: 100,
      rank_constant: 60,
    },
  },
  size: 10,
})
```

### Aggregations Dashboard

```typescript
const analytics = await client.search({
  index: 'orders',
  size: 0,
  query: {
    range: { createdAt: { gte: 'now-30d' } },
  },
  aggs: {
    revenue_over_time: {
      date_histogram: {
        field: 'createdAt',
        calendar_interval: 'day',
      },
      aggs: {
        daily_revenue: { sum: { field: 'total' } },
        order_count: { value_count: { field: '_id' } },
      },
    },
    top_categories: {
      terms: { field: 'category', size: 10 },
      aggs: {
        category_revenue: { sum: { field: 'total' } },
        avg_order_value: { avg: { field: 'total' } },
      },
    },
    price_distribution: {
      histogram: { field: 'total', interval: 100 },
    },
    stats: {
      stats: { field: 'total' },
    },
  },
})
```

### Auto-Embeddings with Cloudflare AI

```typescript
// Configure auto-embedding in wrangler.jsonc
{
  "ai": { "binding": "AI" },
  "vars": {
    "EMBEDDING_MODEL": "@cf/baai/bge-m3",
    "AUTO_EMBED_FIELDS": "title,description"
  }
}
```

```typescript
// Documents are automatically embedded on index
await client.index({
  index: 'products',
  id: '1',
  document: {
    title: 'Wireless Headphones',
    description: 'Premium noise-cancelling headphones',
    price: 299,
    // embedding field auto-generated from title + description
  },
})

// Search with text query (auto-embedded)
const results = await client.search({
  index: 'products',
  knn: {
    field: 'embedding',
    query_text: 'headphones for focus', // Auto-embedded
    k: 10,
  },
})
```

### Scroll API for Large Results

```typescript
// Initial search with scroll
let response = await client.search({
  index: 'logs',
  scroll: '1m',
  size: 1000,
  query: {
    range: { timestamp: { gte: 'now-7d' } },
  },
})

const allHits = [...response.hits.hits]

// Continue scrolling
while (response.hits.hits.length > 0) {
  response = await client.scroll({
    scroll_id: response._scroll_id,
    scroll: '1m',
  })
  allHits.push(...response.hits.hits)
}

// Clear scroll context
await client.clearScroll({ scroll_id: response._scroll_id })
```

### Index Aliases for Zero-Downtime Reindexing

```typescript
// Create new index with updated mappings
await client.indices.create({
  index: 'products_v2',
  mappings: { /* new schema */ },
})

// Reindex data
await client.reindex({
  source: { index: 'products_v1' },
  dest: { index: 'products_v2' },
})

// Atomic alias swap
await client.indices.updateAliases({
  actions: [
    { remove: { index: 'products_v1', alias: 'products' } },
    { add: { index: 'products_v2', alias: 'products' } },
  ],
})

// Delete old index
await client.indices.delete({ index: 'products_v1' })
```

## Architecture

```
+-----------------------------------------------------------------------+
|                         Client Applications                            |
+---------------+---------------+---------------+-----------------------+
|   HTTP/REST   |  Service      |  WebSocket    |  Elasticsearch        |
|   JSON API    |  Bindings     |  Real-time    |  Wire Protocol        |
+---------------+---------------+---------------+-----------------------+
|                      elasticsearch.do Worker (Edge)                    |
+-----------------------------------------------------------------------+
|  Query Parser  |  BM25 Engine  |  Aggregation  |  KNN Search          |
+-----------------------------------------------------------------------+
|                  Durable Objects (SQLite + FTS5)                       |
+---------------+-------------------------------------------------------+
|   Cloudflare  |              R2 (Large Indexes)                        |
|   Vectorize   |                                                        |
+---------------+-------------------------------------------------------+
```

elasticsearch.do translates Elasticsearch queries to SQLite at runtime:

1. **Query Translation** — Elasticsearch DSL to SQLite SQL with FTS5 for full-text
2. **Durable Object Storage** — Each index runs as an isolated DO with SQLite
3. **Edge Execution** — Queries execute at the edge, close to your users
4. **Vector Integration** — Cloudflare Vectorize for embedding storage and search

## Connectivity Options

### HTTP REST API

```typescript
// Standard Elasticsearch REST API
const response = await fetch('https://your-worker.workers.dev/products/_search', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    query: { match: { name: 'laptop' } },
    size: 10,
  }),
})

// Bulk indexing
await fetch('https://your-worker.workers.dev/_bulk', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-ndjson' },
  body: `
{"index":{"_index":"products","_id":"1"}}
{"name":"Product 1","price":99}
{"index":{"_index":"products","_id":"2"}}
{"name":"Product 2","price":149}
`,
})
```

### Service Bindings (Zero Latency)

```typescript
// In your consuming worker
export default {
  async fetch(request: Request, env: Env) {
    const results = await env.ELASTICSEARCH.search('products', {
      query: { match: { name: 'laptop' } },
    })
    return Response.json(results.hits.hits)
  },
}
```

## Configuration

### With Vector Search

```jsonc
{
  "vectorize": {
    "bindings": [{ "binding": "VECTORIZE", "index_name": "embeddings" }]
  },
  "ai": { "binding": "AI" },
  "vars": {
    "EMBEDDING_MODEL": "@cf/baai/bge-m3",
    "EMBEDDING_DIMS": "1024"
  }
}
```

### With Change Webhooks

```jsonc
{
  "vars": {
    "WEBHOOK_URL": "https://your-app.com/webhooks/search",
    "WEBHOOK_EVENTS": "index,delete,bulk"
  }
}
```

## Performance Tuning

### Write Performance

```typescript
// Disable auto-refresh for bulk operations
await client.bulk({
  operations: [...thousands of docs...],
  refresh: false, // Don't refresh after each batch
})

// Manual refresh when done
await client.indices.refresh({ index: 'products' })
```

### Search Performance

```typescript
// Use source filtering to reduce payload
const results = await client.search({
  index: 'products',
  _source: ['name', 'price'], // Only return needed fields
  query: { match: { name: 'laptop' } },
})

// Use filter context for non-scoring queries
const results = await client.search({
  index: 'products',
  query: {
    bool: {
      filter: [ // Filters don't calculate scores
        { term: { category: 'electronics' } },
        { range: { price: { lte: 1000 } } },
      ],
    },
  },
})
```

## Development

```bash
# Install dependencies
npm install

# Run tests
npm test

# Build
npm run build

# Local development
npm run dev
```

## Related

- [@dotdo/elasticsearch](/docs/integrations/elasticsearch/package) - In-memory Elasticsearch for testing
- [Algolia Integration](/docs/integrations/algolia) - Alternative search service
- [Vector Search](/docs/database/vector) - Semantic similarity search
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
