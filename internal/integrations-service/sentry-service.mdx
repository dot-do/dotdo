---
title: sentry.do
description: Sentry on the Edge — A managed error tracking proxy running on Cloudflare Workers with automatic batching, retries, and edge-optimized delivery.
---

# sentry.do

**Sentry on the Edge** — A managed Sentry-compatible proxy that runs on Cloudflare Workers, optimizing error delivery with automatic batching, intelligent retries, and edge-native features.

```typescript
import * as Sentry from 'sentry.do'

Sentry.init({
  dsn: env.SENTRY_DSN,
  environment: 'production',
  release: 'my-app@1.0.0',
})

// Same Sentry API, edge-optimized delivery
Sentry.captureException(new Error('Production error'))
```

<Callout type="info">
Looking for a local testing solution? See [@dotdo/sentry](/docs/integrations/sentry/package) for an in-memory Sentry SDK with InMemoryTransport.
</Callout>

## Why sentry.do?

Traditional Sentry SDKs send events directly to Sentry's ingestion servers. sentry.do adds an intelligent edge layer:

- **Zero Infrastructure** — No servers to manage, runs on Cloudflare's global network
- **Edge-Optimized Delivery** — Events routed through nearest edge location
- **Automatic Batching** — Multiple events consolidated into single requests
- **Intelligent Retries** — Failed events automatically retried with exponential backoff
- **Rate Limiting** — Protect your Sentry quota with edge-side rate limiting
- **Multi-Tenant Support** — Per-tenant DSN routing and isolation

## Features

### Core Error Tracking

| Feature | Description |
|---------|-------------|
| **Error Capture** | `captureException`, `captureMessage`, `captureEvent` with full stack traces |
| **Context Management** | User, tags, extras, and structured contexts |
| **Breadcrumbs** | Full breadcrumb trail with HTTP, navigation, UI, and query types |
| **Scope Management** | `withScope`, `configureScope`, isolated scope operations |
| **Performance Tracing** | Transactions, spans, and distributed tracing |

### Edge Enhancements

| Feature | Description |
|---------|-------------|
| **Request Batching** | Events batched at the edge before forwarding to Sentry |
| **Smart Retries** | Failed events queued in Durable Objects and retried |
| **Edge Sampling** | Sample rate enforcement at the edge before events leave |
| **PII Scrubbing** | Configurable data scrubbing at the edge layer |
| **Multi-DSN Routing** | Route events to different Sentry projects per tenant |
| **Edge Spans** | Automatic spans for edge processing time |

### Connectivity

| Feature | Description |
|---------|-------------|
| **HTTP Transport** | Standard Sentry envelope format over HTTPS |
| **Service Bindings** | Zero-latency Worker-to-Worker event capture |
| **Durable Queue** | Offline events stored and delivered when connectivity restored |

## Installation

```bash
npm install sentry.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { SentryEntrypoint, SentryCollector } from 'sentry.do'

export { SentryCollector }
export default SentryEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-sentry-proxy",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "SENTRY_COLLECTOR", "class_name": "SentryCollector" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["SentryCollector"] }],
  "vars": {
    "SENTRY_DSN": "https://key@o123.ingest.sentry.io/456"
  }
}
```

```bash
npx wrangler deploy
```

### Use in Your Application

```typescript
import * as Sentry from 'sentry.do'

Sentry.init({
  dsn: env.SENTRY_DSN,
  environment: 'production',
  release: 'my-app@1.0.0',
  tracesSampleRate: 0.1,
})

// Capture errors
try {
  await processOrder(order)
} catch (error) {
  Sentry.captureException(error)
}

// Don't forget to flush in Workers
ctx.waitUntil(Sentry.flush(2000))
```

## Examples

### Cloudflare Worker Error Handling

```typescript
import * as Sentry from 'sentry.do'

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    Sentry.init({
      dsn: env.SENTRY_DSN,
      environment: env.ENVIRONMENT,
      release: env.RELEASE,
    })

    // Set request context
    Sentry.setContext('request', {
      url: request.url,
      method: request.method,
      headers: Object.fromEntries(request.headers),
    })

    try {
      return await handleRequest(request, env)
    } catch (error) {
      Sentry.captureException(error, {
        tags: { handler: 'fetch' },
        extra: { requestId: request.headers.get('cf-ray') },
      })
      ctx.waitUntil(Sentry.flush(2000))
      return new Response('Internal Server Error', { status: 500 })
    }
  },
}
```

### Multi-Tenant Error Routing

```typescript
import * as Sentry from 'sentry.do'

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    const tenant = getTenantFromRequest(request)
    const dsn = await getTenantDSN(tenant, env)

    Sentry.init({
      dsn,
      environment: env.ENVIRONMENT,
      initialScope: {
        tags: { tenant: tenant.id },
      },
    })

    // Errors routed to tenant-specific Sentry project
    try {
      return await handleRequest(request, env, tenant)
    } catch (error) {
      Sentry.captureException(error)
      ctx.waitUntil(Sentry.flush(2000))
      throw error
    }
  },
}
```

### Performance Monitoring

```typescript
import * as Sentry from 'sentry.do'

Sentry.init({
  dsn: env.SENTRY_DSN,
  tracesSampleRate: 0.1, // Sample 10% of transactions
})

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    // Continue trace from incoming request headers
    const transaction = Sentry.continueTrace(
      {
        sentryTrace: request.headers.get('sentry-trace') ?? undefined,
        baggage: request.headers.get('baggage') ?? undefined,
      },
      (traceCtx) => Sentry.startTransaction({
        name: `${request.method} ${new URL(request.url).pathname}`,
        op: 'http.server',
        ...traceCtx,
      })
    )

    try {
      // Database span
      const result = await Sentry.startSpan(
        { name: 'database.query', op: 'db.sql' },
        async (span) => {
          const data = await db.query('SELECT * FROM users')
          span.setData('rowCount', data.length)
          return data
        }
      )

      transaction.setHttpStatus(200)
      return Response.json(result)
    } catch (error) {
      transaction.setHttpStatus(500)
      Sentry.captureException(error)
      throw error
    } finally {
      transaction.finish()
      ctx.waitUntil(Sentry.flush(2000))
    }
  },
}
```

### Edge-Side Data Scrubbing

```typescript
import * as Sentry from 'sentry.do'

Sentry.init({
  dsn: env.SENTRY_DSN,
  beforeSend(event, hint) {
    // Scrub sensitive data at the edge before sending to Sentry
    if (event.user) {
      event.user = {
        id: event.user.id, // Keep ID for debugging
        // Remove PII
        email: undefined,
        ip_address: undefined,
        username: undefined,
      }
    }

    // Remove sensitive headers
    if (event.contexts?.request?.headers) {
      const headers = { ...event.contexts.request.headers }
      delete headers.authorization
      delete headers.cookie
      delete headers['x-api-key']
      event.contexts.request.headers = headers
    }

    // Filter noisy errors
    if (event.exception?.values?.some(v =>
      v.value?.includes('ResizeObserver') ||
      v.value?.includes('Network request failed')
    )) {
      return null // Drop the event
    }

    return event
  },
})
```

### Durable Object Integration

```typescript
import * as Sentry from 'sentry.do'

export class MyDurableObject implements DurableObject {
  constructor(
    private state: DurableObjectState,
    private env: Env
  ) {
    Sentry.init({
      dsn: env.SENTRY_DSN,
      initialScope: {
        tags: {
          component: 'durable-object',
          objectId: state.id.toString(),
        },
      },
    })
  }

  async fetch(request: Request): Promise<Response> {
    const transaction = Sentry.startTransaction({
      name: 'DurableObject.fetch',
      op: 'do.request',
    })

    try {
      // Process request
      const result = await this.processRequest(request)
      transaction.setHttpStatus(200)
      return Response.json(result)
    } catch (error) {
      transaction.setHttpStatus(500)
      Sentry.captureException(error, {
        extra: {
          objectId: this.state.id.toString(),
          requestUrl: request.url,
        },
      })
      throw error
    } finally {
      transaction.finish()
    }
  }
}
```

### Service Binding (Zero Latency)

```typescript
// In your main worker
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    // Use service binding for zero-latency Sentry capture
    const sentry = env.SENTRY_SERVICE

    try {
      return await handleRequest(request, env)
    } catch (error) {
      // Events captured via service binding
      await sentry.captureException(error, {
        context: {
          request: {
            url: request.url,
            method: request.method,
          },
        },
      })
      throw error
    }
  },
}
```

## Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Client Applications                          │
├─────────────────┬─────────────────┬─────────────────────────────────┤
│   HTTP/RPC      │  Service Binding │       WebSocket                 │
│   Sentry API    │  Zero Latency    │       Real-time                 │
├─────────────────┴─────────────────┴─────────────────────────────────┤
│                      sentry.do Worker (Edge)                        │
├─────────────────────────────────────────────────────────────────────┤
│  beforeSend     │  Request Batching │  Rate Limiting │  PII Scrub   │
├─────────────────────────────────────────────────────────────────────┤
│                   Durable Objects (Event Queue)                     │
├─────────────────────────────────────────────────────────────────────┤
│                        Sentry Ingest API                            │
│                   (o123.ingest.sentry.io)                           │
└─────────────────────────────────────────────────────────────────────┘
```

sentry.do acts as an intelligent proxy:

1. **Event Collection** — Receives Sentry events from your application
2. **Edge Processing** — Applies beforeSend hooks, sampling, and PII scrubbing
3. **Request Batching** — Consolidates multiple events into batched requests
4. **Durable Queue** — Stores events in Durable Objects for reliable delivery
5. **Smart Forwarding** — Sends events to Sentry with automatic retries

## Configuration

### Basic Configuration

```jsonc
// wrangler.jsonc
{
  "vars": {
    "SENTRY_DSN": "https://key@o123.ingest.sentry.io/456",
    "SENTRY_ENVIRONMENT": "production",
    "SENTRY_RELEASE": "my-app@1.0.0"
  }
}
```

### With Rate Limiting

```jsonc
{
  "vars": {
    "SENTRY_DSN": "https://key@o123.ingest.sentry.io/456",
    "SENTRY_RATE_LIMIT": "100",           // Max events per minute
    "SENTRY_SAMPLE_RATE": "1.0",          // 100% of errors
    "SENTRY_TRACES_SAMPLE_RATE": "0.1"    // 10% of transactions
  }
}
```

### Multi-Tenant Configuration

```typescript
// src/config.ts
export const tenantDSNs: Record<string, string> = {
  'tenant-a': 'https://key-a@o123.ingest.sentry.io/project-a',
  'tenant-b': 'https://key-b@o123.ingest.sentry.io/project-b',
  'default': 'https://key-default@o123.ingest.sentry.io/default',
}

export function getTenantDSN(tenantId: string): string {
  return tenantDSNs[tenantId] ?? tenantDSNs['default']
}
```

## API Reference

### Initialization

```typescript
Sentry.init(options: SentryOptions): void
```

| Option | Type | Description |
|--------|------|-------------|
| `dsn` | `string` | Sentry DSN (Data Source Name) |
| `environment` | `string` | Environment name (e.g., 'production') |
| `release` | `string` | Release version identifier |
| `sampleRate` | `number` | Error event sample rate (0.0 to 1.0) |
| `tracesSampleRate` | `number` | Transaction sample rate (0.0 to 1.0) |
| `maxBreadcrumbs` | `number` | Maximum breadcrumbs (default: 100) |
| `beforeSend` | `function` | Hook to filter/modify events at edge |
| `initialScope` | `object` | Initial scope configuration |

### Capture Methods

```typescript
// Capture an exception
Sentry.captureException(error: unknown, options?: CaptureOptions): string

// Capture a message
Sentry.captureMessage(message: string, level?: SeverityLevel): string

// Capture a custom event
Sentry.captureEvent(event: SentryEvent): string
```

### Lifecycle

```typescript
// Flush pending events (required in Workers)
await Sentry.flush(timeout?: number): Promise<boolean>

// Close client and flush
await Sentry.close(timeout?: number): Promise<boolean>
```

## Pricing

sentry.do runs on Cloudflare Workers with serverless pricing:

| Resource | Free Tier | Paid |
|----------|-----------|------|
| Requests | 100K/day | $0.50/million |
| Durable Object Storage | 1GB | $0.20/GB-month |
| Durable Object Requests | 1M/month | $0.15/million |

Your Sentry costs remain based on your Sentry plan - sentry.do helps optimize event delivery and can reduce Sentry costs through edge-side sampling and rate limiting.

## Related

- [@dotdo/sentry](/docs/integrations/sentry/package) - In-memory Sentry for testing
- [Observability](/docs/observability) - Full observability stack
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
- [Edge Deployment](/docs/deployment/edge) - Global edge deployment
