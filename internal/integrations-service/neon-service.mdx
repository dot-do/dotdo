---
title: neon.do
description: PostgreSQL on the Edge - A fully managed PostgreSQL-compatible database running on Cloudflare Workers with vector search and AI agent support.
---

# neon.do

**PostgreSQL on the Edge** - A PostgreSQL-compatible database that runs entirely on Cloudflare Workers, with native AI agent support, vector search, and real-time analytics.

```typescript
import { NeonClient } from 'neon.do'

const client = new NeonClient('https://your-neon.workers.dev')
const sql = client.sql('myapp')

// It's just PostgreSQL
await sql`
  INSERT INTO users (name, email)
  VALUES (${'Alice'}, ${'alice@example.com'})
`

const users = await sql`SELECT * FROM users WHERE active = ${true}`
```

<Callout type="info">
Looking for a drop-in replacement for testing? See [@dotdo/neon](/docs/integrations/neon/package) for a zero-dependency PostgreSQL-compatible layer.
</Callout>

## Why neon.do?

Traditional PostgreSQL requires infrastructure management, connection pooling, and careful scaling. neon.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** - No servers to manage, no connection limits, no cold starts
- **Global by Default** - Data lives at the edge, close to your users
- **PostgreSQL Compatible** - SQL template tag, Pool, and Client APIs
- **AI-Native** - Built-in support for AI agents, vector search, and LLM tool calling
- **Serverless Economics** - Pay only for what you use, scale to zero

## Features

### Core Database

| Feature | Description |
|---------|-------------|
| **SQL Template Tag** | Safe, parameterized queries with `` sql`...` `` syntax |
| **Pool/Client API** | pg-compatible connection management |
| **Transactions** | Full ACID transactions with `BEGIN`/`COMMIT`/`ROLLBACK` |
| **DDL Operations** | `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`, indexes |
| **JSON/JSONB** | Native JSON storage and querying |
| **Full-Text Search** | FTS5-powered search with relevance scoring |

### AI and Agents

| Feature | Description |
|---------|-------------|
| **Vector Search** | Semantic similarity search powered by Cloudflare Vectorize |
| **Embeddings** | Automatic embedding generation for text columns |
| **MCP Protocol** | Model Context Protocol server for AI agent integration |
| **$function Operator** | Execute sandboxed JavaScript in queries |

### Connectivity

| Feature | Description |
|---------|-------------|
| **Wire Protocol** | Connect with psql, pgAdmin, and PostgreSQL drivers |
| **HTTP/RPC** | JSON-RPC over HTTP with batching |
| **WebSocket** | Real-time notifications and subscriptions |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |

## Installation

```bash
npm install neon.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { NeonEntrypoint, NeonDatabase } from 'neon.do'

export { NeonDatabase }
export default NeonEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-neon.do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "NEON_DATABASE", "class_name": "NeonDatabase" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["NeonDatabase"] }]
}
```

```bash
npx wrangler deploy
```

### Local Development

```bash
# Start a local server
npx neon.do serve --port 5432

# Connect with psql
psql postgresql://localhost:5432/mydb
```

## Examples

### SQL Template Tag

```typescript
import { NeonClient } from 'neon.do'

const client = new NeonClient('https://your-neon.workers.dev')
const sql = client.sql('mydb')

// Create tables
await sql`
  CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    metadata JSONB DEFAULT '{}'
  )
`

// Insert with interpolation (safe from SQL injection)
const name = 'Alice'
const email = 'alice@example.com'
await sql`INSERT INTO users (name, email) VALUES (${name}, ${email})`

// Query with interpolation
const [user] = await sql`SELECT * FROM users WHERE email = ${email}`

// Transactions
await sql.transaction(async (tx) => {
  await tx`UPDATE accounts SET balance = balance - 100 WHERE id = 1`
  await tx`UPDATE accounts SET balance = balance + 100 WHERE id = 2`
})
```

### Vector Search (Semantic Similarity)

```typescript
// Create a table with vector column
await sql`
  CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT,
    embedding VECTOR(1024)
  )
`

// Create a vector index
await sql`CREATE INDEX documents_embedding_idx ON documents USING hnsw (embedding)`

// Insert with automatic embedding generation
await client.insertWithEmbedding('mydb', 'documents', {
  content: 'Machine learning is a subset of artificial intelligence...'
})

// Semantic search
const results = await client.vectorSearch('mydb', 'documents', {
  query: 'AI and neural networks',
  column: 'embedding',
  limit: 10
})

for (const doc of results) {
  console.log(`${doc.content} (score: ${doc.similarity})`)
}
```

### Full-Text Search

```typescript
// Create a text search index
await sql`CREATE INDEX users_search_idx ON users USING gin (to_tsvector('english', name || ' ' || email))`

// Search with relevance scoring
const results = await sql`
  SELECT *, ts_rank(to_tsvector('english', name || ' ' || email), query) as rank
  FROM users, plainto_tsquery('english', ${'alice developer'}) query
  WHERE to_tsvector('english', name || ' ' || email) @@ query
  ORDER BY rank DESC
  LIMIT 10
`
```

### AI Agent with MCP

```typescript
import { createMcpServer, createAnthropicAdapter } from 'neon.do/mcp'
import Anthropic from '@anthropic-ai/sdk'

const server = createMcpServer({ dbAccess: client })
const adapter = createAnthropicAdapter({ server })
await adapter.initialize()

const anthropic = new Anthropic()
const response = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  tools: await adapter.getTools(),
  messages: [{ role: 'user', content: 'Find all users who signed up this month' }]
})
```

### Pool API (pg-compatible)

```typescript
import { Pool } from 'neon.do'

const pool = new Pool({
  connectionString: 'https://your-neon.workers.dev/mydb',
  max: 20,
})

// Simple query
const { rows } = await pool.query('SELECT * FROM users WHERE active = $1', [true])

// Transaction with client checkout
const poolClient = await pool.connect()
try {
  await poolClient.query('BEGIN')
  await poolClient.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1])
  await poolClient.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2])
  await poolClient.query('COMMIT')
} catch (e) {
  await poolClient.query('ROLLBACK')
  throw e
} finally {
  poolClient.release()
}

await pool.end()
```

### Multi-Tenant Databases

```typescript
import { NeonClient } from 'neon.do'

const client = new NeonClient('https://your-neon.workers.dev')

// Each tenant gets an isolated database
const tenant1 = client.sql('tenant-acme')
const tenant2 = client.sql('tenant-globex')

// Schema is isolated per tenant
await tenant1`CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT)`
await tenant2`CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT, company TEXT)`

// Queries are isolated
await tenant1`INSERT INTO users (name) VALUES ('Alice')`
await tenant2`INSERT INTO users (name, company) VALUES ('Bob', 'Globex')`
```

### Real-Time Notifications

```typescript
import { NeonClient } from 'neon.do'

const client = new NeonClient('https://your-neon.workers.dev')

// Subscribe to changes
const subscription = client.subscribe('mydb', 'users', {
  events: ['INSERT', 'UPDATE', 'DELETE'],
  filter: { active: true }
})

for await (const event of subscription) {
  console.log(`${event.type}: ${JSON.stringify(event.row)}`)
  await notifySubscribers(event)
}
```

## Architecture

```
+---------------------------------------------------------------------------+
|                           Client Applications                              |
+-----------------+-----------------+-----------------+---------------------+
|   PostgreSQL    |   HTTP/RPC      |   WebSocket     |  Service Binding    |
|   Wire Protocol |   JSON-RPC      |   Real-time     |  Worker-to-Worker   |
+-----------------+-----------------+-----------------+---------------------+
|                         neon.do Worker (Edge)                             |
+---------------------------------------------------------------------------+
|  SQL Parser  |  Query Engine  |  Vector Search  |  MCP Server  |  FTS    |
+---------------------------------------------------------------------------+
|                      Durable Objects (SQLite Storage)                     |
+---------------------------+-----------------------------------------------+
|     Vectorize             |           R2 (Large Objects)                  |
|  (Vector Embeddings)      |    (Blobs, Backups, Exports)                  |
+---------------------------+-----------------------------------------------+
```

neon.do translates PostgreSQL queries to SQLite at runtime:

1. **Query Translation** - PostgreSQL syntax -> SQLite with full expression support
2. **Durable Object Storage** - Each database runs as an isolated Durable Object
3. **Edge Execution** - Queries execute at the edge, close to your users
4. **Optional Integrations** - Vectorize for embeddings, R2 for large objects

## Connectivity Options

### Wire Protocol (PostgreSQL Compatible)

Connect using psql, pgAdmin, or any PostgreSQL driver:

```bash
# Local development
npx neon.do serve --port 5432

# Connect with psql
psql postgresql://localhost:5432/mydb

# Connect with pgAdmin
# Host: localhost, Port: 5432, Database: mydb
```

### HTTP RPC

```typescript
// Direct HTTP calls
const response = await fetch('https://your-neon.workers.dev/rpc', {
  method: 'POST',
  body: JSON.stringify({
    method: 'query',
    params: ['mydb', 'SELECT * FROM users WHERE active = $1', [true]]
  })
})

// Batch requests
const batch = await fetch('https://your-neon.workers.dev/rpc/batch', {
  method: 'POST',
  body: JSON.stringify([
    { id: '1', method: 'query', params: ['mydb', 'SELECT * FROM users', []] },
    { id: '2', method: 'query', params: ['mydb', 'SELECT COUNT(*) FROM orders', []] }
  ])
})
```

### Service Bindings (Zero Latency)

```typescript
// In your consuming worker
export default {
  async fetch(request: Request, env: Env) {
    const users = await env.NEON.query('mydb', 'SELECT * FROM users WHERE active = $1', [true])
    return Response.json(users)
  }
}
```

## Configuration

### With Vector Search

```jsonc
{
  "vectorize": {
    "bindings": [{ "binding": "VECTORIZE", "index_name": "embeddings" }]
  },
  "ai": { "binding": "AI" },
  "vars": {
    "EMBEDDING_MODEL": "@cf/baai/bge-m3",
    "EMBEDDING_ENABLED": "true"
  }
}
```

### With R2 Storage (Backups/Large Objects)

```jsonc
{
  "r2_buckets": [
    { "binding": "R2_BACKUPS", "bucket_name": "neon-backups" }
  ]
}
```

## API Reference

### NeonClient

```typescript
new NeonClient(baseUrl: string, options?: NeonClientOptions)
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | `number` | `30000` | Request timeout (ms) |
| `headers` | `object` | `{}` | Default headers |
| `fetch` | `function` | `globalThis.fetch` | Custom fetch |

### NeonClient Methods

| Method | Description |
|--------|-------------|
| `sql(database)` | Get SQL template tag for database |
| `query(db, sql, params?)` | Execute parameterized query |
| `transaction(db, callback)` | Execute transaction |
| `vectorSearch(db, table, options)` | Semantic similarity search |
| `insertWithEmbedding(db, table, data)` | Insert with auto-embedding |
| `subscribe(db, table, options)` | Subscribe to changes |

### SQL Function

```typescript
const sql = client.sql('mydb')
```

| Method | Description |
|--------|-------------|
| `` sql`...` `` | Execute template tag query |
| `sql(text, values?)` | Execute parameterized query |
| `sql.transaction(callback)` | Execute callback in transaction |

### Pool

```typescript
new Pool(config: PoolConfig)
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `connectionString` | `string` | - | neon.do URL with database |
| `max` | `number` | `10` | Maximum connections |
| `idleTimeoutMillis` | `number` | `10000` | Idle timeout |
| `connectionTimeoutMillis` | `number` | `30000` | Connection timeout |

### QueryResult

| Field | Type | Description |
|-------|------|-------------|
| `rows` | `R[]` | Result rows |
| `fields` | `FieldDef[]` | Column definitions |
| `rowCount` | `number` | Rows affected |
| `command` | `string` | SQL command |

## HTTP API Endpoints

neon.do exposes a REST API for external access:

### Query Endpoints

- `POST /rpc` - Execute a single query
- `POST /rpc/batch` - Execute multiple queries

### Database Management

- `GET /databases` - List databases
- `POST /databases` - Create database
- `DELETE /databases/:name` - Delete database

### Health Endpoints

- `GET /` - Service info
- `GET /health` - Health check

## Requirements

- Cloudflare Workers environment
- Durable Objects with SQLite storage enabled
- Node.js 18+ (for local development)

## Development

```bash
# Install dependencies
npm install

# Run locally
npm run dev

# Run tests
npm test

# Type check
npm run typecheck

# Deploy to Cloudflare
npm run deploy
```

## Related

- [@dotdo/neon](/docs/integrations/neon/package) - Drop-in replacement for testing
- [PostgreSQL Integration](/docs/integrations/postgres) - pg API with EdgePostgres
- [Vector Search](/docs/database/vector) - Semantic similarity search
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
