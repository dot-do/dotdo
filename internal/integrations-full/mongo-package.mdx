---
title: "@dotdo/mongodb"
description: MongoDB-compatible in-memory document store for edge environments and testing.
---

# @dotdo/mongodb

MongoDB-compatible document store that runs entirely in-memory. Provides a familiar MongoDB API for edge environments (Cloudflare Workers) and testing scenarios where no external database is needed.

```typescript
import { DocumentStore } from '@dotdo/mongodb'

const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

await users.insertOne({ name: 'Alice', age: 30 })

const adults = await users.find({ age: { $gte: 18 } }).toArray()
```

<Callout type="info">
Looking for persistent storage? See [mongo.do](/docs/integrations/mongo/service) for a fully managed MongoDB-compatible edge database.
</Callout>

## Why @dotdo/mongodb?

| MongoDB Driver | @dotdo/mongodb |
|----------------|----------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Requires MongoDB server | In-memory, no external dependencies |
| Network latency | Zero latency |
| Connection management | Stateless, instant startup |
| Complex test setup | Perfect for unit tests |

**This is an in-memory implementation** with a MongoDB-compatible API. Data does not persist between restarts. Ideal for testing, prototyping, and edge environments where you need document storage without external dependencies.

## Installation

```bash
npm install @dotdo/mongodb
```

## Features

### Implemented (Core APIs)

**Collections**
- `insertOne()`, `insertMany()` - Insert documents
- `findOne()`, `find()` - Query documents with cursor support
- `updateOne()`, `updateMany()`, `replaceOne()` - Update documents
- `deleteOne()`, `deleteMany()` - Remove documents
- `findOneAndUpdate()`, `findOneAndDelete()`, `findOneAndReplace()` - Atomic operations
- `countDocuments()`, `estimatedDocumentCount()` - Count operations
- `distinct()` - Get distinct values

**Query Operators**
- Comparison: `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`, `$in`, `$nin`
- Logical: `$and`, `$or`, `$nor`, `$not`
- Element: `$exists`, `$type`
- Evaluation: `$regex`
- Array: `$all`, `$elemMatch`, `$size`

**Update Operators**
- Field: `$set`, `$unset`, `$inc`, `$mul`, `$min`, `$max`, `$setOnInsert`, `$currentDate`
- Array: `$push`, `$pull`, `$addToSet`, `$pop`
- Modifiers: `$each` (for `$push` and `$addToSet`)

**Aggregation Pipeline**
- `$match` - Filter documents
- `$group` - Group with accumulators (`$sum`, `$avg`, `$min`, `$max`, `$first`, `$last`, `$push`, `$addToSet`, `$count`)
- `$project` - Shape output documents
- `$sort` - Order results
- `$limit`, `$skip` - Pagination
- `$unwind` - Deconstruct arrays
- `$count` - Count documents
- `$addFields`, `$set` - Add computed fields
- `$facet` - Multiple pipelines
- `$bucket` - Categorize into buckets
- `$replaceRoot`, `$replaceWith` - Replace documents
- `$sample` - Random selection

**Indexes**
- Single field indexes
- Compound indexes
- Unique indexes
- Text indexes with BM25 scoring
- Sparse indexes

### Not Yet Implemented

- `$lookup` (cross-collection joins)
- `$graphLookup` (recursive lookups)
- `$geoNear`, `$geoWithin` (geospatial)
- `$merge`, `$out` (output stages)
- Change streams
- Transactions
- Sharding

## Quick Start

### Basic Usage

```typescript
import { DocumentStore, ObjectId } from '@dotdo/mongodb'

// Create a document store
const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

// Insert documents
const result = await users.insertOne({
  name: 'Alice',
  email: 'alice@example.com',
  age: 30,
  createdAt: new Date(),
})

console.log('Inserted:', result.insertedId)

// Find documents
const user = await users.findOne({ email: 'alice@example.com' })
console.log('Found:', user?.name)

// Update documents
await users.updateOne(
  { _id: result.insertedId },
  { $set: { age: 31 }, $inc: { loginCount: 1 } }
)

// Delete documents
await users.deleteOne({ _id: result.insertedId })
```

### Query with Operators

```typescript
// Find adults in specific cities
const results = await users.find({
  age: { $gte: 18 },
  city: { $in: ['NYC', 'LA', 'SF'] },
  $or: [
    { status: 'active' },
    { createdAt: { $gt: new Date('2024-01-01') } }
  ]
}).toArray()

// Using cursor methods
const cursor = users.find({ status: 'active' })
  .sort({ createdAt: -1 })
  .skip(10)
  .limit(20)
  .project({ name: 1, email: 1 })

for await (const doc of cursor) {
  console.log(doc.name)
}
```

### Aggregation Pipeline

```typescript
// Group users by city and calculate stats
const stats = await users.aggregate([
  { $match: { status: 'active' } },
  { $group: {
    _id: '$city',
    count: { $sum: 1 },
    avgAge: { $avg: '$age' },
    names: { $push: '$name' }
  }},
  { $sort: { count: -1 } },
  { $limit: 10 }
]).toArray()

// Multi-facet aggregation
const facets = await users.aggregate([
  { $facet: {
    byCity: [
      { $group: { _id: '$city', count: { $sum: 1 } } }
    ],
    byAge: [
      { $bucket: {
        groupBy: '$age',
        boundaries: [0, 18, 30, 50, 100],
        default: 'Other'
      }}
    ],
    recent: [
      { $sort: { createdAt: -1 } },
      { $limit: 5 },
      { $project: { name: 1, createdAt: 1 } }
    ]
  }}
]).toArray()
```

### Index Management

```typescript
// Create indexes
await users.createIndex({ email: 1 }, { unique: true })
await users.createIndex({ city: 1, age: -1 })
await users.createIndex({ bio: 'text' })

// List indexes
const indexes = await users.indexes()
console.log(indexes)

// Check if index exists
const hasEmailIndex = await users.indexExists('email_1')
```

## Type-Safe Collections

```typescript
interface User {
  name: string
  email: string
  age: number
  tags?: string[]
}

// Type-safe collection
const users = db.collection<User>('users')

// TypeScript knows the document shape
await users.insertOne({
  name: 'Alice',
  email: 'alice@example.com',
  age: 30,
}) // Type-checked

const user = await users.findOne({ name: 'Alice' })
// user is WithId<User> | null
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { DocumentStore } from '@dotdo/mongodb'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const store = new DocumentStore()
    const db = store.db('api')
    const users = db.collection('users')

    const url = new URL(request.url)

    if (request.method === 'GET' && url.pathname === '/users') {
      const allUsers = await users.find({}).toArray()
      return Response.json(allUsers)
    }

    if (request.method === 'POST' && url.pathname === '/users') {
      const body = await request.json()
      const result = await users.insertOne(body)
      return Response.json({ id: result.insertedId })
    }

    return new Response('Not Found', { status: 404 })
  },
}
```

## API Reference

### DocumentStore

```typescript
const store = new DocumentStore(options?)

// Get a database
const db = store.db('mydb')

// List databases
const dbs = store.listDatabases() // [{ name: 'mydb' }, ...]

// Drop database
await store.dropDatabase('mydb')
```

### Database

```typescript
// Get collection
const collection = db.collection<T>('name')

// Create collection
const collection = await db.createCollection<T>('name')

// List collections
const list = await db.listCollections().toArray()

// Drop collection
await db.dropCollection('name')

// Drop database
await db.dropDatabase()
```

### Collection

```typescript
// Insert
await collection.insertOne(doc)
await collection.insertMany(docs, { ordered: true })

// Find
await collection.findOne(filter, options)
collection.find(filter, options)

// Update
await collection.updateOne(filter, update, { upsert: false })
await collection.updateMany(filter, update, { upsert: false })
await collection.replaceOne(filter, replacement, { upsert: false })

// Delete
await collection.deleteOne(filter)
await collection.deleteMany(filter)

// Atomic operations
await collection.findOneAndUpdate(filter, update, { returnDocument: 'after' })
await collection.findOneAndDelete(filter)
await collection.findOneAndReplace(filter, replacement, { returnDocument: 'after' })

// Count
await collection.countDocuments(filter)
await collection.estimatedDocumentCount()

// Distinct
await collection.distinct('fieldName', filter)

// Aggregate
collection.aggregate(pipeline, options)

// Indexes
await collection.createIndex(keys, options)
await collection.createIndexes([{ key, options }])
await collection.dropIndex('indexName')
await collection.dropIndexes()
await collection.indexes()
await collection.indexExists('indexName')
collection.listIndexes()

// Collection management
await collection.drop()
```

### Cursor

```typescript
const cursor = collection.find(filter)

// Iterate
for await (const doc of cursor) { ... }
await cursor.forEach(doc => { ... })

// Get all results
const docs = await cursor.toArray()

// Get next document
const doc = await cursor.next()
const hasMore = await cursor.hasNext()

// Chain methods
cursor
  .filter({ status: 'active' })
  .sort({ createdAt: -1 })
  .skip(10)
  .limit(20)
  .project({ name: 1, email: 1 })
  .map(doc => doc.name)

// Count
const count = await cursor.count()

// Close
await cursor.close()
```

## Error Handling

```typescript
import { MongoError, MongoDuplicateKeyError } from '@dotdo/mongodb'

try {
  await users.insertOne({ _id: existingId, name: 'Duplicate' })
} catch (error) {
  if (error instanceof MongoDuplicateKeyError) {
    console.log('Duplicate key:', error.keyValue)
    console.log('Key pattern:', error.keyPattern)
    console.log('Error code:', error.code) // 11000
  }
}
```

## Testing with DocumentStore

DocumentStore is ideal for unit tests - no external MongoDB required:

```typescript
import { DocumentStore } from '@dotdo/mongodb'

describe('UserRepository', () => {
  let store: DocumentStore
  let users: Collection<User>

  beforeEach(() => {
    // Fresh in-memory store for each test
    store = new DocumentStore()
    users = store.db('test').collection('users')
  })

  it('should create a user', async () => {
    const result = await users.insertOne({ name: 'Alice', age: 30 })
    expect(result.acknowledged).toBe(true)

    const user = await users.findOne({ _id: result.insertedId })
    expect(user?.name).toBe('Alice')
  })
})
```

## Migration from mongodb

### Import Change

```typescript
// Before: MongoDB driver
import { MongoClient, ObjectId } from 'mongodb'

// After: dotdo DocumentStore
import { DocumentStore, ObjectId } from '@dotdo/mongodb'
```

### Code Migration

Replace `MongoClient` with `DocumentStore`:

```typescript
// Before
const client = new MongoClient('mongodb://localhost:27017')
await client.connect()
const db = client.db('myapp')
const users = db.collection('users')

// After
const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

// All MongoDB operations work the same
await users.insertOne({ name: 'Alice', age: 30 })
const user = await users.findOne({ name: 'Alice' })
```

## Related

- [mongo.do](/docs/integrations/mongo/service) - Managed MongoDB on the edge
- [Postgres Integration](/docs/integrations/postgres) - SQL database support
- [Algolia Integration](/docs/integrations/algolia) - Full-text search
