---
title: "@dotdo/duckdb"
description: Node.js-compatible DuckDB implementation for testing and local development.
---

# @dotdo/duckdb

Node.js-compatible DuckDB implementation that provides the familiar DuckDB API for testing and local development. Drop-in replacement for the `duckdb` npm package.

```typescript
import { Database } from '@dotdo/duckdb'

const db = new Database(':memory:')

db.run('CREATE TABLE users (id INTEGER, name VARCHAR, age INTEGER)')
db.run('INSERT INTO users VALUES (?, ?, ?)', [1, 'Alice', 30])

const users = db.all('SELECT * FROM users WHERE age > ?', [25])
console.log(users) // [{ id: 1, name: 'Alice', age: 30 }]
```

<Callout type="info">
Looking for edge deployment with Parquet/R2 integration? See [duckdb.do](/docs/integrations/duckdb/service) for production-ready DuckDB WASM on Cloudflare Workers.
</Callout>

## Why @dotdo/duckdb?

| DuckDB Node.js | @dotdo/duckdb |
|----------------|---------------|
| Requires native binaries | Pure JavaScript implementation |
| ~50MB binary size | Lightweight package |
| Complex test setup | Perfect for unit tests |
| Platform-specific | Cross-platform |
| Connection management | Stateless, instant startup |

**This is an API-compatible implementation** designed for testing and development. Use it when you need DuckDB semantics without native binary dependencies.

## Installation

```bash
npm install @dotdo/duckdb
```

## Features

### Implemented (Core APIs)

**Database Management**
- `new Database()` - Create in-memory or file-based database
- `open()` - Async factory for database creation
- `connect()` - Create connections for async operations
- `close()` - Close database and release resources

**Query Execution**
- `run()` - Execute DDL/DML statements (CREATE, INSERT, UPDATE, DELETE)
- `all()` - Execute SELECT queries returning all rows
- `get()` - Execute SELECT returning single row
- `each()` - Row-by-row iteration with callbacks
- `exec()` - Execute multiple statements

**Prepared Statements**
- `prepare()` - Create reusable prepared statement
- `bind()` - Bind parameters to statement
- `Statement.all()`, `Statement.get()`, `Statement.run()` - Execute prepared statement
- `finalize()` - Release statement resources

**Aggregate Functions**
- `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`
- `GROUP BY`, `HAVING`, `ORDER BY`
- Window functions

### Data Types Supported

| Type | Description |
|------|-------------|
| `INTEGER` | 32-bit signed integer |
| `BIGINT` | 64-bit signed integer |
| `DOUBLE` | 64-bit floating point |
| `VARCHAR` | Variable-length string |
| `BOOLEAN` | True/false |
| `DATE` | Calendar date |
| `TIMESTAMP` | Date and time |
| `BLOB` | Binary data |

## Quick Start

### Basic Usage

```typescript
import { Database } from '@dotdo/duckdb'

const db = new Database(':memory:')

// Create table
db.run(`
  CREATE TABLE events (
    id INTEGER PRIMARY KEY,
    event_type VARCHAR,
    user_id INTEGER,
    timestamp TIMESTAMP,
    properties VARCHAR
  )
`)

// Insert data
db.run('INSERT INTO events VALUES (?, ?, ?, ?, ?)', [
  1, 'page_view', 42, '2024-01-15 10:30:00', '{"page": "/home"}'
])

// Analytical query
const results = db.all(`
  SELECT
    event_type,
    COUNT(*) as count,
    COUNT(DISTINCT user_id) as unique_users
  FROM events
  WHERE timestamp >= '2024-01-01'
  GROUP BY event_type
  ORDER BY count DESC
`)

console.log(results)
db.close()
```

### Async API

```typescript
import { open } from '@dotdo/duckdb'

const db = await open(':memory:')
const conn = await db.connect()

await conn.run('CREATE TABLE users (id INTEGER, name VARCHAR)')
await conn.run('INSERT INTO users VALUES (?, ?)', [1, 'Alice'])

const users = await conn.all('SELECT * FROM users')
console.log(users)

await conn.close()
await db.close()
```

### Prepared Statements

```typescript
import { Database } from '@dotdo/duckdb'

const db = new Database(':memory:')
db.run('CREATE TABLE logs (id INTEGER, message VARCHAR, level VARCHAR)')

// Prepare reusable insert statement
const insertStmt = db.prepare('INSERT INTO logs VALUES (?, ?, ?)')
insertStmt.run(1, 'Starting up', 'INFO')
insertStmt.run(2, 'Warning!', 'WARN')
insertStmt.run(3, 'Error occurred', 'ERROR')
insertStmt.finalize()

// Prepare reusable select statement
const selectStmt = db.prepare('SELECT * FROM logs WHERE level = ?')
const warnings = selectStmt.all('WARN')
const errors = selectStmt.all('ERROR')
selectStmt.finalize()

db.close()
```

### Configuration Options

```typescript
const db = new Database(':memory:', {
  access_mode: 'read_write',
  threads: 4,
  max_memory: '512MB',
})
```

```typescript
interface DatabaseConfig {
  access_mode?: 'read_only' | 'read_write'
  threads?: number
  max_memory?: string
  default_null_order?: 'nulls_first' | 'nulls_last'
  default_order?: 'asc' | 'desc'
  enable_external_access?: boolean
}
```

## API Reference

### Database

```typescript
class Database {
  // Properties
  readonly path: string
  readonly open: boolean

  // Constructor
  constructor(path?: string, config?: DatabaseConfig, callback?: DatabaseCallback)

  // Query methods
  run(sql: string, params?: unknown[], callback?: RunCallback): QueryResult
  all<T>(sql: string, params?: unknown[], callback?: AllCallback<T>): T[]
  get<T>(sql: string, params?: unknown[], callback?: GetCallback<T>): T | undefined
  each<T>(sql: string, callback: EachRowCallback<T>, complete?: EachCompleteCallback): void
  exec(sql: string, callback?: (err: Error | null) => void): this

  // Prepared statements
  prepare(sql: string): Statement

  // Async API
  connect(): Promise<Connection>
  close(callback?: CloseCallback): void
}
```

### Statement

```typescript
class Statement {
  readonly sql: string

  bind(...params: unknown[]): this
  run(...params: unknown[]): QueryResult
  all<T>(...params: unknown[]): T[]
  get<T>(...params: unknown[]): T | undefined
  finalize(callback?: FinalizeCallback): void
}
```

### Connection (Async)

```typescript
interface Connection {
  run(sql: string, params?: unknown[]): Promise<QueryResult>
  all<T>(sql: string, params?: unknown[]): Promise<T[]>
  get<T>(sql: string, params?: unknown[]): Promise<T | undefined>
  prepare(sql: string): Promise<Statement>
  close(): Promise<void>
}
```

## Error Handling

```typescript
import { Database, DuckDBError } from '@dotdo/duckdb'

const db = new Database(':memory:')

try {
  db.all('SELECT * FROM nonexistent_table')
} catch (error) {
  if (error instanceof DuckDBError) {
    console.log('Code:', error.code)      // 'CATALOG_ERROR'
    console.log('Message:', error.message) // 'Table not found...'
    console.log('SQL:', error.sql)         // Original query
  }
}
```

### Error Codes

| Code | Description |
|------|-------------|
| `PARSER_ERROR` | SQL syntax error |
| `CATALOG_ERROR` | Table/column not found |
| `CONSTRAINT_ERROR` | Unique/NOT NULL violation |
| `INTERNAL_ERROR` | Internal database error |

## Testing with @dotdo/duckdb

@dotdo/duckdb is ideal for unit tests - no native dependencies required:

```typescript
import { Database } from '@dotdo/duckdb'
import { describe, it, expect, beforeEach } from 'vitest'

describe('AnalyticsRepository', () => {
  let db: Database

  beforeEach(() => {
    // Fresh in-memory database for each test
    db = new Database(':memory:')
    db.run(`
      CREATE TABLE events (
        id INTEGER,
        event_type VARCHAR,
        user_id INTEGER,
        timestamp TIMESTAMP
      )
    `)
  })

  it('should aggregate events by type', () => {
    db.run('INSERT INTO events VALUES (1, ?, 42, ?)', ['page_view', '2024-01-15'])
    db.run('INSERT INTO events VALUES (2, ?, 42, ?)', ['page_view', '2024-01-15'])
    db.run('INSERT INTO events VALUES (3, ?, 43, ?)', ['click', '2024-01-15'])

    const results = db.all(`
      SELECT event_type, COUNT(*) as count
      FROM events
      GROUP BY event_type
    `)

    expect(results).toContainEqual({ event_type: 'page_view', count: 2 })
    expect(results).toContainEqual({ event_type: 'click', count: 1 })
  })

  it('should handle window functions', () => {
    db.run('INSERT INTO events VALUES (1, ?, 42, ?)', ['view', '2024-01-01'])
    db.run('INSERT INTO events VALUES (2, ?, 42, ?)', ['view', '2024-01-02'])

    const results = db.all(`
      SELECT
        id,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY timestamp) as seq
      FROM events
    `)

    expect(results[0].seq).toBe(1)
    expect(results[1].seq).toBe(2)
  })
})
```

## Types

```typescript
import type {
  // Configuration
  DatabaseConfig,
  AccessMode,
  ExtendedDuckDBConfig,

  // Results
  QueryResult,
  ColumnInfo,

  // Callbacks
  DatabaseCallback,
  CloseCallback,
  RunCallback,
  AllCallback,
  GetCallback,
  EachRowCallback,
  EachCompleteCallback,
  FinalizeCallback,

  // Interfaces
  IDatabase,
  IConnection,
  IStatement,
} from '@dotdo/duckdb'

// Error class
import { DuckDBError } from '@dotdo/duckdb'
```

## Migration from duckdb

### Import Change

```typescript
// Before: DuckDB Node.js
import duckdb from 'duckdb'

// After: dotdo
import { Database, open } from '@dotdo/duckdb'
```

### Code Migration

Replace the native DuckDB with @dotdo/duckdb:

```typescript
// Before
const duckdb = require('duckdb')
const db = new duckdb.Database(':memory:')

// After
import { Database } from '@dotdo/duckdb'
const db = new Database(':memory:')

// All DuckDB operations work the same
db.run('CREATE TABLE users (id INTEGER, name VARCHAR)')
db.run('INSERT INTO users VALUES (?, ?)', [1, 'Alice'])
const users = db.all('SELECT * FROM users')
```

## Related

- [duckdb.do](/docs/integrations/duckdb/service) - Managed DuckDB WASM on the edge
- [Postgres Integration](/docs/integrations/postgres) - PostgreSQL compatibility layer
- [S3/R2 Integration](/docs/integrations/s3) - Object storage for Parquet files
