---
title: Type Inference
description: Automatic type derivation from schemas and runtime values
---

# Type Inference

dotdo leverages TypeScript's advanced type inference capabilities to derive types automatically from schemas, reducing duplication and ensuring consistency between runtime validation and compile-time types.

## Schema-to-Type Inference

Located in `/types/AIFunction.ts`:

### Basic Type Mapping

```typescript
/**
 * Infer TypeScript type from JSON Schema type string
 */
export type InferSchemaType<T extends JSONSchemaType> =
  T extends 'string' ? string :
  T extends 'number' ? number :
  T extends 'integer' ? number :
  T extends 'boolean' ? boolean :
  T extends 'null' ? null :
  T extends 'object' ? Record<string, unknown> :
  T extends 'array' ? unknown[] :
  unknown
```

### Full Schema Inference

The `InferSchema` type recursively infers TypeScript types from JSON Schema definitions:

```typescript
export type InferSchema<S extends JSONSchema> =
  // Const values become literal types
  S extends { const: infer C } ? C :

  // Enums become union of literal types
  S extends { enum: readonly (infer E)[] } ? E :

  // Primitive types
  S extends { type: 'string' } ? string :
  S extends { type: 'number' } ? number :
  S extends { type: 'integer' } ? number :
  S extends { type: 'boolean' } ? boolean :
  S extends { type: 'null' } ? null :

  // Arrays infer item types
  S extends { type: 'array'; items: infer I extends JSONSchema }
    ? InferSchema<I>[] :

  // Objects with required fields
  S extends {
    type: 'object';
    properties: infer P extends Record<string, JSONSchema>;
    required: infer R extends readonly string[]
  }
    ? { [K in keyof P & string as K extends R[number] ? K : never]: InferSchema<P[K]> } &
      { [K in keyof P & string as K extends R[number] ? never : K]?: InferSchema<P[K]> }

  // Objects without required (all optional)
  : S extends { type: 'object'; properties: infer P extends Record<string, JSONSchema> }
    ? { [K in keyof P]?: InferSchema<P[K]> }

  // Generic object
  : S extends { type: 'object' } ? Record<string, unknown> :

  // Union types
  S extends { oneOf: readonly (infer U extends JSONSchema)[] } ? InferSchema<U> :
  S extends { anyOf: readonly (infer U extends JSONSchema)[] } ? InferSchema<U> :

  unknown
```

### Usage Example

```typescript
// Define schema with const assertion for literal types
const userSchema = {
  type: 'object',
  properties: {
    id: { type: 'string' },
    name: { type: 'string' },
    age: { type: 'number' },
    email: { type: 'string' },
    role: { enum: ['admin', 'user', 'guest'] as const }
  },
  required: ['id', 'name', 'email'] as const
} as const

// Inferred type:
// {
//   id: string;
//   name: string;
//   email: string;
//   age?: number;
//   role?: 'admin' | 'user' | 'guest';
// }
type User = InferSchema<typeof userSchema>

// Use in function definitions
function createUser(data: User): User {
  return data
}
```

## Event Payload Inference

Located in `/types/EventHandler.ts`:

### Event Payload Registry

```typescript
/**
 * Look up the payload type for a specific Noun and Verb combination.
 */
export type EventPayload<Noun extends string, Verb extends string> =
  Noun extends keyof EventPayloadRegistry
    ? Verb extends keyof EventPayloadRegistry[Noun]
      ? EventPayloadRegistry[Noun][Verb]
      : unknown
    : unknown
```

### Inferring from Handler Functions

```typescript
/**
 * Infer the payload type from an event handler function.
 */
export type InferEventPayload<T> =
  T extends TypedEventHandler<infer P>
    ? P
    : T extends (event: TypedDomainEvent<infer P>) => Promise<void>
      ? P
      : T extends EventHandler
        ? unknown
        : never

// Usage
const myHandler: TypedEventHandler<CustomerCreatedPayload> = async (e) => {}
type Payload = InferEventPayload<typeof myHandler>  // CustomerCreatedPayload
```

## Template Literal Inference

Extract parameter names from template strings:

```typescript
/**
 * Extract parameter names from a template string type
 */
export type ExtractTemplateParams<S extends string> =
  S extends `${infer _}${'${'}${infer Param}${'}'}${infer Rest}`
    ? Param | ExtractTemplateParams<Rest>
    : never

// Usage
type Params = ExtractTemplateParams<'Hello ${name}, you have ${count} messages'>
// Params = 'name' | 'count'
```

### Template Function Typing

```typescript
/**
 * Create a type-safe template function
 */
export interface TemplateFn<
  Output,
  Params extends Record<string, unknown> = Record<string, unknown>
> {
  (params: Params): Promise<Output>
  readonly template: string
  readonly params: (keyof Params)[]
}

/**
 * AI template literal function type
 */
export type AITemplateFn<Output> = <S extends string>(
  strings: TemplateStringsArray & { raw: readonly S[] },
  ...values: unknown[]
) => TemplateFn<Output, Record<ExtractTemplateParams<S>, unknown>>
```

## Function Result Type Inference

### Execution Result Unwrapping

```typescript
/**
 * Unwrap the output type from an execution result
 */
export type UnwrapResult<R> = R extends ExecutionResult<infer T, any> ? T : never

// Usage
type Result = AgenticExecutionResult<{ answer: string }>
type Output = UnwrapResult<Result>  // { answer: string }
```

### Options Type Resolution

```typescript
/**
 * Get the options type for a function type
 */
export type OptionsForType<T extends FunctionType> =
  T extends 'code' ? CodeOptions :
  T extends 'generative' ? GenerativeOptions :
  T extends 'agentic' ? AgenticOptions :
  T extends 'human' ? HumanOptions :
  BaseExecutorOptions

// Usage
type AgentOpts = OptionsForType<'agentic'>  // AgenticOptions
```

### Result Type Resolution

```typescript
/**
 * Get the result type for a function type
 */
export type ResultForType<T extends FunctionType, Output> =
  T extends 'code' ? CodeExecutionResult<Output> :
  T extends 'generative' ? GenerativeExecutionResult<Output> :
  T extends 'agentic' ? AgenticExecutionResult<Output> :
  T extends 'human' ? HumanExecutionResult<Output> :
  ExecutionResult<Output>

// Usage
type MyResult = ResultForType<'generative', string>  // GenerativeExecutionResult<string>
```

## RPC Promise Inference

Located in `/types/fn.ts`:

### Tagged Template Results

```typescript
/**
 * Result type for tagged templates with named parameters.
 * When using fn`hello ${'name'}`, returns a function that accepts params.
 */
export type TaggedResult<
  Out,
  S extends string,
  Opts extends Record<string, unknown> = {},
> = (params: Record<string, unknown>, opts?: Opts) => Out
```

### Function Interface with Inference

```typescript
/**
 * Core function type with triple calling style support.
 * TypeScript infers the return type based on usage.
 */
export interface Fn<Out, In = unknown, Opts extends Record<string, unknown> = {}> {
  // Style 1: Direct call
  (input: In, opts?: Opts): Out

  // Style 2: Tagged template with interpolation
  (strings: TemplateStringsArray, ...values: unknown[]): Out

  // Style 3: Tagged template with named params - returns a function
  <S extends string>(
    strings: TemplateStringsArray & { raw: readonly S[] },
  ): TaggedResult<Out, S, Opts>
}
```

## Builder Pattern with Type Inference

The AI function builder uses inference at each step:

```typescript
export interface AIFunctionBuilder<Input = unknown, Output = unknown> {
  name(name: string): this
  description(desc: string): this
  type(type: FunctionType): this

  // Input schema inference
  input<S extends JSONSchema>(schema: S): AIFunctionBuilder<InferSchema<S>, Output>

  // Output schema inference
  output<S extends JSONSchema>(schema: S): AIFunctionBuilder<Input, InferSchema<S>>

  options(opts: BaseExecutorOptions): this

  // Build methods with inferred types
  code(handler: (input: Input) => Output | Promise<Output>): CodeFunctionDefinition<Input, Output>
  generative(prompt: string | ((input: Input) => string)): GenerativeFunctionDefinition<Input, Output>
}
```

### Usage

```typescript
const summarize = builder
  .name('summarize')
  .input({
    type: 'object',
    properties: {
      text: { type: 'string' },
      maxLength: { type: 'number' }
    },
    required: ['text']
  } as const)
  .output({
    type: 'object',
    properties: {
      summary: { type: 'string' },
      wordCount: { type: 'number' }
    },
    required: ['summary', 'wordCount']
  } as const)
  .generative('Summarize the following text...')

// Input is inferred as { text: string; maxLength?: number }
// Output is inferred as { summary: string; wordCount: number }
```

## Best Practices

### 1. Use `as const` for Literal Inference

```typescript
// Without as const - types are widened
const schema = {
  type: 'object',
  required: ['name']
}
// required is string[], not ['name']

// With as const - literal types preserved
const schema = {
  type: 'object',
  required: ['name']
} as const
// required is readonly ['name']
```

### 2. Leverage Conditional Types for Fallbacks

```typescript
type SafePayload<T> = T extends undefined ? unknown : T

// Usage in event handlers
type Payload = SafePayload<EventPayloadRegistry['Customer']['created']>
```

### 3. Use `infer` in Conditional Types

```typescript
// Extract the value type from a Promise
type Awaited<T> = T extends Promise<infer U> ? U : T

// Extract array element type
type ElementType<T> = T extends (infer E)[] ? E : never
```

### 4. Combine with Type Guards

```typescript
function isValidResult<T>(
  result: ExecutionResult<T>
): result is ExecutionResult<T> & { success: true; value: T } {
  return result.success === true && result.value !== undefined
}

// After guard, value is guaranteed to exist
if (isValidResult(result)) {
  console.log(result.value)  // T, not T | undefined
}
```

## Implementation References

- `/types/AIFunction.ts` - Schema inference and function types
- `/types/EventHandler.ts` - Event payload inference
- `/types/fn.ts` - Function type inference
- `/types/WorkflowContext.ts` - Context type inference
