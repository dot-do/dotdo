---
title: E-Commerce Store
description: Build a complete e-commerce store with cart, checkout, and agent-powered fulfillment in 30 minutes
---

import { Callout } from 'fumadocs-ui/components/callout'

# Build an E-Commerce Store in 30 Minutes

Product catalog. Shopping cart backed by Durable Objects. Checkout flow. Order fulfillment with agents handling inventory and shipping.

By the end, you'll have a deployed store where Sally handles customer service and your warehouse gets notified automatically on every order.

---

<Steps>

<Step>

## Create the Project

```bash
npx dotdo init my-store --template ecommerce
cd my-store
npm install
```

You get:
- Product catalog structure
- Cart backed by Durable Objects
- Checkout flow scaffolding
- Order management system

</Step>

<Step>

## Configure Environment

```bash title=".env"
# Payments
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Shipping (optional)
SHIPPO_API_KEY=shippo_test_...

# Email
RESEND_API_KEY=re_...

# Inventory (optional - uses internal by default)
INVENTORY_WEBHOOK_URL=https://your-warehouse.com/webhook
```

</Step>

<Step>

## Define Your Store

Create `src/store.ts`:

```typescript title="src/store.ts"
import { Startup } from 'dotdo'
import { priya, ralph, tom, sally, quinn } from 'agents.do'

export class MyStore extends Startup {
  hypothesis = 'People want to buy artisan coffee online'

  async launch() {
    // Priya defines the store experience
    const spec = priya`
      define an e-commerce MVP for ${this.hypothesis}
      include: catalog, cart, checkout, order tracking
    `

    // Ralph builds it
    let store = ralph`build ${spec}`

    // Review loop
    do {
      store = ralph`improve ${store} per ${tom}`
    } while (!await tom.approve(store))

    // Quinn tests checkout flow
    await quinn`test the checkout flow for ${store}`

    // Ship it
    await tom`deploy ${store}`

    // Fire-and-forget: announce
    sally`announce store launch to mailing list`
  }
}
```

</Step>

<Step>

## Build the Product Catalog

Create `src/catalog.ts`:

```typescript title="src/catalog.ts"
import { DO } from 'dotdo'

export interface Product {
  id: string
  name: string
  description: string
  price: number
  currency: string
  images: string[]
  inventory: number
  category: string
}

export class Catalog extends DO {
  async init() {
    // Reindex daily for search
    $.every.day.atmidnight(async () => {
      await this.reindex()
    })
  }

  async listProducts(options?: {
    category?: string
    limit?: number
    offset?: number
  }): Promise<Product[]> {
    const query: Record<string, any> = {}

    if (options?.category) {
      query.category = options.category
    }

    return await $.query('products', query, {
      limit: options?.limit ?? 20,
      offset: options?.offset ?? 0
    })
  }

  async getProduct(id: string): Promise<Product | null> {
    return await $.query('products', { id }).then(r => r[0] ?? null)
  }

  async searchProducts(term: string): Promise<Product[]> {
    // Vector search on product embeddings
    return await $.search('products', term, { limit: 20 })
  }

  async createProduct(product: Omit<Product, 'id'>): Promise<Product> {
    const id = $.id()

    const created = await $.do('createProduct', {
      ...product,
      id
    })

    // Fire-and-forget: update search index
    $.send('product.created', { product: created })

    return created
  }

  async updateInventory(productId: string, delta: number): Promise<number> {
    // Must succeed - use $.do for durability
    const result = await $.do('updateInventory', {
      productId,
      delta
    })

    // Check for low stock
    if (result.newInventory < 10) {
      $.send('inventory.low', {
        productId,
        current: result.newInventory
      })
    }

    return result.newInventory
  }

  private async reindex() {
    const products = await this.listProducts({ limit: 1000 })

    for (const product of products) {
      // Generate embedding and index
      await $.do('indexProduct', {
        id: product.id,
        text: `${product.name} ${product.description} ${product.category}`
      })
    }

    $.log('Catalog reindexed', { count: products.length })
  }
}
```

</Step>

<Step>

## Build the Shopping Cart

Create `src/cart.ts` - each cart is its own Durable Object:

```typescript title="src/cart.ts"
import { DO } from 'dotdo'
import type { Product } from './catalog'

interface CartItem {
  productId: string
  quantity: number
  price: number
  name: string
}

export class Cart extends DO {
  // Cart state persists automatically
  items: CartItem[] = []

  async addItem(productId: string, quantity: number = 1) {
    // Get product details
    const product = await $.Catalog('default').getProduct(productId)

    if (!product) {
      throw new Error(`Product ${productId} not found`)
    }

    // Check inventory
    if (product.inventory < quantity) {
      throw new Error(`Only ${product.inventory} available`)
    }

    // Find existing item or add new
    const existing = this.items.find(i => i.productId === productId)

    if (existing) {
      existing.quantity += quantity
    } else {
      this.items.push({
        productId,
        quantity,
        price: product.price,
        name: product.name
      })
    }

    // Track for analytics - fire and forget
    $.send('cart.itemAdded', {
      cartId: this.id,
      productId,
      quantity
    })

    return this.getCart()
  }

  async removeItem(productId: string) {
    this.items = this.items.filter(i => i.productId !== productId)

    $.send('cart.itemRemoved', {
      cartId: this.id,
      productId
    })

    return this.getCart()
  }

  async updateQuantity(productId: string, quantity: number) {
    if (quantity <= 0) {
      return this.removeItem(productId)
    }

    const item = this.items.find(i => i.productId === productId)
    if (item) {
      // Check inventory
      const product = await $.Catalog('default').getProduct(productId)
      if (product && product.inventory < quantity) {
        throw new Error(`Only ${product.inventory} available`)
      }

      item.quantity = quantity
    }

    return this.getCart()
  }

  async getCart() {
    const subtotal = this.items.reduce(
      (sum, item) => sum + item.price * item.quantity,
      0
    )

    return {
      items: this.items,
      subtotal,
      itemCount: this.items.reduce((sum, item) => sum + item.quantity, 0)
    }
  }

  async clear() {
    this.items = []
    return this.getCart()
  }
}
```

<Callout type="info">
Each cart is a separate Durable Object instance. Cart state persists between requests automatically. The DO ID is typically the user's session or customer ID.
</Callout>

</Step>

<Step>

## Build the Checkout Flow

Create `src/checkout.ts`:

```typescript title="src/checkout.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'
import { ceo } from 'humans.do'

interface ShippingAddress {
  name: string
  line1: string
  line2?: string
  city: string
  state: string
  postal: string
  country: string
}

interface CheckoutSession {
  cartId: string
  customerId?: string
  email: string
  shipping: ShippingAddress
  shippingMethod: 'standard' | 'express'
  paymentIntentId?: string
}

export class Checkout extends DO {
  session: CheckoutSession | null = null

  async init() {
    // Handle successful payments
    $.on.Payment.succeeded(async (event) => {
      const { checkoutId } = event.data

      if (checkoutId === this.id) {
        await this.completeOrder()
      }
    })

    // Handle failed payments
    $.on.Payment.failed(async (event) => {
      const { checkoutId, reason } = event.data

      if (checkoutId === this.id && this.session) {
        // Sally follows up
        sally`
          email ${this.session.email} about failed payment
          reason: ${reason}
          offer help completing their order
        `
      }
    })
  }

  async startCheckout(cartId: string, email: string): Promise<{ sessionId: string }> {
    // Get cart
    const cart = await $.Cart(cartId).getCart()

    if (cart.items.length === 0) {
      throw new Error('Cart is empty')
    }

    this.session = {
      cartId,
      email,
      shipping: {} as ShippingAddress,
      shippingMethod: 'standard'
    }

    return { sessionId: this.id }
  }

  async setShipping(address: ShippingAddress, method: 'standard' | 'express') {
    if (!this.session) {
      throw new Error('No checkout session')
    }

    this.session.shipping = address
    this.session.shippingMethod = method

    // Calculate shipping cost
    const cart = await $.Cart(this.session.cartId).getCart()
    const shippingCost = method === 'express' ? 15 : 5

    return {
      subtotal: cart.subtotal,
      shipping: shippingCost,
      total: cart.subtotal + shippingCost
    }
  }

  async createPaymentIntent() {
    if (!this.session) {
      throw new Error('No checkout session')
    }

    const cart = await $.Cart(this.session.cartId).getCart()
    const shippingCost = this.session.shippingMethod === 'express' ? 15 : 5
    const total = cart.subtotal + shippingCost

    // Create Stripe payment intent - must succeed
    const intent = await $.do('stripe.createPaymentIntent', {
      amount: Math.round(total * 100), // cents
      currency: 'usd',
      metadata: {
        checkoutId: this.id,
        cartId: this.session.cartId
      }
    })

    this.session.paymentIntentId = intent.id

    return {
      clientSecret: intent.client_secret,
      amount: total
    }
  }

  async completeOrder() {
    if (!this.session) {
      throw new Error('No checkout session')
    }

    const cart = await $.Cart(this.session.cartId).getCart()

    // Create order - must succeed
    const order = await $.do('createOrder', {
      id: $.id(),
      checkoutId: this.id,
      email: this.session.email,
      items: cart.items,
      shipping: this.session.shipping,
      shippingMethod: this.session.shippingMethod,
      status: 'paid',
      createdAt: new Date()
    })

    // Clear the cart
    await $.Cart(this.session.cartId).clear()

    // Fire-and-forget: notifications and fulfillment
    $.send('order.placed', { order })
    sally`send order confirmation to ${this.session.email} for order ${order.id}`

    return order
  }
}
```

</Step>

<Step>

## Build Order Management

Create `src/orders.ts`:

```typescript title="src/orders.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'
import { warehouse } from 'humans.do'

interface Order {
  id: string
  email: string
  items: Array<{ productId: string; quantity: number; price: number }>
  shipping: {
    name: string
    line1: string
    city: string
    state: string
    postal: string
    country: string
  }
  status: 'paid' | 'processing' | 'shipped' | 'delivered' | 'cancelled'
  trackingNumber?: string
}

export class Orders extends DO {
  async init() {
    // New order placed
    $.on.Order.placed(async (event) => {
      const { order } = event.data

      // Reserve inventory - must succeed
      for (const item of order.items) {
        await $.Catalog('default').updateInventory(
          item.productId,
          -item.quantity
        )
      }

      // Notify warehouse - fire and forget
      $.send('warehouse.newOrder', { order })

      // Update order status
      await this.updateStatus(order.id, 'processing')
    })

    // Low inventory alert
    $.on.Inventory.low(async (event) => {
      const { productId, current } = event.data
      const product = await $.Catalog('default').getProduct(productId)

      // Notify warehouse team
      warehouse`
        Low inventory alert: ${product?.name}
        Current stock: ${current}
        Please reorder soon.
      `
    })

    // Check for stale orders daily
    $.every.day.at9am(async () => {
      await this.checkStaleOrders()
    })
  }

  async getOrder(id: string): Promise<Order | null> {
    return await $.query('orders', { id }).then(r => r[0] ?? null)
  }

  async listOrders(email: string): Promise<Order[]> {
    return await $.query('orders', { email }, { orderBy: 'createdAt', desc: true })
  }

  async updateStatus(
    orderId: string,
    status: Order['status'],
    trackingNumber?: string
  ) {
    const order = await this.getOrder(orderId)
    if (!order) {
      throw new Error(`Order ${orderId} not found`)
    }

    await $.do('updateOrder', {
      id: orderId,
      status,
      trackingNumber
    })

    // Notify customer based on status
    switch (status) {
      case 'shipped':
        sally`
          send shipping notification to ${order.email}
          order: ${orderId}
          tracking: ${trackingNumber}
        `
        break

      case 'delivered':
        sally`
          send delivery confirmation to ${order.email}
          ask for a review
        `
        break

      case 'cancelled':
        // Restore inventory
        for (const item of order.items) {
          await $.Catalog('default').updateInventory(
            item.productId,
            item.quantity
          )
        }
        sally`send cancellation confirmation to ${order.email}`
        break
    }

    $.send(`order.${status}`, { orderId, order })
  }

  async cancelOrder(orderId: string, reason: string) {
    const order = await this.getOrder(orderId)

    if (!order) {
      throw new Error(`Order ${orderId} not found`)
    }

    if (order.status === 'shipped' || order.status === 'delivered') {
      throw new Error('Cannot cancel shipped or delivered orders')
    }

    await this.updateStatus(orderId, 'cancelled')

    // Process refund - must succeed
    await $.do('processRefund', { orderId, reason })
  }

  private async checkStaleOrders() {
    // Find orders stuck in processing for > 2 days
    const staleOrders = await $.query('orders', {
      status: 'processing',
      createdAt: { $lt: twoDaysAgo() }
    })

    for (const order of staleOrders) {
      // Escalate to warehouse
      warehouse`
        Order ${order.id} has been processing for over 2 days.
        Please check fulfillment status.
        Customer: ${order.email}
      `
    }
  }
}

const twoDaysAgo = () => new Date(Date.now() - 2 * 24 * 60 * 60 * 1000)
```

<Callout type="warn">
The `warehouse` import from `humans.do` routes to your warehouse team via Slack, email, or SMS. They can respond directly to fulfill orders.
</Callout>

</Step>

<Step>

## Wire Up the API

Create `src/api.ts`:

```typescript title="src/api.ts"
import { Hono } from 'hono'
import { Catalog } from './catalog'
import { Cart } from './cart'
import { Checkout } from './checkout'
import { Orders } from './orders'

const app = new Hono()

// Catalog routes
app.get('/products', async (c) => {
  const catalog = await Catalog.get('default')
  const category = c.req.query('category')
  return c.json(await catalog.listProducts({ category }))
})

app.get('/products/:id', async (c) => {
  const catalog = await Catalog.get('default')
  const product = await catalog.getProduct(c.req.param('id'))
  return product ? c.json(product) : c.json({ error: 'Not found' }, 404)
})

app.get('/products/search', async (c) => {
  const catalog = await Catalog.get('default')
  const term = c.req.query('q') ?? ''
  return c.json(await catalog.searchProducts(term))
})

// Cart routes - cart ID from session/cookie
app.get('/cart/:cartId', async (c) => {
  const cart = await Cart.get(c.req.param('cartId'))
  return c.json(await cart.getCart())
})

app.post('/cart/:cartId/items', async (c) => {
  const { productId, quantity } = await c.req.json()
  const cart = await Cart.get(c.req.param('cartId'))
  return c.json(await cart.addItem(productId, quantity))
})

app.delete('/cart/:cartId/items/:productId', async (c) => {
  const cart = await Cart.get(c.req.param('cartId'))
  return c.json(await cart.removeItem(c.req.param('productId')))
})

app.patch('/cart/:cartId/items/:productId', async (c) => {
  const { quantity } = await c.req.json()
  const cart = await Cart.get(c.req.param('cartId'))
  return c.json(await cart.updateQuantity(c.req.param('productId'), quantity))
})

// Checkout routes
app.post('/checkout/start', async (c) => {
  const { cartId, email } = await c.req.json()
  const checkoutId = `checkout_${$.id()}`
  const checkout = await Checkout.get(checkoutId)
  return c.json(await checkout.startCheckout(cartId, email))
})

app.post('/checkout/:id/shipping', async (c) => {
  const { address, method } = await c.req.json()
  const checkout = await Checkout.get(c.req.param('id'))
  return c.json(await checkout.setShipping(address, method))
})

app.post('/checkout/:id/payment', async (c) => {
  const checkout = await Checkout.get(c.req.param('id'))
  return c.json(await checkout.createPaymentIntent())
})

// Stripe webhook
app.post('/webhooks/stripe', async (c) => {
  const event = await c.req.json()

  if (event.type === 'payment_intent.succeeded') {
    const checkoutId = event.data.object.metadata.checkoutId
    $.send('Payment.succeeded', { checkoutId })
  } else if (event.type === 'payment_intent.payment_failed') {
    const checkoutId = event.data.object.metadata.checkoutId
    $.send('Payment.failed', {
      checkoutId,
      reason: event.data.object.last_payment_error?.message
    })
  }

  return c.json({ received: true })
})

// Order routes
app.get('/orders', async (c) => {
  const orders = await Orders.get('default')
  const email = c.req.query('email')
  if (!email) return c.json({ error: 'Email required' }, 400)
  return c.json(await orders.listOrders(email))
})

app.get('/orders/:id', async (c) => {
  const orders = await Orders.get('default')
  const order = await orders.getOrder(c.req.param('id'))
  return order ? c.json(order) : c.json({ error: 'Not found' }, 404)
})

app.post('/orders/:id/cancel', async (c) => {
  const { reason } = await c.req.json()
  const orders = await Orders.get('default')
  await orders.cancelOrder(c.req.param('id'), reason)
  return c.json({ success: true })
})

export default app
```

</Step>

<Step>

## Test Locally

```bash
npm run dev
```

Test the full flow:

```bash
# Get products
curl http://localhost:8787/products

# Add to cart
curl -X POST http://localhost:8787/cart/my-session/items \
  -H "Content-Type: application/json" \
  -d '{"productId":"prod_123","quantity":2}'

# View cart
curl http://localhost:8787/cart/my-session

# Start checkout
curl -X POST http://localhost:8787/checkout/start \
  -H "Content-Type: application/json" \
  -d '{"cartId":"my-session","email":"test@example.com.ai"}'

# Set shipping
curl -X POST http://localhost:8787/checkout/checkout_abc/shipping \
  -H "Content-Type: application/json" \
  -d '{
    "address": {
      "name": "Test User",
      "line1": "123 Main St",
      "city": "San Francisco",
      "state": "CA",
      "postal": "94102",
      "country": "US"
    },
    "method": "standard"
  }'

# Create payment intent
curl -X POST http://localhost:8787/checkout/checkout_abc/payment
```

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Set production secrets:

```bash
npx wrangler secret put STRIPE_SECRET_KEY
npx wrangler secret put STRIPE_WEBHOOK_SECRET
npx wrangler secret put RESEND_API_KEY
```

Update your Stripe webhook URL to `https://my-store.workers.dev/webhooks/stripe`.

</Step>

</Steps>

---

## What You Built

In 30 minutes, you've deployed an e-commerce store with:

| Feature | Implementation |
|---------|----------------|
| Product catalog | Vector search, categories, inventory |
| Shopping cart | Durable Object per session |
| Checkout flow | Shipping, payment intents, order creation |
| Order management | Status tracking, fulfillment, cancellation |
| Inventory | Auto-updates, low stock alerts |
| Customer service | Sally handles confirmations and follow-ups |
| Warehouse integration | Human escalation for fulfillment |

---

## Key Patterns Used

### Durable Object Per Cart

```typescript
// Each cart is its own DO instance
const cart = await Cart.get(sessionId)
await cart.addItem(productId, quantity)
```

State persists automatically. No database calls for cart operations.

### $.do() for Critical Business Logic

```typescript
// Inventory updates must succeed
await $.do('updateInventory', { productId, delta: -quantity })

// Order creation must succeed
await $.do('createOrder', { ... })
```

### Fire-and-Forget for Notifications

```typescript
// Don't block checkout for email
sally`send order confirmation to ${email}`

// Don't block for analytics
$.send('cart.itemAdded', { productId })
```

### Human Escalation for Operations

```typescript
import { warehouse } from 'humans.do'

warehouse`Low inventory alert: ${product.name}`
warehouse`Order ${orderId} stale - check fulfillment`
```

---

## Next Steps

Your store is live. Now explore:

- [Add more products](/docs/sdk/thing) - Define product entities
- [Custom agents](/docs/agents/custom-agents) - Train Sally for your brand
- [Content site tutorial](/docs/tutorials/content-site) - Add a blog
- [Deployment options](/docs/deployment) - Multi-region, custom domains

---

**You built a store. Sally's handling customers. The warehouse gets notified automatically. Go list some products.**
