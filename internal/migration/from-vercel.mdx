---
title: From Vercel
description: Migrate from Vercel serverless and edge functions to dotdo. Same deployment simplicity, true edge everywhere.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Migrating from Vercel

You've deployed on Vercel. The git-push-to-deploy workflow, serverless functions, edge functions - you know the developer experience. dotdo gives you that same simplicity with a fundamentally different architecture.

## Why Migrate?

Vercel is excellent for deploying Next.js and serverless functions. But when you're building AI-native applications:

| Challenge | Vercel | dotdo |
|-----------|--------|-------|
| Cold starts | 50-250ms (serverless), 0ms (edge) | 0ms everywhere |
| Edge functions | Limited runtime, no state | Full runtime, persistent state |
| WebSockets | Not supported | Native |
| Database connections | Pool exhaustion at scale | No connection pools |
| Concurrent AI agents | Hundreds before limits | Millions |
| Regions | Select few | 300+ cities |
| Durable execution | Not available | Built-in |
| Pricing | Request + duration | More predictable |

<Callout type="info">
Vercel Edge Functions run V8 isolates like dotdo, but without persistent state. dotdo's Durable Objects add stateful, single-threaded execution to the edge model.
</Callout>

## Architecture Comparison

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            Vercel Architecture                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐             │
│   │   Serverless │    │    Edge      │    │   Next.js    │             │
│   │   Functions  │    │   Functions  │    │   App/Pages  │             │
│   │   (Lambda)   │    │    (V8)      │    │   (Hybrid)   │             │
│   └──────┬───────┘    └──────┬───────┘    └──────┬───────┘             │
│          │                   │                   │                      │
│          ▼                   ▼                   ▼                      │
│   ┌──────────────────────────────────────────────────────────┐         │
│   │              External Database (Postgres, etc.)           │         │
│   │              - Connection pooling required                │         │
│   │              - Single region latency                      │         │
│   └──────────────────────────────────────────────────────────┘         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                            dotdo Architecture                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                        Hono HTTP Layer                           │   │
│   │                   (API routes, middleware)                       │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                      Durable Objects                             │   │
│   │            - Persistent state (SQLite per tenant)               │   │
│   │            - Single-threaded (no race conditions)               │   │
│   │            - Edge location (closest to user)                    │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     Cloudflare R2/KV                             │   │
│   │                   (Cold storage, backups)                        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Key Differences

| Aspect | Vercel | dotdo |
|--------|--------|-------|
| Compute model | Serverless (stateless) + Edge (stateless) | Durable Objects (stateful) |
| State persistence | External DB only | Built-in SQLite per DO |
| Cold starts | Lambda: 50-250ms, Edge: 0ms | 0ms |
| Request timeout | 10s (hobby), 60s (pro) | 30s default, configurable |
| WebSocket | Not supported | Native |
| Cron jobs | Vercel Cron | `$.every.*` scheduling |
| Environment | Node.js (Lambda) or V8 (Edge) | V8 everywhere |
| Deployment | Git push | Git push (`wrangler deploy`) |

## Serverless Functions Migration

### Basic API Route

```typescript
// Vercel - api/users.ts
import type { VercelRequest, VercelResponse } from '@vercel/node'

export default async function handler(
  req: VercelRequest,
  res: VercelResponse
) {
  if (req.method === 'GET') {
    const users = await db.query('SELECT * FROM users')
    return res.json(users)
  }

  if (req.method === 'POST') {
    const user = await db.query(
      'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
      [req.body.name, req.body.email]
    )
    return res.status(201).json(user)
  }

  res.status(405).json({ error: 'Method not allowed' })
}
```

```typescript
// dotdo - src/routes/users.ts
import { Hono } from 'hono'

const users = new Hono()

users.get('/', async (c) => {
  const users = await $.things.list('User')
  return c.json(users)
})

users.post('/', async (c) => {
  const { name, email } = await c.req.json()
  const user = await $.things.create('User', { name, email })
  return c.json(user, 201)
})

export default users
```

### With Middleware

```typescript
// Vercel - middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.headers.get('authorization')?.split(' ')[1]

  if (!token && request.nextUrl.pathname.startsWith('/api/protected')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/api/protected/:path*'
}
```

```typescript
// dotdo - src/middleware/auth.ts
import { createMiddleware } from 'hono/factory'

export const auth = createMiddleware(async (c, next) => {
  const token = c.req.header('Authorization')?.split(' ')[1]

  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401)
  }

  const user = await verifyToken(token)
  c.set('user', user)
  await next()
})

// Apply to routes
app.use('/api/protected/*', auth)
```

## Edge Functions Migration

Vercel Edge Functions are already V8-based, making migration straightforward.

### Basic Edge Function

```typescript
// Vercel - api/hello.ts (edge runtime)
export const config = {
  runtime: 'edge'
}

export default async function handler(request: Request) {
  const { searchParams } = new URL(request.url)
  const name = searchParams.get('name') || 'World'

  return new Response(JSON.stringify({ message: `Hello, ${name}!` }), {
    headers: { 'Content-Type': 'application/json' }
  })
}
```

```typescript
// dotdo - same pattern, Hono syntax
app.get('/hello', (c) => {
  const name = c.req.query('name') || 'World'
  return c.json({ message: `Hello, ${name}!` })
})
```

### Edge Function with KV

```typescript
// Vercel - using Vercel KV (Redis-like)
import { kv } from '@vercel/kv'

export const config = { runtime: 'edge' }

export default async function handler(request: Request) {
  const { searchParams } = new URL(request.url)
  const key = searchParams.get('key')

  // Get from KV
  const value = await kv.get(key)

  // Set in KV
  await kv.set('visits', (await kv.get('visits') || 0) + 1)

  return Response.json({ value })
}
```

```typescript
// dotdo - using Cloudflare KV or DO state
app.get('/data', async (c) => {
  const key = c.req.query('key')

  // Option 1: Cloudflare KV
  const value = await c.env.KV.get(key)

  // Option 2: DO state (preferred for per-tenant data)
  const value = await $.state.get(key)

  // Track visits in DO state
  const visits = (await $.state.get('visits') || 0) + 1
  await $.state.put('visits', visits)

  return c.json({ value, visits })
})
```

## Vercel KV to dotdo

Vercel KV is Redis-compatible. dotdo offers multiple storage options.

### KV Operations

```typescript
// Vercel KV
import { kv } from '@vercel/kv'

// String operations
await kv.set('user:1:name', 'Alice')
const name = await kv.get('user:1:name')
await kv.del('user:1:name')

// With expiry
await kv.set('session:abc', data, { ex: 3600 })

// Hash operations
await kv.hset('user:1', { name: 'Alice', email: 'alice@example.com' })
const user = await kv.hgetall('user:1')

// List operations
await kv.lpush('queue', 'task1')
const task = await kv.rpop('queue')
```

```typescript
// dotdo - Cloudflare KV (simple key-value)
const kv = c.env.KV

await kv.put('user:1:name', 'Alice')
const name = await kv.get('user:1:name')
await kv.delete('user:1:name')

// With expiry
await kv.put('session:abc', JSON.stringify(data), { expirationTtl: 3600 })

// dotdo - DO state (for structured data, preferred)
await $.state.put('user', { name: 'Alice', email: 'alice@example.com' })
const user = await $.state.get('user')

// dotdo - for Redis-like operations, use @dotdo/redis compat
import { createClient } from '@dotdo/redis'
const redis = createClient()

await redis.hset('user:1', { name: 'Alice', email: 'alice@example.com' })
const user = await redis.hgetall('user:1')
```

## Vercel Postgres to dotdo

### Database Queries

```typescript
// Vercel Postgres
import { sql } from '@vercel/postgres'

export default async function handler(req, res) {
  // Select
  const { rows } = await sql`SELECT * FROM users WHERE id = ${userId}`

  // Insert
  await sql`INSERT INTO users (name, email) VALUES (${name}, ${email})`

  // Transaction
  const client = await sql.connect()
  try {
    await client.sql`BEGIN`
    await client.sql`UPDATE accounts SET balance = balance - ${amount} WHERE id = ${fromId}`
    await client.sql`UPDATE accounts SET balance = balance + ${amount} WHERE id = ${toId}`
    await client.sql`COMMIT`
  } catch (e) {
    await client.sql`ROLLBACK`
    throw e
  } finally {
    client.release()
  }
}
```

```typescript
// dotdo - Things store (recommended)
app.get('/users/:id', async (c) => {
  const { id } = c.req.param()
  const user = await $.things.get('User', id)
  return c.json(user)
})

app.post('/users', async (c) => {
  const { name, email } = await c.req.json()
  const user = await $.things.create('User', { name, email })
  return c.json(user)
})

// Transaction-like operations with $.do (durable execution)
app.post('/transfer', async (c) => {
  const { fromId, toId, amount } = await c.req.json()

  await $.do(async () => {
    const from = await $.things.get('Account', fromId)
    const to = await $.things.get('Account', toId)

    if (from.balance < amount) {
      throw new Error('Insufficient funds')
    }

    await $.things.update('Account', fromId, { balance: from.balance - amount })
    await $.things.update('Account', toId, { balance: to.balance + amount })
  })

  return c.json({ success: true })
})

// Or use @dotdo/postgres for SQL syntax
import { createClient } from '@dotdo/postgres'
const db = createClient(env.DATABASE_URL)

const { rows } = await db.query('SELECT * FROM users WHERE id = $1', [userId])
```

## Vercel Blob to dotdo (R2)

```typescript
// Vercel Blob
import { put, del, list } from '@vercel/blob'

// Upload
const blob = await put('avatar.png', file, { access: 'public' })
console.log(blob.url)

// Delete
await del('avatar.png')

// List
const { blobs } = await list()
```

```typescript
// dotdo - Cloudflare R2
const r2 = c.env.BUCKET

// Upload
await r2.put('avatar.png', file)
const url = `https://your-bucket.r2.cloudflarestorage.com/avatar.png`

// Delete
await r2.delete('avatar.png')

// List
const { objects } = await r2.list()

// Or use @dotdo/s3 for S3-compatible API
import { S3Client, PutObjectCommand } from '@dotdo/s3'

const s3 = new S3Client({
  endpoint: env.R2_ENDPOINT,
  credentials: {
    accessKeyId: env.R2_ACCESS_KEY,
    secretAccessKey: env.R2_SECRET_KEY
  }
})

await s3.send(new PutObjectCommand({
  Bucket: 'my-bucket',
  Key: 'avatar.png',
  Body: file
}))
```

## Vercel Cron to dotdo

```typescript
// Vercel - vercel.json
{
  "crons": [
    {
      "path": "/api/daily-cleanup",
      "schedule": "0 0 * * *"
    }
  ]
}

// api/daily-cleanup.ts
export default async function handler(req, res) {
  await cleanupOldRecords()
  res.json({ success: true })
}
```

```typescript
// dotdo - using $.every.* scheduling
$.every.day.at('midnight')(async () => {
  await cleanupOldRecords()
})

// More scheduling options
$.every.hour(async () => {
  await syncMetrics()
})

$.every.monday.at('9am')(async () => {
  await sendWeeklyReport()
})

$.every('5 minutes')(async () => {
  await checkHealthStatus()
})
```

## Authentication Migration

If you're using NextAuth.js (Auth.js) with Vercel, dotdo provides a complete authentication solution using better-auth with edge-native storage. This section covers migrating your auth setup.

### NextAuth/Auth.js Migration

dotdo uses [better-auth](https://better-auth.com) with a GraphStore adapter, providing similar capabilities to NextAuth but optimized for edge runtimes.

```typescript
// Vercel - NextAuth configuration
// pages/api/auth/[...nextauth].ts
import NextAuth from 'next-auth'
import GoogleProvider from 'next-auth/providers/google'
import GitHubProvider from 'next-auth/providers/github'
import { PrismaAdapter } from '@auth/prisma-adapter'
import { prisma } from '@/lib/prisma'

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    GitHubProvider({
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    }),
  ],
  session: {
    strategy: 'database',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    async session({ session, user }) {
      session.user.id = user.id
      return session
    },
  },
}

export default NextAuth(authOptions)
```

```typescript
// dotdo - better-auth configuration
// src/auth/config.ts
import { createAuthWithGraph } from 'dotdo/auth'
import { SQLiteGraphStore } from 'dotdo/db/graph'

const store = new SQLiteGraphStore(env.DB)
await store.initialize()

export const auth = createAuthWithGraph({
  graphStore: store,
  authDomain: 'auth.myapp.com',
  allowedDomainPatterns: ['*.myapp.com'],
  resolveTenantNs: async (domain) => {
    // Map custom domains to tenant namespaces
    const customDomain = await store.findOne('CustomDomain', { domain })
    return customDomain?.tenantNs || null
  },
})

// Hono handler
app.on(['GET', 'POST'], '/api/auth/*', (c) => auth.handler(c.req.raw))
```

### Session Strategy

NextAuth offers JWT or database sessions. dotdo uses database sessions stored in the GraphStore with built-in cross-domain support.

```typescript
// Vercel - NextAuth JWT strategy
// pages/api/auth/[...nextauth].ts
export const authOptions = {
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
  },
}
```

```typescript
// dotdo - Database sessions with cross-domain support
// better-auth uses database sessions by default
// Sessions are stored in GraphStore as Thing entities

// Session configuration in createAuthWithGraph
const auth = createAuthWithGraph({
  // ... other config
  // Session config is built-in:
  // - 7 day expiry (configurable)
  // - Auto-refresh on activity
  // - Cross-subdomain cookie support
})
```

### Edge Middleware Auth Patterns

Vercel uses Next.js middleware for edge auth. dotdo uses Hono middleware with similar patterns.

```typescript
// Vercel - middleware.ts (edge runtime)
import { getToken } from 'next-auth/jwt'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  const token = await getToken({
    req: request,
    secret: process.env.JWT_SECRET,
  })

  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Add user to headers for API routes
  const requestHeaders = new Headers(request.headers)
  if (token) {
    requestHeaders.set('x-user-id', token.sub!)
    requestHeaders.set('x-user-email', token.email!)
  }

  return NextResponse.next({ headers: requestHeaders })
}

export const config = {
  matcher: ['/dashboard/:path*', '/api/protected/:path*'],
}
```

```typescript
// dotdo - Hono middleware (edge runtime)
import { createMiddleware } from 'hono/factory'
import { getSessionFromRequest, requireAuth } from 'dotdo/auth'

// Auth middleware
export const auth = createMiddleware(async (c, next) => {
  const session = await getSessionFromRequest(c.req.raw, c.get('db'))

  if (!session) {
    const url = new URL(c.req.url)
    if (url.pathname.startsWith('/dashboard')) {
      return c.redirect('/login')
    }
    return c.json({ error: 'Unauthorized' }, 401)
  }

  // Store user in context
  c.set('session', session)
  c.set('userId', session.userId)

  await next()
})

// Apply to routes
app.use('/dashboard/*', auth)
app.use('/api/protected/*', auth)

// Or use requireAuth helper for API routes
app.get('/api/me', async (c) => {
  const result = await requireAuth(c.req.raw, c.get('db'))
  if (result instanceof Response) return result

  const { user, session } = result
  return c.json({ user, session })
})
```

### Provider Configuration

OAuth provider setup is similar between NextAuth and better-auth, but with different configuration patterns.

```typescript
// Vercel - NextAuth providers
import GoogleProvider from 'next-auth/providers/google'
import GitHubProvider from 'next-auth/providers/github'
import CredentialsProvider from 'next-auth/providers/credentials'

export const authOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          scope: 'openid email profile',
          prompt: 'consent',
          access_type: 'offline',
        },
      },
    }),
    GitHubProvider({
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        // Verify credentials
        const user = await verifyCredentials(credentials)
        return user
      },
    }),
  ],
}
```

```typescript
// dotdo - better-auth providers (in createAuthWithGraph)
// Providers are configured via socialProviders option

const auth = createAuthWithGraph({
  graphStore: store,
  authDomain: 'auth.myapp.com',
  // Providers configured via environment variables
  // GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET
  // GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET
  // ...
})

// For credentials auth, use email/password plugin
import { betterAuth } from 'better-auth'

const auth = betterAuth({
  // ... base config
  emailAndPassword: {
    enabled: true,
    async verifyPassword(email, password) {
      // Custom password verification
      const user = await store.findOne('User', { email })
      return verifyPassword(password, user?.passwordHash)
    },
  },
})
```

### Adapter Replacement

NextAuth uses adapters (Prisma, Drizzle, etc.) for database storage. dotdo uses GraphAuthAdapter which stores auth entities as Things in the graph model.

```typescript
// Vercel - NextAuth with Prisma adapter
import { PrismaAdapter } from '@auth/prisma-adapter'
import { prisma } from '@/lib/prisma'

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  // ...
}
```

```typescript
// Vercel - NextAuth with Drizzle adapter
import { DrizzleAdapter } from '@auth/drizzle-adapter'
import { db } from '@/lib/db'
import * as schema from '@/lib/schema'

export const authOptions = {
  adapter: DrizzleAdapter(db, {
    usersTable: schema.users,
    accountsTable: schema.accounts,
    sessionsTable: schema.sessions,
  }),
  // ...
}
```

```typescript
// dotdo - GraphAuthAdapter (built into createAuthWithGraph)
// Auth entities are stored as Things in the graph model

import { createAuthWithGraph, graphAuthAdapter } from 'dotdo/auth'
import { SQLiteGraphStore } from 'dotdo/db/graph'

// GraphStore stores auth entities as Things:
// - User: user information, email, name, image
// - Session: session tokens, expiry, active org
// - Account: OAuth provider accounts linked to users
// - Organization: multi-tenant organizations

const store = new SQLiteGraphStore(env.DB)
await store.initialize()

// Auth entities become queryable like any other Thing
const users = await store.query('User', {
  where: { emailVerified: true },
  include: ['sessions', 'accounts']
})

// Graph relationships enable powerful queries
const userWithOrgs = await store.findOne('User', { id: userId }, {
  include: ['organizations', 'sessions']
})
```

### Data Migration

If you have existing users in NextAuth, you can migrate them to dotdo's GraphStore.

```typescript
// Migration script: NextAuth to dotdo
import { PrismaClient } from '@prisma/client'
import { SQLiteGraphStore } from 'dotdo/db/graph'

const prisma = new PrismaClient()
const graphStore = new SQLiteGraphStore(':memory:')

async function migrateAuth() {
  await graphStore.initialize()

  // Migrate users
  const users = await prisma.user.findMany({
    include: { accounts: true, sessions: true }
  })

  for (const user of users) {
    // Create user Thing
    await graphStore.create('User', {
      id: user.id,
      email: user.email,
      name: user.name,
      image: user.image,
      emailVerified: user.emailVerified,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    })

    // Migrate linked accounts
    for (const account of user.accounts) {
      await graphStore.create('Account', {
        id: account.id,
        userId: user.id,
        provider: account.provider,
        providerAccountId: account.providerAccountId,
        type: account.type,
        accessToken: account.access_token,
        refreshToken: account.refresh_token,
        expiresAt: account.expires_at,
      })
    }

    // Sessions will be recreated on next login
    // Old sessions can be optionally migrated if needed
  }

  console.log(`Migrated ${users.length} users`)
}

migrateAuth()
```

### Multi-Tenant Auth

dotdo's auth system is built for multi-tenant applications with cross-domain OAuth support.

```typescript
// Vercel - Multi-tenant with NextAuth (complex setup)
// Requires custom logic for tenant routing

// middleware.ts
export async function middleware(request: NextRequest) {
  const hostname = request.headers.get('host')
  const tenant = hostname?.split('.')[0]

  // Rewrite to tenant-specific routes
  request.headers.set('x-tenant', tenant!)
  return NextResponse.next()
}

// pages/api/auth/[...nextauth].ts
export default async function handler(req, res) {
  const tenant = req.headers['x-tenant']

  return NextAuth(req, res, {
    ...authOptions,
    callbacks: {
      async session({ session, user }) {
        session.tenant = tenant
        return session
      },
    },
  })
}
```

```typescript
// dotdo - Multi-tenant auth (built-in)
// Cross-domain OAuth with automatic tenant routing

const auth = createAuthWithGraph({
  graphStore: store,
  authDomain: 'auth.myapp.com',  // Central auth domain
  allowedDomainPatterns: ['*.myapp.com', '*.custom.com'],

  // Resolve tenant from custom domains
  resolveTenantNs: async (domain) => {
    // crm.acme.com -> acme tenant namespace
    const customDomain = await store.findOne('CustomDomain', {
      domain,
      verified: true
    })
    return customDomain?.tenantNs || null
  },
})

// Organization plugin for team management
// Includes: organizations, members, invitations, teams
// Built into better-auth with organization() plugin

// Flow for custom domains:
// 1. User visits crm.acme.com
// 2. Login redirects to auth.myapp.com/api/auth/signin/google
// 3. After OAuth, redirects back with one-time token
// 4. Tenant domain exchanges token for session cookie
```

<Callout type="info">
dotdo's auth architecture uses a central auth domain for OAuth callbacks, then issues one-time tokens for cross-domain session transfer. This enables custom domains for each tenant without registering separate OAuth credentials.
</Callout>

## Complete Migration Example

### Before: Vercel E-commerce API

```typescript
// api/products/index.ts
import { sql } from '@vercel/postgres'
import { kv } from '@vercel/kv'

export default async function handler(req, res) {
  if (req.method === 'GET') {
    // Check cache first
    const cached = await kv.get('products:all')
    if (cached) return res.json(cached)

    const { rows } = await sql`
      SELECT p.*, c.name as category_name
      FROM products p
      JOIN categories c ON p.category_id = c.id
      ORDER BY p.created_at DESC
      LIMIT 100
    `

    // Cache for 5 minutes
    await kv.set('products:all', rows, { ex: 300 })

    return res.json(rows)
  }

  if (req.method === 'POST') {
    const { name, price, categoryId } = req.body

    const { rows } = await sql`
      INSERT INTO products (name, price, category_id)
      VALUES (${name}, ${price}, ${categoryId})
      RETURNING *
    `

    // Invalidate cache
    await kv.del('products:all')

    return res.status(201).json(rows[0])
  }
}
```

```typescript
// api/products/[id].ts
export default async function handler(req, res) {
  const { id } = req.query

  if (req.method === 'GET') {
    const cached = await kv.get(`product:${id}`)
    if (cached) return res.json(cached)

    const { rows } = await sql`SELECT * FROM products WHERE id = ${id}`
    if (!rows[0]) return res.status(404).json({ error: 'Not found' })

    await kv.set(`product:${id}`, rows[0], { ex: 300 })
    return res.json(rows[0])
  }

  if (req.method === 'PUT') {
    const { name, price } = req.body
    const { rows } = await sql`
      UPDATE products SET name = ${name}, price = ${price}
      WHERE id = ${id} RETURNING *
    `

    await kv.del(`product:${id}`)
    await kv.del('products:all')

    return res.json(rows[0])
  }

  if (req.method === 'DELETE') {
    await sql`DELETE FROM products WHERE id = ${id}`
    await kv.del(`product:${id}`)
    await kv.del('products:all')
    return res.status(204).end()
  }
}
```

### After: dotdo E-commerce API

```typescript
// src/routes/products.ts
import { Hono } from 'hono'

const products = new Hono()

products.get('/', async (c) => {
  // DO state acts as automatic cache
  const products = await $.things.list('Product', {
    include: ['category'],
    orderBy: { field: 'createdAt', direction: 'desc' },
    limit: 100
  })

  return c.json(products)
})

products.get('/:id', async (c) => {
  const { id } = c.req.param()
  const product = await $.things.get('Product', id)

  if (!product) {
    return c.json({ error: 'Not found' }, 404)
  }

  return c.json(product)
})

products.post('/', async (c) => {
  const { name, price, categoryId } = await c.req.json()

  const product = await $.things.create('Product', {
    name,
    price,
    categoryId
  })

  // Emit event for other systems
  await $.send({ type: 'Product.created', data: product })

  return c.json(product, 201)
})

products.put('/:id', async (c) => {
  const { id } = c.req.param()
  const { name, price } = await c.req.json()

  const product = await $.things.update('Product', id, { name, price })

  await $.send({ type: 'Product.updated', data: product })

  return c.json(product)
})

products.delete('/:id', async (c) => {
  const { id } = c.req.param()

  await $.things.delete('Product', id)

  await $.send({ type: 'Product.deleted', data: { id } })

  return c.body(null, 204)
})

export default products
```

```typescript
// src/index.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import products from './routes/products'
import { auth } from './middleware/auth'

const app = new Hono()

app.use('/*', cors())
app.use('/api/*', auth)
app.route('/api/products', products)

app.onError((err, c) => {
  console.error(err)
  return c.json({ error: 'Internal server error' }, 500)
})

export default app
```

## What You Gain

| Aspect | Vercel | dotdo |
|--------|--------|-------|
| Cold starts | 50-250ms (serverless) | 0ms |
| State management | External DB + KV | Built-in DO state |
| WebSocket | Not supported | Native |
| Durable execution | Not available | $.do() retries |
| AI agents | Manual integration | Native support |
| Regions | Select few | 300+ cities |
| Connection pooling | Required | Not needed |
| Cache invalidation | Manual | Automatic (DO locality) |

## Step-by-Step Migration

<Steps>

<Step>

### Create dotdo project

```bash
npx dotdo init my-app
cd my-app
npm install
```

</Step>

<Step>

### Migrate API routes

For each file in `api/` or `pages/api/`:

1. Create corresponding Hono route in `src/routes/`
2. Convert request/response handling to Hono context
3. Update database calls to Things store or compat SDK

</Step>

<Step>

### Migrate KV usage

Replace `@vercel/kv` with:
- DO state for per-tenant data
- Cloudflare KV for global cache
- `@dotdo/redis` for Redis-like operations

</Step>

<Step>

### Migrate Postgres

Replace `@vercel/postgres` with:
- Things store (recommended)
- `@dotdo/postgres` for SQL syntax

</Step>

<Step>

### Migrate Blob storage

Replace `@vercel/blob` with:
- Cloudflare R2 direct
- `@dotdo/s3` for S3-compatible API

</Step>

<Step>

### Update cron jobs

Convert `vercel.json` crons to `$.every.*` scheduling.

</Step>

<Step>

### Migrate authentication

Replace NextAuth/Auth.js with dotdo auth:

1. Set up environment variables (`GOOGLE_CLIENT_ID`, `GITHUB_CLIENT_ID`, etc.)
2. Create auth instance with `createAuthWithGraph()`
3. Add auth routes to Hono app
4. Replace `getServerSession()` with `getSessionFromRequest()`
5. Update middleware to use dotdo auth helpers
6. Run user migration script if you have existing users

</Step>

<Step>

### Configure deployment

```toml
# wrangler.toml
name = "my-app"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[d1_databases]]
binding = "DB"
database_name = "my-db"
database_id = "xxx"

[[r2_buckets]]
binding = "BUCKET"
bucket_name = "my-bucket"
```

</Step>

<Step>

### Deploy

```bash
npm run deploy
```

</Step>

</Steps>

## Data Migration

If you're using Vercel's data products (KV, Postgres, Blob), here's how to migrate your data safely.

### Exporting from Vercel Postgres

```bash
# Use pg_dump to export your database
pg_dump $VERCEL_POSTGRES_URL > vercel-backup.sql

# Or export specific tables
pg_dump $VERCEL_POSTGRES_URL -t users -t orders > critical-data.sql
```

For programmatic exports:

```typescript
// scripts/export-vercel-postgres.ts
import { sql } from '@vercel/postgres'
import fs from 'fs'

async function exportTable(tableName: string) {
  const { rows } = await sql`SELECT * FROM ${sql(tableName)}`

  fs.writeFileSync(
    `./export/${tableName}.json`,
    JSON.stringify(rows, null, 2)
  )

  console.log(`Exported ${rows.length} rows from ${tableName}`)
}

async function main() {
  const tables = ['users', 'products', 'orders', 'sessions']

  for (const table of tables) {
    await exportTable(table)
  }
}

main()
```

### Exporting from Vercel KV

```typescript
// scripts/export-vercel-kv.ts
import { kv } from '@vercel/kv'
import fs from 'fs'

async function exportKV() {
  const keys = await kv.keys('*')
  const data: Record<string, any> = {}

  for (const key of keys) {
    const type = await kv.type(key)

    switch (type) {
      case 'string':
        data[key] = { type: 'string', value: await kv.get(key) }
        break
      case 'hash':
        data[key] = { type: 'hash', value: await kv.hgetall(key) }
        break
      case 'list':
        data[key] = { type: 'list', value: await kv.lrange(key, 0, -1) }
        break
      case 'set':
        data[key] = { type: 'set', value: await kv.smembers(key) }
        break
    }
  }

  fs.writeFileSync('./export/kv-data.json', JSON.stringify(data, null, 2))
  console.log(`Exported ${keys.length} keys`)
}

exportKV()
```

### Importing to dotdo

```bash
# Import SQL data
npx dotdo db:import ./vercel-backup.sql

# Or import JSON exports to Things store
npx dotdo db:import ./export/users.json --collection User
```

```typescript
// scripts/import-to-dotdo.ts
import { createClient } from '@dotdo/client'
import kvData from './export/kv-data.json'

const dotdo = createClient({
  url: process.env.DOTDO_URL,
  key: process.env.DOTDO_KEY
})

// Import KV data to DO state or Cloudflare KV
async function importKV() {
  for (const [key, entry] of Object.entries(kvData)) {
    switch (entry.type) {
      case 'string':
        await $.state.put(key, entry.value)
        break
      case 'hash':
        await $.state.put(key, entry.value)
        break
      // Handle other types...
    }
  }
}

importKV()
```

### Schema Mapping

| Vercel | dotdo | Notes |
|--------|-------|-------|
| Postgres tables | Things collections | Similar relational model |
| KV strings | DO state or CF KV | Choose based on access pattern |
| KV hashes | DO state objects | Native JSON objects |
| Blob storage | R2 | S3-compatible API |
| Edge Config | CF KV or DO state | Low-latency config storage |

## Rollback Strategy

### Phase 1: Dual-Write Setup

Run both systems in parallel during migration:

```typescript
// lib/dual-write.ts
import { sql } from '@vercel/postgres'
import { createClient } from '@dotdo/client'

const dotdo = createClient({ url: DOTDO_URL, key: DOTDO_KEY })

const MIGRATION_PHASE = process.env.MIGRATION_PHASE || 'dual-write'

export async function createUser(data: UserData) {
  switch (MIGRATION_PHASE) {
    case 'vercel-only':
      return await sql`INSERT INTO users (name, email) VALUES (${data.name}, ${data.email}) RETURNING *`

    case 'dual-write':
      const [vercelResult, dotdoResult] = await Promise.allSettled([
        sql`INSERT INTO users (name, email) VALUES (${data.name}, ${data.email}) RETURNING *`,
        dotdo.things.create('User', data)
      ])

      if (vercelResult.status !== dotdoResult.status) {
        console.error('Dual-write mismatch', { vercelResult, dotdoResult })
      }

      return vercelResult.value?.rows[0]

    case 'dotdo-primary':
      const result = await dotdo.things.create('User', data)
      // Async backup to Vercel
      sql`INSERT INTO users (name, email) VALUES (${data.name}, ${data.email})`.catch(console.error)
      return result

    case 'dotdo-only':
      return await dotdo.things.create('User', data)
  }
}
```

### Phase 2: Shadow Reads

Verify data consistency between systems:

```typescript
// middleware/shadow-read.ts
async function shadowRead(table: string, id: string) {
  const [vercelData, dotdoData] = await Promise.all([
    sql`SELECT * FROM ${sql(table)} WHERE id = ${id}`.then(r => r.rows[0]),
    dotdo.things.get(table, id)
  ])

  const differences = compareRecords(vercelData, dotdoData)

  if (differences.length > 0) {
    await logDifference({ table, id, differences })
  }

  return vercelData // Vercel is still source of truth
}
```

### Rollback Procedures

If issues arise after cutover:

```typescript
// scripts/rollback-to-vercel.ts
async function rollback() {
  // 1. Switch back to Vercel
  process.env.MIGRATION_PHASE = 'vercel-only'

  // 2. Sync recent dotdo writes back to Vercel
  const cutoverTime = '2024-01-15T10:00:00Z'

  const recentWrites = await dotdo.things.list('*', {
    where: { updatedAt: { $gte: cutoverTime } }
  })

  for (const record of recentWrites) {
    await syncToVercelPostgres(record)
  }

  // 3. Alert team
  await notify('Migration rolled back. Vercel is primary.')
}
```

### Keeping Vercel Running During Cutover

Maintain Vercel as hot standby:

```typescript
// config/migration.ts
export const migrationConfig = {
  keepVercelAlive: true,
  backupPeriodDays: 30,
  criticalTables: ['users', 'orders', 'payments']
}

// Middleware to backup writes
app.use(async (c, next) => {
  await next()

  if (c.req.method === 'POST' || c.req.method === 'PUT') {
    const table = extractTable(c.req.path)

    if (migrationConfig.criticalTables.includes(table)) {
      backupToVercel(table, await c.req.json()).catch(console.error)
    }
  }
})
```

## Validation Checklist

### Pre-Migration

- [ ] **Inventory all data stores** - List Postgres tables, KV keys, Blob buckets
- [ ] **Document schemas** - Table structures, relationships, indexes
- [ ] **Map API routes** - List all `/api/*` and `/app/api/*` routes
- [ ] **Identify middleware** - Document middleware.ts logic
- [ ] **List cron jobs** - Map vercel.json crons to `$.every.*`
- [ ] **Backup all data** - Export Postgres, KV, and Blob data

### Data Integrity Validation

```typescript
// scripts/validate-migration.ts
async function validateMigration() {
  const tables = ['users', 'products', 'orders']
  const results = { tables: {}, issues: [] }

  for (const table of tables) {
    const vercelCount = await sql`SELECT COUNT(*) FROM ${sql(table)}`.then(r => parseInt(r.rows[0].count))
    const dotdoCount = await dotdo.things.count(table)

    results.tables[table] = {
      vercelCount,
      dotdoCount,
      match: vercelCount === dotdoCount
    }

    if (vercelCount !== dotdoCount) {
      results.issues.push({ type: 'count_mismatch', table, vercelCount, dotdoCount })
    }

    // Sample 100 random records for deep comparison
    const samples = await sql`SELECT * FROM ${sql(table)} ORDER BY RANDOM() LIMIT 100`

    for (const vercelRow of samples.rows) {
      const dotdoRow = await dotdo.things.get(table, vercelRow.id)
      const diff = compareRecords(vercelRow, dotdoRow)

      if (diff.length > 0) {
        results.issues.push({ type: 'data_mismatch', table, id: vercelRow.id, diff })
      }
    }
  }

  return results
}
```

### Smoke Test Procedures

```typescript
// scripts/smoke-test.ts
async function smokeTest() {
  const tests = [
    // Test API routes
    async () => {
      const res = await fetch(`${DOTDO_URL}/api/users`)
      assert(res.ok, 'GET /api/users failed')
      return 'API routes: PASS'
    },

    // Test database operations
    async () => {
      const user = await dotdo.things.create('User', { name: 'Test', email: `test-${Date.now()}@example.com` })
      const fetched = await dotdo.things.get('User', user.id)
      await dotdo.things.delete('User', user.id)
      assert(fetched.name === 'Test', 'CRUD failed')
      return 'Database CRUD: PASS'
    },

    // Test caching (if using KV)
    async () => {
      await $.state.put('test-key', 'test-value')
      const value = await $.state.get('test-key')
      await $.state.delete('test-key')
      assert(value === 'test-value', 'State operations failed')
      return 'State/KV: PASS'
    },

    // Test latency
    async () => {
      const start = Date.now()
      await dotdo.things.list('User', { limit: 1 })
      const duration = Date.now() - start
      assert(duration < 50, `Latency too high: ${duration}ms`)
      return `Latency: ${duration}ms - PASS`
    }
  ]

  for (const test of tests) {
    try {
      console.log(await test())
    } catch (error) {
      console.error(`FAILED: ${error}`)
      process.exit(1)
    }
  }

  console.log('\nAll smoke tests passed!')
}
```

### Post-Migration Checklist

- [ ] **All smoke tests pass** - Run automated test suite
- [ ] **Error rates stable** - Monitor for 24-48 hours
- [ ] **Latency acceptable** - p50, p95, p99 within targets
- [ ] **No data discrepancies** - Comparison tests pass
- [ ] **Team notified** - Everyone knows the new system is live
- [ ] **Vercel backup retained** - Keep for 30+ days minimum
- [ ] **DNS/rewrites updated** - Traffic flowing to dotdo

## Common Gotchas

### Request Body Parsing

```typescript
// Vercel - body parsed automatically
const { name } = req.body

// dotdo - parse on demand
const { name } = await c.req.json()
```

### Environment Variables

```typescript
// Vercel
process.env.API_KEY

// dotdo - from context
c.env.API_KEY
```

### Response Format

```typescript
// Vercel
res.status(201).json(data)

// dotdo
return c.json(data, 201)
```

### File Uploads

```typescript
// Vercel - multipart handled by framework
const file = req.body.file

// dotdo - use formData
const form = await c.req.formData()
const file = form.get('file')
```

## Keeping Vercel Frontend

You can keep your Next.js frontend on Vercel and only migrate the API:

```typescript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://your-dotdo-app.workers.dev/api/:path*'
      }
    ]
  }
}
```

This lets you migrate gradually - backend first, then frontend when ready.

## Next Steps

- [Workflow Context ($)](/docs/sdk/workflow-context) - Durable execution and events
- [Things Store](/docs/sdk/things) - Data persistence patterns
- [Named Agents](/docs/agents/named-agents) - Add AI to your API
- [Deployment](/docs/deployment) - Production configuration

---

**Same git-push-to-deploy experience. True edge everywhere. Your Vercel skills transfer directly.**
