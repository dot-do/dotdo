---
title: From Firebase
description: Migrate from Firebase to dotdo. Real-time, auth, and storage patterns that scale to AI workloads.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Migrating from Firebase

You've built on Firebase. The real-time database, authentication, hosting - you know how it all fits together. dotdo gives you similar capabilities with an architecture designed for AI-native applications.

## Why Migrate?

Firebase is powerful for building real-time apps quickly. But at scale with AI workloads:

| Challenge | Firebase | dotdo |
|-----------|----------|-------|
| Real-time connections | 200K concurrent (Blaze) | Unlimited |
| Database reads | Pay per read | Bundled |
| Cold start functions | 100-500ms | 0ms |
| Function timeout | 9 min max | Configurable |
| WebSocket customization | Limited | Full control |
| AI agent concurrency | Hundreds | Millions |
| Data locality | Single region | 300+ cities |
| Vendor lock-in | High | Cloudflare (portable) |

<Callout type="info">
Firebase's real-time sync is powerful, but the per-read pricing model becomes expensive with AI agents making frequent queries. dotdo's Durable Objects provide similar real-time capabilities with predictable costs.
</Callout>

## Architecture Comparison

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Firebase Architecture                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐             │
│   │   Firestore  │    │   Realtime   │    │    Cloud     │             │
│   │   Database   │    │   Database   │    │   Functions  │             │
│   └──────┬───────┘    └──────┬───────┘    └──────┬───────┘             │
│          │                   │                   │                      │
│          └───────────┬───────┴───────────────────┘                      │
│                      │                                                   │
│                      ▼                                                   │
│   ┌──────────────────────────────────────────────────────────┐         │
│   │                   Firebase SDK                            │         │
│   │          (Offline sync, real-time listeners)             │         │
│   └──────────────────────────────────────────────────────────┘         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                            dotdo Architecture                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                      Hono HTTP + WebSocket                       │   │
│   │               (API routes, real-time connections)                │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                      Durable Objects                             │   │
│   │            - Per-tenant isolated state                          │   │
│   │            - WebSocket hibernation                              │   │
│   │            - SQLite storage                                     │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                   Tiered Storage (R2/KV)                         │   │
│   │              Hot → Warm → Cold data lifecycle                    │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Key Differences

| Aspect | Firebase | dotdo |
|--------|----------|-------|
| Data model | Documents/Collections | Things (typed entities) |
| Real-time | Firebase SDK listeners | WebSocket + DO broadcast |
| Auth | Firebase Auth | Pluggable (Auth0, Clerk, WorkOS) |
| Functions | Cloud Functions | Hono handlers + DO |
| Storage | Cloud Storage | R2 |
| Hosting | Firebase Hosting | Workers Sites |
| Offline | Built-in SDK | Custom (via DO state) |

## Firestore to Things Store

### Basic CRUD Operations

```typescript
// Firebase Firestore
import { initializeApp } from 'firebase/app'
import {
  getFirestore,
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit
} from 'firebase/firestore'

const app = initializeApp(config)
const db = getFirestore(app)

// Create
await setDoc(doc(db, 'users', 'user-1'), {
  name: 'Alice',
  email: 'alice@example.com',
  createdAt: new Date()
})

// Read
const docSnap = await getDoc(doc(db, 'users', 'user-1'))
const user = docSnap.data()

// Update
await updateDoc(doc(db, 'users', 'user-1'), {
  name: 'Alice Smith'
})

// Delete
await deleteDoc(doc(db, 'users', 'user-1'))
```

```typescript
// dotdo Things Store
// Create
const user = await $.things.create('User', {
  name: 'Alice',
  email: 'alice@example.com'
  // createdAt added automatically
})

// Read
const user = await $.things.get('User', 'user-1')

// Update
await $.things.update('User', 'user-1', {
  name: 'Alice Smith'
})

// Delete
await $.things.delete('User', 'user-1')
```

### Queries

```typescript
// Firebase - Query with filters
const q = query(
  collection(db, 'products'),
  where('category', '==', 'electronics'),
  where('price', '>=', 100),
  orderBy('price', 'desc'),
  limit(10)
)
const snapshot = await getDocs(q)
const products = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))

// Firebase - Compound query
const q = query(
  collection(db, 'orders'),
  where('status', '==', 'pending'),
  where('userId', '==', currentUserId),
  orderBy('createdAt', 'desc')
)
```

```typescript
// dotdo - Query with filters
const products = await $.things.list('Product', {
  where: {
    category: 'electronics',
    price: { $gte: 100 }
  },
  orderBy: { field: 'price', direction: 'desc' },
  limit: 10
})

// dotdo - Compound query
const orders = await $.things.list('Order', {
  where: {
    status: 'pending',
    userId: currentUserId
  },
  orderBy: { field: 'createdAt', direction: 'desc' }
})
```

### Subcollections

```typescript
// Firebase - Subcollections
// users/{userId}/orders/{orderId}
const ordersRef = collection(db, 'users', userId, 'orders')
const snapshot = await getDocs(ordersRef)

// Add to subcollection
await setDoc(doc(db, 'users', userId, 'orders', orderId), orderData)
```

```typescript
// dotdo - Relationships instead of subcollections
const orders = await $.things.list('Order', {
  where: { userId }
})

// Or use include for nested data
const user = await $.things.get('User', userId)
const ordersWithItems = await $.things.list('Order', {
  where: { userId },
  include: ['items']
})
```

## Real-time Database Migration

### Listeners

```typescript
// Firebase Realtime - Listen for changes
import { getDatabase, ref, onValue, onChildAdded } from 'firebase/database'

const db = getDatabase()

// Document listener
const unsubscribe = onValue(ref(db, `users/${userId}`), (snapshot) => {
  const user = snapshot.val()
  updateUI(user)
})

// Collection listener
onChildAdded(ref(db, 'messages'), (snapshot) => {
  const message = snapshot.val()
  appendMessage(message)
})

// Cleanup
unsubscribe()
```

```typescript
// dotdo - WebSocket-based real-time
// Server: src/routes/realtime.ts
import { Hono } from 'hono'
import { upgradeWebSocket } from 'hono/cloudflare-workers'

const app = new Hono()

app.get('/ws/:room', upgradeWebSocket((c) => {
  const room = c.req.param('room')

  return {
    onOpen(event, ws) {
      // Join room for broadcasts
      $.rooms.join(room, ws)
    },
    onMessage(event, ws) {
      const data = JSON.parse(event.data)

      // Broadcast to room
      $.rooms.broadcast(room, {
        type: 'message',
        data
      })
    },
    onClose() {
      $.rooms.leave(room, ws)
    }
  }
}))

// Client
const ws = new WebSocket('wss://your-app.workers.dev/ws/room-1')

ws.onmessage = (event) => {
  const { type, data } = JSON.parse(event.data)
  if (type === 'message') {
    appendMessage(data)
  }
}
```

### Presence

```typescript
// Firebase - Presence system
import { getDatabase, ref, onDisconnect, set, onValue } from 'firebase/database'

const db = getDatabase()
const presenceRef = ref(db, '.info/connected')
const userStatusRef = ref(db, `status/${userId}`)

onValue(presenceRef, (snapshot) => {
  if (snapshot.val() === true) {
    // Set online status
    set(userStatusRef, { state: 'online', lastSeen: Date.now() })

    // Set offline on disconnect
    onDisconnect(userStatusRef).set({
      state: 'offline',
      lastSeen: Date.now()
    })
  }
})
```

```typescript
// dotdo - Presence with DO state
// Server
app.get('/presence/:room', upgradeWebSocket((c) => {
  const room = c.req.param('room')

  return {
    onOpen(event, ws) {
      const userId = c.get('user').id

      // Track presence in DO state
      $.presence.join(room, userId)

      // Broadcast presence update
      $.rooms.broadcast(room, {
        type: 'presence',
        users: $.presence.list(room)
      })
    },
    onClose() {
      const userId = c.get('user').id
      $.presence.leave(room, userId)

      $.rooms.broadcast(room, {
        type: 'presence',
        users: $.presence.list(room)
      })
    }
  }
}))

// Client
ws.onmessage = (event) => {
  const { type, users } = JSON.parse(event.data)
  if (type === 'presence') {
    updateOnlineUsers(users)
  }
}
```

## Firebase Auth Migration

### Basic Authentication

```typescript
// Firebase Auth
import {
  getAuth,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged
} from 'firebase/auth'

const auth = getAuth()

// Sign up
const { user } = await createUserWithEmailAndPassword(
  auth,
  'alice@example.com',
  'password123'
)

// Sign in
const { user } = await signInWithEmailAndPassword(
  auth,
  'alice@example.com',
  'password123'
)

// Sign out
await signOut(auth)

// Auth state listener
onAuthStateChanged(auth, (user) => {
  if (user) {
    console.log('Logged in:', user.uid)
  } else {
    console.log('Logged out')
  }
})
```

```typescript
// dotdo - Using @dotdo/clerk (or Auth0, WorkOS)
// lib/auth.ts
import { createClerkClient } from '@dotdo/clerk'

const clerk = createClerkClient({
  secretKey: env.CLERK_SECRET_KEY
})

// Server-side auth middleware
export const auth = async (c, next) => {
  const token = c.req.header('Authorization')?.split(' ')[1]

  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401)
  }

  try {
    const session = await clerk.sessions.verifySession(token)
    c.set('user', session.user)
    await next()
  } catch {
    return c.json({ error: 'Invalid token' }, 401)
  }
}

// Client-side (using Clerk React SDK)
import { SignIn, SignUp, useUser } from '@clerk/clerk-react'

function App() {
  const { user, isLoaded } = useUser()

  if (!isLoaded) return <Loading />

  if (!user) return <SignIn />

  return <Dashboard user={user} />
}
```

### OAuth Providers

```typescript
// Firebase - Google OAuth
import { GoogleAuthProvider, signInWithPopup } from 'firebase/auth'

const provider = new GoogleAuthProvider()
const { user } = await signInWithPopup(auth, provider)
```

```typescript
// dotdo - OAuth via Clerk/Auth0
// Already configured in Clerk dashboard
// Client just uses the component
import { SignIn } from '@clerk/clerk-react'

// SignIn component includes OAuth buttons based on dashboard config
<SignIn />

// Or programmatic OAuth
import { useSignIn } from '@clerk/clerk-react'

function OAuthButtons() {
  const { signIn } = useSignIn()

  const handleGoogleSignIn = async () => {
    await signIn.authenticateWithRedirect({
      strategy: 'oauth_google',
      redirectUrl: '/sso-callback',
      redirectUrlComplete: '/dashboard'
    })
  }

  return <button onClick={handleGoogleSignIn}>Sign in with Google</button>
}
```

## Cloud Functions Migration

### HTTP Functions

```typescript
// Firebase Cloud Functions
import * as functions from 'firebase-functions'
import * as admin from 'firebase-admin'

admin.initializeApp()

export const createUser = functions.https.onRequest(async (req, res) => {
  if (req.method !== 'POST') {
    res.status(405).send('Method not allowed')
    return
  }

  const { name, email } = req.body

  const userRef = admin.firestore().collection('users').doc()
  await userRef.set({ name, email, createdAt: admin.firestore.FieldValue.serverTimestamp() })

  res.json({ id: userRef.id, name, email })
})

export const getUser = functions.https.onRequest(async (req, res) => {
  const { id } = req.query

  const doc = await admin.firestore().collection('users').doc(id).get()

  if (!doc.exists) {
    res.status(404).json({ error: 'Not found' })
    return
  }

  res.json({ id: doc.id, ...doc.data() })
})
```

```typescript
// dotdo - Hono routes
import { Hono } from 'hono'

const app = new Hono()

app.post('/users', async (c) => {
  const { name, email } = await c.req.json()

  const user = await $.things.create('User', { name, email })

  return c.json(user, 201)
})

app.get('/users/:id', async (c) => {
  const { id } = c.req.param()

  const user = await $.things.get('User', id)

  if (!user) {
    return c.json({ error: 'Not found' }, 404)
  }

  return c.json(user)
})

export default app
```

### Triggered Functions

```typescript
// Firebase - Firestore triggers
export const onUserCreated = functions.firestore
  .document('users/{userId}')
  .onCreate(async (snapshot, context) => {
    const user = snapshot.data()

    // Send welcome email
    await sendWelcomeEmail(user.email)

    // Create default workspace
    await admin.firestore()
      .collection('workspaces')
      .add({
        name: `${user.name}'s Workspace`,
        ownerId: context.params.userId,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      })
  })

export const onOrderCreated = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snapshot) => {
    const order = snapshot.data()

    // Update inventory
    for (const item of order.items) {
      await admin.firestore()
        .collection('products')
        .doc(item.productId)
        .update({
          stock: admin.firestore.FieldValue.increment(-item.quantity)
        })
    }

    // Send confirmation
    await sendOrderConfirmation(order)
  })
```

```typescript
// dotdo - Event handlers
// src/events/users.ts
$.on.User.created(async (event) => {
  const { data: user } = event

  // Send welcome email
  await sendWelcomeEmail(user.email)

  // Create default workspace
  await $.things.create('Workspace', {
    name: `${user.name}'s Workspace`,
    ownerId: user.id
  })
})

// src/events/orders.ts
$.on.Order.created(async (event) => {
  const { data: order } = event

  // Update inventory (durable execution)
  await $.do(async () => {
    for (const item of order.items) {
      const product = await $.things.get('Product', item.productId)
      await $.things.update('Product', item.productId, {
        stock: product.stock - item.quantity
      })
    }
  })

  // Send confirmation
  await sendOrderConfirmation(order)
})
```

### Scheduled Functions

```typescript
// Firebase - Scheduled functions
export const dailyCleanup = functions.pubsub
  .schedule('0 0 * * *')
  .timeZone('America/Los_Angeles')
  .onRun(async () => {
    // Delete old sessions
    const cutoff = new Date()
    cutoff.setDate(cutoff.getDate() - 30)

    const snapshot = await admin.firestore()
      .collection('sessions')
      .where('createdAt', '<', cutoff)
      .get()

    const batch = admin.firestore().batch()
    snapshot.docs.forEach(doc => batch.delete(doc.ref))
    await batch.commit()
  })
```

```typescript
// dotdo - Scheduled handlers
$.every.day.at('midnight').tz('America/Los_Angeles')(async () => {
  // Delete old sessions
  const cutoff = new Date()
  cutoff.setDate(cutoff.getDate() - 30)

  const oldSessions = await $.things.list('Session', {
    where: { createdAt: { $lt: cutoff.toISOString() } }
  })

  for (const session of oldSessions) {
    await $.things.delete('Session', session.id)
  }
})
```

## Firebase Storage Migration

```typescript
// Firebase Storage
import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll } from 'firebase/storage'

const storage = getStorage()

// Upload
const fileRef = ref(storage, `uploads/${userId}/${filename}`)
await uploadBytes(fileRef, file)
const url = await getDownloadURL(fileRef)

// Download URL
const url = await getDownloadURL(ref(storage, path))

// Delete
await deleteObject(ref(storage, path))

// List files
const listRef = ref(storage, `uploads/${userId}`)
const { items } = await listAll(listRef)
const files = items.map(item => item.fullPath)
```

```typescript
// dotdo - Cloudflare R2
const r2 = c.env.BUCKET

// Upload
await r2.put(`uploads/${userId}/${filename}`, file)
const url = `https://your-bucket.r2.dev/uploads/${userId}/${filename}`

// Get object
const object = await r2.get(path)
const data = await object.arrayBuffer()

// Delete
await r2.delete(path)

// List files
const { objects } = await r2.list({ prefix: `uploads/${userId}/` })
const files = objects.map(obj => obj.key)

// Or use @dotdo/storage for Firebase-like API
import { storage } from '@dotdo/storage'

const fileRef = storage.ref(`uploads/${userId}/${filename}`)
await fileRef.put(file)
const url = await fileRef.getDownloadURL()
```

## Complete Migration Example

### Before: Firebase Chat App

```typescript
// Firebase chat implementation
import { initializeApp } from 'firebase/app'
import {
  getFirestore,
  collection,
  addDoc,
  query,
  orderBy,
  limit,
  onSnapshot
} from 'firebase/firestore'
import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from 'firebase/auth'

const app = initializeApp(config)
const db = getFirestore(app)
const auth = getAuth(app)

// Auth
await signInWithEmailAndPassword(auth, email, password)

// Listen for messages
const q = query(
  collection(db, 'rooms', roomId, 'messages'),
  orderBy('timestamp', 'desc'),
  limit(50)
)

const unsubscribe = onSnapshot(q, (snapshot) => {
  const messages = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }))
  renderMessages(messages.reverse())
})

// Send message
await addDoc(collection(db, 'rooms', roomId, 'messages'), {
  text: messageText,
  userId: auth.currentUser.uid,
  userName: auth.currentUser.displayName,
  timestamp: serverTimestamp()
})

// Presence
const presenceRef = ref(getDatabase(), `presence/${roomId}/${userId}`)
set(presenceRef, { online: true, lastSeen: Date.now() })
onDisconnect(presenceRef).set({ online: false, lastSeen: Date.now() })
```

### After: dotdo Chat App

```typescript
// src/routes/chat.ts - Server
import { Hono } from 'hono'
import { upgradeWebSocket } from 'hono/cloudflare-workers'

const chat = new Hono()

// Get messages
chat.get('/rooms/:roomId/messages', async (c) => {
  const { roomId } = c.req.param()

  const messages = await $.things.list('Message', {
    where: { roomId },
    orderBy: { field: 'createdAt', direction: 'desc' },
    limit: 50
  })

  return c.json(messages.reverse())
})

// WebSocket for real-time
chat.get('/rooms/:roomId/ws', upgradeWebSocket((c) => {
  const roomId = c.req.param('roomId')
  const user = c.get('user')

  return {
    onOpen(event, ws) {
      // Join room
      $.rooms.join(roomId, ws)

      // Track presence
      $.presence.join(roomId, user.id, {
        name: user.name,
        online: true
      })

      // Broadcast presence update
      $.rooms.broadcast(roomId, {
        type: 'presence',
        users: $.presence.list(roomId)
      })
    },

    async onMessage(event, ws) {
      const { type, data } = JSON.parse(event.data)

      if (type === 'message') {
        // Save message
        const message = await $.things.create('Message', {
          roomId,
          text: data.text,
          userId: user.id,
          userName: user.name
        })

        // Broadcast to room
        $.rooms.broadcast(roomId, {
          type: 'message',
          data: message
        })
      }
    },

    onClose() {
      // Leave room
      $.rooms.leave(roomId, ws)

      // Update presence
      $.presence.leave(roomId, user.id)

      $.rooms.broadcast(roomId, {
        type: 'presence',
        users: $.presence.list(roomId)
      })
    }
  }
}))

export default chat
```

```typescript
// Client - chat.ts
class ChatClient {
  private ws: WebSocket
  private onMessage: (message: Message) => void
  private onPresence: (users: User[]) => void

  constructor(roomId: string, token: string) {
    this.ws = new WebSocket(
      `wss://your-app.workers.dev/rooms/${roomId}/ws`,
      ['authorization', token]
    )

    this.ws.onmessage = (event) => {
      const { type, data } = JSON.parse(event.data)

      if (type === 'message') {
        this.onMessage?.(data)
      } else if (type === 'presence') {
        this.onPresence?.(data.users)
      }
    }
  }

  send(text: string) {
    this.ws.send(JSON.stringify({
      type: 'message',
      data: { text }
    }))
  }

  onMessageReceived(callback: (message: Message) => void) {
    this.onMessage = callback
  }

  onPresenceChanged(callback: (users: User[]) => void) {
    this.onPresence = callback
  }

  disconnect() {
    this.ws.close()
  }
}
```

## What You Gain

| Aspect | Firebase | dotdo |
|--------|----------|-------|
| Real-time connections | 200K concurrent limit | Unlimited |
| Cold starts | 100-500ms | 0ms |
| Database reads | Pay per read | Bundled |
| WebSocket flexibility | Limited | Full control |
| Edge deployment | No | 300+ cities |
| AI agent support | Manual | Native |
| Vendor lock-in | High | Lower (Cloudflare) |

## Step-by-Step Migration

<Steps>

<Step>

### Create dotdo project

```bash
npx dotdo init my-app
cd my-app
npm install
```

</Step>

<Step>

### Set up authentication

Choose an auth provider and configure:

```bash
npm install @dotdo/clerk
# or @dotdo/auth0
```

</Step>

<Step>

### Migrate Firestore data

Export from Firebase and import to dotdo:

```bash
# Export from Firebase
firebase firestore:export ./backup

# Convert and import
npx dotdo db:import-firebase ./backup
```

</Step>

<Step>

### Convert Cloud Functions to Hono routes

For each function:
1. Create corresponding Hono handler
2. Update database calls to Things store
3. Convert triggers to `$.on.*` handlers

</Step>

<Step>

### Migrate real-time to WebSocket

Replace Firebase listeners with WebSocket connections:
1. Set up WebSocket routes
2. Implement room/presence logic
3. Update client to use WebSocket

</Step>

<Step>

### Migrate storage to R2

Replace Firebase Storage with R2:
1. Configure R2 bucket in `wrangler.toml`
2. Update upload/download code
3. Migrate existing files

</Step>

<Step>

### Test and deploy

```bash
npm run dev     # Test locally
npm run deploy  # Deploy to edge
```

</Step>

</Steps>

## Data Migration

Moving your data from Firebase to dotdo requires careful planning. Here's detailed guidance for different scenarios.

### Exporting from Firestore

Firebase provides several ways to export your data:

```bash
# Option 1: Firebase CLI export (recommended for small-medium datasets)
firebase firestore:export gs://your-bucket/backup

# Download from Cloud Storage
gsutil -m cp -r gs://your-bucket/backup ./firebase-backup

# Option 2: Use the Firebase Admin SDK for custom exports
```

```typescript
// scripts/export-firestore.ts
import admin from 'firebase-admin'
import fs from 'fs'

admin.initializeApp()
const db = admin.firestore()

async function exportCollection(collectionName: string) {
  const snapshot = await db.collection(collectionName).get()
  const data = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data(),
    // Convert Firestore timestamps to ISO strings
    createdAt: doc.data().createdAt?.toDate?.()?.toISOString(),
    updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString(),
  }))

  fs.writeFileSync(
    `./export/${collectionName}.json`,
    JSON.stringify(data, null, 2)
  )

  console.log(`Exported ${data.length} documents from ${collectionName}`)
}

async function main() {
  const collections = ['users', 'products', 'orders', 'messages']

  for (const collection of collections) {
    await exportCollection(collection)
  }
}

main()
```

### Schema Mapping

Firestore and dotdo have different data models. Here's how to map them:

| Firestore | dotdo Things Store | Notes |
|-----------|-------------------|-------|
| Document ID | `id` field | Auto-generated or specify manually |
| `createdAt` (Timestamp) | `createdAt` (ISO string) | Auto-added by Things store |
| `updatedAt` (Timestamp) | `updatedAt` (ISO string) | Auto-added by Things store |
| Subcollections | Relationships | Use `userId`, `orderId`, etc. |
| DocumentReference | String ID | Store the ID, not the reference |
| GeoPoint | Object `{lat, lng}` | Or use separate lat/lng fields |
| Array | Array | Same structure |
| Map | Object | Same structure |

```typescript
// Transform Firestore data to dotdo format
function transformDocument(firestoreDoc: any, collection: string) {
  const transformed = { ...firestoreDoc }

  // Convert Firestore-specific types
  for (const [key, value] of Object.entries(transformed)) {
    // DocumentReference → string ID
    if (value?._path?.segments) {
      transformed[key] = value._path.segments.slice(-1)[0]
    }

    // GeoPoint → {lat, lng}
    if (value?._latitude !== undefined) {
      transformed[key] = {
        lat: value._latitude,
        lng: value._longitude
      }
    }

    // Timestamp → ISO string
    if (value?.toDate) {
      transformed[key] = value.toDate().toISOString()
    }
  }

  return transformed
}
```

### Importing to dotdo

```bash
# Import exported data to dotdo
npx dotdo db:import ./export/users.json --collection User
npx dotdo db:import ./export/products.json --collection Product
npx dotdo db:import ./export/orders.json --collection Order
```

Or use the programmatic import for custom transformations:

```typescript
// scripts/import-to-dotdo.ts
import { createClient } from '@dotdo/client'
import usersData from './export/users.json'

const dotdo = createClient({
  url: process.env.DOTDO_URL,
  key: process.env.DOTDO_KEY
})

async function importUsers() {
  const BATCH_SIZE = 100

  for (let i = 0; i < usersData.length; i += BATCH_SIZE) {
    const batch = usersData.slice(i, i + BATCH_SIZE)

    await Promise.all(
      batch.map(user =>
        dotdo.things.create('User', {
          id: user.id,  // Preserve original Firebase ID
          name: user.name,
          email: user.email,
          role: user.role,
          // Map other fields...
        })
      )
    )

    console.log(`Imported ${Math.min(i + BATCH_SIZE, usersData.length)}/${usersData.length} users`)
  }
}

importUsers()
```

### Large Dataset Considerations

For datasets larger than 100,000 documents:

1. **Use streaming exports** instead of loading everything into memory:

```typescript
// Stream large collections
async function* streamCollection(collectionName: string) {
  let lastDoc = null
  const PAGE_SIZE = 1000

  while (true) {
    let query = db.collection(collectionName)
      .orderBy('__name__')
      .limit(PAGE_SIZE)

    if (lastDoc) {
      query = query.startAfter(lastDoc)
    }

    const snapshot = await query.get()

    if (snapshot.empty) break

    for (const doc of snapshot.docs) {
      yield { id: doc.id, ...doc.data() }
    }

    lastDoc = snapshot.docs[snapshot.docs.length - 1]
  }
}

// Process in batches
async function migrateCollection(name: string) {
  const batch = []

  for await (const doc of streamCollection(name)) {
    batch.push(transformDocument(doc, name))

    if (batch.length >= 100) {
      await importBatch(batch)
      batch.length = 0
    }
  }

  if (batch.length > 0) {
    await importBatch(batch)
  }
}
```

2. **Run migrations during low-traffic periods** to minimize impact on your Firebase billing and dotdo rate limits.

3. **Use parallel workers** for independent collections:

```bash
# Run multiple imports in parallel (for independent collections)
npx dotdo db:import ./users.json --collection User &
npx dotdo db:import ./products.json --collection Product &
npx dotdo db:import ./categories.json --collection Category &
wait
```

4. **Monitor progress and resume on failure**:

```typescript
// Track migration progress
const progress = await $.state.get('migration:progress') || {}

async function migrateWithCheckpoint(collection: string) {
  const lastId = progress[collection] || null

  for await (const doc of streamCollection(collection, lastId)) {
    await dotdo.things.create(collection, doc)

    // Checkpoint every 1000 documents
    if (doc._index % 1000 === 0) {
      progress[collection] = doc.id
      await $.state.put('migration:progress', progress)
    }
  }

  progress[collection] = 'complete'
  await $.state.put('migration:progress', progress)
}
```

## Rollback Strategy

A successful migration requires a solid rollback plan. Here's how to migrate with confidence.

### Phase 1: Dual-Write Setup

Before cutting over, run both systems in parallel:

```typescript
// lib/dual-write.ts
import { initializeApp } from 'firebase/app'
import { getFirestore, doc, setDoc, deleteDoc } from 'firebase/firestore'
import { createClient } from '@dotdo/client'

const firebase = getFirestore(initializeApp(config))
const dotdo = createClient({ url: DOTDO_URL, key: DOTDO_KEY })

// Feature flag to control migration phases
const MIGRATION_PHASE = process.env.MIGRATION_PHASE || 'dual-write'

export async function createUser(data: UserData) {
  switch (MIGRATION_PHASE) {
    case 'firebase-only':
      // Original behavior
      return await setDoc(doc(firebase, 'users', data.id), data)

    case 'dual-write':
      // Write to both systems
      const [firebaseResult, dotdoResult] = await Promise.allSettled([
        setDoc(doc(firebase, 'users', data.id), data),
        dotdo.things.create('User', data)
      ])

      // Log any discrepancies
      if (firebaseResult.status !== dotdoResult.status) {
        console.error('Dual-write mismatch', { firebaseResult, dotdoResult })
      }

      return firebaseResult // Primary is still Firebase

    case 'dotdo-primary':
      // dotdo is primary, Firebase is backup
      const result = await dotdo.things.create('User', data)

      // Async write to Firebase (don't await)
      setDoc(doc(firebase, 'users', data.id), data).catch(console.error)

      return result

    case 'dotdo-only':
      // Migration complete
      return await dotdo.things.create('User', data)
  }
}

export async function getUser(id: string) {
  switch (MIGRATION_PHASE) {
    case 'firebase-only':
    case 'dual-write':
      // Read from Firebase (source of truth)
      const docSnap = await getDoc(doc(firebase, 'users', id))
      return docSnap.data()

    case 'dotdo-primary':
    case 'dotdo-only':
      // Read from dotdo
      return await dotdo.things.get('User', id)
  }
}
```

### Phase 2: Shadow Reads

Verify dotdo returns the same data as Firebase:

```typescript
// middleware/shadow-read.ts
export async function shadowRead(collection: string, id: string) {
  const [firebaseData, dotdoData] = await Promise.all([
    getFirestoreDoc(collection, id),
    dotdo.things.get(collection, id)
  ])

  const differences = compareDocuments(firebaseData, dotdoData)

  if (differences.length > 0) {
    // Log to monitoring system
    await logDifference({
      collection,
      id,
      differences,
      firebaseData,
      dotdoData
    })
  }

  // Return Firebase data (still source of truth)
  return firebaseData
}

function compareDocuments(a: any, b: any): string[] {
  const differences: string[] = []
  const allKeys = new Set([...Object.keys(a || {}), ...Object.keys(b || {})])

  for (const key of allKeys) {
    if (JSON.stringify(a?.[key]) !== JSON.stringify(b?.[key])) {
      differences.push(key)
    }
  }

  return differences
}
```

### Phase 3: Cutover

When ready to switch:

```typescript
// 1. Stop writes to Firebase
// Set MIGRATION_PHASE=dotdo-primary

// 2. Verify all data is synced
async function verifySync() {
  const collections = ['users', 'products', 'orders']

  for (const collection of collections) {
    const firebaseCount = await getFirestoreCount(collection)
    const dotdoCount = await dotdo.things.count(collection)

    if (firebaseCount !== dotdoCount) {
      throw new Error(`Count mismatch in ${collection}: Firebase=${firebaseCount}, dotdo=${dotdoCount}`)
    }

    // Sample 1% of documents for deep comparison
    const sampleSize = Math.ceil(firebaseCount * 0.01)
    const samples = await getRandomSamples(collection, sampleSize)

    for (const sample of samples) {
      const dotdoDoc = await dotdo.things.get(collection, sample.id)
      const differences = compareDocuments(sample, dotdoDoc)

      if (differences.length > 0) {
        console.warn(`Differences in ${collection}/${sample.id}:`, differences)
      }
    }
  }

  console.log('Sync verification complete')
}

// 3. Switch to dotdo-only
// Set MIGRATION_PHASE=dotdo-only
```

### Rollback Procedures

If issues arise after cutover:

```typescript
// Emergency rollback script
// scripts/rollback-to-firebase.ts

async function rollback() {
  // 1. Switch back to Firebase
  process.env.MIGRATION_PHASE = 'firebase-only'

  // 2. Sync any writes that went to dotdo during cutover
  const cutoverTimestamp = '2024-01-15T10:00:00Z'

  const recentDotdoWrites = await dotdo.things.list('*', {
    where: { updatedAt: { $gte: cutoverTimestamp } }
  })

  for (const doc of recentDotdoWrites) {
    await setDoc(
      doc(firebase, doc._type, doc.id),
      excludeSystemFields(doc)
    )
  }

  // 3. Alert team
  await notify('Migration rolled back. Firebase is now primary.')
}
```

### Keeping Firebase Running During Cutover

To minimize risk, keep Firebase running as a hot standby:

```typescript
// config/migration.ts
export const migrationConfig = {
  // Keep Firebase SDK initialized
  keepFirebaseAlive: true,

  // Continue paying for Firebase (small cost for safety)
  firebaseProject: 'my-app-backup',

  // Auto-sync critical writes back to Firebase for 30 days
  backupPeriodDays: 30,

  // Collections to keep synced
  criticalCollections: ['users', 'orders', 'payments']
}

// Middleware to backup writes
app.use(async (c, next) => {
  await next()

  // After successful dotdo write, backup to Firebase
  if (c.req.method === 'POST' || c.req.method === 'PUT') {
    const collection = extractCollection(c.req.path)

    if (migrationConfig.criticalCollections.includes(collection)) {
      const data = await c.req.json()

      // Async backup (don't block response)
      backupToFirebase(collection, data).catch(console.error)
    }
  }
})
```

## Validation Checklist

Use this checklist to verify your migration is complete and correct.

### Pre-Migration

- [ ] **Inventory all collections** - List every Firestore collection and subcollection
- [ ] **Document schema for each collection** - Field names, types, and relationships
- [ ] **Identify data volumes** - Count documents per collection
- [ ] **Map security rules** - Document Firebase rules to migrate to dotdo policies
- [ ] **List Cloud Functions** - Map triggers to dotdo event handlers
- [ ] **Backup Firebase data** - Create full export before starting

### Data Integrity

```typescript
// scripts/validate-migration.ts

async function validateMigration() {
  const results = {
    collections: {},
    issues: []
  }

  const collections = ['users', 'products', 'orders', 'messages']

  for (const collection of collections) {
    // Count comparison
    const firebaseCount = await getFirestoreCount(collection)
    const dotdoCount = await dotdo.things.count(collection)

    results.collections[collection] = {
      firebaseCount,
      dotdoCount,
      match: firebaseCount === dotdoCount
    }

    if (firebaseCount !== dotdoCount) {
      results.issues.push({
        type: 'count_mismatch',
        collection,
        expected: firebaseCount,
        actual: dotdoCount
      })
    }

    // Sample validation (check 100 random documents)
    const samples = await getRandomFirestoreDocs(collection, 100)

    for (const firebaseDoc of samples) {
      const dotdoDoc = await dotdo.things.get(collection, firebaseDoc.id)

      if (!dotdoDoc) {
        results.issues.push({
          type: 'missing_document',
          collection,
          id: firebaseDoc.id
        })
        continue
      }

      // Compare fields (excluding system fields)
      const fieldsToCompare = Object.keys(firebaseDoc)
        .filter(k => !['_path', '_firestore'].includes(k))

      for (const field of fieldsToCompare) {
        const firebaseValue = normalizeValue(firebaseDoc[field])
        const dotdoValue = normalizeValue(dotdoDoc[field])

        if (JSON.stringify(firebaseValue) !== JSON.stringify(dotdoValue)) {
          results.issues.push({
            type: 'field_mismatch',
            collection,
            id: firebaseDoc.id,
            field,
            expected: firebaseValue,
            actual: dotdoValue
          })
        }
      }
    }
  }

  return results
}

// Run validation
const validation = await validateMigration()

if (validation.issues.length > 0) {
  console.error('Migration validation failed:')
  console.table(validation.issues)
  process.exit(1)
} else {
  console.log('Migration validation passed!')
  console.table(validation.collections)
}
```

### Functional Testing

- [ ] **Authentication flows work** - Sign up, sign in, sign out, OAuth
- [ ] **CRUD operations work** - Create, read, update, delete for each entity
- [ ] **Real-time updates work** - WebSocket connections receive updates
- [ ] **File uploads work** - Storage operations succeed
- [ ] **Scheduled jobs run** - Cron equivalents execute correctly

### Smoke Test Procedures

```typescript
// scripts/smoke-test.ts

async function smokeTest() {
  const tests = []

  // Test 1: Create and read a user
  tests.push(async () => {
    const testUser = {
      name: 'Smoke Test User',
      email: `smoke-test-${Date.now()}@example.com`
    }

    const created = await dotdo.things.create('User', testUser)
    const fetched = await dotdo.things.get('User', created.id)

    assert(fetched.name === testUser.name, 'User creation/read failed')

    // Cleanup
    await dotdo.things.delete('User', created.id)

    return 'User CRUD: PASS'
  })

  // Test 2: Query with filters
  tests.push(async () => {
    const results = await dotdo.things.list('Product', {
      where: { category: 'electronics' },
      limit: 10
    })

    assert(Array.isArray(results), 'Query returned non-array')

    return 'Query filters: PASS'
  })

  // Test 3: Real-time connection
  tests.push(async () => {
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(DOTDO_WS_URL)
      const timeout = setTimeout(() => reject('WebSocket timeout'), 5000)

      ws.onopen = () => {
        clearTimeout(timeout)
        ws.close()
        resolve('WebSocket: PASS')
      }

      ws.onerror = reject
    })
  })

  // Test 4: API response times
  tests.push(async () => {
    const start = Date.now()
    await dotdo.things.list('User', { limit: 1 })
    const duration = Date.now() - start

    assert(duration < 100, `API too slow: ${duration}ms`)

    return `API latency: ${duration}ms - PASS`
  })

  // Run all tests
  console.log('Running smoke tests...\n')

  for (const test of tests) {
    try {
      const result = await test()
      console.log(`✓ ${result}`)
    } catch (error) {
      console.error(`✗ ${error}`)
      process.exit(1)
    }
  }

  console.log('\nAll smoke tests passed!')
}

smokeTest()
```

### Comparison Testing

Run the same operations against both systems and compare results:

```typescript
// scripts/comparison-test.ts

async function compareApis() {
  const operations = [
    // List users
    async () => ({
      name: 'List users',
      firebase: await firestore.collection('users').limit(10).get()
        .then(s => s.docs.map(d => ({ id: d.id, ...d.data() }))),
      dotdo: await dotdo.things.list('User', { limit: 10 })
    }),

    // Get specific user
    async () => ({
      name: 'Get user by ID',
      firebase: await firestore.collection('users').doc('user-123').get()
        .then(d => ({ id: d.id, ...d.data() })),
      dotdo: await dotdo.things.get('User', 'user-123')
    }),

    // Complex query
    async () => ({
      name: 'Complex query',
      firebase: await firestore.collection('orders')
        .where('status', '==', 'pending')
        .where('total', '>=', 100)
        .orderBy('total', 'desc')
        .limit(5)
        .get()
        .then(s => s.docs.map(d => ({ id: d.id, ...d.data() }))),
      dotdo: await dotdo.things.list('Order', {
        where: { status: 'pending', total: { $gte: 100 } },
        orderBy: { field: 'total', direction: 'desc' },
        limit: 5
      })
    })
  ]

  for (const op of operations) {
    const result = await op()

    const normalizedFirebase = normalizeResults(result.firebase)
    const normalizedDotdo = normalizeResults(result.dotdo)

    const match = JSON.stringify(normalizedFirebase) === JSON.stringify(normalizedDotdo)

    console.log(`${result.name}: ${match ? '✓ MATCH' : '✗ MISMATCH'}`)

    if (!match) {
      console.log('  Firebase:', JSON.stringify(normalizedFirebase, null, 2))
      console.log('  dotdo:', JSON.stringify(normalizedDotdo, null, 2))
    }
  }
}

function normalizeResults(data: any) {
  // Remove system fields and normalize for comparison
  if (Array.isArray(data)) {
    return data.map(normalizeDoc).sort((a, b) => a.id.localeCompare(b.id))
  }
  return normalizeDoc(data)
}

function normalizeDoc(doc: any) {
  if (!doc) return null

  const { createdAt, updatedAt, _type, ...rest } = doc
  return rest
}
```

### Post-Migration Checklist

- [ ] **All smoke tests pass** - Run automated test suite
- [ ] **Error rates are stable** - Monitor for 24-48 hours
- [ ] **Latency is acceptable** - p50, p95, p99 within targets
- [ ] **No data discrepancies** - Comparison tests pass
- [ ] **Team is notified** - Everyone knows the new system is live
- [ ] **Runbook is ready** - Document how to handle issues
- [ ] **Firebase backup retained** - Keep for 30+ days minimum

## Common Gotchas

### Server Timestamps

```typescript
// Firebase
{ timestamp: serverTimestamp() }

// dotdo - handled automatically
// createdAt and updatedAt are auto-added by Things store
const thing = await $.things.create('Message', { text: 'Hello' })
// thing.createdAt is set automatically
```

### Document IDs

```typescript
// Firebase - auto-generated or specified
const ref = doc(collection(db, 'users'))  // auto
const ref = doc(db, 'users', 'custom-id') // specified

// dotdo - same flexibility
const user = await $.things.create('User', data)        // auto-generated
const user = await $.things.create('User', data, 'custom-id')  // specified
```

### Batch Writes

```typescript
// Firebase
const batch = writeBatch(db)
batch.set(doc1, data1)
batch.update(doc2, data2)
batch.delete(doc3)
await batch.commit()

// dotdo - use $.do for atomic operations
await $.do(async () => {
  await $.things.create('Entity', data1)
  await $.things.update('Entity', id2, data2)
  await $.things.delete('Entity', id3)
})
```

### Security Rules

```typescript
// Firebase - security rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}

// dotdo - JavaScript policies
$.policies.define('User', {
  read: (user, doc) => user.id === doc.id,
  write: (user, doc) => user.id === doc.id
})

// Or middleware-based
app.use('/api/users/:id/*', async (c, next) => {
  const user = c.get('user')
  const { id } = c.req.param()

  if (user.id !== id) {
    return c.json({ error: 'Forbidden' }, 403)
  }

  await next()
})
```

## Next Steps

- [Workflow Context ($)](/docs/sdk/workflow-context) - Events and scheduling
- [Things Store](/docs/sdk/things) - Data persistence
- [Real-time Patterns](/docs/compat/realtime) - WebSocket best practices
- [Named Agents](/docs/agents/named-agents) - Add AI to your app

---

**Firebase patterns transfer. Real-time works. Your skills apply. Scale further with dotdo.**
