---
title: From Firebase
description: Migrate from Firebase to dotdo. Real-time, auth, and storage patterns that scale to AI workloads.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Migrating from Firebase

You've built on Firebase. The real-time database, authentication, hosting - you know how it all fits together. dotdo gives you similar capabilities with an architecture designed for AI-native applications.

## Why Migrate?

Firebase is powerful for building real-time apps quickly. But at scale with AI workloads:

| Challenge | Firebase | dotdo |
|-----------|----------|-------|
| Real-time connections | 200K concurrent (Blaze) | Unlimited |
| Database reads | Pay per read | Bundled |
| Cold start functions | 100-500ms | 0ms |
| Function timeout | 9 min max | Configurable |
| WebSocket customization | Limited | Full control |
| AI agent concurrency | Hundreds | Millions |
| Data locality | Single region | 300+ cities |
| Vendor lock-in | High | Cloudflare (portable) |

<Callout type="info">
Firebase's real-time sync is powerful, but the per-read pricing model becomes expensive with AI agents making frequent queries. dotdo's Durable Objects provide similar real-time capabilities with predictable costs.
</Callout>

## Architecture Comparison

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Firebase Architecture                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐             │
│   │   Firestore  │    │   Realtime   │    │    Cloud     │             │
│   │   Database   │    │   Database   │    │   Functions  │             │
│   └──────┬───────┘    └──────┬───────┘    └──────┬───────┘             │
│          │                   │                   │                      │
│          └───────────┬───────┴───────────────────┘                      │
│                      │                                                   │
│                      ▼                                                   │
│   ┌──────────────────────────────────────────────────────────┐         │
│   │                   Firebase SDK                            │         │
│   │          (Offline sync, real-time listeners)             │         │
│   └──────────────────────────────────────────────────────────┘         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                            dotdo Architecture                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                      Hono HTTP + WebSocket                       │   │
│   │               (API routes, real-time connections)                │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                      Durable Objects                             │   │
│   │            - Per-tenant isolated state                          │   │
│   │            - WebSocket hibernation                              │   │
│   │            - SQLite storage                                     │   │
│   └─────────────────────────────┬───────────────────────────────────┘   │
│                                 │                                        │
│                                 ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                   Tiered Storage (R2/KV)                         │   │
│   │              Hot → Warm → Cold data lifecycle                    │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Key Differences

| Aspect | Firebase | dotdo |
|--------|----------|-------|
| Data model | Documents/Collections | Things (typed entities) |
| Real-time | Firebase SDK listeners | WebSocket + DO broadcast |
| Auth | Firebase Auth | Pluggable (Auth0, Clerk, WorkOS) |
| Functions | Cloud Functions | Hono handlers + DO |
| Storage | Cloud Storage | R2 |
| Hosting | Firebase Hosting | Workers Sites |
| Offline | Built-in SDK | Custom (via DO state) |

## Firestore to Things Store

### Basic CRUD Operations

```typescript
// Firebase Firestore
import { initializeApp } from 'firebase/app'
import {
  getFirestore,
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit
} from 'firebase/firestore'

const app = initializeApp(config)
const db = getFirestore(app)

// Create
await setDoc(doc(db, 'users', 'user-1'), {
  name: 'Alice',
  email: 'alice@example.com',
  createdAt: new Date()
})

// Read
const docSnap = await getDoc(doc(db, 'users', 'user-1'))
const user = docSnap.data()

// Update
await updateDoc(doc(db, 'users', 'user-1'), {
  name: 'Alice Smith'
})

// Delete
await deleteDoc(doc(db, 'users', 'user-1'))
```

```typescript
// dotdo Things Store
// Create
const user = await $.things.create('User', {
  name: 'Alice',
  email: 'alice@example.com'
  // createdAt added automatically
})

// Read
const user = await $.things.get('User', 'user-1')

// Update
await $.things.update('User', 'user-1', {
  name: 'Alice Smith'
})

// Delete
await $.things.delete('User', 'user-1')
```

### Queries

```typescript
// Firebase - Query with filters
const q = query(
  collection(db, 'products'),
  where('category', '==', 'electronics'),
  where('price', '>=', 100),
  orderBy('price', 'desc'),
  limit(10)
)
const snapshot = await getDocs(q)
const products = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))

// Firebase - Compound query
const q = query(
  collection(db, 'orders'),
  where('status', '==', 'pending'),
  where('userId', '==', currentUserId),
  orderBy('createdAt', 'desc')
)
```

```typescript
// dotdo - Query with filters
const products = await $.things.list('Product', {
  where: {
    category: 'electronics',
    price: { $gte: 100 }
  },
  orderBy: { field: 'price', direction: 'desc' },
  limit: 10
})

// dotdo - Compound query
const orders = await $.things.list('Order', {
  where: {
    status: 'pending',
    userId: currentUserId
  },
  orderBy: { field: 'createdAt', direction: 'desc' }
})
```

### Subcollections

```typescript
// Firebase - Subcollections
// users/{userId}/orders/{orderId}
const ordersRef = collection(db, 'users', userId, 'orders')
const snapshot = await getDocs(ordersRef)

// Add to subcollection
await setDoc(doc(db, 'users', userId, 'orders', orderId), orderData)
```

```typescript
// dotdo - Relationships instead of subcollections
const orders = await $.things.list('Order', {
  where: { userId }
})

// Or use include for nested data
const user = await $.things.get('User', userId)
const ordersWithItems = await $.things.list('Order', {
  where: { userId },
  include: ['items']
})
```

## Real-time Database Migration

### Listeners

```typescript
// Firebase Realtime - Listen for changes
import { getDatabase, ref, onValue, onChildAdded } from 'firebase/database'

const db = getDatabase()

// Document listener
const unsubscribe = onValue(ref(db, `users/${userId}`), (snapshot) => {
  const user = snapshot.val()
  updateUI(user)
})

// Collection listener
onChildAdded(ref(db, 'messages'), (snapshot) => {
  const message = snapshot.val()
  appendMessage(message)
})

// Cleanup
unsubscribe()
```

```typescript
// dotdo - WebSocket-based real-time
// Server: src/routes/realtime.ts
import { Hono } from 'hono'
import { upgradeWebSocket } from 'hono/cloudflare-workers'

const app = new Hono()

app.get('/ws/:room', upgradeWebSocket((c) => {
  const room = c.req.param('room')

  return {
    onOpen(event, ws) {
      // Join room for broadcasts
      $.rooms.join(room, ws)
    },
    onMessage(event, ws) {
      const data = JSON.parse(event.data)

      // Broadcast to room
      $.rooms.broadcast(room, {
        type: 'message',
        data
      })
    },
    onClose() {
      $.rooms.leave(room, ws)
    }
  }
}))

// Client
const ws = new WebSocket('wss://your-app.workers.dev/ws/room-1')

ws.onmessage = (event) => {
  const { type, data } = JSON.parse(event.data)
  if (type === 'message') {
    appendMessage(data)
  }
}
```

### Presence

```typescript
// Firebase - Presence system
import { getDatabase, ref, onDisconnect, set, onValue } from 'firebase/database'

const db = getDatabase()
const presenceRef = ref(db, '.info/connected')
const userStatusRef = ref(db, `status/${userId}`)

onValue(presenceRef, (snapshot) => {
  if (snapshot.val() === true) {
    // Set online status
    set(userStatusRef, { state: 'online', lastSeen: Date.now() })

    // Set offline on disconnect
    onDisconnect(userStatusRef).set({
      state: 'offline',
      lastSeen: Date.now()
    })
  }
})
```

```typescript
// dotdo - Presence with DO state
// Server
app.get('/presence/:room', upgradeWebSocket((c) => {
  const room = c.req.param('room')

  return {
    onOpen(event, ws) {
      const userId = c.get('user').id

      // Track presence in DO state
      $.presence.join(room, userId)

      // Broadcast presence update
      $.rooms.broadcast(room, {
        type: 'presence',
        users: $.presence.list(room)
      })
    },
    onClose() {
      const userId = c.get('user').id
      $.presence.leave(room, userId)

      $.rooms.broadcast(room, {
        type: 'presence',
        users: $.presence.list(room)
      })
    }
  }
}))

// Client
ws.onmessage = (event) => {
  const { type, users } = JSON.parse(event.data)
  if (type === 'presence') {
    updateOnlineUsers(users)
  }
}
```

## Firebase Auth Migration

### Basic Authentication

```typescript
// Firebase Auth
import {
  getAuth,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged
} from 'firebase/auth'

const auth = getAuth()

// Sign up
const { user } = await createUserWithEmailAndPassword(
  auth,
  'alice@example.com',
  'password123'
)

// Sign in
const { user } = await signInWithEmailAndPassword(
  auth,
  'alice@example.com',
  'password123'
)

// Sign out
await signOut(auth)

// Auth state listener
onAuthStateChanged(auth, (user) => {
  if (user) {
    console.log('Logged in:', user.uid)
  } else {
    console.log('Logged out')
  }
})
```

```typescript
// dotdo - Using @dotdo/clerk (or Auth0, WorkOS)
// lib/auth.ts
import { createClerkClient } from '@dotdo/clerk'

const clerk = createClerkClient({
  secretKey: env.CLERK_SECRET_KEY
})

// Server-side auth middleware
export const auth = async (c, next) => {
  const token = c.req.header('Authorization')?.split(' ')[1]

  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401)
  }

  try {
    const session = await clerk.sessions.verifySession(token)
    c.set('user', session.user)
    await next()
  } catch {
    return c.json({ error: 'Invalid token' }, 401)
  }
}

// Client-side (using Clerk React SDK)
import { SignIn, SignUp, useUser } from '@clerk/clerk-react'

function App() {
  const { user, isLoaded } = useUser()

  if (!isLoaded) return <Loading />

  if (!user) return <SignIn />

  return <Dashboard user={user} />
}
```

### OAuth Providers

```typescript
// Firebase - Google OAuth
import { GoogleAuthProvider, signInWithPopup } from 'firebase/auth'

const provider = new GoogleAuthProvider()
const { user } = await signInWithPopup(auth, provider)
```

```typescript
// dotdo - OAuth via Clerk/Auth0
// Already configured in Clerk dashboard
// Client just uses the component
import { SignIn } from '@clerk/clerk-react'

// SignIn component includes OAuth buttons based on dashboard config
<SignIn />

// Or programmatic OAuth
import { useSignIn } from '@clerk/clerk-react'

function OAuthButtons() {
  const { signIn } = useSignIn()

  const handleGoogleSignIn = async () => {
    await signIn.authenticateWithRedirect({
      strategy: 'oauth_google',
      redirectUrl: '/sso-callback',
      redirectUrlComplete: '/dashboard'
    })
  }

  return <button onClick={handleGoogleSignIn}>Sign in with Google</button>
}
```

## Cloud Functions Migration

### HTTP Functions

```typescript
// Firebase Cloud Functions
import * as functions from 'firebase-functions'
import * as admin from 'firebase-admin'

admin.initializeApp()

export const createUser = functions.https.onRequest(async (req, res) => {
  if (req.method !== 'POST') {
    res.status(405).send('Method not allowed')
    return
  }

  const { name, email } = req.body

  const userRef = admin.firestore().collection('users').doc()
  await userRef.set({ name, email, createdAt: admin.firestore.FieldValue.serverTimestamp() })

  res.json({ id: userRef.id, name, email })
})

export const getUser = functions.https.onRequest(async (req, res) => {
  const { id } = req.query

  const doc = await admin.firestore().collection('users').doc(id).get()

  if (!doc.exists) {
    res.status(404).json({ error: 'Not found' })
    return
  }

  res.json({ id: doc.id, ...doc.data() })
})
```

```typescript
// dotdo - Hono routes
import { Hono } from 'hono'

const app = new Hono()

app.post('/users', async (c) => {
  const { name, email } = await c.req.json()

  const user = await $.things.create('User', { name, email })

  return c.json(user, 201)
})

app.get('/users/:id', async (c) => {
  const { id } = c.req.param()

  const user = await $.things.get('User', id)

  if (!user) {
    return c.json({ error: 'Not found' }, 404)
  }

  return c.json(user)
})

export default app
```

### Triggered Functions

```typescript
// Firebase - Firestore triggers
export const onUserCreated = functions.firestore
  .document('users/{userId}')
  .onCreate(async (snapshot, context) => {
    const user = snapshot.data()

    // Send welcome email
    await sendWelcomeEmail(user.email)

    // Create default workspace
    await admin.firestore()
      .collection('workspaces')
      .add({
        name: `${user.name}'s Workspace`,
        ownerId: context.params.userId,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      })
  })

export const onOrderCreated = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snapshot) => {
    const order = snapshot.data()

    // Update inventory
    for (const item of order.items) {
      await admin.firestore()
        .collection('products')
        .doc(item.productId)
        .update({
          stock: admin.firestore.FieldValue.increment(-item.quantity)
        })
    }

    // Send confirmation
    await sendOrderConfirmation(order)
  })
```

```typescript
// dotdo - Event handlers
// src/events/users.ts
$.on.User.created(async (event) => {
  const { data: user } = event

  // Send welcome email
  await sendWelcomeEmail(user.email)

  // Create default workspace
  await $.things.create('Workspace', {
    name: `${user.name}'s Workspace`,
    ownerId: user.id
  })
})

// src/events/orders.ts
$.on.Order.created(async (event) => {
  const { data: order } = event

  // Update inventory (durable execution)
  await $.do(async () => {
    for (const item of order.items) {
      const product = await $.things.get('Product', item.productId)
      await $.things.update('Product', item.productId, {
        stock: product.stock - item.quantity
      })
    }
  })

  // Send confirmation
  await sendOrderConfirmation(order)
})
```

### Scheduled Functions

```typescript
// Firebase - Scheduled functions
export const dailyCleanup = functions.pubsub
  .schedule('0 0 * * *')
  .timeZone('America/Los_Angeles')
  .onRun(async () => {
    // Delete old sessions
    const cutoff = new Date()
    cutoff.setDate(cutoff.getDate() - 30)

    const snapshot = await admin.firestore()
      .collection('sessions')
      .where('createdAt', '<', cutoff)
      .get()

    const batch = admin.firestore().batch()
    snapshot.docs.forEach(doc => batch.delete(doc.ref))
    await batch.commit()
  })
```

```typescript
// dotdo - Scheduled handlers
$.every.day.at('midnight').tz('America/Los_Angeles')(async () => {
  // Delete old sessions
  const cutoff = new Date()
  cutoff.setDate(cutoff.getDate() - 30)

  const oldSessions = await $.things.list('Session', {
    where: { createdAt: { $lt: cutoff.toISOString() } }
  })

  for (const session of oldSessions) {
    await $.things.delete('Session', session.id)
  }
})
```

## Firebase Storage Migration

```typescript
// Firebase Storage
import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll } from 'firebase/storage'

const storage = getStorage()

// Upload
const fileRef = ref(storage, `uploads/${userId}/${filename}`)
await uploadBytes(fileRef, file)
const url = await getDownloadURL(fileRef)

// Download URL
const url = await getDownloadURL(ref(storage, path))

// Delete
await deleteObject(ref(storage, path))

// List files
const listRef = ref(storage, `uploads/${userId}`)
const { items } = await listAll(listRef)
const files = items.map(item => item.fullPath)
```

```typescript
// dotdo - Cloudflare R2
const r2 = c.env.BUCKET

// Upload
await r2.put(`uploads/${userId}/${filename}`, file)
const url = `https://your-bucket.r2.dev/uploads/${userId}/${filename}`

// Get object
const object = await r2.get(path)
const data = await object.arrayBuffer()

// Delete
await r2.delete(path)

// List files
const { objects } = await r2.list({ prefix: `uploads/${userId}/` })
const files = objects.map(obj => obj.key)

// Or use @dotdo/storage for Firebase-like API
import { storage } from '@dotdo/storage'

const fileRef = storage.ref(`uploads/${userId}/${filename}`)
await fileRef.put(file)
const url = await fileRef.getDownloadURL()
```

## Complete Migration Example

### Before: Firebase Chat App

```typescript
// Firebase chat implementation
import { initializeApp } from 'firebase/app'
import {
  getFirestore,
  collection,
  addDoc,
  query,
  orderBy,
  limit,
  onSnapshot
} from 'firebase/firestore'
import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from 'firebase/auth'

const app = initializeApp(config)
const db = getFirestore(app)
const auth = getAuth(app)

// Auth
await signInWithEmailAndPassword(auth, email, password)

// Listen for messages
const q = query(
  collection(db, 'rooms', roomId, 'messages'),
  orderBy('timestamp', 'desc'),
  limit(50)
)

const unsubscribe = onSnapshot(q, (snapshot) => {
  const messages = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }))
  renderMessages(messages.reverse())
})

// Send message
await addDoc(collection(db, 'rooms', roomId, 'messages'), {
  text: messageText,
  userId: auth.currentUser.uid,
  userName: auth.currentUser.displayName,
  timestamp: serverTimestamp()
})

// Presence
const presenceRef = ref(getDatabase(), `presence/${roomId}/${userId}`)
set(presenceRef, { online: true, lastSeen: Date.now() })
onDisconnect(presenceRef).set({ online: false, lastSeen: Date.now() })
```

### After: dotdo Chat App

```typescript
// src/routes/chat.ts - Server
import { Hono } from 'hono'
import { upgradeWebSocket } from 'hono/cloudflare-workers'

const chat = new Hono()

// Get messages
chat.get('/rooms/:roomId/messages', async (c) => {
  const { roomId } = c.req.param()

  const messages = await $.things.list('Message', {
    where: { roomId },
    orderBy: { field: 'createdAt', direction: 'desc' },
    limit: 50
  })

  return c.json(messages.reverse())
})

// WebSocket for real-time
chat.get('/rooms/:roomId/ws', upgradeWebSocket((c) => {
  const roomId = c.req.param('roomId')
  const user = c.get('user')

  return {
    onOpen(event, ws) {
      // Join room
      $.rooms.join(roomId, ws)

      // Track presence
      $.presence.join(roomId, user.id, {
        name: user.name,
        online: true
      })

      // Broadcast presence update
      $.rooms.broadcast(roomId, {
        type: 'presence',
        users: $.presence.list(roomId)
      })
    },

    async onMessage(event, ws) {
      const { type, data } = JSON.parse(event.data)

      if (type === 'message') {
        // Save message
        const message = await $.things.create('Message', {
          roomId,
          text: data.text,
          userId: user.id,
          userName: user.name
        })

        // Broadcast to room
        $.rooms.broadcast(roomId, {
          type: 'message',
          data: message
        })
      }
    },

    onClose() {
      // Leave room
      $.rooms.leave(roomId, ws)

      // Update presence
      $.presence.leave(roomId, user.id)

      $.rooms.broadcast(roomId, {
        type: 'presence',
        users: $.presence.list(roomId)
      })
    }
  }
}))

export default chat
```

```typescript
// Client - chat.ts
class ChatClient {
  private ws: WebSocket
  private onMessage: (message: Message) => void
  private onPresence: (users: User[]) => void

  constructor(roomId: string, token: string) {
    this.ws = new WebSocket(
      `wss://your-app.workers.dev/rooms/${roomId}/ws`,
      ['authorization', token]
    )

    this.ws.onmessage = (event) => {
      const { type, data } = JSON.parse(event.data)

      if (type === 'message') {
        this.onMessage?.(data)
      } else if (type === 'presence') {
        this.onPresence?.(data.users)
      }
    }
  }

  send(text: string) {
    this.ws.send(JSON.stringify({
      type: 'message',
      data: { text }
    }))
  }

  onMessageReceived(callback: (message: Message) => void) {
    this.onMessage = callback
  }

  onPresenceChanged(callback: (users: User[]) => void) {
    this.onPresence = callback
  }

  disconnect() {
    this.ws.close()
  }
}
```

## What You Gain

| Aspect | Firebase | dotdo |
|--------|----------|-------|
| Real-time connections | 200K concurrent limit | Unlimited |
| Cold starts | 100-500ms | 0ms |
| Database reads | Pay per read | Bundled |
| WebSocket flexibility | Limited | Full control |
| Edge deployment | No | 300+ cities |
| AI agent support | Manual | Native |
| Vendor lock-in | High | Lower (Cloudflare) |

## Step-by-Step Migration

<Steps>

<Step>

### Create dotdo project

```bash
npx dotdo init my-app
cd my-app
npm install
```

</Step>

<Step>

### Set up authentication

Choose an auth provider and configure:

```bash
npm install @dotdo/clerk
# or @dotdo/auth0
```

</Step>

<Step>

### Migrate Firestore data

Export from Firebase and import to dotdo:

```bash
# Export from Firebase
firebase firestore:export ./backup

# Convert and import
npx dotdo db:import-firebase ./backup
```

</Step>

<Step>

### Convert Cloud Functions to Hono routes

For each function:
1. Create corresponding Hono handler
2. Update database calls to Things store
3. Convert triggers to `$.on.*` handlers

</Step>

<Step>

### Migrate real-time to WebSocket

Replace Firebase listeners with WebSocket connections:
1. Set up WebSocket routes
2. Implement room/presence logic
3. Update client to use WebSocket

</Step>

<Step>

### Migrate storage to R2

Replace Firebase Storage with R2:
1. Configure R2 bucket in `wrangler.toml`
2. Update upload/download code
3. Migrate existing files

</Step>

<Step>

### Test and deploy

```bash
npm run dev     # Test locally
npm run deploy  # Deploy to edge
```

</Step>

</Steps>

## Common Gotchas

### Server Timestamps

```typescript
// Firebase
{ timestamp: serverTimestamp() }

// dotdo - handled automatically
// createdAt and updatedAt are auto-added by Things store
const thing = await $.things.create('Message', { text: 'Hello' })
// thing.createdAt is set automatically
```

### Document IDs

```typescript
// Firebase - auto-generated or specified
const ref = doc(collection(db, 'users'))  // auto
const ref = doc(db, 'users', 'custom-id') // specified

// dotdo - same flexibility
const user = await $.things.create('User', data)        // auto-generated
const user = await $.things.create('User', data, 'custom-id')  // specified
```

### Batch Writes

```typescript
// Firebase
const batch = writeBatch(db)
batch.set(doc1, data1)
batch.update(doc2, data2)
batch.delete(doc3)
await batch.commit()

// dotdo - use $.do for atomic operations
await $.do(async () => {
  await $.things.create('Entity', data1)
  await $.things.update('Entity', id2, data2)
  await $.things.delete('Entity', id3)
})
```

### Security Rules

```typescript
// Firebase - security rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}

// dotdo - JavaScript policies
$.policies.define('User', {
  read: (user, doc) => user.id === doc.id,
  write: (user, doc) => user.id === doc.id
})

// Or middleware-based
app.use('/api/users/:id/*', async (c, next) => {
  const user = c.get('user')
  const { id } = c.req.param()

  if (user.id !== id) {
    return c.json({ error: 'Forbidden' }, 403)
  }

  await next()
})
```

## Next Steps

- [Workflow Context ($)](/docs/sdk/workflow-context) - Events and scheduling
- [Things Store](/docs/sdk/things) - Data persistence
- [Real-time Patterns](/docs/compat/realtime) - WebSocket best practices
- [Named Agents](/docs/agents/named-agents) - Add AI to your app

---

**Firebase patterns transfer. Real-time works. Your skills apply. Scale further with dotdo.**
