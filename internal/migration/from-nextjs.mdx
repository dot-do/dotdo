---
title: From Next.js
description: Migrate your Next.js app to dotdo. API routes, server components, and data fetching patterns.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Migrating from Next.js

You've built with Next.js. The file-based routing, API routes, server-side rendering - you know it well. Here's how those patterns translate to dotdo.

## Architecture Comparison

| Next.js | dotdo |
|---------|-------|
| API routes (`/pages/api/*`) | Hono routes |
| Server Components | TanStack Start + DO fetch |
| `getServerSideProps` | DO data loading |
| Prisma/Drizzle | Things store or compat SDK |
| Vercel deployment | Cloudflare Workers |
| Edge functions | Everything is edge |

## API Routes Migration

Next.js API routes map directly to Hono handlers.

### Basic Route Handler

```typescript
// Next.js - pages/api/users.ts
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === 'GET') {
    const users = await prisma.user.findMany()
    return res.json(users)
  }

  if (req.method === 'POST') {
    const user = await prisma.user.create({ data: req.body })
    return res.status(201).json(user)
  }

  res.status(405).json({ error: 'Method not allowed' })
}
```

```typescript
// dotdo - src/routes/users.ts
import { Hono } from 'hono'

const users = new Hono()

users.get('/', async (c) => {
  const users = await $.things.list('User')
  return c.json(users)
})

users.post('/', async (c) => {
  const body = await c.req.json()
  const user = await $.things.create('User', body)
  return c.json(user, 201)
})

export default users
```

### App Router Route Handlers

```typescript
// Next.js 13+ - app/api/users/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  const users = await prisma.user.findMany()
  return NextResponse.json(users)
}

export async function POST(request: Request) {
  const body = await request.json()
  const user = await prisma.user.create({ data: body })
  return NextResponse.json(user, { status: 201 })
}
```

```typescript
// dotdo - same Hono pattern
import { Hono } from 'hono'

const users = new Hono()

users.get('/', async (c) => {
  const users = await $.things.list('User')
  return c.json(users)
})

users.post('/', async (c) => {
  const body = await c.req.json()
  const user = await $.things.create('User', body)
  return c.json(user, 201)
})

export default users
```

### Dynamic Routes

```typescript
// Next.js - pages/api/users/[id].ts
export default async function handler(req, res) {
  const { id } = req.query

  if (req.method === 'GET') {
    const user = await prisma.user.findUnique({ where: { id } })
    if (!user) return res.status(404).json({ error: 'Not found' })
    return res.json(user)
  }

  if (req.method === 'PUT') {
    const user = await prisma.user.update({
      where: { id },
      data: req.body
    })
    return res.json(user)
  }

  if (req.method === 'DELETE') {
    await prisma.user.delete({ where: { id } })
    return res.status(204).end()
  }
}
```

```typescript
// dotdo
users.get('/:id', async (c) => {
  const { id } = c.req.param()
  const user = await $.things.get('User', id)
  if (!user) return c.json({ error: 'Not found' }, 404)
  return c.json(user)
})

users.put('/:id', async (c) => {
  const { id } = c.req.param()
  const body = await c.req.json()
  const user = await $.things.update('User', id, body)
  return c.json(user)
})

users.delete('/:id', async (c) => {
  const { id } = c.req.param()
  await $.things.delete('User', id)
  return c.body(null, 204)
})
```

## Server-Side Data Fetching

Next.js has `getServerSideProps` and Server Components. dotdo uses Durable Objects for server-side state.

### getServerSideProps Pattern

```typescript
// Next.js - pages/dashboard.tsx
export async function getServerSideProps(context) {
  const session = await getSession(context)
  if (!session) {
    return { redirect: { destination: '/login', permanent: false } }
  }

  const user = await prisma.user.findUnique({
    where: { id: session.userId },
    include: { projects: true }
  })

  return {
    props: { user }
  }
}

export default function Dashboard({ user }) {
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <ProjectList projects={user.projects} />
    </div>
  )
}
```

```typescript
// dotdo - using TanStack Start
// src/routes/dashboard.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/dashboard')({
  beforeLoad: async ({ context }) => {
    const session = await context.getSession()
    if (!session) {
      throw redirect({ to: '/login' })
    }
    return { session }
  },
  loader: async ({ context }) => {
    const user = await $.things.get('User', context.session.userId)
    const projects = await $.things.list('Project', {
      where: { userId: user.id }
    })
    return { user, projects }
  },
  component: Dashboard
})

function Dashboard() {
  const { user, projects } = Route.useLoaderData()
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <ProjectList projects={projects} />
    </div>
  )
}
```

### Server Components Pattern

```typescript
// Next.js 13+ - app/dashboard/page.tsx
import { getSession } from '@/lib/auth'
import { redirect } from 'next/navigation'

export default async function Dashboard() {
  const session = await getSession()
  if (!session) redirect('/login')

  const user = await prisma.user.findUnique({
    where: { id: session.userId },
    include: { projects: true }
  })

  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <Suspense fallback={<Loading />}>
        <ProjectList userId={user.id} />
      </Suspense>
    </div>
  )
}

// Async server component
async function ProjectList({ userId }) {
  const projects = await prisma.project.findMany({
    where: { userId }
  })

  return (
    <ul>
      {projects.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  )
}
```

```typescript
// dotdo - TanStack Start with streaming
// src/routes/dashboard.tsx
export const Route = createFileRoute('/dashboard')({
  loader: async ({ context }) => {
    const session = await context.getSession()
    if (!session) throw redirect({ to: '/login' })

    const user = await $.things.get('User', session.userId)

    // Defer projects for streaming
    const projectsPromise = $.things.list('Project', {
      where: { userId: user.id }
    })

    return {
      user,
      projects: projectsPromise  // Streamed to client
    }
  },
  component: Dashboard
})

function Dashboard() {
  const { user, projects } = Route.useLoaderData()

  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <Suspense fallback={<Loading />}>
        <Await resolve={projects}>
          {(resolvedProjects) => (
            <ul>
              {resolvedProjects.map(p => <li key={p.id}>{p.name}</li>)}
            </ul>
          )}
        </Await>
      </Suspense>
    </div>
  )
}
```

## Database Migration

Next.js typically uses Prisma. dotdo has multiple options.

### Option 1: Things Store (Recommended)

```typescript
// Prisma
const user = await prisma.user.create({
  data: { name: 'Alice', email: 'alice@example.com.ai' }
})

const users = await prisma.user.findMany({
  where: { role: 'admin' },
  orderBy: { createdAt: 'desc' }
})

// Things store
const user = await $.things.create('User', {
  name: 'Alice',
  email: 'alice@example.com.ai'
})

const users = await $.things.list('User', {
  where: { role: 'admin' },
  orderBy: { field: 'createdAt', direction: 'desc' }
})
```

### Option 2: Compat SDK

Keep your Prisma-like syntax with `@dotdo/postgres`:

```typescript
import { createClient } from '@dotdo/postgres'

const db = createClient(env.DATABASE_URL)

// Raw SQL still works
const users = await db.query('SELECT * FROM users WHERE role = $1', ['admin'])
```

### Option 3: External Database

Connect to your existing Postgres, Supabase, or PlanetScale:

```typescript
// Keep using Prisma with external database
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Works in dotdo Workers runtime
const users = await prisma.user.findMany()
```

<Callout type="warn">
External database connections add latency (your DB is in one region). Consider migrating to Things store for full edge performance.
</Callout>

## Middleware Migration

Next.js middleware runs on the edge. dotdo middleware runs on Workers.

```typescript
// Next.js - middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.cookies.get('token')

  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/dashboard/:path*'
}
```

```typescript
// dotdo - src/middleware/auth.ts
import { createMiddleware } from 'hono/factory'

export const requireAuth = createMiddleware(async (c, next) => {
  const token = c.req.header('Cookie')?.match(/token=([^;]+)/)?.[1]

  if (!token) {
    return c.redirect('/login')
  }

  // Verify and attach user
  const user = await verifyToken(token)
  c.set('user', user)
  await next()
})

// Apply to routes
app.use('/dashboard/*', requireAuth)
```

## Environment Variables

```typescript
// Next.js
// .env.local
DATABASE_URL=postgres://...
NEXT_PUBLIC_API_URL=https://api.example.com.ai

// Access
const db = process.env.DATABASE_URL
const apiUrl = process.env.NEXT_PUBLIC_API_URL

// dotdo
// wrangler.toml
[vars]
API_URL = "https://api.example.com.ai"

[[d1_databases]]
binding = "DB"
database_name = "my-db"
database_id = "xxx"

// Access in handlers
app.get('/config', (c) => {
  const apiUrl = c.env.API_URL
  const db = c.env.DB
  // ...
})
```

## Complete Migration Example

### Before: Next.js E-commerce API

```typescript
// pages/api/products/index.ts
import { prisma } from '@/lib/prisma'
import { getSession } from 'next-auth/react'

export default async function handler(req, res) {
  const session = await getSession({ req })

  if (req.method === 'GET') {
    const { category, minPrice, maxPrice } = req.query

    const products = await prisma.product.findMany({
      where: {
        ...(category && { category }),
        ...(minPrice && { price: { gte: parseFloat(minPrice) } }),
        ...(maxPrice && { price: { lte: parseFloat(maxPrice) } }),
      },
      include: { reviews: { take: 3 } }
    })

    return res.json(products)
  }

  if (req.method === 'POST') {
    if (!session?.user?.isAdmin) {
      return res.status(403).json({ error: 'Forbidden' })
    }

    const product = await prisma.product.create({
      data: req.body
    })

    return res.status(201).json(product)
  }

  res.status(405).json({ error: 'Method not allowed' })
}
```

```typescript
// pages/api/products/[id].ts
export default async function handler(req, res) {
  const { id } = req.query

  if (req.method === 'GET') {
    const product = await prisma.product.findUnique({
      where: { id },
      include: {
        reviews: true,
        relatedProducts: { take: 4 }
      }
    })

    if (!product) return res.status(404).json({ error: 'Not found' })
    return res.json(product)
  }

  // ... PUT, DELETE handlers
}
```

### After: dotdo E-commerce API

```typescript
// src/routes/products.ts
import { Hono } from 'hono'

const products = new Hono()

// List products with filters
products.get('/', async (c) => {
  const { category, minPrice, maxPrice } = c.req.query()

  const filters = {
    ...(category && { category }),
    ...(minPrice && { price: { $gte: parseFloat(minPrice) } }),
    ...(maxPrice && { price: { $lte: parseFloat(maxPrice) } }),
  }

  const products = await $.things.list('Product', {
    where: filters,
    include: ['reviews']
  })

  return c.json(products)
})

// Get single product
products.get('/:id', async (c) => {
  const { id } = c.req.param()

  const product = await $.things.get('Product', id)
  if (!product) return c.json({ error: 'Not found' }, 404)

  // Fetch related data
  const reviews = await $.things.list('Review', {
    where: { productId: id }
  })

  const relatedProducts = await $.things.list('Product', {
    where: { category: product.category, id: { $ne: id } },
    limit: 4
  })

  return c.json({
    ...product,
    reviews,
    relatedProducts
  })
})

// Create product (admin only)
products.post('/', requireAdmin, async (c) => {
  const body = await c.req.json()
  const product = await $.things.create('Product', body)
  return c.json(product, 201)
})

// Update product
products.put('/:id', requireAdmin, async (c) => {
  const { id } = c.req.param()
  const body = await c.req.json()
  const product = await $.things.update('Product', id, body)
  return c.json(product)
})

// Delete product
products.delete('/:id', requireAdmin, async (c) => {
  const { id } = c.req.param()
  await $.things.delete('Product', id)
  return c.body(null, 204)
})

export default products
```

```typescript
// src/index.ts
import { Hono } from 'hono'
import products from './routes/products'
import { auth, requireAdmin } from './middleware/auth'

const app = new Hono()

app.use('/api/*', auth)
app.route('/api/products', products)

export default app
```

## What You Gain

| Aspect | Next.js (Vercel) | dotdo |
|--------|------------------|-------|
| Cold starts | 50-250ms | 0ms |
| Regions | 1-few | 300+ cities |
| Edge functions | Separate | Everything |
| Database | External only | Built-in DO state |
| WebSocket | Limited | Native |
| AI agents | Retrofit | Native |
| Pricing | Request-based | More predictable |

## Step-by-Step Migration

<Steps>

<Step>

### Create dotdo project

```bash
npx dotdo init my-app
cd my-app
npm install
```

</Step>

<Step>

### Migrate API routes

For each file in `pages/api/` or `app/api/`:

1. Create corresponding Hono route
2. Convert `req`/`res` to `c`
3. Update database calls

</Step>

<Step>

### Migrate pages to TanStack Start

For pages with server-side data:

1. Convert `getServerSideProps` to route loaders
2. Update component to use `useLoaderData()`

</Step>

<Step>

### Migrate middleware

Convert `middleware.ts` to Hono middleware.

</Step>

<Step>

### Update environment variables

Move from `.env.local` to `wrangler.toml`.

</Step>

<Step>

### Test and deploy

```bash
npm run dev     # Test locally
npm run deploy  # Deploy to edge
```

</Step>

</Steps>

## Keeping Next.js Frontend

You can keep your Next.js frontend and only migrate the API:

```typescript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://your-dotdo-app.workers.dev/api/:path*'
      }
    ]
  }
}
```

This lets you migrate gradually - API first, then frontend when ready.

## App Router Patterns

Next.js 13+ App Router patterns have direct equivalents in dotdo.

### Layout Components

```typescript
// Next.js - app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Header />
        <main>{children}</main>
        <Footer />
      </body>
    </html>
  )
}

// app/dashboard/layout.tsx
export default function DashboardLayout({ children }) {
  return (
    <div className="dashboard">
      <Sidebar />
      <div className="content">{children}</div>
    </div>
  )
}
```

```typescript
// dotdo - TanStack Router layouts
// src/routes/__root.tsx
import { createRootRoute, Outlet } from '@tanstack/react-router'

export const Route = createRootRoute({
  component: () => (
    <html lang="en">
      <body>
        <Header />
        <main><Outlet /></main>
        <Footer />
      </body>
    </html>
  )
})

// src/routes/dashboard.tsx
export const Route = createFileRoute('/dashboard')({
  component: () => (
    <div className="dashboard">
      <Sidebar />
      <div className="content"><Outlet /></div>
    </div>
  )
})
```

### Loading States

```typescript
// Next.js - app/dashboard/loading.tsx
export default function Loading() {
  return <div className="spinner">Loading...</div>
}

// app/dashboard/page.tsx
export default async function Dashboard() {
  const data = await fetchDashboardData()
  return <DashboardContent data={data} />
}
```

```typescript
// dotdo - TanStack Router pending states
export const Route = createFileRoute('/dashboard')({
  loader: async () => {
    return await fetchDashboardData()
  },
  pendingComponent: () => <div className="spinner">Loading...</div>,
  component: Dashboard
})

function Dashboard() {
  const data = Route.useLoaderData()
  return <DashboardContent data={data} />
}
```

### Error Handling

```typescript
// Next.js - app/dashboard/error.tsx
'use client'

export default function Error({ error, reset }) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

```typescript
// dotdo - TanStack Router error handling
export const Route = createFileRoute('/dashboard')({
  loader: async () => fetchDashboardData(),
  errorComponent: ({ error, reset }) => (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  ),
  component: Dashboard
})
```

### Not Found

```typescript
// Next.js - app/not-found.tsx
export default function NotFound() {
  return (
    <div>
      <h2>Page not found</h2>
      <Link href="/">Go home</Link>
    </div>
  )
}
```

```typescript
// dotdo - TanStack Router 404
// src/routes/__root.tsx
export const Route = createRootRoute({
  component: RootComponent,
  notFoundComponent: () => (
    <div>
      <h2>Page not found</h2>
      <Link to="/">Go home</Link>
    </div>
  )
})
```

## Static Site Generation (SSG) and ISR

### Static Generation

```typescript
// Next.js - Static generation
// app/blog/[slug]/page.tsx
export async function generateStaticParams() {
  const posts = await getPosts()
  return posts.map((post) => ({ slug: post.slug }))
}

export default async function Post({ params }) {
  const post = await getPost(params.slug)
  return <article>{post.content}</article>
}
```

```typescript
// dotdo - Pre-rendering with static exports
// Pre-build posts at deploy time
// scripts/prebuild.ts
import { getPosts, getPost } from '../lib/posts'

export async function prebuild() {
  const posts = await getPosts()

  for (const post of posts) {
    const content = await getPost(post.slug)
    // Write to static assets or cache in KV
    await KV.put(`post:${post.slug}`, JSON.stringify(content))
  }
}

// src/routes/blog/[slug].tsx
export const Route = createFileRoute('/blog/$slug')({
  loader: async ({ params }) => {
    // Try cache first (like ISR)
    const cached = await c.env.KV.get(`post:${params.slug}`)
    if (cached) return JSON.parse(cached)

    // Fall back to fresh fetch
    return await getPost(params.slug)
  },
  component: Post
})
```

### Incremental Static Regeneration

```typescript
// Next.js - ISR
export async function generateStaticParams() {
  return [{ slug: 'hello-world' }]
}

// Revalidate every 60 seconds
export const revalidate = 60

export default async function Post({ params }) {
  const post = await getPost(params.slug)
  return <article>{post.content}</article>
}
```

```typescript
// dotdo - Cache with TTL (similar to ISR)
export const Route = createFileRoute('/blog/$slug')({
  loader: async ({ params, context }) => {
    const cacheKey = `post:${params.slug}`

    // Check cache with TTL
    const cached = await context.env.KV.get(cacheKey, {
      type: 'json',
      cacheTtl: 60 // Cache for 60 seconds
    })

    if (cached) return cached

    // Fetch fresh data
    const post = await getPost(params.slug)

    // Store in cache
    await context.env.KV.put(cacheKey, JSON.stringify(post), {
      expirationTtl: 60
    })

    return post
  }
})

// Or use Cache API for fine-grained control
const cache = caches.default

app.get('/blog/:slug', async (c) => {
  const cacheKey = new Request(c.req.url)

  // Try cache
  const cached = await cache.match(cacheKey)
  if (cached) return cached

  // Fresh fetch
  const post = await getPost(c.req.param('slug'))
  const response = c.json(post)

  // Cache for 60 seconds
  response.headers.set('Cache-Control', 'public, max-age=60')
  await cache.put(cacheKey, response.clone())

  return response
})
```

## Image Optimization

### Next.js Image Component

```typescript
// Next.js
import Image from 'next/image'

export default function Avatar() {
  return (
    <Image
      src="/avatar.png"
      alt="User avatar"
      width={64}
      height={64}
      placeholder="blur"
      blurDataURL="data:image/..."
    />
  )
}
```

```typescript
// dotdo - Cloudflare Images or manual optimization
// Option 1: Cloudflare Images
export function Avatar() {
  return (
    <img
      src="https://imagedelivery.net/account/avatar/width=64,height=64"
      alt="User avatar"
      width={64}
      height={64}
      loading="lazy"
    />
  )
}

// Option 2: R2 with Image Resizing
export function Avatar({ src }: { src: string }) {
  // Cloudflare Image Resizing via URL
  const optimizedSrc = `/cdn-cgi/image/width=64,height=64,fit=cover/${src}`

  return (
    <img
      src={optimizedSrc}
      alt="User avatar"
      width={64}
      height={64}
      loading="lazy"
    />
  )
}

// Option 3: Custom image component with blur placeholder
export function OptimizedImage({ src, width, height, alt }) {
  const [loaded, setLoaded] = useState(false)

  return (
    <div className="relative" style={{ width, height }}>
      {!loaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      <img
        src={`/cdn-cgi/image/width=${width},height=${height}/${src}`}
        alt={alt}
        width={width}
        height={height}
        loading="lazy"
        onLoad={() => setLoaded(true)}
        className={loaded ? 'opacity-100' : 'opacity-0'}
      />
    </div>
  )
}
```

## Authentication Patterns

### NextAuth.js to dotdo Auth

```typescript
// Next.js - NextAuth.js
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth'
import GoogleProvider from 'next-auth/providers/google'

export const authOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_ID!,
      clientSecret: process.env.GOOGLE_SECRET!,
    }),
  ],
  callbacks: {
    session: ({ session, token }) => ({
      ...session,
      user: { ...session.user, id: token.sub }
    })
  }
}

const handler = NextAuth(authOptions)
export { handler as GET, handler as POST }

// Usage in page
import { getServerSession } from 'next-auth'

export default async function Page() {
  const session = await getServerSession(authOptions)

  if (!session) {
    redirect('/login')
  }

  return <div>Welcome, {session.user.name}</div>
}
```

```typescript
// dotdo - Using Clerk or Auth0
// lib/auth.ts
import { createClerkClient, verifyToken } from '@dotdo/clerk'

export const clerk = createClerkClient({
  secretKey: env.CLERK_SECRET_KEY
})

// Middleware
export const authMiddleware = async (c, next) => {
  const token = c.req.header('Authorization')?.split(' ')[1]
    || c.req.cookie('__session')

  if (!token) {
    return c.redirect('/sign-in')
  }

  try {
    const session = await verifyToken(token, {
      secretKey: c.env.CLERK_SECRET_KEY
    })
    c.set('user', session)
    await next()
  } catch {
    return c.redirect('/sign-in')
  }
}

// Route protection
app.use('/dashboard/*', authMiddleware)

// In TanStack Router
export const Route = createFileRoute('/dashboard')({
  beforeLoad: async ({ context }) => {
    const session = await context.getSession()
    if (!session) {
      throw redirect({ to: '/sign-in' })
    }
    return { user: session.user }
  },
  component: Dashboard
})

function Dashboard() {
  const { user } = Route.useRouteContext()
  return <div>Welcome, {user.name}</div>
}
```

### Session Management

```typescript
// Next.js - Session in middleware
// middleware.ts
import { getToken } from 'next-auth/jwt'

export async function middleware(request: NextRequest) {
  const token = await getToken({ req: request })

  if (!token && request.nextUrl.pathname.startsWith('/protected')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
}
```

```typescript
// dotdo - Session middleware
// src/middleware/session.ts
import { verify } from 'hono/jwt'

export const sessionMiddleware = async (c, next) => {
  const token = c.req.cookie('session')
    || c.req.header('Authorization')?.replace('Bearer ', '')

  if (token) {
    try {
      const payload = await verify(token, c.env.JWT_SECRET)
      c.set('session', payload)
    } catch {
      // Invalid token - clear cookie
      c.header('Set-Cookie', 'session=; HttpOnly; Secure; SameSite=Strict; Max-Age=0')
    }
  }

  await next()
}

// Protected routes middleware
export const requireAuth = async (c, next) => {
  const session = c.get('session')

  if (!session) {
    return c.redirect('/login')
  }

  await next()
}

// Apply
app.use('*', sessionMiddleware)
app.use('/protected/*', requireAuth)
```

## Middleware (Edge Runtime)

Next.js middleware runs on the edge. All dotdo code runs on the edge.

### Request/Response Modification

```typescript
// Next.js - middleware.ts
import { NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // Add custom header
  const response = NextResponse.next()
  response.headers.set('x-custom-header', 'my-value')

  // Geo-based routing
  const country = request.geo?.country || 'US'
  if (country === 'DE') {
    return NextResponse.redirect(new URL('/de', request.url))
  }

  // A/B testing
  const bucket = request.cookies.get('ab-bucket')?.value
    || (Math.random() < 0.5 ? 'a' : 'b')

  if (!request.cookies.get('ab-bucket')) {
    response.cookies.set('ab-bucket', bucket)
  }

  return response
}
```

```typescript
// dotdo - Hono middleware
app.use('*', async (c, next) => {
  await next()

  // Add custom header
  c.header('x-custom-header', 'my-value')
})

// Geo-based routing
app.use('*', async (c, next) => {
  const country = c.req.header('CF-IPCountry') || 'US'

  if (country === 'DE' && !c.req.path.startsWith('/de')) {
    return c.redirect('/de' + c.req.path)
  }

  await next()
})

// A/B testing
app.use('*', async (c, next) => {
  let bucket = c.req.cookie('ab-bucket')

  if (!bucket) {
    bucket = Math.random() < 0.5 ? 'a' : 'b'
    c.header('Set-Cookie', `ab-bucket=${bucket}; Path=/; HttpOnly; Secure`)
  }

  c.set('abBucket', bucket)
  await next()
})
```

### URL Rewriting

```typescript
// Next.js - Rewrite rules
export function middleware(request: NextRequest) {
  // Rewrite /old-path to /new-path
  if (request.nextUrl.pathname === '/old-path') {
    return NextResponse.rewrite(new URL('/new-path', request.url))
  }

  // API versioning
  if (request.nextUrl.pathname.startsWith('/api/v1')) {
    const newPath = request.nextUrl.pathname.replace('/api/v1', '/api')
    return NextResponse.rewrite(new URL(newPath, request.url))
  }
}
```

```typescript
// dotdo - URL rewriting
// Redirect old paths
app.get('/old-path', (c) => c.redirect('/new-path', 301))

// API versioning with route aliasing
const v1Router = new Hono()
v1Router.route('/', apiRouter) // Same handlers

app.route('/api', apiRouter)
app.route('/api/v1', v1Router)

// Or use middleware for transparent rewrites
app.use('/api/v1/*', async (c, next) => {
  // Rewrite URL internally
  const newPath = c.req.path.replace('/api/v1', '/api')
  c.req.raw = new Request(
    new URL(newPath, c.req.url),
    c.req.raw
  )
  await next()
})
```

## Route Handlers vs API Routes

### Route Handler Patterns

```typescript
// Next.js - app/api/users/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const page = searchParams.get('page') || '1'

  const users = await getUsers({ page: parseInt(page) })
  return NextResponse.json(users)
}

export async function POST(request: Request) {
  const body = await request.json()

  // Validate
  if (!body.email) {
    return NextResponse.json(
      { error: 'Email required' },
      { status: 400 }
    )
  }

  const user = await createUser(body)
  return NextResponse.json(user, { status: 201 })
}
```

```typescript
// dotdo - Hono routes (cleaner syntax)
const users = new Hono()

users.get('/', async (c) => {
  const page = parseInt(c.req.query('page') || '1')
  const users = await $.things.list('User', { page })
  return c.json(users)
})

users.post('/', async (c) => {
  const body = await c.req.json()

  // Validate with Zod
  const schema = z.object({ email: z.string().email() })
  const result = schema.safeParse(body)

  if (!result.success) {
    return c.json({ error: result.error.flatten() }, 400)
  }

  const user = await $.things.create('User', result.data)
  return c.json(user, 201)
})

export default users
```

## Streaming and Suspense

```typescript
// Next.js - Streaming with Suspense
// app/dashboard/page.tsx
import { Suspense } from 'react'

async function SlowComponent() {
  const data = await fetchSlowData() // Takes 3 seconds
  return <div>{data}</div>
}

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Suspense fallback={<Skeleton />}>
        <SlowComponent />
      </Suspense>
    </div>
  )
}
```

```typescript
// dotdo - TanStack Router with deferred data
export const Route = createFileRoute('/dashboard')({
  loader: async () => {
    // Start slow fetch but don't await
    const slowDataPromise = fetchSlowData()

    // Return immediately with fast data
    const fastData = await fetchFastData()

    return {
      fastData,
      slowData: slowDataPromise // Deferred
    }
  },
  component: Dashboard
})

function Dashboard() {
  const { fastData, slowData } = Route.useLoaderData()

  return (
    <div>
      <h1>Dashboard</h1>
      <FastSection data={fastData} />

      <Suspense fallback={<Skeleton />}>
        <Await resolve={slowData}>
          {(data) => <SlowSection data={data} />}
        </Await>
      </Suspense>
    </div>
  )
}
```

## Common Migration Gotchas

### useSearchParams vs c.req.query

```typescript
// Next.js Client Component
'use client'
import { useSearchParams } from 'next/navigation'

export default function Search() {
  const searchParams = useSearchParams()
  const query = searchParams.get('q')
  // ...
}

// dotdo - Server-side
app.get('/search', (c) => {
  const query = c.req.query('q')
  // ...
})

// Client-side with TanStack Router
function Search() {
  const { q } = Route.useSearch()
  // ...
}
```

### usePathname vs Route Context

```typescript
// Next.js
'use client'
import { usePathname } from 'next/navigation'

export default function Nav() {
  const pathname = usePathname()
  const isActive = pathname === '/dashboard'
}

// dotdo - TanStack Router
import { useLocation } from '@tanstack/react-router'

function Nav() {
  const { pathname } = useLocation()
  const isActive = pathname === '/dashboard'
}
```

### next/headers vs Hono Context

```typescript
// Next.js
import { headers, cookies } from 'next/headers'

export async function GET() {
  const headersList = headers()
  const cookieStore = cookies()

  const token = headersList.get('authorization')
  const session = cookieStore.get('session')
}

// dotdo
app.get('/api/example', (c) => {
  const token = c.req.header('authorization')
  const session = c.req.cookie('session')
})
```

## Next Steps

- [Workflow Context ($)](/docs/sdk/workflow-context) - Event handling and scheduling
- [Things Store](/docs/sdk/things) - Data persistence patterns
- [Named Agents](/docs/agents/named-agents) - Add AI to your app
- [Deployment](/docs/deployment) - Production configuration
- [Testing Guide](/docs/guides/testing) - Testing patterns for dotdo

---

**You built with Next.js. You can build with dotdo. Same skills, new superpowers.**
