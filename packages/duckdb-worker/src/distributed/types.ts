/**
 * Type definitions for Distributed Query Layer
 *
 * Implements Coordinator + Data Worker pattern for distributed query execution
 * across Cloudflare Workers within 128MB memory limits.
 *
 * Architecture:
 * ```
 * User Query -> Coordinator Worker -> Fan-out via RPC
 *                                      |-> Data Worker A (Partition 1)
 *                                      |-> Data Worker B (Partition 2)
 *                                      |-> Data Worker C (Partition 3)
 *                                   -> Merge Results
 * ```
 *
 * @module packages/duckdb-worker/src/distributed/types
 */

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Configuration for distributed query execution
 */
export interface DistributedQueryConfig {
  /**
   * Path to Iceberg metadata in R2
   * @example 'r2://analytics/metadata/'
   */
  metadataPath: string

  /**
   * Maximum number of concurrent data workers
   * @default 10
   */
  maxWorkers?: number

  /**
   * Memory budget per worker in bytes
   * @default 84 * 1024 * 1024 (84MB - accounts for 34MB DuckDB + 10MB overhead)
   */
  memoryBudgetBytes?: number

  /**
   * Timeout for individual worker execution in milliseconds
   * @default 30000
   */
  workerTimeoutMs?: number

  /**
   * R2 bucket binding for data access (Workers environment)
   */
  r2Bucket?: R2Bucket

  /**
   * Custom fetch function for R2 operations (for testing)
   */
  fetchFn?: typeof fetch

  /**
   * Enable query result streaming for large results
   * @default false
   */
  enableStreaming?: boolean
}

// ============================================================================
// Partition Types
// ============================================================================

/**
 * Column statistics for partition pruning decisions
 */
export interface PruningStats {
  /** Minimum value in the partition (for range comparisons) */
  min?: unknown

  /** Maximum value in the partition (for range comparisons) */
  max?: unknown

  /** Number of rows in the partition */
  rowCount: number

  /** Distinct value count (for cardinality estimation) */
  distinctCount?: number

  /** Null value count */
  nullCount?: number

  /** File size in bytes */
  sizeBytes: number
}

/**
 * Partition information for query planning
 */
export interface PartitionInfo {
  /** R2 path to the partition's Parquet file */
  path: string

  /** Partition values (e.g., { date: '2024-01-01', region: 'us-west-2' }) */
  partitionValues: Record<string, unknown>

  /** Column statistics for pruning decisions */
  pruningStats: Record<string, PruningStats>

  /** File format (always 'parquet' for now) */
  format: 'parquet'

  /** File size in bytes */
  sizeBytes: number

  /** Row count in this partition */
  rowCount: number
}

// ============================================================================
// Query Planning Types
// ============================================================================

/**
 * Supported aggregate functions for pushdown
 */
export type AggregateFunction = 'SUM' | 'COUNT' | 'AVG' | 'MIN' | 'MAX' | 'COUNT_DISTINCT'

/**
 * Aggregate expression in the query
 */
export interface AggregateExpr {
  /** Aggregate function */
  fn: AggregateFunction

  /** Column being aggregated (null for COUNT(*)) */
  column: string | null

  /** Output alias */
  alias: string

  /** Whether DISTINCT is applied */
  distinct?: boolean
}

/**
 * Filter predicate for WHERE clause pushdown
 */
export interface FilterPredicate {
  /** Column name */
  column: string

  /** Comparison operator */
  op: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'IN' | 'NOT IN' | 'BETWEEN' | 'LIKE' | 'IS NULL' | 'IS NOT NULL'

  /** Comparison value(s) */
  value: unknown

  /** Second value for BETWEEN */
  value2?: unknown
}

/**
 * Sort specification for ORDER BY
 */
export interface SortSpec {
  /** Column name or alias */
  column: string

  /** Sort direction */
  direction: 'ASC' | 'DESC'

  /** Null handling */
  nulls?: 'FIRST' | 'LAST'
}

/**
 * Pushdown operations that can be executed on data workers
 */
export interface PushdownOps {
  /** WHERE clause filters to push down */
  filters: FilterPredicate[]

  /** GROUP BY columns */
  groupBy: string[]

  /** Aggregate expressions */
  aggregates: AggregateExpr[]

  /** SELECT columns (projection pushdown) */
  projection: string[]

  /** ORDER BY (for top-N optimization) */
  orderBy?: SortSpec[]

  /** LIMIT (for top-N per partition) */
  limit?: number
}

/**
 * Query plan generated by the coordinator
 */
export interface QueryPlan {
  /** Original SQL query */
  originalSql: string

  /** Table being queried */
  table: string

  /** Partitions selected after pruning */
  partitions: PartitionInfo[]

  /** Partitions that were pruned */
  prunedPartitions: number

  /** Operations to push down to workers */
  pushdownOps: PushdownOps

  /** Whether results need global sorting */
  requiresGlobalSort: boolean

  /** Whether this is a top-N query */
  isTopN: boolean

  /** Estimated total rows to process */
  estimatedRows: number

  /** Estimated total bytes to process */
  estimatedBytes: number
}

// ============================================================================
// Worker Communication Types
// ============================================================================

/**
 * Task sent to a data worker
 */
export interface WorkerTask {
  /** Unique task ID */
  taskId: string

  /** Partition to process */
  partition: PartitionInfo

  /** SQL to execute on the partition */
  sql: string

  /** Pushdown operations */
  pushdownOps: PushdownOps

  /** Memory budget for this task */
  memoryBudgetBytes: number
}

/**
 * Result from a data worker
 */
export interface WorkerResult {
  /** Task ID this result is for */
  taskId: string

  /** Whether execution succeeded */
  success: boolean

  /** Error message if failed */
  error?: string

  /** Partial result data */
  data?: PartialResult

  /** Execution statistics */
  stats: WorkerStats
}

/**
 * Execution statistics from a worker
 */
export interface WorkerStats {
  /** Time to fetch data from R2 in ms */
  fetchTimeMs: number

  /** Time to execute query in ms */
  queryTimeMs: number

  /** Total execution time in ms */
  totalTimeMs: number

  /** Bytes read from R2 */
  bytesRead: number

  /** Rows processed */
  rowsProcessed: number

  /** Peak memory usage in bytes */
  peakMemoryBytes?: number
}

// ============================================================================
// Partial Result Types
// ============================================================================

/**
 * Partial aggregate state that can be merged
 */
export interface PartialAggregate {
  /** Aggregate function */
  fn: AggregateFunction

  /** Output alias */
  alias: string

  /** Partial value (depends on function) */
  value: unknown

  /** Count (for AVG calculation) */
  count?: number
}

/**
 * Partial result from a data worker
 */
export interface PartialResult {
  /** Result rows (for non-aggregate queries or grouped results) */
  rows: Record<string, unknown>[]

  /** Partial aggregates (keyed by group values as JSON string, or '__global__') */
  aggregates: Map<string, PartialAggregate[]>

  /** Column metadata */
  columns: ColumnMeta[]

  /** Number of rows in this partial result */
  rowCount: number

  /** Whether there are more results (for streaming) */
  hasMore?: boolean

  /** Continuation token for streaming */
  continuationToken?: string
}

/**
 * Column metadata
 */
export interface ColumnMeta {
  /** Column name */
  name: string

  /** Column type */
  type: string

  /** Whether nullable */
  nullable?: boolean
}

// ============================================================================
// Merged Result Types
// ============================================================================

/**
 * Final merged result from all workers
 */
export interface MergedResult {
  /** Final result rows */
  rows: Record<string, unknown>[]

  /** Column metadata */
  columns: ColumnMeta[]

  /** Total row count */
  rowCount: number

  /** Query execution statistics */
  stats: QueryStats
}

/**
 * Query execution statistics
 */
export interface QueryStats {
  /** Total partitions in table */
  totalPartitions: number

  /** Partitions pruned by planner */
  prunedPartitions: number

  /** Partitions actually scanned */
  scannedPartitions: number

  /** Total bytes scanned */
  bytesScanned: number

  /** Total rows processed */
  rowsProcessed: number

  /** Planning time in ms */
  planningTimeMs: number

  /** Total execution time in ms */
  executionTimeMs: number

  /** Worker execution times */
  workerStats: WorkerStats[]
}

// ============================================================================
// Storage Interface (R2)
// ============================================================================

/**
 * Simplified R2Bucket interface for type safety
 * (actual implementation uses @cloudflare/workers-types)
 */
export interface R2Bucket {
  get(key: string): Promise<R2Object | null>
  head(key: string): Promise<R2ObjectHead | null>
  list(options?: R2ListOptions): Promise<R2ObjectList>
}

export interface R2Object {
  key: string
  size: number
  arrayBuffer(): Promise<ArrayBuffer>
}

export interface R2ObjectHead {
  key: string
  size: number
}

export interface R2ListOptions {
  prefix?: string
  limit?: number
  cursor?: string
}

export interface R2ObjectList {
  objects: R2ObjectHead[]
  truncated: boolean
  cursor?: string
}

// ============================================================================
// Error Types
// ============================================================================

/**
 * Error codes for distributed query errors
 */
export type DistributedQueryErrorCode =
  | 'PLANNING_ERROR'
  | 'PARTITION_FETCH_ERROR'
  | 'WORKER_TIMEOUT'
  | 'WORKER_OOM'
  | 'MERGE_ERROR'
  | 'INVALID_SQL'
  | 'TABLE_NOT_FOUND'
  | 'METADATA_ERROR'

/**
 * Error thrown by distributed query operations
 */
export class DistributedQueryError extends Error {
  constructor(
    message: string,
    public readonly code: DistributedQueryErrorCode,
    public readonly cause?: Error
  ) {
    super(message)
    this.name = 'DistributedQueryError'
  }
}
