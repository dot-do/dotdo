/**
 * DuckDB WASM Bindings for Cloudflare Workers
 *
 * This module provides Workers-compatible bindings to our custom DuckDB WASM build.
 * The WASM is built with Emscripten flags that eliminate GOT imports for Workers compatibility.
 */

import type { DuckDBInstance, DuckDBConfig, QueryResult, ColumnInfo } from './types.js'
import type { DuckDBModule, DuckDBModuleConfig } from '../wasm/duckdb-worker.js'
import {
  registerFileBuffer as runtimeRegisterBuffer,
  dropFile as runtimeDropFile,
  clearAllFiles,
} from './runtime.js'

// ============================================================================
// Types for Emscripten Module Interface
// ============================================================================

/**
 * Extended DuckDB module interface with optional Emscripten FS
 */
interface EmscriptenModule extends DuckDBModule {
  // Emscripten filesystem (if available)
  FS?: {
    mkdir(path: string): void
    writeFile(path: string, data: Uint8Array): void
    readFile(path: string): Uint8Array
    unlink(path: string): void
  }
}

/**
 * DuckDB type enum values from C API
 */
const DuckDBType = {
  INVALID: 0,
  BOOLEAN: 1,
  TINYINT: 2,
  SMALLINT: 3,
  INTEGER: 4,
  BIGINT: 5,
  UTINYINT: 6,
  USMALLINT: 7,
  UINTEGER: 8,
  UBIGINT: 9,
  FLOAT: 10,
  DOUBLE: 11,
  TIMESTAMP: 12,
  DATE: 13,
  TIME: 14,
  INTERVAL: 15,
  HUGEINT: 16,
  UHUGEINT: 32,
  VARCHAR: 17,
  BLOB: 18,
  DECIMAL: 19,
  TIMESTAMP_S: 20,
  TIMESTAMP_MS: 21,
  TIMESTAMP_NS: 22,
  ENUM: 23,
  LIST: 24,
  STRUCT: 25,
  MAP: 26,
  ARRAY: 33,
  UUID: 27,
  UNION: 28,
  BIT: 29,
  TIME_TZ: 30,
  TIMESTAMP_TZ: 31,
} as const

/**
 * Map DuckDB type code to string name
 */
function typeCodeToString(code: number): string {
  const entry = Object.entries(DuckDBType).find(([, v]) => v === code)
  return entry ? entry[0] : 'UNKNOWN'
}

// ============================================================================
// Global Module Cache
// ============================================================================

/**
 * Cached WASM module instance.
 * The WASM module itself can be safely shared - it's stateless.
 * Each DuckDB instance gets its own database and connection pointers.
 */
let cachedWasmModule: EmscriptenModule | null = null

// ============================================================================
// WASM Loading - Using Emscripten Loader
// ============================================================================

/**
 * Type for Emscripten module factory function
 * Generated by our custom build with -sMODULARIZE=1 -sEXPORT_NAME='createDuckDB'
 */
type CreateDuckDBFn = (config?: DuckDBModuleConfig) => Promise<EmscriptenModule>

/**
 * Global reference to the Emscripten loader function
 * This is set by loadDuckDBModule when the JS glue code is loaded
 */
let createDuckDBFn: CreateDuckDBFn | null = null

/**
 * Options for loading DuckDB WASM module
 */
export interface LoadDuckDBOptions {
  /**
   * Pre-loaded WASM binary (ArrayBuffer)
   * Use this when you've fetched the WASM from a URL or R2
   */
  wasmBinary?: ArrayBuffer

  /**
   * Pre-compiled WebAssembly.Module
   * Use this in Workers with wasm_modules binding
   */
  wasmModule?: WebAssembly.Module

  /**
   * Pre-loaded Emscripten loader module
   * Use this if the loader is already imported
   */
  loaderModule?: { default: CreateDuckDBFn }
}

/**
 * Load DuckDB WASM module using Emscripten loader
 *
 * This function loads the custom WASM build via the Emscripten-generated JS loader.
 * The loader handles all the complex imports and initialization.
 *
 * @param options Optional loading options (wasmBinary, wasmModule, loaderModule)
 */
export async function loadDuckDBModule(
  options?: ArrayBuffer | LoadDuckDBOptions
): Promise<EmscriptenModule> {
  if (cachedWasmModule) {
    return cachedWasmModule
  }

  // Handle legacy signature: loadDuckDBModule(wasmBinary)
  const opts: LoadDuckDBOptions =
    options instanceof ArrayBuffer ? { wasmBinary: options } : (options ?? {})

  // Get the createDuckDB function from loader module or dynamic import
  if (opts.loaderModule?.default) {
    createDuckDBFn = opts.loaderModule.default
  } else if (!createDuckDBFn) {
    // Dynamic import of the Emscripten loader
    // In Workers, this should be bundled or statically imported
    try {
      const loader = await import('../wasm/duckdb-worker.js')
      createDuckDBFn = loader.default
    } catch (err) {
      throw new Error(
        `Failed to load DuckDB WASM loader: ${err instanceof Error ? err.message : String(err)}. ` +
          'Ensure duckdb-worker.js is bundled with your Worker.'
      )
    }
  }

  if (!createDuckDBFn) {
    throw new Error('DuckDB WASM loader not available')
  }

  // Configure the module
  const moduleConfig: DuckDBModuleConfig = {}

  // Priority 1: Use pre-compiled WebAssembly.Module (most efficient for Workers)
  if (opts.wasmModule) {
    moduleConfig.instantiateWasm = (imports, receiveInstance) => {
      WebAssembly.instantiate(opts.wasmModule!, imports).then((instance) => {
        receiveInstance(instance, opts.wasmModule!)
      })
      // Return empty object to signal async instantiation
      return {}
    }
  }
  // Priority 2: Use pre-loaded WASM binary
  else if (opts.wasmBinary) {
    moduleConfig.wasmBinary = opts.wasmBinary
  }
  // Priority 3: Let Emscripten loader fetch the WASM
  else {
    moduleConfig.locateFile = (path: string) => {
      // Return the path as-is - Workers bundler should resolve it
      return path
    }
  }

  try {
    // Initialize the Emscripten module
    cachedWasmModule = await createDuckDBFn(moduleConfig)
    return cachedWasmModule
  } catch (err) {
    throw new Error(
      `Failed to initialize DuckDB WASM: ${err instanceof Error ? err.message : String(err)}`
    )
  }
}

/**
 * Check if module is cached
 */
export function isModuleCached(): boolean {
  return cachedWasmModule !== null
}

/**
 * Clear module cache
 */
export function clearModuleCache(): void {
  cachedWasmModule = null
}

// ============================================================================
// Instance Creation
// ============================================================================

/**
 * Create a DuckDB instance from loaded module
 *
 * Each instance has its own database and connection, isolated from others.
 * This enables safe concurrent use in Workers.
 */
export function createInstanceFromModule(
  mod: EmscriptenModule,
  config?: DuckDBConfig
): DuckDBInstance {
  // Allocate pointers for database and connection handles
  const dbPtrPtr = mod._malloc(4)
  const connPtrPtr = mod._malloc(4)

  // Open in-memory database
  const pathPtr = mod._malloc(9)
  mod.stringToUTF8(':memory:', pathPtr, 9)

  const openResult = mod._duckdb_open(pathPtr, dbPtrPtr)
  mod._free(pathPtr)

  if (openResult !== 0) {
    mod._free(dbPtrPtr)
    mod._free(connPtrPtr)
    throw new Error('Failed to open DuckDB database')
  }

  // Instance-scoped state (NOT global)
  const instanceDbPtr = mod.HEAP32[dbPtrPtr / 4]!
  mod._free(dbPtrPtr)

  // Connect to database
  const connectResult = mod._duckdb_connect(instanceDbPtr, connPtrPtr)
  if (connectResult !== 0) {
    mod._duckdb_close(instanceDbPtr)
    mod._free(connPtrPtr)
    throw new Error('Failed to connect to DuckDB database')
  }

  const instanceConnPtr = mod.HEAP32[connPtrPtr / 4]!
  mod._free(connPtrPtr)

  // Track if instance is closed
  let isClosed = false

  // Apply configuration via PRAGMA statements
  const applyConfig = async () => {
    const pragmas: string[] = []

    if (config?.maxMemory !== undefined) {
      pragmas.push(`SET memory_limit='${config.maxMemory}'`)
    }
    if (config?.threads !== undefined) {
      pragmas.push(`SET threads=${config.threads}`)
    }
    if (config?.accessMode !== undefined) {
      pragmas.push(`SET access_mode='${config.accessMode}'`)
    }
    if (config?.defaultOrder !== undefined) {
      pragmas.push(`SET default_order='${config.defaultOrder}'`)
    }

    // Execute each PRAGMA
    for (const pragma of pragmas) {
      await executeQuery(pragma)
    }
  }

  // Execute a query (internal helper)
  const executeQuery = async (sql: string): Promise<QueryResult> => {
    if (isClosed) {
      throw new Error('Database instance is closed')
    }

    const stackPtr = mod.stackSave()

    try {
      // Allocate query string
      const queryLen = mod.lengthBytesUTF8(sql) + 1
      const queryPtr = mod.stackAlloc(queryLen)
      mod.stringToUTF8(sql, queryPtr, queryLen)

      // Allocate result struct (64 bytes should be sufficient)
      const resultPtr = mod.stackAlloc(64)

      // Execute query
      const queryResult = mod._duckdb_query(instanceConnPtr, queryPtr, resultPtr)

      if (queryResult !== 0) {
        const errorPtr = mod._duckdb_result_error(resultPtr)
        const errorMsg = errorPtr ? mod.UTF8ToString(errorPtr) : 'Query failed'
        mod._duckdb_destroy_result(resultPtr)
        throw new Error(errorMsg)
      }

      // Get column count and row count
      const columnCount = mod._duckdb_column_count(resultPtr)
      const rowCount = Number(mod._duckdb_row_count(resultPtr))

      // Build column info
      const columns: ColumnInfo[] = []
      for (let col = 0; col < columnCount; col++) {
        const namePtr = mod._duckdb_column_name(resultPtr, col)
        const name = mod.UTF8ToString(namePtr)
        const typeCode = mod._duckdb_column_type(resultPtr, col)
        columns.push({
          name,
          type: typeCodeToString(typeCode),
          typeCode,
        })
      }

      // Extract row data
      const rows: Record<string, unknown>[] = []
      for (let row = 0; row < rowCount; row++) {
        const rowData: Record<string, unknown> = {}
        for (let col = 0; col < columnCount; col++) {
          const colInfo = columns[col]!
          const isNull = mod._duckdb_value_is_null(resultPtr, col, row)

          if (isNull) {
            rowData[colInfo.name] = null
          } else {
            // Extract value based on type
            switch (colInfo.typeCode) {
              case DuckDBType.BOOLEAN:
              case DuckDBType.TINYINT:
              case DuckDBType.SMALLINT:
              case DuckDBType.INTEGER:
              case DuckDBType.UTINYINT:
              case DuckDBType.USMALLINT:
              case DuckDBType.UINTEGER: {
                // Get as varchar and parse
                const valPtr = mod._duckdb_value_varchar(resultPtr, col, row)
                const valStr = mod.UTF8ToString(valPtr)
                mod._free(valPtr)
                if (colInfo.typeCode === DuckDBType.BOOLEAN) {
                  rowData[colInfo.name] = valStr === 'true'
                } else {
                  rowData[colInfo.name] = parseInt(valStr, 10)
                }
                break
              }
              case DuckDBType.BIGINT:
              case DuckDBType.UBIGINT:
              case DuckDBType.HUGEINT:
              case DuckDBType.UHUGEINT: {
                // Preserve BigInt for large integers
                const valPtr = mod._duckdb_value_varchar(resultPtr, col, row)
                const valStr = mod.UTF8ToString(valPtr)
                mod._free(valPtr)
                rowData[colInfo.name] = BigInt(valStr)
                break
              }
              case DuckDBType.FLOAT:
              case DuckDBType.DOUBLE:
              case DuckDBType.DECIMAL: {
                const val = mod._duckdb_value_double(resultPtr, col, row)
                rowData[colInfo.name] = val
                break
              }
              default: {
                // Default to varchar for everything else
                const valPtr = mod._duckdb_value_varchar(resultPtr, col, row)
                const valStr = mod.UTF8ToString(valPtr)
                mod._free(valPtr)
                rowData[colInfo.name] = valStr
              }
            }
          }
        }
        rows.push(rowData)
      }

      // Clean up result
      mod._duckdb_destroy_result(resultPtr)

      return {
        columns,
        rows,
        rowCount,
        success: true,
      }
    } finally {
      mod.stackRestore(stackPtr)
    }
  }

  // Create the instance object
  const instance: DuckDBInstance = {
    async query<T = Record<string, unknown>>(
      sql: string,
      params?: unknown[]
    ): Promise<QueryResult<T>> {
      if (params !== undefined && params.length > 0) {
        throw new Error(
          'Parameterized queries are not yet supported. Use string interpolation with proper escaping.'
        )
      }
      return executeQuery(sql) as Promise<QueryResult<T>>
    },

    async exec(sql: string, params?: unknown[]): Promise<void> {
      if (params !== undefined && params.length > 0) {
        throw new Error(
          'Parameterized queries are not yet supported. Use string interpolation with proper escaping.'
        )
      }
      await executeQuery(sql)
    },

    registerFileBuffer(name: string, buffer: ArrayBuffer | Uint8Array): void {
      if (isClosed) {
        throw new Error('Cannot register buffer on closed database')
      }
      runtimeRegisterBuffer(name, buffer)

      // If Emscripten FS is available, also write to virtual filesystem
      if (mod.FS) {
        try {
          const data = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer)
          mod.FS.writeFile(`/${name}`, data)
        } catch {
          // FS write failed, but runtime buffer is still registered
        }
      }
    },

    dropFile(name: string): boolean {
      if (isClosed) {
        return false
      }
      const result = runtimeDropFile(name)

      // Also remove from Emscripten FS if available
      if (mod.FS) {
        try {
          mod.FS.unlink(`/${name}`)
        } catch {
          // Ignore unlink errors
        }
      }

      return result
    },

    async close(): Promise<void> {
      if (isClosed) return

      isClosed = true
      clearAllFiles()

      // Disconnect and close
      mod._duckdb_disconnect(instanceConnPtr)
      mod._duckdb_close(instanceDbPtr)
    },

    isOpen(): boolean {
      return !isClosed
    },
  }

  // Apply config if provided
  if (config) {
    applyConfig().catch(() => {
      // Config application failed silently
    })
  }

  return instance
}

// ============================================================================
// Convenience Function
// ============================================================================

/**
 * Create a new DuckDB instance
 *
 * This is the main entry point for using DuckDB in Workers.
 *
 * @param loadOptions Optional WASM loading options
 * @param config Optional DuckDB configuration
 */
export async function createDuckDB(
  loadOptions?: ArrayBuffer | LoadDuckDBOptions,
  config?: DuckDBConfig
): Promise<DuckDBInstance> {
  const mod = await loadDuckDBModule(loadOptions)
  return createInstanceFromModule(mod, config)
}
