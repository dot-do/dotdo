---
title: Tools
description: Built-in MCP tools (fetch, search, do) and custom tool registration for AI agents
---

# Tools

The MCP server provides a tool registry for AI agents to execute actions. Tools are permission-gated and can be registered or unregistered dynamically at runtime.

Each tool defines:
- **Name**: Unique identifier for the tool
- **Description**: Human-readable explanation for AI agents
- **Input Schema**: JSON Schema defining accepted parameters
- **Required Permissions**: Permissions needed to execute the tool

## Built-in Tools

### echo

A simple test tool that echoes back messages.

```typescript
// Tool definition
{
  name: 'echo',
  description: 'Echo back the provided message (for testing)',
  inputSchema: {
    type: 'object',
    properties: {
      message: { type: 'string', description: 'The message to echo back' }
    },
    required: ['message']
  },
  requiredPermissions: ['tools:read']
}

// Usage
const result = await mcpClient.executeTool('echo', { message: 'Hello!' })
// { content: [{ type: 'text', text: 'Echo: Hello!' }] }
```

### ping

Health check tool with no permissions required.

```typescript
// Tool definition
{
  name: 'ping',
  description: 'Check if the MCP server is responsive',
  inputSchema: { type: 'object', properties: {} },
  requiredPermissions: []
}

// Usage
const result = await mcpClient.executeTool('ping', {})
// { content: [{ type: 'text', text: 'pong' }] }
```

### fetch

Fetch data from URLs, Durable Objects, or internal resources. Supports multiple URL formats, response transformations, and automatic retries.

**Required Permission**: `fetch`

```typescript
import { z } from 'zod'

// Schema definition (from mcp/tools/fetch.ts)
const fetchToolSchema = z.object({
  url: z.string().describe('URL, DO reference (do://Noun/id), or resource path (/things/Type/id)'),
  method: z.enum(['GET', 'POST', 'PUT', 'DELETE']).optional().default('GET'),
  headers: z.record(z.string()).optional().describe('Custom HTTP headers'),
  body: z.unknown().optional().describe('Request body (for POST/PUT)'),
  transform: z
    .enum(['json', 'text', 'html', 'markdown', 'extract'])
    .optional()
    .default('json')
    .describe('Response transformation type'),
  cache: z.object({
    ttl: z.number().optional().describe('Cache TTL in seconds'),
    key: z.string().optional().describe('Custom cache key'),
  }).optional().describe('Caching configuration'),
  timeout: z.number().optional().default(30000).describe('Request timeout in milliseconds'),
  retries: z.number().optional().default(0).describe('Number of retries on transient failures'),
  retryDelay: z.number().optional().default(1000).describe('Base delay between retries in ms'),
})
```

#### URL Types

The fetch tool supports three URL formats:

| Format | Example | Description |
|--------|---------|-------------|
| External URL | `https://api.example.com/data` | Standard HTTP/HTTPS requests |
| DO Reference | `do://Customer/cust-123` | Direct Durable Object access |
| Resource Path | `/things/Customer/id` or `/Customer/id` | Internal resource lookup |

```typescript
// External URL - standard HTTP/HTTPS
await mcpClient.executeTool('fetch', {
  url: 'https://api.example.com/data',
  transform: 'json'
})

// Durable Object reference - do://Noun/id format
await mcpClient.executeTool('fetch', {
  url: 'do://Customer/cust-123'
})

// Internal resource paths (two formats):
// Long form: /things/Type/id
await mcpClient.executeTool('fetch', {
  url: '/things/Customer/cust-123'
})
// Short form: /Type/id
await mcpClient.executeTool('fetch', {
  url: '/Customer/cust-123'
})
```

#### Response Transformations

| Transform | Output | Description |
|-----------|--------|-------------|
| `json` | Parsed JSON | Default - parses response body as JSON |
| `text` | Raw string | Returns response as plain text |
| `html` | `{ title, content, links }` | Extracts title, strips scripts/styles, extracts links |
| `markdown` | Markdown string | Converts HTML to Markdown format |
| `extract` | AI-extracted data | Uses AI to extract structured data (requires AI binding) |

```typescript
// JSON (default) - parses response as JSON
await mcpClient.executeTool('fetch', { url, transform: 'json' })

// Plain text - returns raw text
await mcpClient.executeTool('fetch', { url, transform: 'text' })

// HTML parsed to { title, content, links }
await mcpClient.executeTool('fetch', { url, transform: 'html' })

// HTML converted to Markdown
await mcpClient.executeTool('fetch', { url, transform: 'markdown' })

// AI extraction (requires AI binding in environment)
await mcpClient.executeTool('fetch', { url, transform: 'extract' })
```

#### Retry Logic

The fetch tool implements exponential backoff for transient failures:

```typescript
await mcpClient.executeTool('fetch', {
  url: 'https://api.example.com/data',
  retries: 3,        // Number of retry attempts
  retryDelay: 1000,  // Base delay (doubles each retry)
})
// Retries on: timeout errors, network errors, 5xx responses
```

### search

Search across DOs, documents, and data using semantic, keyword, or hybrid search. Combines vector embeddings with full-text search for optimal results.

**Required Permission**: `search`

```typescript
import { z } from 'zod'

// Schema definition (from mcp/tools/search.ts)
const searchToolSchema = z.object({
  query: z.string().min(1).describe('Search query text'),
  type: z
    .enum(['semantic', 'keyword', 'hybrid'])
    .optional()
    .default('hybrid')
    .describe('Search mode: semantic (vector), keyword (FTS), or hybrid (RRF)'),
  filters: z.object({
    $type: z.string().optional().describe('Filter by entity type (noun)'),
    namespace: z.string().optional().describe('Filter by namespace/tenant'),
    dateRange: z.object({
      from: z.string().optional().describe('ISO date string for range start'),
      to: z.string().optional().describe('ISO date string for range end'),
    }).optional().describe('Filter by date range'),
  }).optional().describe('Optional filters'),
  limit: z.number().min(1).max(100).optional().default(10).describe('Maximum results to return'),
  offset: z.number().min(0).optional().default(0).describe('Offset for pagination'),
})
```

#### Search Types

| Type | Method | Best For |
|------|--------|----------|
| `semantic` | Vector embeddings via Cloudflare AI | Meaning-based queries, similar concepts |
| `keyword` | SQLite FTS5 with BM25 ranking | Exact terms, specific phrases |
| `hybrid` | Reciprocal Rank Fusion (60/40) | General queries (default) |

```typescript
// Semantic search (vector embeddings via Cloudflare AI + Vectorize)
// Uses @cf/baai/bge-base-en-v1.5 embedding model
await mcpClient.executeTool('search', {
  query: 'customer support issues',
  type: 'semantic',
  limit: 10
})

// Keyword search (SQLite FTS5 with BM25 ranking)
// Falls back to LIKE search if FTS tables don't exist
await mcpClient.executeTool('search', {
  query: 'billing error',
  type: 'keyword'
})

// Hybrid search (Reciprocal Rank Fusion) - recommended for most cases
// Combines semantic (60% weight) and keyword (40% weight) results
await mcpClient.executeTool('search', {
  query: 'account problems',
  type: 'hybrid',
  filters: { $type: 'Ticket' }
})
```

#### Search Response

```typescript
{
  results: [
    {
      id: 'ticket-123',
      $type: 'Ticket',
      score: 0.89,
      data: { subject: 'Billing issue', status: 'open' },
      highlights: ['<mark>billing</mark> error in invoice'],
      source: 'both'  // matched in semantic AND keyword
    }
  ],
  total: 15,
  query: 'billing error',
  type: 'hybrid',
  took: 45  // milliseconds
}
```

### do

Execute JavaScript/TypeScript code in isolated V8 sandboxes. Designed for secure code execution by AI agents.

**Required Permission**: `execute`

```typescript
import { z } from 'zod'

// Schema definition (from mcp/tools/do.ts)
const doToolSchema = z.object({
  code: z.string().describe('JavaScript/TypeScript code to execute'),
  module: z.string().optional().describe('Module code with exports'),
  tests: z.string().optional().describe('Vitest-style test code'),
  env: z.record(z.string()).optional().describe('Environment variables'),
  timeout: z.number().optional().default(5000).describe('Execution timeout in ms'),
  sdk: z.boolean().optional().default(false).describe('Enable $, db, ai SDK globals'),
  allowNetwork: z.boolean().optional().default(false).describe('Allow outbound network'),
})
```

> **Warning**: The `do` tool executes arbitrary code. Ensure proper permission controls and consider rate limiting in production.

**Security features**:

| Feature | Default | Description |
|---------|---------|-------------|
| V8 Isolation | Always | No filesystem access |
| Network Access | Blocked | Must explicitly enable with `allowNetwork: true` |
| Memory Limits | Enforced | Cloudflare Workers runtime limits |
| CPU Limits | Enforced | Cloudflare Workers runtime limits |
| Timeout | 5000ms | Configurable per-execution |
| SDK Access | Disabled | Must explicitly enable with `sdk: true` |

#### Code Execution

```typescript
// Simple script
const result = await mcpClient.executeTool('do', {
  code: 'return 1 + 1'
})
// { success: true, value: 2, logs: [], duration: 5 }

// With SDK globals
const result = await mcpClient.executeTool('do', {
  code: `
    await $.send({ type: 'UserCreated', user: { name: 'Alice' } })
    return 'sent'
  `,
  sdk: true
})

// With tests
const result = await mcpClient.executeTool('do', {
  module: `
    export const add = (a, b) => a + b
  `,
  tests: `
    test('add works', () => {
      expect(add(1, 2)).toBe(3)
    })
  `
})
// { success: true, testResults: { passed: 1, failed: 0, total: 1 } }
```

## Tool Registry

The MCP module provides a global `toolRegistry` for managing tools dynamically. Tools can be registered at startup or added/removed at runtime.

### Registering Tools

```typescript
import { toolRegistry, textResult, jsonResult, errorResult } from 'dotdo/mcp'
import type { McpTool, McpToolResult, McpAgentProps, McpEnv } from 'dotdo/mcp'

// Define the tool metadata
const myTool: McpTool = {
  name: 'greet',
  description: 'Greet a user by name',
  inputSchema: {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Name to greet' }
    },
    required: ['name']
  },
  requiredPermissions: ['tools:execute']
}

// Register the tool with its handler function
toolRegistry.register(myTool, async (args, props, env) => {
  const name = args.name as string
  return textResult(`Hello, ${name}!`)
})
```

### Result Helpers

Use these helpers to create properly formatted tool responses:

```typescript
import { textResult, jsonResult, errorResult } from 'dotdo/mcp'

// Plain text response
const text = textResult('Operation complete')
// { content: [{ type: 'text', text: 'Operation complete' }], isError: false }

// JSON response (formatted with 2-space indentation)
const json = jsonResult({ status: 'ok', count: 42 })
// { content: [{ type: 'text', text: '{\n  "status": "ok",\n  "count": 42\n}' }], isError: false }

// Error response
const error = errorResult('Something went wrong')
// { content: [{ type: 'text', text: 'Something went wrong' }], isError: true }

// Text result with explicit error flag
const customError = textResult('Custom error message', true)
// { content: [{ type: 'text', text: 'Custom error message' }], isError: true }
```

> **Tip**: Always use `errorResult` or set `isError: true` when returning errors. This helps AI agents understand when operations fail.

### Registry Operations

```typescript
// Check if tool exists
toolRegistry.has('greet')  // true

// Get tool definition
const tool = toolRegistry.get('greet')

// Get tool handler
const handler = toolRegistry.getHandler('greet')

// Get all tools
const allTools = toolRegistry.getAll()

// Unregister tool
toolRegistry.unregister('greet')

// Clear all tools
toolRegistry.clear()

// Get tool count
toolRegistry.size  // number
```

## Custom Tool Development

Creating custom tools allows you to expose any functionality to AI agents in a secure, permission-controlled manner.

### Tool Handler Signature

Every tool handler receives three arguments:

```typescript
type ToolHandler = (
  args: Record<string, unknown>,  // Validated input arguments
  props: McpAgentProps,           // User context (userId, permissions)
  env: McpEnv                     // Environment bindings
) => Promise<McpToolResult>

interface McpAgentProps {
  userId: string        // Authenticated user ID
  permissions: string[] // User's granted permissions
  sessionId?: string    // Session ID (if using sessions)
  orgId?: string        // Organization ID (if applicable)
}

interface McpToolResult {
  content: Array<{
    type: 'text' | 'image' | 'resource'
    text?: string
    data?: string        // Base64-encoded for binary data
    mimeType?: string
  }>
  isError?: boolean
}
```

### Example: Database Tool

```typescript
const dbQueryTool: McpTool = {
  name: 'db_query',
  description: 'Query the database',
  inputSchema: {
    type: 'object',
    properties: {
      collection: { type: 'string' },
      filter: { type: 'object' },
      limit: { type: 'number', default: 10 }
    },
    required: ['collection']
  },
  requiredPermissions: ['db:read']
}

toolRegistry.register(dbQueryTool, async (args, props, env) => {
  const { collection, filter, limit } = args

  // Access user's namespace
  const namespace = props.orgId || 'default'

  // Query database
  const doId = env.DO.idFromName(namespace)
  const stub = env.DO.get(doId)

  const results = await stub.things.list({
    $type: collection as string,
    ...filter as object,
    limit: limit as number
  })

  return jsonResult(results)
})
```

### Example: External API Tool

```typescript
const weatherTool: McpTool = {
  name: 'weather',
  description: 'Get current weather for a location',
  inputSchema: {
    type: 'object',
    properties: {
      location: { type: 'string', description: 'City name or coordinates' }
    },
    required: ['location']
  },
  requiredPermissions: ['external:weather']
}

toolRegistry.register(weatherTool, async (args, props, env) => {
  const location = args.location as string

  try {
    const response = await fetch(
      `https://api.weather.example/v1/current?q=${encodeURIComponent(location)}`,
      { headers: { 'X-API-Key': env.WEATHER_API_KEY } }
    )

    if (!response.ok) {
      return errorResult(`Weather API error: ${response.status}`)
    }

    const data = await response.json()
    return jsonResult({
      location: data.location.name,
      temperature: data.current.temp_c,
      condition: data.current.condition.text,
      humidity: data.current.humidity
    })
  } catch (err) {
    return errorResult(`Failed to fetch weather: ${(err as Error).message}`)
  }
})
```

## Tool Execution via MCP Server

### Via HTTP

```typescript
// POST /tools/weather
const response = await fetch('https://mcp.your-domain.com/tools/weather', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer <jwt>'
  },
  body: JSON.stringify({
    arguments: { location: 'San Francisco' }
  })
})

const data = await response.json()
// { result: { content: [...], isError: false } }
```

### Via RPC

```typescript
// Direct RPC to MCP Durable Object
const mcpId = env.MCP.idFromName('default')
const mcp = env.MCP.get(mcpId)

// Register custom tool
mcp.registerTool(myTool, myHandler)

// Unregister tool
mcp.unregisterTool('myTool')

// Get server info
const info = mcp.getServerInfo()
```

## Listing Available Tools

The `/tools` endpoint returns only tools the authenticated user has permission to use:

```typescript
// GET /tools
const response = await fetch('https://mcp.your-domain.com/tools', {
  headers: { 'Authorization': 'Bearer <jwt>' }
})

const { tools } = await response.json()
// Returns only tools the user has permission to use

tools.forEach(tool => {
  console.log(`${tool.name}: ${tool.description}`)
})
```

> **Note**: Tools are filtered based on the user's permissions at request time. Adding or removing permissions immediately affects which tools are visible.

## Next Steps

- **[Security](/mcp/security)**: Configure tool permissions and sandboxing
- **[Authentication](/mcp/authentication)**: Set up user authentication for tool access
