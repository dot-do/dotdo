---
title: Functions
description: Implementation-agnostic function abstraction with four types and cascade patterns
---

# Functions

**Function<Output, Input, Options>** is the core abstraction for all executable logic in do.md. The caller doesn't care HOW it runs - just that it returns the expected output for the given input.

## Four Implementation Types

| Type | Description | Artifacts |
|------|-------------|-----------|
| **Code** | Deterministic TypeScript | types + module + tests + script |
| **Generative** | Single AI completion | prompt template + output schema |
| **Agentic** | AI + tools in a loop | instructions + tool selection |
| **Human** | Human-in-the-loop | context + channel config + actions |

## Natural Expression

Functions are expressed naturally in code, not verbose config:

```typescript
// Code - just write code
export const sum = (a, b) => a + b

// Generative - ai.* template
const brand = ai.storyBrand({ hero: customer, problem: pain })

// Agentic - amy template literal
const research = amy`research ${competitor} market position`

// Human - user template literal
const approval = user`please review ${expense} for ${amount}`
```

## Type System

The core function type supports triple calling style:

```typescript
interface Fn<Out, In = any, Opts extends Record<string, unknown> = {}> {
  // Style 1: Direct call
  (input: In, opts?: Opts): Out

  // Style 2: Tagged template with interpolation
  (strings: TemplateStringsArray, ...values: unknown[]): Out

  // Style 3: Tagged template with named params
  <S extends string>(
    strings: TemplateStringsArray & { raw: readonly S[] }
  ): TaggedResult<Out, S, Opts>
}
```

### Variants

- `AsyncFn<Out, In, Opts>` - Returns `Promise<Out>`
- `RpcFn<Out, In, Opts>` - Returns `RpcPromise<Out>` for pipelining
- `StreamFn<Out, In, Opts>` - Returns `AsyncIterable<Out>`

## Cascade Pattern

Functions cascade through types, trying simpler/cheaper first:

```
Code (fastest, cheapest, deterministic)
  ↓ fails
Generative (AI inference, single call)
  ↓ fails
Agentic (AI + tools, multi-step)
  ↓ fails
Human (slowest, most expensive, guaranteed judgment)
```

## Cascade Operators

Operators define generative relationships between things:

| Operator | Direction | Method | Description |
|----------|-----------|--------|-------------|
| `->` | Forward | Insert | Generate current, INSERT new target, link TO it |
| `~>` | Forward | Search | Generate current, SEARCH existing target, link TO it |
| `<-` | Backward | Insert | Generate current, INSERT new target, link FROM it |
| `<~` | Backward | Search | Generate current, SEARCH existing target, link FROM it |

Each operator IS a GenerativeFunction.

## Type Classifier

The type classifier itself is a GenerativeFunction:

```typescript
const type = ai`what type of function is this? ${spec}`
// Returns: { type: 'code' | 'generative' | 'agentic' | 'human', reasoning: string }
```

## Execution Durability

Three levels of execution durability:

```typescript
$.send(event, data)  // Fire-and-forget (non-blocking, non-durable)
$.try(action, data)  // Quick attempt (blocking, non-durable)
$.do(action, data)   // Durable execution (blocking, retries, guaranteed)
```

## Artifact Generation

Each function type generates specific artifacts:

### Code Functions
- TypeScript types (input/output schemas)
- Module implementation
- Test suite
- Example script

### Generative Functions
- Prompt template
- Output schema
- Evaluation dataset

### Agentic Functions
- System instructions
- Tool selection
- Memory configuration
- Goal definitions

### Human Functions
- Context document
- Channel configuration (Slack, email, SMS)
- Available actions
- Escalation policy
