---
title: Things
description: Named entities with URL-based identity backed by Durable Objects
---

import { Callout } from 'fumadocs-ui/components/callout'

# Things

**Every entity in dotdo is a Thing.** Customers, orders, products, invoices - they're all Things with URL-based identity, persistent state, and the ability to relate to other Things.

```typescript
// Access a Thing
const customer = await $.Thing('Customer/cust-123')

// Things have identity and data
console.log(customer.$id)   // 'https://app.example.com/Customer/cust-123'
console.log(customer.$type) // 'Customer'
console.log(customer.name)  // 'Alice'

// Update a Thing
await customer.update({ name: 'Alice Smith' })

// Create relationships
await customer.relate('purchased', 'Order/ord-456')
```

## What Are Things?

Things are the fundamental building blocks of dotdo applications. They combine:

- **Identity** - URL-based, globally unique
- **State** - Persisted in SQLite
- **Relationships** - Typed edges to other Things
- **Operations** - CRUD, relationships, promotion

| Property | Description |
|----------|-------------|
| `$id` | Fully qualified URL identity |
| `$type` | Type identifier (the Noun) |
| `name` | Display name |
| `data` | Custom data fields |
| `createdAt` | Creation timestamp |
| `updatedAt` | Last modification |

<Callout type="info">
Things are schema-less by default. Add any fields to `data` without migrations. For type safety, extend the Thing interface with your domain types.
</Callout>

## Things and Durable Objects

Every Thing lives inside a Durable Object. The relationship is hierarchical:

```
Startup (DO)
├── Customer/cust-123 (Thing)
├── Customer/cust-456 (Thing)
├── Order/ord-789 (Thing)
└── Product/prod-001 (Thing)
```

A single DO can hold thousands of Things. When a Thing grows too large or needs its own compute, it can be **promoted** to its own DO:

```typescript
// Before: Thing inside parent DO
const customer = await $.Thing('Customer/cust-123')
console.log(customer.isDO) // false

// Promote to its own DO
const customerDO = await customer.promote()
console.log(customerDO.isDO) // true

// Now it has its own namespace and can hold other Things
const orders = customerDO.collection('Order')
```

### The Namespace

Every Thing has a namespace (`ns`) derived from its `$id`:

```typescript
const thing = await $.Thing('Customer/cust-123')

console.log(thing.identity.ns)     // 'https://app.example.com'
console.log(thing.identity.type)   // 'Customer'
console.log(thing.identity.id)     // 'cust-123'
console.log(thing.identity.path)   // 'Customer/cust-123'
```

The namespace determines which DO owns the Thing. Same namespace = same DO.

## Thing Identity

Things use URL-based identity for global uniqueness:

```
https://app.example.com/Customer/cust-123
└──────────┬─────────────┘└──┬───┘└──┬────┘
         namespace        type      id
```

### Identity Rules

1. **Globally unique** - No two Things share the same `$id`
2. **URL-based** - Valid URLs enable cross-system references
3. **Type-prefixed** - The Noun (`Customer`, `Order`) is part of the path
4. **Immutable** - Once created, `$id` never changes

```typescript
// Create with explicit ID
const customer = await things.create({
  $id: 'https://app.example.com/Customer/cust-123',
  $type: 'Customer',
  name: 'Alice',
  data: { email: 'alice@example.com' }
})

// Or let the system generate a Sqid
const order = await things.create({
  $type: 'Order',
  name: 'Order #1234',
  data: { total: 99.99 }
})
// order.$id = 'https://app.example.com/Order/a1b2c3d4'
```

<Callout type="info">
IDs can be deterministic (from external systems) or generated (Sqids). See [Sqids](/docs/concepts/sqids) for encoding options.
</Callout>

## Thing Lifecycle

Things move through a simple lifecycle:

```
create → update → (promote) → delete
```

### Create

```typescript
// Via collection
const things = thingDO.collection<Customer>('Customer')
const customer = await things.create({
  name: 'Alice',
  data: { email: 'alice@example.com', plan: 'starter' }
})

// Via $.Thing with full path
const product = await $.Thing.create({
  $type: 'Product',
  name: 'Widget Pro',
  data: { sku: 'WDG-001', price: 49.99 }
})
```

### Update

```typescript
// Partial update - merges with existing data
await customer.update({
  name: 'Alice Smith',
  data: { plan: 'professional' }
})

// Read after update
const updated = await $.Thing('Customer/cust-123')
console.log(updated.data.plan) // 'professional'
console.log(updated.data.email) // 'alice@example.com' (preserved)
```

### Promote

When a Thing needs its own DO:

```typescript
// Signs that a Thing should be promoted:
// - Has many child Things
// - Needs its own compute/memory
// - Requires isolation for scaling

const thingDO = await customer.promote()

// Now it can hold collections
const orders = thingDO.collection('Order')
const sessions = thingDO.collection('Session')
```

### Delete

```typescript
await customer.delete()
// Related relationships are also cleaned up
```

## Common Thing Types

dotdo applications typically have these Thing types:

| Thing | Description | Example Fields |
|-------|-------------|----------------|
| `Customer` | User/account entity | email, name, plan |
| `Order` | Transaction record | items, total, status |
| `Product` | Catalog item | sku, price, inventory |
| `Invoice` | Billing document | amount, dueDate, paid |
| `Session` | User session | token, expiresAt |
| `Event` | Domain event record | verb, data, timestamp |

### Typed Things

For type safety, extend the Thing interface:

```typescript
import { Thing } from 'dotdo'

interface Customer extends Thing {
  data: {
    email: string
    plan: 'starter' | 'professional' | 'enterprise'
    stripeId?: string
  }
}

interface Order extends Thing {
  data: {
    customerId: string
    items: Array<{ sku: string; qty: number; price: number }>
    total: number
    status: 'pending' | 'paid' | 'shipped' | 'delivered'
  }
}

// Now collections are typed
const customers = thingDO.collection<Customer>('Customer')
const orders = thingDO.collection<Order>('Order')
```

## Things vs Durable Objects

Understanding when to use each:

| Use Thing When | Use DO When |
|----------------|-------------|
| Simple entity storage | Need custom methods |
| Part of a larger aggregate | Top-level namespace |
| Doesn't need own compute | Needs isolation |
| Can share storage with siblings | Has many child Things |

```typescript
// Thing: Customer is just data inside Startup DO
const customer = await $.Thing('Customer/cust-123')

// DO: Startup has its own methods and state
class MyStartup extends Startup {
  async launch() {
    // Custom logic here
  }
}
```

<Callout type="info">
Start with Things. Promote to DOs when you need custom methods or the Thing grows large enough to warrant its own isolate.
</Callout>

## Related

- [SDK: Thing](/docs/sdk/thing) - Full Thing interface reference
- [SDK: Things](/docs/sdk/things) - Collection interface
- [Relationships](/docs/concepts/relationships) - How Things relate to each other
- [Actions](/docs/concepts/actions) - Operations Things can perform
- [Sqids](/docs/concepts/sqids) - Entity ID encoding
