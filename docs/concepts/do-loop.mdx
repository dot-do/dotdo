---
title: The do...while Loop
description: The signature pattern of dotdo - review cycles with a single await
---

# The do...while Loop

**One await in the whole function.** The `do...while` loop is the signature pattern of dotdo (it's literally `.do`). It captures the natural rhythm of creative work: build, review, improve, repeat.

```typescript
const spec = priya`define the MVP for ${this.hypothesis}`
let app = ralph`build ${spec}`

do {
  app = ralph`improve ${app} per ${tom}`
} while (!await tom.approve(app))

mark`announce the launch`
sally`start selling`
```

## Why do...while Fits Review Cycles

The `do...while` loop is uniquely suited for review cycles because it guarantees **at least one iteration**. This matches reality: you always need at least one review pass, even if it's just confirming the work is already good.

<Callout type="info">
Unlike `while` loops that check conditions first, `do...while` executes first and checks after. This means Ralph always gets a chance to improve before Tom's verdict matters.
</Callout>

The pattern maps directly to how creative work flows:

| Loop Phase | Review Cycle Phase |
|------------|-------------------|
| **do {** | Start improvement cycle |
| **body** | Ralph improves based on feedback |
| **} while** | Tom reviews |
| **(condition)** | Is it approved? |

## The Single Await

Notice the only `await` in the entire function sits in the `while` condition:

```typescript
while (!await tom.approve(app))
```

This is intentional. The `await` controls the loop - it's the gatekeeper that decides whether we continue iterating or break out and ship.

<Callout type="warn">
Everything else is fire-and-forget. No awaits on spec generation, no awaits on building, no awaits on improvements. The review decision is the only synchronization point.
</Callout>

## First Iteration: The Minimal Pass

On the first iteration, something interesting happens:

```typescript
app = ralph`improve ${app} per ${tom}`
```

The `per ${tom}` syntax means "according to Tom's feedback." But on the first pass, Tom hasn't given any feedback yet - `tom.feedback` is empty.

Ralph sees this and does the minimal improvement pass: basic cleanup, obvious fixes, maybe a quick self-review. He doesn't have direction yet, so he doesn't invent it.

## Subsequent Iterations: Real Feedback

Once Tom reviews and rejects (returning `false` from `approve`), his feedback becomes available. Now `per ${tom}` carries weight:

```typescript
// Tom's feedback might include:
// - "Add error handling for the payment flow"
// - "The dashboard is missing loading states"
// - "Authentication needs rate limiting"

app = ralph`improve ${app} per ${tom}`
// Ralph now incorporates this specific feedback
```

Each iteration incorporates Tom's latest concerns until he's satisfied.

## The `per` Syntax

The `per ${tom}` pattern is cleaner than `per ${tom.feedback}`. It lets the template literal system resolve what "according to Tom" means in context:

```typescript
// These are equivalent, but the first reads more naturally:
ralph`improve ${app} per ${tom}`
ralph`improve ${app} per ${tom.feedback}`
ralph`improve ${app} according to ${await tom.getLatestFeedback()}`
```

<Callout type="info">
Named agents like Tom have implicit context. When referenced in a template literal, they provide their relevant state for that context - feedback in a review cycle, requirements in a planning session.
</Callout>

## Fire-and-Forget: Mark and Sally

After the loop breaks (Tom approved), we launch:

```typescript
mark`announce the launch`
sally`start selling`
```

No `await`. These are fire-and-forget operations. Marketing and sales can run in parallel, and we don't need to wait for them to complete before the function returns.

This is the `.send()` semantics under the hood - non-blocking, non-durable, just dispatched and done.

## Comparison: while Loop

You could write the same logic with a `while` loop:

```typescript
let approved = false
while (!approved) {
  app = ralph`improve ${app} per ${tom}`
  approved = await tom.approve(app)
}
```

This works, but it's less elegant:
- Extra variable (`approved`)
- The improvement happens before any feedback on the first pass (same behavior, but reads oddly)
- More lines for the same semantics

The `do...while` version is more direct: "do this, while not approved."

## Comparison: Traditional Await Patterns

Traditional async code would await every step:

```typescript
// The old way - await everything
const spec = await priya.define(this.hypothesis)
let app = await ralph.build(spec)

let feedback = await tom.review(app)
while (!feedback.approved) {
  app = await ralph.improve(app, feedback)
  feedback = await tom.review(app)
}

await mark.announce(app)
await sally.startSelling(app)
```

Problems:
- **Multiple round trips**: Each await is a potential network hop
- **Sequential where unnecessary**: Mark and Sally could run in parallel
- **Verbose**: The ceremony obscures the intent

<Callout type="warn">
With Cap'n Web RPC and promise pipelining, dotdo executes multiple agent calls in a single network round trip. The elegant syntax isn't just prettier - it's faster.
</Callout>

## The Complete Pattern

Here's the full startup launch with the `do...while` at its heart:

```typescript
import { Startup } from 'dotdo'
import { priya, ralph, tom, mark, sally } from 'agents.do'

export class MyStartup extends Startup {
  async launch() {
    const spec = priya`define the MVP for ${this.hypothesis}`
    let app = ralph`build ${spec}`

    do {
      app = ralph`improve ${app} per ${tom}`
    } while (!await tom.approve(app))

    mark`announce the launch`
    sally`start selling`
  }
}
```

Five agents. One await. One loop. Ship it.
