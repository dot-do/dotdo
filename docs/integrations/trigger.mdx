---
title: Trigger.dev
description: Drop-in replacement for Trigger.dev background jobs with edge-native execution and zero cold starts.
---

# Trigger.dev

Drop-in replacement for `@trigger.dev/sdk`. Same API, runs on Cloudflare's edge.

```typescript
// Before
import { task, wait, retry } from '@trigger.dev/sdk/v3'

// After
import { task, wait, retry } from '@dotdo/trigger'
```

Your existing Trigger.dev code works unchanged. No migration required.

## Why trigger.do?

| Feature | Trigger.dev | trigger.do |
|---------|-------------|------------|
| **API compatibility** | - | 100% v3 API |
| **Payloads leave infra** | Yes | No |
| **Cold start** | ~100ms | 0ms (V8 isolates) |
| **Global edge** | Limited regions | 300+ cities |
| **Max duration** | Varies by plan | Unlimited (DO) |
| **Pricing** | Per-task run | Included |
| **Self-hosted** | Enterprise only | Always |
| **DO integration** | N/A | Native |
| **CF Workflows** | N/A | Native backend |

The math: Trigger.dev charges per task run. On dotdo, background jobs are included in your compute.

## Features

| Feature | Status |
|---------|--------|
| Task definition | Supported |
| trigger() - fire and forget | Supported |
| triggerAndWait() | Supported |
| batchTrigger() | Supported |
| batchTriggerAndWait() | Supported |
| ctx.run() step memoization | Supported |
| Retry configuration | Supported |
| Queue configuration | Supported |
| Machine presets | Supported |
| Lifecycle hooks (onStart, onSuccess, onFailure) | Supported |
| Middleware | Supported |
| wait.for() / wait.until() | Supported |
| Scheduled tasks (cron) | Supported |
| abort() utility | Supported |
| Idempotency keys | Supported |
| Delayed execution | Supported |
| Tags and metadata | Supported |
| Run handles (status, result, cancel) | Supported |

## Installation

```bash
npm install @dotdo/trigger
```

## Quick Start

### Define a Task

```typescript
import { task, wait } from '@dotdo/trigger'

export const helloWorld = task({
  id: 'hello-world',
  run: async (payload: { name: string }) => {
    await wait.for({ seconds: 5 })
    return `Hello, ${payload.name}!`
  },
})
```

### Trigger and Forget

```typescript
const { id, handle } = await helloWorld.trigger({ name: 'World' })

console.log('Run ID:', id)

// Later, check status or get result
const status = await handle.status()  // 'PENDING' | 'QUEUED' | 'EXECUTING' | 'COMPLETED' | 'FAILED'
const result = await handle.result()  // Polls until complete
```

### Trigger and Wait

```typescript
const result = await helloWorld.triggerAndWait({ name: 'World' })

if (result.ok) {
  console.log('Output:', result.output)  // "Hello, World!"
} else {
  console.error('Failed:', result.error.message)
}
```

## Task Configuration

Full task configuration with all options:

```typescript
import { task, retry } from '@dotdo/trigger'

interface OrderPayload {
  orderId: string
  userId: string
  items: Array<{ productId: string; quantity: number }>
}

interface OrderResult {
  orderId: string
  status: 'processed' | 'failed'
  processedAt: Date
}

export const processOrder = task<OrderPayload, OrderResult>({
  id: 'process-order',
  version: '1.0.0',

  // Retry configuration
  retry: {
    maxAttempts: 5,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 30000,
    factor: 2,
    randomize: true,
  },

  // Queue configuration
  queue: {
    name: 'orders',
    concurrencyLimit: 10,
  },

  // Machine resources
  machine: {
    preset: 'medium',
  },

  // Maximum duration
  maxDuration: 60000,  // 1 minute

  // Lifecycle hooks
  onStart: async (payload, ctx) => {
    console.log(`Starting task ${ctx.task.id}`)
  },

  onSuccess: async (payload, output, ctx) => {
    console.log(`Task completed:`, output)
  },

  onFailure: async (payload, error, ctx) => {
    console.error(`Task failed:`, error.message)
  },

  run: async (payload, { ctx }) => {
    return {
      orderId: payload.orderId,
      status: 'processed',
      processedAt: new Date(),
    }
  },
})
```

## Context Operations (ctx.run)

Execute sub-steps with automatic memoization and replay:

```typescript
export const complexWorkflow = task({
  id: 'complex-workflow',
  run: async (payload, { ctx }) => {
    // Each step is memoized - on replay, cached results are returned
    const user = await ctx.run('fetch-user', async () => {
      return await db.users.findById(payload.userId)
    })

    const order = await ctx.run('create-order', async () => {
      return await db.orders.create({
        userId: user.id,
        items: payload.items,
      })
    })

    // Steps can depend on previous step results
    const payment = await ctx.run('process-payment', async () => {
      return await stripe.charges.create({
        amount: order.total,
        customer: user.stripeId,
      })
    })

    // Access run context
    console.log('Run ID:', ctx.run.id)
    console.log('Attempt:', ctx.attempt.number)
    console.log('Is test:', ctx.run.isTest)

    return { orderId: order.id, paymentId: payment.id }
  },
})
```

## Batch Operations

### Batch Trigger

```typescript
const { runs } = await processOrder.batchTrigger([
  { orderId: '1', userId: 'user_1', items: [] },
  { orderId: '2', userId: 'user_2', items: [] },
  { orderId: '3', userId: 'user_3', items: [] },
])

// Each run has its own handle
runs.forEach(run => console.log(run.id))
```

### Batch Trigger and Wait

```typescript
const { runs } = await processOrder.batchTriggerAndWait([
  { orderId: '1', userId: 'user_1', items: [] },
  { orderId: '2', userId: 'user_2', items: [] },
])

const successful = runs.filter(r => r.ok)
const failed = runs.filter(r => !r.ok)
```

## Trigger Options

```typescript
await processOrder.trigger(payload, {
  // Idempotency - prevent duplicate processing
  idempotencyKey: `order-${payload.orderId}`,
  idempotencyKeyTTL: '24h',

  // Delay execution
  delay: '5m',  // or delay: 300000 (ms) or delay: new Date('2024-12-25')

  // Tags for filtering/querying
  tags: ['high-priority', 'vip-customer'],

  // Queue override
  queue: { name: 'priority-orders', concurrencyLimit: 5 },

  // Concurrency control
  concurrencyKey: `user-${payload.userId}`,

  // Override max attempts
  maxAttempts: 10,

  // Custom metadata
  metadata: { source: 'api', version: '2.0' },
})
```

## Wait Utilities

Durable wait operations that persist across restarts:

```typescript
import { wait } from '@dotdo/trigger'

// Wait for a duration
await wait.for({ seconds: 30 })
await wait.for({ minutes: 5 })
await wait.for({ hours: 2 })
await wait.for({ days: 1 })

// Combine units
await wait.for({ hours: 1, minutes: 30 })

// Wait until a specific time
await wait.until(new Date('2024-12-25T00:00:00Z'))
```

## Retry Utilities

```typescript
import { retry } from '@dotdo/trigger'

// Use presets
const defaultRetry = retry.preset('default')      // 3 attempts, exponential backoff
const aggressiveRetry = retry.preset('aggressive') // 10 attempts, faster backoff
const patientRetry = retry.preset('patient')       // 5 attempts, longer delays

// Exponential backoff
const exponential = retry.exponential(5, {
  minTimeout: 1000,   // Start at 1s
  maxTimeout: 60000,  // Cap at 60s
})

// Linear backoff (constant delay)
const linear = retry.linear(3, 5000)  // 3 attempts, 5s between each

// Apply to task
export const myTask = task({
  id: 'my-task',
  retry: retry.exponential(5),
  run: async (payload) => {
    // ...
  },
})
```

## Queue Utilities

```typescript
import { queue, task } from '@dotdo/trigger'

// Create a queue configuration
const orderQueue = queue.create('orders', {
  concurrency: 10,  // Max 10 concurrent executions
  rateLimit: {
    limit: 100,
    period: '1m',   // 100 per minute
  },
})

// Apply to task
export const processOrder = task({
  id: 'process-order',
  queue: orderQueue,
  run: async (payload) => {
    // At most 10 running concurrently, 100/min
  },
})
```

## Middleware

Extend task functionality with middleware:

```typescript
import { task, type TaskMiddleware } from '@dotdo/trigger'

const loggingMiddleware: TaskMiddleware = {
  name: 'logging',

  // Called once when worker starts
  init: async () => {
    console.log('Logging middleware initialized')
  },

  // Transform payload before enqueueing
  onEnqueue: async (payload) => {
    console.log('Enqueueing task:', payload)
    return payload
  },

  // Called before task execution
  beforeRun: async (payload, ctx) => {
    console.log(`Starting ${ctx.task.id} (run: ${ctx.run.id})`)
  },

  // Called after successful execution
  afterRun: async (payload, output, ctx) => {
    console.log(`Completed ${ctx.task.id}:`, output)
  },

  // Called on error
  onError: async (payload, error, ctx) => {
    console.error(`Failed ${ctx.task.id}:`, error.message)
  },
}

export const processOrder = task({
  id: 'process-order',
  middleware: [loggingMiddleware],
  run: async (payload) => {
    // ...
  },
})
```

## Scheduled Tasks

Create cron-triggered tasks:

```typescript
import { schedules } from '@dotdo/trigger'

export const dailyReport = schedules({
  id: 'daily-report',
  cron: '0 9 * * MON-FRI',  // Weekdays at 9 AM
  timezone: 'America/New_York',

  run: async (payload, { ctx }) => {
    const report = await generateReport()
    await sendEmail(report)
    return { sentAt: new Date() }
  },
})
```

## Abort Utility

Gracefully abort task execution without retries:

```typescript
import { abort, AbortTaskRunError } from '@dotdo/trigger'

export const validateOrder = task({
  id: 'validate-order',
  run: async (payload) => {
    if (!payload.orderId) {
      // Immediately abort - no retries
      abort('Missing orderId')
    }

    const order = await fetchOrder(payload.orderId)

    if (order.status === 'cancelled') {
      abort('Order has been cancelled')
    }

    return { valid: true }
  },
})
```

## Inbound Mode - Local Development

For development and testing, trigger.do runs entirely in-process:

```typescript
import { task, configure } from '@dotdo/trigger'
import { InMemoryStepStorage } from '@dotdo/workflows/runtime'

// Configure in-memory storage for local development
configure({
  storage: new InMemoryStepStorage(),
})

// Tasks execute immediately in-process
const result = await myTask.triggerAndWait({ value: 42 })
console.log(result.output)
```

### Testing

```typescript
import { describe, it, expect } from 'vitest'
import { task } from '@dotdo/trigger'

describe('my task', () => {
  it('should process payload', async () => {
    const myTask = task({
      id: 'test-task',
      run: async (payload: { x: number }) => payload.x * 2,
    })

    const result = await myTask.triggerAndWait({ x: 5 })

    expect(result.ok).toBe(true)
    expect(result.output).toBe(10)
  })

  it('should handle errors', async () => {
    const failingTask = task({
      id: 'failing-task',
      run: async () => {
        throw new Error('Task failed')
      },
    })

    const result = await failingTask.triggerAndWait({})

    expect(result.ok).toBe(false)
    expect(result.error?.message).toBe('Task failed')
  })
})
```

## Outbound Mode - Connecting to Trigger.dev

To use real Trigger.dev infrastructure (hybrid mode):

```typescript
import { Stripe } from '@dotdo/trigger/outbound'

// Configure to forward to Trigger.dev
const trigger = new TriggerClient({
  apiKey: env.TRIGGER_DEV_API_KEY,
  apiUrl: 'https://api.trigger.dev',
})

// Tasks forward to Trigger.dev
export const myTask = trigger.defineTask({
  id: 'my-task',
  run: async (payload) => {
    // Executes on Trigger.dev infrastructure
  },
})
```

## Backend Options

trigger.do supports multiple execution backends:

| Backend | Best For | Durability | Max Duration | Cost |
|---------|----------|------------|--------------|------|
| **Durable Objects** | Real-time, interactive | Transactional | Unlimited | Wall-clock billing |
| **CF Workflows** | Background jobs, long waits | Event-sourced | 24h | CPU-only (sleep is FREE) |
| **Pipelines** | High-throughput batch | At-least-once | 5m/step | Batch writes |

```typescript
import { configure } from '@dotdo/trigger'
import { CFWorkflowsBackend } from '@dotdo/workflows/backends'

// Use CF Workflows backend for cost-efficient background jobs
configure({
  storage: new CFWorkflowsBackend(env.MY_WORKFLOW),
})
```

## Durable Object Integration

For maximum control, integrate directly with Durable Objects:

```typescript
import { configure } from '@dotdo/trigger'

export class MyDO extends DurableObject {
  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)

    // Configure trigger.do to use DO storage
    configure({
      state: ctx.state,
    })
  }

  async processOrder(payload: OrderPayload) {
    // Tasks execute within the DO context
    const result = await processOrder.triggerAndWait(payload)
    return result
  }
}
```

## API Reference

### Task Factory

| Function | Parameters | Returns | Description |
|----------|------------|---------|-------------|
| `task<P, O>(config)` | `TaskConfig<P, O>` | `Task<P, O>` | Create a new task |
| `schedules<P, O>(config)` | `ScheduledTaskConfig<P, O>` | `Task<P, O>` | Create a scheduled task |
| `configure(config)` | `GlobalConfig` | `void` | Set global configuration |

### TaskConfig Options

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `id` | `string` | required | Unique task identifier |
| `version` | `string` | - | Task version |
| `retry` | `RetryConfig` | - | Retry configuration |
| `queue` | `QueueConfig` | - | Queue configuration |
| `machine` | `MachineConfig` | - | Resource allocation |
| `maxDuration` | `number` | - | Maximum run duration (ms) |
| `middleware` | `TaskMiddleware[]` | - | Middleware chain |
| `onStart` | `(payload, ctx) => void` | - | Start lifecycle hook |
| `onSuccess` | `(payload, output, ctx) => void` | - | Success lifecycle hook |
| `onFailure` | `(payload, error, ctx) => void` | - | Failure lifecycle hook |
| `handleError` | `(payload, error, ctx) => void` | - | Custom error handler |
| `init` | `() => void` | - | Worker initialization |
| `cleanup` | `() => void` | - | Worker cleanup |
| `run` | `(payload, { ctx }) => output` | required | Task implementation |

### Task Instance Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `trigger(payload, opts?)` | `TPayload, TriggerOptions?` | `Promise<TriggerResult>` | Fire and forget |
| `triggerAndWait(payload, opts?)` | `TPayload, TriggerOptions?` | `Promise<TaskRunResult<O>>` | Await completion |
| `batchTrigger(items, opts?)` | `TPayload[], TriggerOptions?` | `Promise<{ runs: TriggerResult[] }>` | Batch trigger |
| `batchTriggerAndWait(items, opts?)` | `TPayload[], TriggerOptions?` | `Promise<{ runs: TaskRunResult<O>[] }>` | Batch await |
| `getFailedRuns()` | - | `Map<string, { error, timestamp }>` | Get failed runs for observability |
| `getRunningTaskCount()` | - | `number` | Count of running background tasks |
| `waitForAllTasks()` | - | `Promise<void>` | Wait for all background tasks |

### TaskRunHandle

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `id` | `string` | Run identifier |
| `result()` | `Promise<unknown>` | Poll for result |
| `status()` | `Promise<TaskRunStatus>` | Get current status |
| `cancel()` | `Promise<void>` | Cancel the run |

### TaskRunStatus

```typescript
type TaskRunStatus =
  | 'PENDING'
  | 'QUEUED'
  | 'EXECUTING'
  | 'COMPLETED'
  | 'FAILED'
  | 'CANCELED'
  | 'TIMED_OUT'
```

### TaskContext Properties

| Property | Type | Description |
|----------|------|-------------|
| `run` | `TaskRunContext` | Run context (also callable for ctx.run) |
| `run.id` | `string` | Unique run identifier |
| `run.tags` | `string[]` | Run tags |
| `run.isTest` | `boolean` | Whether this is a test run |
| `run.createdAt` | `Date` | When run was created |
| `run.startedAt` | `Date` | When execution started |
| `run.idempotencyKey` | `string?` | Idempotency key if provided |
| `run.parentId` | `string?` | Parent run ID (for child tasks) |
| `run.batchId` | `string?` | Batch ID (for batch triggers) |
| `task.id` | `string` | Task identifier |
| `task.version` | `string?` | Task version |
| `attempt.id` | `string` | Attempt identifier |
| `attempt.number` | `number` | Attempt number (1-indexed) |
| `attempt.startedAt` | `Date` | When attempt started |
| `environment.type` | `string` | Environment type |
| `organization.id` | `string` | Organization identifier |
| `project.id` | `string` | Project identifier |
| `machine.cpu` | `number` | CPU allocation |
| `machine.memory` | `number` | Memory allocation (MB) |

### Wait Utilities

| Method | Parameters | Description |
|--------|------------|-------------|
| `wait.for(duration)` | `{ seconds?, minutes?, hours?, days? }` | Wait for duration |
| `wait.until(date)` | `Date` | Wait until specific time |

### Retry Utilities

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `retry.preset(name)` | `'default' \| 'aggressive' \| 'patient'` | `RetryConfig` | Get preset config |
| `retry.exponential(max, opts?)` | `number, { minTimeout?, maxTimeout? }` | `RetryConfig` | Exponential backoff |
| `retry.linear(max, delay)` | `number, number` | `RetryConfig` | Linear backoff |

### Queue Utilities

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `queue.create(name, opts?)` | `string, { concurrency?, rateLimit? }` | `QueueConfig` | Create queue config |

### Error Classes

| Class | Description |
|-------|-------------|
| `AbortTaskRunError` | Thrown by `abort()` to stop execution without retry |

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Your Application                          │
│                                                              │
│  const task = task({ id: 'my-task', run: ... })             │
│  await task.trigger({ orderId: '123' })                      │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────┐
│   Durable Objects        │     │   Cloudflare Workflows  │
├─────────────────────────┤     ├─────────────────────────┤
│                         │     │                         │
│  → Real-time execution  │     │  → CPU-only billing     │
│  → Unlimited duration   │     │  → Sleep is FREE        │
│  → Transactional        │     │  → Up to 24h duration   │
│  → WebSocket support    │     │  → Event-sourced        │
│                         │     │                         │
└─────────────────────────┘     └─────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Edge Execution                           │
│                                                              │
│   ┌────────────────────────────────────────────────────┐    │
│   │               V8 Isolate Runtime                    │    │
│   │   - 0ms cold start                                  │    │
│   │   - 300+ global locations                           │    │
│   │   - Automatic failover                              │    │
│   └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

## Migration from Trigger.dev

### Package Change

```bash
# Remove
npm uninstall @trigger.dev/sdk

# Install
npm install @dotdo/trigger
```

### Import Change

```typescript
// Before
import { task, wait, retry, queue } from '@trigger.dev/sdk/v3'

// After
import { task, wait, retry, queue } from '@dotdo/trigger'
```

### Code Compatibility

Your existing Trigger.dev code works unchanged:

```typescript
// This code works with both @trigger.dev/sdk and @dotdo/trigger
export const processOrder = task({
  id: 'process-order',
  retry: { maxAttempts: 3 },
  run: async (payload, { ctx }) => {
    const user = await ctx.run('fetch-user', async () => {
      return await fetchUser(payload.userId)
    })

    await wait.for({ seconds: 30 })

    return { userId: user.id, status: 'processed' }
  },
})

await processOrder.trigger({ orderId: '123' })
```

## Common Patterns

### Order Processing

```typescript
export const processOrder = task({
  id: 'process-order',
  retry: retry.exponential(5),

  run: async (payload, { ctx }) => {
    // Validate
    const order = await ctx.run('validate', async () => {
      const order = await db.orders.findById(payload.orderId)
      if (!order) abort('Order not found')
      return order
    })

    // Charge payment
    const payment = await ctx.run('charge', async () => {
      return await stripe.paymentIntents.create({
        amount: order.total,
        customer: order.customerId,
      })
    })

    // Fulfill
    await ctx.run('fulfill', async () => {
      await inventory.reserve(order.items)
      await shipping.createLabel(order)
    })

    // Notify
    await ctx.run('notify', async () => {
      await email.send(order.email, 'order-confirmation', { order })
    })

    return { orderId: order.id, paymentId: payment.id }
  },
})
```

### Scheduled Reports

```typescript
export const dailyDigest = schedules({
  id: 'daily-digest',
  cron: '0 8 * * *',  // 8 AM daily
  timezone: 'America/New_York',

  run: async (payload, { ctx }) => {
    const stats = await ctx.run('gather-stats', async () => {
      return await analytics.getDailyStats()
    })

    const users = await ctx.run('get-subscribers', async () => {
      return await db.users.findSubscribers()
    })

    await ctx.run('send-emails', async () => {
      await Promise.all(
        users.map(user => email.send(user.email, 'daily-digest', stats))
      )
    })

    return { sentTo: users.length }
  },
})
```

### Webhook Processing

```typescript
export const processWebhook = task({
  id: 'process-webhook',
  queue: queue.create('webhooks', { concurrency: 50 }),

  run: async (payload, { ctx }) => {
    const { event, data } = payload

    switch (event) {
      case 'customer.created':
        await ctx.run('sync-crm', () => crm.createContact(data))
        break

      case 'payment.succeeded':
        await ctx.run('update-subscription', () =>
          db.subscriptions.activate(data.subscriptionId)
        )
        break

      case 'subscription.cancelled':
        await ctx.run('cleanup', () =>
          db.subscriptions.deactivate(data.subscriptionId)
        )
        break
    }

    return { processed: event }
  },
})
```

## Performance

- **29 tests** covering all functionality
- **0ms cold start** via V8 isolates
- **<1ms** task dispatch latency (edge)
- **Unlimited duration** with Durable Objects
- **Global edge** execution in 300+ cities
- **Automatic memoization** for ctx.run steps
- **Free sleep** on CF Workflows backend

## Related

- [Workflows Overview](/docs/workflows) - Workflow primitives and DSL
- [Durable Objects](/docs/architecture/durable-objects) - DO-based execution
- [Deployment](/docs/deployment) - Deployment and infrastructure
- [Events](/docs/events) - Event-driven patterns
