---
title: Pusher
description: Drop-in replacement for Pusher Channels, self-hosted on Durable Objects with unlimited connections.
---

# Pusher

Drop-in replacement for `pusher-js`. Same API, self-hosted on Durable Objects.

```typescript
// Before
import Pusher from 'pusher-js'

// After
import Pusher from '@dotdo/pusher'
```

Your existing Pusher code works unchanged. No migration required.

## Why pusher.do?

| Feature | Pusher | pusher.do |
|---------|--------|-----------|
| **Connections/channel** | 100 (Free), 10K (Enterprise) | Unlimited |
| **Per-connection fees** | Yes ($0.0001/connection/day) | No |
| **Per-message fees** | Yes ($0.000001/message) | No |
| **Channel limit** | 100 per app (Free) | Unlimited |
| **Message size** | 10KB | 128KB |
| **Latency** | Single region | Edge (300+ cities) |
| **Cold start** | N/A (hosted) | 0ms (V8 isolates) |
| **Self-hosted** | No | Yes |

The math: 10,000 concurrent connections for 30 days on Pusher = $30/month minimum. On dotdo, it's included.

## Features

| Feature | Status |
|---------|--------|
| Public channels | Supported |
| Private channels | Supported |
| Presence channels | Supported |
| Client events | Supported |
| Connection state management | Supported |
| Event binding (bind/unbind) | Supported |
| Global event binding | Supported |
| User signin | Supported |
| Server SDK | Planned |
| Channel authorization endpoint | Planned |
| Encrypted channels | Planned |
| Webhooks | Planned |

## Installation

```bash
npm install @dotdo/pusher
```

## Quick Start

### Client SDK

```typescript
import Pusher from '@dotdo/pusher'

const pusher = new Pusher('your-app-key', {
  cluster: 'mt1',
  forceTLS: true,
})

// Subscribe to a public channel
const channel = pusher.subscribe('my-channel')

// Bind to events
channel.bind('my-event', (data) => {
  console.log('Received:', data)
})

// Connection state
pusher.connection.bind('connected', () => {
  console.log('Socket ID:', pusher.connection.socket_id)
})

pusher.connection.bind('state_change', ({ previous, current }) => {
  console.log(`Connection: ${previous} -> ${current}`)
})
```


## Channel Types

### Public Channels

Anyone can subscribe. No authorization required.

```typescript
const channel = pusher.subscribe('news')

channel.bind('breaking', (data) => {
  console.log('Breaking news:', data.headline)
})

channel.bind('pusher:subscription_succeeded', () => {
  console.log('Subscribed to news channel')
})
```

### Private Channels

Require server-side authorization. Channel names must start with `private-`.

```typescript
// Client
const privateChannel = pusher.subscribe('private-user-123')

privateChannel.bind('pusher:subscription_succeeded', () => {
  console.log('Authorized and subscribed')
})

privateChannel.bind('pusher:subscription_error', (error) => {
  console.error('Authorization failed:', error)
})

// Client events (must start with 'client-')
privateChannel.trigger('client-typing', { user: 'alice' })
```

Note: Server-side authorization is planned. Currently, channels are auto-authorized for development.

### Presence Channels

Track who's online. Channel names must start with `presence-`.

```typescript
import type { PresenceChannel, Members, PresenceMember } from '@dotdo/pusher'

const presence = pusher.subscribe('presence-room-1') as PresenceChannel

// When subscription succeeds, get current members
presence.bind('pusher:subscription_succeeded', (members: Members) => {
  console.log('Members online:', members.count)
  console.log('My user ID:', members.me?.id)

  members.each((member) => {
    console.log(`- ${member.id}:`, member.info)
  })
})

// When someone joins
presence.bind('pusher:member_added', (member: PresenceMember) => {
  console.log('Joined:', member.id, member.info)
})

// When someone leaves
presence.bind('pusher:member_removed', (member: PresenceMember) => {
  console.log('Left:', member.id)
})

// Access members anytime
console.log('Current count:', presence.members.count)
const specificMember = presence.members.get('user-123')
const allMembers = presence.members.toArray()
```

Note: Server-side presence authorization is planned. Currently, presence data is auto-generated for development.

## Event Binding

### Channel Events

```typescript
const channel = pusher.subscribe('updates')

// Bind to specific event
channel.bind('new-item', (data) => {
  console.log('New item:', data)
})

// Unbind specific callback
const handler = (data) => console.log(data)
channel.bind('event', handler)
channel.unbind('event', handler)

// Unbind all handlers for an event
channel.unbind('event')

// Bind to ALL events on this channel
channel.bind_global((eventName, data) => {
  console.log(`Event: ${eventName}`, data)
})

// Unbind global handler
channel.unbind_global(globalHandler)
```

### Connection Events

```typescript
pusher.connection.bind('initialized', () => {
  console.log('Pusher initialized')
})

pusher.connection.bind('connecting', () => {
  console.log('Connecting...')
})

pusher.connection.bind('connected', () => {
  console.log('Connected! Socket ID:', pusher.connection.socket_id)
})

pusher.connection.bind('disconnected', () => {
  console.log('Disconnected')
})

pusher.connection.bind('unavailable', () => {
  console.log('Connection unavailable')
})

pusher.connection.bind('failed', () => {
  console.log('Connection failed')
})

pusher.connection.bind('state_change', ({ previous, current }) => {
  console.log(`State: ${previous} -> ${current}`)
})
```

### Global Event Binding

Listen to events across all channels:

```typescript
pusher.bind('notification', (data) => {
  // Called for 'notification' event on ANY channel
  console.log('Notification:', data)
})

pusher.bind_global((eventName, data) => {
  // Called for ALL events on ALL channels
  console.log(`[${eventName}]`, data)
})
```

## Client Events

Trigger events directly from clients on private/presence channels:

```typescript
const privateChannel = pusher.subscribe('private-chat-room')

// Wait for subscription
privateChannel.bind('pusher:subscription_succeeded', () => {
  // Trigger client event (must start with 'client-')
  privateChannel.trigger('client-typing', {
    user: 'alice',
    typing: true,
  })
})

// Other clients receive it
privateChannel.bind('client-typing', (data) => {
  console.log(`${data.user} is ${data.typing ? 'typing' : 'not typing'}`)
})
```

Rules for client events:
- Only on private (`private-`) or presence (`presence-`) channels
- Event name must start with `client-`
- Channel must be subscribed
- Sender does not receive their own event


## Connection Management

```typescript
const pusher = new Pusher('app-key', {
  disableStats: true, // Don't auto-connect
})

// Manual connect
pusher.connect()

// Disconnect
pusher.disconnect()

// Check state
if (pusher.connection.state === 'connected') {
  // Safe to send
}

// Unsubscribe from channel
pusher.unsubscribe('my-channel')

// Or via channel object
const channel = pusher.subscribe('my-channel')
channel.unsubscribe()

// Unsubscribe from all
pusher.unsubscribeAll()

// Get all subscribed channels
const channels = pusher.allChannels()

// Get specific channel
const channel = pusher.channel('my-channel') // null if not subscribed
```

## TypeScript Types

```typescript
import type {
  // Client types
  PusherClient,
  PusherOptions,
  ExtendedPusherOptions,
  Connection,
  ConnectionState,
  StateChange,
  Channel,
  ChannelState,
  PrivateChannel,
  PresenceChannel,
  PresenceMember,
  Members,
  UserData,

  // Auth types
  AuthData,
  AuthOptions,
  AuthTransport,
  Authorizer,
  AuthorizerCallback,
  ChannelAuthorizationOptions,
  UserAuthenticationOptions,

  // Event types
  EventHandler,
  GlobalEventHandler,
  ConnectionEvents,
  ChannelEvents,
  PresenceChannelEvents,

  // Factory type
  CreatePusher,
} from '@dotdo/pusher'

// Type guards
import { isPrivateChannel, isPresenceChannel } from '@dotdo/pusher'

// Error classes
import { PusherError, ConnectionError, AuthError, SubscriptionError } from '@dotdo/pusher'

const channel = pusher.subscribe('presence-room')

if (isPresenceChannel(channel)) {
  // TypeScript knows channel.members exists
  console.log(channel.members.count)
}
```

## Error Handling

```typescript
import { PusherError, AuthError, SubscriptionError } from '@dotdo/pusher'

try {
  // ...
} catch (error) {
  if (error instanceof AuthError) {
    console.error('Auth failed:', error.message, error.status)
  } else if (error instanceof SubscriptionError) {
    console.error('Subscription failed:', error.message)
  } else if (error instanceof PusherError) {
    console.error('Pusher error:', error.type, error.message)
  }
}

// Channel subscription errors
channel.bind('pusher:subscription_error', (error) => {
  console.error('Subscription error:', error.type, error.error, error.status)
})

// Connection errors
pusher.connection.bind('error', (error) => {
  console.error('Connection error:', error)
})
```

## Migration from Pusher

### Package Change

```bash
# Remove
npm uninstall pusher-js

# Install
npm install @dotdo/pusher
```

### Import Change

```typescript
// Before
import Pusher from 'pusher-js'

// After
import Pusher from '@dotdo/pusher'
```

### Configuration

```typescript
// Before: Pusher Cloud
const pusher = new Pusher('your-key', {
  cluster: 'us2',
  forceTLS: true,
})

// After: dotdo (identical)
const pusher = new Pusher('your-key', {
  cluster: 'us2',
  forceTLS: true,
})
```

## Architecture

Each channel is backed by a Durable Object:

```
┌─────────────────────────────────────────────────────────────┐
│                        Client                                │
│           pusher.subscribe('my-channel')                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Edge (Nearest Colo)                       │
│              WebSocket terminates here                       │
│                  0ms cold start                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Channel DO                               │
│                                                              │
│   ┌────────────────────────────────────────────────────┐    │
│   │               SQLite State                          │    │
│   │   - Connection registry                             │    │
│   │   - Presence members                                │    │
│   │   - Channel metadata                                │    │
│   └────────────────────────────────────────────────────┘    │
│                                                              │
│   ┌────────────────────────────────────────────────────┐    │
│   │         Hibernatable WebSockets                     │    │
│   │   - 0 CPU when idle                                 │    │
│   │   - Wake on message                                 │    │
│   │   - Unlimited connections                           │    │
│   └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

Benefits over Pusher Cloud:
- **Edge-native**: Connections terminate at nearest location (300+ cities)
- **No connection limits**: Durable Objects scale horizontally
- **No per-message fees**: Pay only for compute
- **Self-hosted**: Your data stays in your infrastructure

## Common Patterns

### Real-Time Chat

```typescript
// Client
const chat = pusher.subscribe('presence-chat-room') as PresenceChannel

chat.bind('pusher:subscription_succeeded', (members) => {
  displayOnlineUsers(members.toArray())
})

chat.bind('pusher:member_added', (member) => {
  addOnlineUser(member)
})

chat.bind('pusher:member_removed', (member) => {
  removeOnlineUser(member)
})

chat.bind('client-message', (data) => {
  displayMessage(data)
})

// Send message
chat.trigger('client-message', {
  user: chat.members.me?.id,
  text: 'Hello!',
  timestamp: Date.now(),
})
```

### Live Notifications

```typescript
// Client subscribes to user-specific channel
const notifications = pusher.subscribe(`private-user-${userId}`)

notifications.bind('notification', (data) => {
  showNotification(data.title, data.body)
})

// Another client (e.g., sender) triggers notification via client event
const senderChannel = pusher.subscribe(`private-user-${recipientId}`)
senderChannel.trigger('client-notification', {
  title: 'New message',
  body: 'You have a new message from Alice',
})
```

Note: Server-triggered events will be available when the Server SDK is implemented.

### Typing Indicators

```typescript
const chat = pusher.subscribe('private-chat-123')

// Debounced typing indicator
let typingTimeout: number | undefined
input.addEventListener('input', () => {
  chat.trigger('client-typing', { user: myUserId, typing: true })

  clearTimeout(typingTimeout)
  typingTimeout = setTimeout(() => {
    chat.trigger('client-typing', { user: myUserId, typing: false })
  }, 1000)
})

// Display typing status
chat.bind('client-typing', (data) => {
  if (data.typing) {
    showTypingIndicator(data.user)
  } else {
    hideTypingIndicator(data.user)
  }
})
```

## API Reference

### Client API

| Method | Description |
|--------|-------------|
| `new Pusher(key, options?)` | Create client instance |
| `pusher.subscribe(channel)` | Subscribe to channel |
| `pusher.unsubscribe(channel)` | Unsubscribe from channel |
| `pusher.unsubscribeAll()` | Unsubscribe from all channels |
| `pusher.channel(name)` | Get channel by name |
| `pusher.allChannels()` | Get all subscribed channels |
| `pusher.connect()` | Connect to server |
| `pusher.disconnect()` | Disconnect from server |
| `pusher.bind(event, callback)` | Bind to global event |
| `pusher.unbind(event?, callback?)` | Unbind from global event |
| `pusher.bind_global(callback)` | Bind to all global events |
| `pusher.unbind_global(callback?)` | Unbind from all global events |
| `pusher.signin()` | Sign in user |

### Channel API

| Method | Description |
|--------|-------------|
| `channel.bind(event, callback)` | Bind to event |
| `channel.unbind(event?, callback?)` | Unbind from event |
| `channel.bind_global(callback)` | Bind to all events |
| `channel.unbind_global(callback?)` | Unbind from all events |
| `channel.trigger(event, data)` | Trigger client event |
| `channel.unsubscribe()` | Unsubscribe |
| `channel.name` | Channel name |
| `channel.subscribed` | Subscription status |

### Presence Channel API

| Method | Description |
|--------|-------------|
| `channel.members.count` | Member count |
| `channel.members.me` | Current user |
| `channel.members.each(callback)` | Iterate members |
| `channel.members.get(userId)` | Get member by ID |
| `channel.members.toArray()` | Get all members |

## Related

- [Realtime SDKs](/docs/compat/realtime) - Pusher, Ably, Socket.IO
- [Messaging SDKs](/docs/compat/messaging) - Kafka, Redis, NATS, SQS
