---
title: Supabase
description: Choose between @dotdo/supabase (OSS package) and supabase.do (managed edge service) for your Supabase-compatible needs.
---

# Supabase Integration

dotdo provides two ways to work with Supabase-compatible APIs:

| | @dotdo/supabase | supabase.do |
|---|-----------------|-------------|
| **Type** | OSS npm package | Managed edge service |
| **Backend** | In-memory | Durable Object SQLite |
| **Persistence** | None (resets on restart) | Full durability |
| **Use case** | Testing, development | Production workloads |
| **Infrastructure** | Zero | Zero (we manage it) |
| **Install** | `npm install @dotdo/supabase` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/supabase - In-memory, great for tests
import { createClient } from '@dotdo/supabase'

const supabase = createClient('https://local.supabase.co', 'local-key')
await supabase.from('users').insert({ name: 'Alice' })
// Data lost on restart
```

```typescript
// supabase.do - Persistent edge database
import { createClient } from 'supabase.do'

const supabase = createClient('https://your-worker.workers.dev', env.ANON_KEY)
await supabase.from('users').insert({ name: 'Alice' })
// Data persists globally
```

## When to Use Each

### Use @dotdo/supabase when:

- **Unit testing** - Fast, isolated tests without external dependencies
- **Prototyping** - Quick iteration without infrastructure setup
- **CI/CD pipelines** - Tests that need Supabase SDK semantics
- **Migration testing** - Validate your code works with the Supabase API

<Callout type="info">
@dotdo/supabase is a complete in-memory Supabase implementation. Perfect for tests and development, but data doesn't persist between restarts.
</Callout>

### Use supabase.do when:

- **Production applications** - Real user data that must persist
- **Global edge deployment** - Data close to users worldwide
- **Multi-tenant SaaS** - Built-in sharding and jurisdiction support
- **Real-time features** - Database changes, presence, broadcast

<Callout type="info">
supabase.do is Supabase on the Edge - a fully managed service running on Cloudflare's global network with zero infrastructure to manage.
</Callout>

## Feature Comparison

| Feature | @dotdo/supabase | supabase.do |
|---------|-----------------|-------------|
| Database (PostgREST) | Full API | Full API |
| Query Filters | Full | Full |
| Auth (GoTrue) | Full API | Full API + OAuth |
| Storage | In-memory blobs | R2-backed |
| Realtime | In-memory events | WebSocket + DO |
| Edge Functions | Mock handler | Workers-native |
| Sharding | Config only | Active routing |
| Replication | Config only | Multi-region |
| Jurisdiction Support | Config only | EU/US/FedRAMP |
| MCP Protocol | No | AI agent integration |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/supabase/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/supabase</h3>
    <p className="text-sm text-muted-foreground">In-memory Supabase for testing and development</p>
  </a>
  <a href="/docs/integrations/supabase/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">supabase.do</h3>
    <p className="text-sm text-muted-foreground">Managed Supabase on the edge for production</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/supabase` for development, then upgrade to `supabase.do` for production:

```typescript
// Development (package) - isolated in-memory testing
import { createClient } from '@dotdo/supabase'

const supabase = createClient('https://test.supabase.co', 'test-key')
const { data } = await supabase.from('users').select('*').eq('active', true)
```

```typescript
// Production (service) - same API, persistent storage
import { createClient } from 'supabase.do'

const supabase = createClient('https://your-project.workers.dev', env.ANON_KEY)
const { data } = await supabase.from('users').select('*').eq('active', true)
```

Both packages share the same Supabase-compatible API, making migration seamless.

## Architecture Comparison

### @dotdo/supabase

```
+-------------------------------------------+
|            Your Application                |
|                                           |
|  import { createClient } from '@dotdo/supabase' |
+-------------------------------------------+
                    |
                    v
+-------------------------------------------+
|        @dotdo/supabase (In-Memory)        |
+-------------------------------------------+
|  Database:  Map<table, Row[]>             |
|  Auth:      In-memory sessions            |
|  Storage:   In-memory blobs               |
|  Realtime:  In-memory events              |
+-------------------------------------------+
```

### supabase.do

```
+-------------------------------------------+
|            Your Application                |
|                                           |
|  import { createClient } from 'supabase.do' |
+-------------------------------------------+
                    |
                    v
+-------------------------------------------+
|         supabase.do Worker (Edge)         |
+-------------------------------------------+
|  PostgREST  |  GoTrue  |  Realtime  |     |
+-------------------------------------------+
|  ShardDO  |  AuthDO  |  RealtimeDO        |
+-------------------------------------------+
|        Durable Object SQLite + R2         |
+-------------------------------------------+
```

Both approaches support the same Supabase patterns (database queries, auth flows, storage, realtime) - choose based on whether you need testing isolation or production persistence.
