---
title: Upstash
description: Drop-in replacement for @upstash/redis, @upstash/qstash, and @upstash/ratelimit with edge compatibility and Durable Object storage.
---

# Upstash

Drop-in replacement for the Upstash SDK suite. Your existing Upstash code works unchanged - just swap the import.

```typescript
// Before: @upstash/redis
import { Redis } from '@upstash/redis'

// After: dotdo
import { Redis } from '@dotdo/upstash'

// Code stays the same
const redis = new Redis({ url: env.UPSTASH_URL, token: env.UPSTASH_TOKEN })

await redis.set('user:123', JSON.stringify({ name: 'Alice' }))
const user = await redis.get('user:123')

await redis.hset('session:abc', { userId: '123', role: 'admin' })
await redis.expire('session:abc', 3600)
```

## Why @dotdo/upstash?

| @upstash/* SDKs | @dotdo/upstash |
|-----------------|----------------|
| Requires Upstash account | Runs locally on Durable Objects |
| External HTTP requests | Zero network latency in local mode |
| Per-request pricing | Unlimited local operations |
| Single region unless replicated | Global edge deployment |
| Separate dev/prod environments | Same code, different backends |

**This is a compatibility layer.** It can either run entirely locally using Durable Object storage (development/edge) or connect to real Upstash services (production). The API surface matches the official Upstash SDKs.

## Features

### Redis (Full Coverage)

**Strings**
- `get()`, `set()`, `mget()`, `mset()`
- `incr()`, `decr()`, `incrby()`, `decrby()`, `incrbyfloat()`
- `append()`, `strlen()`, `getrange()`, `setrange()`
- `setnx()`, `setex()`, `psetex()`, `getset()`, `getdel()`
- SET options: `EX`, `PX`, `EXAT`, `PXAT`, `NX`, `XX`, `GET`, `KEEPTTL`

**Hashes**
- `hget()`, `hset()`, `hmget()`, `hmset()`, `hgetall()`
- `hdel()`, `hexists()`, `hkeys()`, `hvals()`, `hlen()`
- `hincrby()`, `hincrbyfloat()`, `hsetnx()`

**Lists**
- `lpush()`, `rpush()`, `lpop()`, `rpop()`
- `lrange()`, `llen()`, `lindex()`, `lset()`
- `lrem()`, `ltrim()`

**Sets**
- `sadd()`, `srem()`, `smembers()`, `sismember()`, `smismember()`
- `scard()`, `sinter()`, `sunion()`, `sdiff()`
- `srandmember()`, `spop()`

**Sorted Sets**
- `zadd()`, `zrem()`, `zrange()`, `zrevrange()`
- `zscore()`, `zrank()`, `zrevrank()`, `zcard()`, `zcount()`
- `zincrby()`, `zrangebyscore()`, `zpopmin()`, `zpopmax()`
- ZADD options: `NX`, `XX`, `GT`, `LT`, `CH`, `INCR`

**Keys**
- `del()`, `exists()`, `expire()`, `expireat()`, `pexpire()`, `pexpireat()`
- `ttl()`, `pttl()`, `persist()`, `keys()`, `type()`
- `rename()`, `renamenx()`, `scan()`, `randomkey()`

**JSON (Upstash JSON)**
- `json.get()`, `json.set()`, `json.del()`
- `json.mget()`, `json.type()`, `json.strlen()`
- `json.arrlen()`, `json.arrappend()`, `json.objkeys()`

**Pipelines**
- `pipeline()` for batch commands
- Atomic execution with result arrays

**Server**
- `ping()`, `echo()`, `dbsize()`
- `flushdb()`, `flushall()`, `info()`, `time()`

### QStash (Full Coverage)

**Publishing**
- `publish()` - Send message to URL
- `publishJSON()` - Send JSON payload
- `batch()` - Publish multiple messages
- Delay support with human-readable durations

**Schedules**
- `schedules.create()` - Create cron schedule
- `schedules.get()`, `schedules.list()`, `schedules.delete()`
- `schedules.pause()`, `schedules.resume()`

**Topics**
- `topics.create()`, `topics.get()`, `topics.list()`, `topics.delete()`
- `topics.subscribe()`, `topics.unsubscribe()`
- Fan-out to multiple endpoints

**URL Groups**
- `urlGroups.create()`, `urlGroups.get()`, `urlGroups.list()`
- `urlGroups.delete()`, `urlGroups.addEndpoints()`, `urlGroups.removeEndpoints()`

**Dead Letter Queue**
- `dlq.list()`, `dlq.get()`, `dlq.delete()`
- `dlq.replay()` - Retry failed messages
- `dlq.purge()` - Clear all dead letters

**Events**
- `events.list()`, `events.get()`
- Filter by type, messageId, with pagination

**Webhooks**
- `Receiver.verify()` - HMAC-SHA256 signature verification
- Callback URL support for success/failure

### Ratelimit (Full Coverage)

**Algorithms**
- Fixed Window - Simple time-based windows
- Sliding Window - Smooth rate limiting
- Token Bucket - Burst-friendly with steady refill

**Operations**
- `limit()` - Check rate limit
- `blockUntil()` - Block for duration
- `reset()` - Reset limit for identifier
- `getRemaining()` - Get current state

**Configuration**
- `Ratelimit.fixedWindow(requests, window)`
- `Ratelimit.slidingWindow(requests, window)`
- `Ratelimit.tokenBucket(maxTokens, refillRate, interval)`

### Not Yet Implemented

- Lua scripting (`EVAL`, `EVALSHA`)
- Blocking commands (`BLPOP`, `BRPOP`, `BLMOVE`)
- Streams (`XADD`, `XREAD`, `XGROUP`)
- HyperLogLog (`PFADD`, `PFCOUNT`, `PFMERGE`)
- Geospatial (`GEOADD`, `GEODIST`, `GEOSEARCH`)

## Quick Start

### Install

```bash
npm install @dotdo/upstash
```

### Redis

```typescript
import { Redis } from '@dotdo/upstash'

// Local mode (no Upstash account needed)
const redis = new Redis({ url: 'http://localhost:8787/redis' })

// Basic operations
await redis.set('key', 'value')
const value = await redis.get('key')

// With expiry
await redis.set('session', 'data', { ex: 3600 })

// Increment counters
await redis.incr('pageviews')
await redis.incrby('score', 10)

// Hash operations
await redis.hset('user:123', {
  name: 'Alice',
  email: 'alice@example.com',
  score: '100'
})

const user = await redis.hgetall('user:123')
console.log(user.name) // 'Alice'

// Pipeline for batch operations
const results = await redis
  .pipeline()
  .set('k1', 'v1')
  .set('k2', 'v2')
  .get('k1')
  .incr('counter')
  .exec()
```

### QStash

```typescript
import { QStash } from '@dotdo/upstash'

const qstash = new QStash({ url: 'http://localhost:8787/qstash' })

// Publish a message
const { messageId } = await qstash.publish({
  url: 'https://example.com/api/webhook',
  body: { event: 'user.created', userId: '123' },
})

// Publish with delay
await qstash.publish({
  url: 'https://example.com/api/reminder',
  body: { message: 'Follow up!' },
  delay: '1h', // Human-readable duration
})

// Create a cron schedule
await qstash.schedules.create({
  destination: 'https://example.com/api/daily-report',
  cron: '0 9 * * *', // Every day at 9am
  body: { type: 'daily' },
})

// Fan-out with URL groups
await qstash.urlGroups.create('webhooks', [
  'https://service1.example.com/webhook',
  'https://service2.example.com/webhook',
])

await qstash.publish({
  urlGroup: 'webhooks',
  body: { event: 'notification' },
})
```

### Ratelimit

```typescript
import { Ratelimit } from '@dotdo/upstash'

const ratelimit = new Ratelimit({
  url: 'http://localhost:8787/ratelimit',
  prefix: 'api',
})

// Check rate limit
const { success, limit, remaining, reset } = await ratelimit.limit('user:123')

if (!success) {
  return new Response('Rate limited', {
    status: 429,
    headers: {
      'X-RateLimit-Limit': limit.toString(),
      'X-RateLimit-Remaining': remaining.toString(),
      'X-RateLimit-Reset': reset.toString(),
    }
  })
}

// Use different algorithms
const fixedResult = await ratelimit.limit('user:123', {
  algorithm: 'fixedWindow',
  limit: 100,
  window: 60, // 60 seconds
})

const slidingResult = await ratelimit.limit('user:123', {
  algorithm: 'slidingWindow',
  limit: 100,
  window: 60,
})

const tokenResult = await ratelimit.limit('user:123', {
  algorithm: 'tokenBucket',
  maxTokens: 100,
  refillRate: 10,
  refillInterval: 1000, // 10 tokens per second
})
```

## Inbound Mode - Using upstash.do Locally

For local development and edge deployment, the client uses Durable Object storage as the backend. No Upstash account required.

```typescript
import { Redis, QStash, Ratelimit } from '@dotdo/upstash'

// All clients point to local DO endpoints
const redis = new Redis({ url: 'http://localhost:8787/redis' })
const qstash = new QStash({ url: 'http://localhost:8787/qstash' })
const ratelimit = new Ratelimit({ url: 'http://localhost:8787/ratelimit' })

// Operations run entirely in DO storage
await redis.set('key', 'value')
await qstash.publish({ url: 'https://example.com', body: 'hello' })
const { success } = await ratelimit.limit('user:123')
```

### Durable Object Implementation

The local implementation uses SQLite-backed storage for each service:

```typescript
// UpstashRedisDO - Redis REST API compatible
export class UpstashRedisDO extends DO {
  // Tables: kv, hash_fields, list_items, set_members, zset_members
  // Full Redis command support via HTTP REST API
}

// QStashDO - Message queue with delivery
export class QStashDO extends DO {
  // Tables: messages, schedules, topics, dlq, dedup
  // Retry logic, callbacks, signatures
}

// RateLimitDO - Rate limiting algorithms
export class RateLimitDO extends DO {
  // Tables: fixed_window, sliding_window, token_bucket
  // Analytics tracking
}
```

### Extended Configuration

```typescript
import { Redis } from '@dotdo/upstash'

const redis = new Redis({
  url: 'http://localhost:8787/redis',
  token: 'optional-auth-token',
  automaticDeserialization: true, // Auto JSON parse/stringify
})
```

## Outbound Mode - Connecting to Real Upstash

For production, connect to Upstash services:

```typescript
import { Redis } from '@dotdo/upstash'

// Connect to Upstash Redis
const redis = new Redis({
  url: env.UPSTASH_REDIS_REST_URL,
  token: env.UPSTASH_REDIS_REST_TOKEN,
})

// Same API, requests go to Upstash
await redis.set('key', 'value')
const value = await redis.get('key')
```

### Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { Redis, Ratelimit } from '@dotdo/upstash'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const redis = new Redis({
      url: env.UPSTASH_REDIS_REST_URL,
      token: env.UPSTASH_REDIS_REST_TOKEN,
    })

    const ratelimit = new Ratelimit({
      url: env.RATELIMIT_URL,
    })

    // Rate limiting
    const ip = request.headers.get('CF-Connecting-IP')!
    const { success } = await ratelimit.limit(`ip:${ip}`)

    if (!success) {
      return new Response('Rate limited', { status: 429 })
    }

    // Cache check
    const cached = await redis.get(`cache:${request.url}`)
    if (cached) {
      return new Response(cached as string)
    }

    // Process request...
    return new Response('OK')
  },
}
```

## API Reference

### Redis Commands

```typescript
// GET/SET
await redis.set('key', 'value')
await redis.set('key', 'value', { ex: 60 })      // Expire in 60 seconds
await redis.set('key', 'value', { px: 60000 })   // Expire in 60000 ms
await redis.set('key', 'value', { nx: true })    // Only if not exists
await redis.set('key', 'value', { xx: true })    // Only if exists

const value = await redis.get('key')             // Returns string | null

// MGET/MSET
await redis.mset({ k1: 'v1', k2: 'v2' })
const values = await redis.mget('k1', 'k2')      // ['v1', 'v2']

// Counters
await redis.incr('counter')                      // Increment by 1
await redis.decr('counter')                      // Decrement by 1
await redis.incrby('counter', 5)                 // Increment by 5
await redis.incrbyfloat('counter', 0.5)          // Increment by 0.5

// Hashes
await redis.hset('user', { name: 'Alice', email: 'alice@example.com' })
const name = await redis.hget('user', 'name')
const user = await redis.hgetall('user')         // { name: 'Alice', ... }

// Lists
await redis.lpush('queue', 'a', 'b', 'c')        // Push to head
await redis.rpush('queue', 'x', 'y', 'z')        // Push to tail
const item = await redis.lpop('queue')           // Pop from head
const range = await redis.lrange('queue', 0, -1) // All elements

// Sets
await redis.sadd('tags', 'redis', 'cache', 'fast')
await redis.srem('tags', 'cache')
const members = await redis.smembers('tags')     // ['redis', 'fast']
const isMember = await redis.sismember('tags', 'redis') // 1 or 0

// Sorted Sets
await redis.zadd('scores', 100, 'alice', 200, 'bob')
const top3 = await redis.zrange('scores', 0, 2)
const withScores = await redis.zrange('scores', 0, 2, { withScores: true })
const score = await redis.zscore('scores', 'bob')

// JSON (Upstash JSON)
await redis.json.set('doc', '$', { name: 'Alice', age: 30 })
const doc = await redis.json.get('doc')
await redis.json.set('doc', '$.age', 31)
```

### QStash Operations

```typescript
// Publish message
const { messageId } = await qstash.publish({
  url: 'https://example.com/webhook',
  body: { data: 'payload' },
  method: 'POST',                    // Default: POST
  headers: { 'X-Custom': 'value' },
  delay: '5m',                       // Delay before delivery
  retries: 3,                        // Retry count on failure
  callback: 'https://example.com/success',
  failureCallback: 'https://example.com/failure',
  deduplicationId: 'unique-key',     // Dedupe by ID
  contentBasedDeduplication: true,   // Dedupe by content hash
  timeout: 30,                       // Request timeout in seconds
  deadLetterQueue: 'https://example.com/dlq',
})

// Publish JSON (convenience)
await qstash.publishJSON({
  url: 'https://example.com/webhook',
  body: { event: 'user.created', userId: '123' },
})

// Batch publish
const { responses } = await qstash.batch([
  { url: 'https://service1.com', body: 'message1' },
  { url: 'https://service2.com', body: 'message2' },
])

// Schedules
await qstash.schedules.create({
  destination: 'https://example.com/cron',
  cron: '0 * * * *',  // Every hour
  body: { type: 'hourly' },
})

const schedules = await qstash.schedules.list()
await qstash.schedules.pause('schedule-id')
await qstash.schedules.resume('schedule-id')
await qstash.schedules.delete('schedule-id')

// Topics
await qstash.topics.create({ name: 'notifications' })
await qstash.topics.subscribe('notifications', { url: 'https://example.com' })
await qstash.publish({ topic: 'notifications', body: 'broadcast' })

// Dead Letter Queue
const deadLetters = await qstash.dlq.list()
await qstash.dlq.replay('message-id')
await qstash.dlq.delete('message-id')
await qstash.dlq.purge()
```

### Ratelimit Operations

```typescript
// Basic rate limiting
const { success, limit, remaining, reset, retryAfter } = await ratelimit.limit('identifier')

// With custom configuration
await ratelimit.limit('user:123', {
  algorithm: 'fixedWindow',
  limit: 100,
  window: 60,
  windowUnit: 's', // 's', 'ms', 'm', 'h', 'd'
})

// Token bucket
await ratelimit.limit('api:123', {
  algorithm: 'tokenBucket',
  maxTokens: 100,
  refillRate: 10,       // Tokens per interval
  refillInterval: 1000, // Interval in ms
})

// Block an identifier
await ratelimit.blockUntil('user:123', 60000) // Block for 60 seconds

// Reset rate limit
await ratelimit.reset('user:123')

// Get remaining without consuming
const remaining = await ratelimit.getRemaining('user:123', {
  algorithm: 'fixedWindow',
  limit: 100,
  window: 60,
})

// Static factory methods
const config = Ratelimit.fixedWindow(100, '1m')
const config2 = Ratelimit.slidingWindow(100, '1m')
const config3 = Ratelimit.tokenBucket(100, 10, '1s')
```

## Webhook Verification

```typescript
import { Receiver } from '@dotdo/upstash/qstash'

const receiver = new Receiver({
  currentSigningKey: env.QSTASH_CURRENT_SIGNING_KEY,
  nextSigningKey: env.QSTASH_NEXT_SIGNING_KEY,
})

export default {
  async fetch(request: Request): Promise<Response> {
    const signature = request.headers.get('Upstash-Signature')!
    const body = await request.text()

    const isValid = await receiver.verify({
      signature,
      body,
      clockTolerance: 60, // Allow 60 seconds clock skew
    })

    if (!isValid) {
      return new Response('Invalid signature', { status: 401 })
    }

    // Process webhook...
    return new Response('OK')
  },
}
```

## Common Patterns

### Caching with Redis

```typescript
async function getUser(userId: string) {
  const cacheKey = `user:${userId}`

  // Check cache
  const cached = await redis.get(cacheKey)
  if (cached) {
    return JSON.parse(cached as string)
  }

  // Fetch from database
  const user = await db.query(`SELECT * FROM users WHERE id = ?`, [userId])

  // Cache for 1 hour
  await redis.set(cacheKey, JSON.stringify(user), { ex: 3600 })

  return user
}
```

### Rate Limiting API

```typescript
async function handleRequest(request: Request, env: Env) {
  const ip = request.headers.get('CF-Connecting-IP')!

  const { success, reset } = await ratelimit.limit(`ip:${ip}`, {
    algorithm: 'slidingWindow',
    limit: 100,
    window: 60,
  })

  if (!success) {
    return new Response('Too many requests', {
      status: 429,
      headers: { 'Retry-After': Math.ceil((reset - Date.now()) / 1000).toString() }
    })
  }

  // Process request...
}
```

### Background Job Queue

```typescript
// Enqueue a job
async function enqueueJob(type: string, payload: object) {
  await qstash.publish({
    url: 'https://workers.example.com/jobs',
    body: { type, payload, timestamp: Date.now() },
    retries: 5,
    deadLetterQueue: 'https://workers.example.com/failed-jobs',
  })
}

// Schedule recurring job
async function scheduleReport() {
  await qstash.schedules.create({
    destination: 'https://workers.example.com/reports',
    cron: '0 9 * * MON', // Every Monday at 9am
    body: { type: 'weekly-report' },
  })
}
```

### Session Storage

```typescript
async function createSession(userId: string) {
  const sessionId = crypto.randomUUID()

  await redis.hset(`session:${sessionId}`, {
    userId,
    createdAt: Date.now().toString(),
    expiresAt: (Date.now() + 86400000).toString(),
  })

  await redis.expire(`session:${sessionId}`, 86400) // 24 hours

  return sessionId
}

async function getSession(sessionId: string) {
  const session = await redis.hgetall(`session:${sessionId}`)
  return Object.keys(session).length ? session : null
}
```

### Leaderboard

```typescript
async function updateScore(playerId: string, score: number) {
  await redis.zadd('leaderboard', score, playerId)
}

async function getTopPlayers(count: number = 10) {
  return redis.zrevrange('leaderboard', 0, count - 1, { withScores: true })
}

async function getPlayerRank(playerId: string) {
  const rank = await redis.zrevrank('leaderboard', playerId)
  return rank !== null ? rank + 1 : null
}
```

## Types

```typescript
import type {
  // Redis
  Redis,
  RedisOptions,
  RedisResult,

  // QStash
  QStash,
  QStashOptions,
  PublishRequest,
  PublishResponse,
  Schedule,
  ScheduleRequest,
  Topic,
  URLGroup,
  DLQMessage,
  QStashEvent,

  // Ratelimit
  Ratelimit,
  RatelimitOptions,
  LimitResponse,
  Algorithm,
  RateLimitConfig,
  TokenBucketConfig,

  // Receiver
  Receiver,
  ReceiverConfig,
  VerifyRequest,
} from '@dotdo/upstash'
```

## Migration from Upstash SDKs

### Package Change

```bash
# Remove
npm uninstall @upstash/redis @upstash/qstash @upstash/ratelimit

# Install
npm install @dotdo/upstash
```

### Import Change

```typescript
// Before
import { Redis } from '@upstash/redis'
import { Client as QStash } from '@upstash/qstash'
import { Ratelimit } from '@upstash/ratelimit'

// After
import { Redis, QStash, Ratelimit } from '@dotdo/upstash'
```

### Code Compatibility

Your existing Upstash code should work unchanged:

```typescript
// This code works with both @upstash/* and @dotdo/upstash
const redis = new Redis({ url, token })

await redis.set('key', 'value', { ex: 3600 })
await redis.hset('user', { name: 'Alice', age: '30' })
await redis.zadd('scores', 100, 'player1', 200, 'player2')

const pipeline = redis.pipeline()
pipeline.incr('counter')
pipeline.get('counter')
const results = await pipeline.exec()
```

## Architecture

```
                    Your Application
                           |
         +-----------------+-----------------+
         |                 |                 |
         v                 v                 v
  +-----------+     +-----------+     +-------------+
  |   Redis   |     |   QStash  |     |  Ratelimit  |
  +-----------+     +-----------+     +-------------+
         |                 |                 |
         v                 v                 v
  +------------------------------------------------+
  |              Durable Objects (Local)            |
  |                                                 |
  |  UpstashRedisDO   QStashDO   RateLimitDO       |
  |  - SQLite KV      - Messages  - Fixed Window   |
  |  - Hashes         - Schedules - Sliding Window |
  |  - Lists/Sets     - Topics    - Token Bucket   |
  |  - Sorted Sets    - DLQ       - Analytics      |
  |  - JSON           - Events                     |
  +------------------------------------------------+
                           |
           OR              v
         +--------------------------------+
         |       Upstash Cloud Services   |
         |                                |
         |  Redis      QStash   Ratelimit |
         |  - Global   - Queue  - Limiter |
         |  - Replicas - Cron             |
         +--------------------------------+
```

### Local Mode Benefits

- **Zero latency**: No network round-trips
- **No API limits**: Unlimited local operations
- **No cost**: No per-request pricing
- **Predictable**: No external dependencies
- **Testable**: Control time, simulate failures
- **Offline**: Works without internet

## Related

- [Redis Integration](/docs/integrations/redis) - ioredis/node-redis compatibility
- [Realtime SDKs](/docs/compat/realtime) - Pusher, Ably, Socket.IO
- [Compat SDKs](/docs/compat) - All API-compatible SDKs
