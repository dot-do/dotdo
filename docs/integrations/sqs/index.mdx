---
title: SQS
description: Choose between @dotdo/sqs (OSS package) and sqs.do (managed edge service) for your message queuing needs.
---

# SQS Integration

dotdo provides two ways to work with SQS-compatible message queuing APIs:

| | @dotdo/sqs | sqs.do |
|---|------------|--------|
| **Type** | OSS npm package | Managed edge service |
| **Backend** | In-memory or real AWS SQS | Durable Object SQLite |
| **Persistence** | Depends on mode | Full durability |
| **Use case** | Testing, AWS SQS proxy | Production queuing |
| **Infrastructure** | Your AWS or none | Zero (we manage it) |
| **Install** | `npm install @dotdo/sqs` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/sqs - AWS SDK v3 compatible, can proxy to real SQS
import { SQSClient, SendMessageCommand } from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

await client.send(new SendMessageCommand({
  QueueUrl: 'https://sqs.us-east-1.amazonaws.com/123/my-queue',
  MessageBody: JSON.stringify({ event: 'order.created' }),
}))
```

```typescript
// sqs.do - Native edge message queuing
import { createQueue } from 'sqs.do'

const queue = createQueue(env, 'orders')

await queue.send({
  body: { event: 'order.created', orderId: '123' },
  delaySeconds: 0,
})
```

## When to Use Each

### Use @dotdo/sqs when:

- **Migrating from AWS SQS** - Drop-in replacement with same API
- **Proxy to real AWS SQS** - Connect to existing AWS infrastructure
- **Unit testing** - Local mode for tests without infrastructure
- **Gradual migration** - Keep using real AWS while moving to edge

<Callout type="info">
@dotdo/sqs is an AWS SDK v3 compatible library. Use it when you need the familiar AWS SQS API or want to connect to real AWS SQS queues.
</Callout>

### Use sqs.do when:

- **Edge-native queuing** - Built for Cloudflare Workers from the ground up
- **Zero infrastructure** - No AWS account or SQS setup required
- **Global distribution** - Messages stored at the edge
- **HTTP access** - REST API for external clients
- **FIFO guarantees** - Native message ordering per partition

<Callout type="info">
sqs.do is SQS-compatible message queuing built natively on Cloudflare. Use it for production edge workloads without managing infrastructure.
</Callout>

## Feature Comparison

| Feature | @dotdo/sqs | sqs.do |
|---------|------------|--------|
| SendMessage | Full | Native |
| ReceiveMessage | Full | Native + HTTP |
| DeleteMessage | Full | Native |
| Batch Operations | Full (up to 10) | Native |
| FIFO Queues | Full | Native |
| Message Delays | 0-900 seconds | 0-900 seconds |
| Visibility Timeout | Full | Full |
| Dead Letter Queues | Partial | Full |
| Real AWS backend | Yes | No |
| HTTP Client SDK | No | Yes |
| Queue Tagging | Full | Full |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/sqs/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/sqs</h3>
    <p className="text-sm text-muted-foreground">AWS SDK v3 compatible SQS for migration and testing</p>
  </a>
  <a href="/docs/integrations/sqs/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">sqs.do</h3>
    <p className="text-sm text-muted-foreground">Managed SQS-compatible queuing on the edge</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/sqs` pointing to real AWS SQS, then migrate to `sqs.do`:

```typescript
// Phase 1: Use @dotdo/sqs with real AWS SQS (drop-in for @aws-sdk/client-sqs)
import { SQSClient, SendMessageCommand } from '@dotdo/sqs'

const client = new SQSClient({
  region: 'us-east-1',
  credentials: {
    accessKeyId: env.AWS_ACCESS_KEY_ID,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY,
  },
})

await client.send(new SendMessageCommand({
  QueueUrl: 'https://sqs.us-east-1.amazonaws.com/123/orders',
  MessageBody: JSON.stringify(event),
}))
```

```typescript
// Phase 2: Migrate to sqs.do for zero-infrastructure
import { createQueue } from 'sqs.do'

const queue = createQueue(env, 'orders')
await queue.send({
  body: event, // Native JSON support
})
```

## Architecture Comparison

### @dotdo/sqs

```
+-----------------------------------------------+
|              Your Application                  |
|                                               |
|  import { SQSClient } from '@dotdo/sqs'       |
+-----------------------------------------------+
                    |
        +-----------+-----------+
        |                       |
        v                       v
+---------------+     +---------------+
|  Local Mode   |     | Production    |
|  (In-memory)  |     | (Real AWS)    |
+---------------+     +---------------+
```

### sqs.do

```
+-----------------------------------------------+
|              Your Application                  |
|                                               |
|  import { createQueue } from 'sqs.do'         |
+-----------------------------------------------+
                    |
                    v
+-----------------------------------------------+
|              sqs.do Worker                     |
+-----------------------------------------------+
|  QueueDO  |  MessageDO  |  DeadLetterDO       |
+-----------------------------------------------+
|        Durable Object SQLite                  |
+-----------------------------------------------+
```

Both approaches support the same queuing patterns (work queues, fan-out, delayed processing) - choose based on whether you need real AWS compatibility or native edge deployment.
