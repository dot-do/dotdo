---
title: Discord
description: Choose between @dotdo/discord (OSS package) and discord.do (managed edge service) for Discord bot development.
---

# Discord Integration

dotdo provides two ways to build Discord bots:

| | @dotdo/discord | discord.do |
|---|----------------|------------|
| **Type** | OSS npm package | Managed edge service |
| **Architecture** | Webhook-based interactions | Webhook + gateway hybrid |
| **Persistence** | None (stateless) | Durable Object state |
| **Use case** | Testing, simple bots | Production workloads |
| **Infrastructure** | Zero | Zero (we manage it) |
| **Install** | `npm install @dotdo/discord` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/discord - Lightweight, webhook-based
import { verifyInteraction, createMessageResponse, InteractionType } from '@dotdo/discord'

export default {
  async fetch(request: Request, env: Env) {
    if (!await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)) {
      return new Response('Unauthorized', { status: 401 })
    }
    const interaction = await request.json()
    if (interaction.type === InteractionType.ApplicationCommand) {
      return Response.json(createMessageResponse('Pong!'))
    }
  }
}
```

```typescript
// discord.do - Full-featured edge bot
import { DiscordBot } from 'discord.do'

export class MyBot extends DiscordBot {
  commands = {
    ping: () => 'Pong!',
    stats: async () => {
      const count = await this.storage.get('commandCount') ?? 0
      await this.storage.put('commandCount', count + 1)
      return `Commands run: ${count + 1}`
    }
  }
}
```

## When to Use Each

### Use @dotdo/discord when:

- **Unit testing** - Test Discord bot logic without external dependencies
- **Simple bots** - Slash commands, webhooks, basic interactions
- **Prototyping** - Quick iteration without infrastructure setup
- **CI/CD pipelines** - Tests that need Discord.js-compatible API

<Callout type="info">
@dotdo/discord is a Discord.js-compatible package optimized for edge runtimes. It uses webhook-based interactions instead of WebSocket gateway, making it perfect for serverless deployments.
</Callout>

### Use discord.do when:

- **Production bots** - Real users, persistent state, reliability requirements
- **Stateful interactions** - Multi-step flows, user preferences, command history
- **Global deployment** - Low latency worldwide with edge execution
- **Advanced features** - Rate limiting, analytics, scheduled messages

<Callout type="info">
discord.do is a fully managed Discord bot platform running on Cloudflare Workers. Zero infrastructure to manage, automatic scaling, and built-in state management.
</Callout>

## Feature Comparison

| Feature | @dotdo/discord | discord.do |
|---------|----------------|------------|
| Slash Commands | Full | Full |
| Message Components | Full | Full |
| Embeds | Full | Full |
| Webhooks | Full | Full + managed |
| Modals | Full | Full |
| Autocomplete | Full | Full |
| Interaction Verification | Manual | Automatic |
| Persistent State | None | Durable Objects |
| Command Analytics | None | Built-in |
| Rate Limiting | Basic | Advanced |
| Scheduled Messages | None | Cron triggers |
| Gateway Events | None | Selected events |
| Voice | None | None |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/discord/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/discord</h3>
    <p className="text-sm text-muted-foreground">Discord.js-compatible package for edge runtimes and testing</p>
  </a>
  <a href="/docs/integrations/discord/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">discord.do</h3>
    <p className="text-sm text-muted-foreground">Managed Discord bot platform on the edge</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/discord` for development, then upgrade to `discord.do` for production:

```typescript
// Development (package) - stateless handlers
import { verifyInteraction, createMessageResponse } from '@dotdo/discord'

export default {
  async fetch(request: Request, env: Env) {
    // Manual verification and routing
    if (!await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)) {
      return new Response('Unauthorized', { status: 401 })
    }
    const interaction = await request.json()
    // Handle interaction...
  }
}

// Production (service) - class-based with state
import { DiscordBot } from 'discord.do'

export class MyBot extends DiscordBot {
  // Automatic verification, routing, and state
  commands = {
    ping: () => 'Pong!'
  }
}
```

Both approaches use the same Discord API concepts, making migration straightforward. The main difference is that discord.do provides automatic request handling, persistent state, and managed infrastructure.
