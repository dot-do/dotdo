---
title: Firebase
description: Drop-in replacement for Firebase Firestore and Realtime Database with edge compatibility and local testing support.
---

# Firebase

Drop-in replacement for Firebase Firestore and Realtime Database. Your existing Firebase code works unchanged - just swap the import.

```typescript
// Before: Firebase
import { initializeApp } from 'firebase/app'
import { getFirestore, collection, addDoc } from 'firebase/firestore'
import { getDatabase, ref, set } from 'firebase/database'

// After: dotdo (unified import)
import {
  initializeApp,
  getFirestore,
  collection,
  addDoc,
  getDatabase,
  ref,
  set,
} from '@dotdo/firebase'

// Code stays the same
const app = initializeApp({ projectId: 'my-project' })

// Firestore
const db = getFirestore(app)
await addDoc(collection(db, 'users'), { name: 'Alice', age: 30 })

// Realtime Database
const rtdb = getDatabase(app)
await set(ref(rtdb, 'messages/1'), { text: 'Hello', timestamp: Date.now() })
```

## Why firebase.do?

| Firebase SDK | @dotdo/firebase |
|--------------|-----------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Real API calls in tests | Local testing with in-memory storage |
| Network latency | Zero latency in local mode |
| Requires emulator setup | No setup - works immediately |
| Separate test/prod modes | Same code, different backends |
| Client-side only real-time | Server-side real-time via Pusher compat |

**This is a proxy/compatibility layer.** It can either run entirely locally on Durable Object SQLite storage (development/testing) or connect to real Firebase APIs (production). The API surface matches Firebase's official SDK.

## Features

### Firestore (Implemented)

**App Management**
- `initializeApp()`, `getApp()`, `getApps()`, `deleteApp()`

**Collections & Documents**
- `collection()`, `doc()` - Reference creation
- `addDoc()`, `setDoc()`, `getDoc()`, `getDocs()`, `updateDoc()`, `deleteDoc()` - CRUD operations
- Subcollections and nested paths

**Queries**
- `query()` - Create queries with constraints
- `where()` - Filter with operators: `==`, `!=`, `<`, `<=`, `>`, `>=`, `in`, `not-in`, `array-contains`, `array-contains-any`
- `orderBy()` - Sort ascending or descending
- `limit()`, `limitToLast()` - Pagination
- `startAt()`, `startAfter()`, `endAt()`, `endBefore()` - Cursor-based pagination

**Real-time Listeners**
- `onSnapshot()` - Document and query listeners
- Document change tracking (`added`, `modified`, `removed`)

**Batches & Transactions**
- `writeBatch()` - Atomic batch writes
- `runTransaction()` - Read-write transactions with retries

**Field Values**
- `serverTimestamp()` - Server-generated timestamps
- `deleteField()` - Remove fields
- `increment()` - Atomic increment/decrement
- `arrayUnion()`, `arrayRemove()` - Array operations

**Data Types**
- `Timestamp` - Date/time with nanosecond precision
- `GeoPoint` - Latitude/longitude coordinates
- `FieldPath` - Dot-notation field paths
- `Bytes` - Binary data

**Aggregation**
- `getCountFromServer()` - Count documents
- `getAggregateFromServer()` - Sum, average, count
- `count()`, `sum()`, `average()` - Aggregate field builders

### Realtime Database (Implemented)

**References**
- `ref()`, `child()`, `push()` - Reference navigation
- `refFromURL()` - Create ref from URL

**CRUD Operations**
- `set()`, `get()`, `update()`, `remove()` - Basic operations
- `setWithPriority()`, `setPriority()` - Priority-based ordering

**Real-time Listeners**
- `onValue()` - Value changes
- `onChildAdded()`, `onChildChanged()`, `onChildRemoved()`, `onChildMoved()` - Child events
- `off()` - Remove listeners

**Queries**
- `orderByChild()`, `orderByKey()`, `orderByValue()`, `orderByPriority()` - Ordering
- `limitToFirst()`, `limitToLast()` - Limits
- `startAt()`, `startAfter()`, `endAt()`, `endBefore()` - Cursors
- `equalTo()` - Exact match

**Transactions**
- `runTransaction()` - Atomic read-modify-write

**Connection State**
- `goOnline()`, `goOffline()` - Connection management

### Not Yet Implemented

- Firebase Authentication
- Firebase Storage
- Cloud Functions triggers
- Security Rules evaluation
- Multi-region replication
- Offline persistence (IndexedDB)

## Installation

```bash
npm install @dotdo/firebase
```

## Quick Start

### Firestore

```typescript
import {
  initializeApp,
  getFirestore,
  collection,
  doc,
  addDoc,
  setDoc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  limit,
} from '@dotdo/firebase'

// Initialize app
const app = initializeApp({ projectId: 'my-project' })
const db = getFirestore(app)

// Add document with auto-generated ID
const docRef = await addDoc(collection(db, 'users'), {
  name: 'Alice',
  email: 'alice@example.com',
  createdAt: new Date(),
})
console.log('Document ID:', docRef.id)

// Set document with specific ID
await setDoc(doc(db, 'users/bob'), {
  name: 'Bob',
  email: 'bob@example.com',
})

// Get a single document
const snapshot = await getDoc(doc(db, 'users/alice'))
if (snapshot.exists) {
  console.log('User:', snapshot.data())
}

// Query documents
const q = query(
  collection(db, 'users'),
  where('age', '>', 21),
  orderBy('age'),
  limit(10)
)
const querySnapshot = await getDocs(q)
querySnapshot.forEach((doc) => {
  console.log(doc.id, '=>', doc.data())
})
```

### Realtime Database

```typescript
import {
  initializeApp,
  getDatabase,
  ref,
  set,
  get,
  update,
  push,
  onValue,
} from '@dotdo/firebase'

// Initialize app
const app = initializeApp({
  projectId: 'my-project',
  databaseURL: 'https://my-project.firebaseio.com',
})
const db = getDatabase(app)

// Write data
await set(ref(db, 'users/alice'), {
  name: 'Alice',
  email: 'alice@example.com',
})

// Read data
const snapshot = await get(ref(db, 'users/alice'))
console.log('User:', snapshot.val())

// Update specific fields
await update(ref(db, 'users/alice'), {
  lastLogin: Date.now(),
})

// Push to list
const newPostRef = push(ref(db, 'posts'))
await set(newPostRef, {
  title: 'My Post',
  content: 'Hello world!',
  timestamp: Date.now(),
})

// Listen for changes
const unsubscribe = onValue(ref(db, 'users/alice'), (snapshot) => {
  console.log('User updated:', snapshot.val())
})

// Later: stop listening
unsubscribe()
```

## Inbound Mode - Using firebase.do Locally

For testing and development, the SDK uses in-memory storage. No Firebase project or emulator required.

```typescript
import { initializeApp, getFirestore, collection, addDoc, getDocs } from '@dotdo/firebase'

// Initialize without any credentials
const app = initializeApp({ projectId: 'local-test' })
const db = getFirestore(app)

// Use exactly like real Firebase
const docRef = await addDoc(collection(db, 'users'), {
  name: 'Test User',
  email: 'test@example.com',
})

// Query immediately - data is stored locally
const snapshot = await getDocs(collection(db, 'users'))
console.log('Users:', snapshot.size) // 1
```

### Real-time Listeners in Local Mode

```typescript
import { initializeApp, getFirestore, collection, onSnapshot, addDoc } from '@dotdo/firebase'

const app = initializeApp({ projectId: 'local-test' })
const db = getFirestore(app)
const usersRef = collection(db, 'users')

// Set up listener
const unsubscribe = onSnapshot(usersRef, (snapshot) => {
  console.log('Users updated:', snapshot.size)
  snapshot.forEach((doc) => {
    console.log(doc.id, '=>', doc.data())
  })
})

// Add document - listener fires automatically
await addDoc(usersRef, { name: 'Alice' })
// Console: "Users updated: 1"

await addDoc(usersRef, { name: 'Bob' })
// Console: "Users updated: 2"

// Clean up
unsubscribe()
```

### Transactions in Local Mode

```typescript
import { initializeApp, getFirestore, doc, setDoc, runTransaction } from '@dotdo/firebase'

const app = initializeApp({ projectId: 'local-test' })
const db = getFirestore(app)

// Set up accounts
await setDoc(doc(db, 'accounts/alice'), { balance: 100 })
await setDoc(doc(db, 'accounts/bob'), { balance: 50 })

// Transfer funds atomically
await runTransaction(db, async (transaction) => {
  const aliceRef = doc(db, 'accounts/alice')
  const bobRef = doc(db, 'accounts/bob')

  const aliceSnap = await transaction.get(aliceRef)
  const bobSnap = await transaction.get(bobRef)

  const aliceBalance = aliceSnap.data()?.balance as number
  const bobBalance = bobSnap.data()?.balance as number

  // Transfer 20 from Alice to Bob
  transaction.update(aliceRef, { balance: aliceBalance - 20 })
  transaction.update(bobRef, { balance: bobBalance + 20 })
})
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { initializeApp, getFirestore, collection, addDoc } from '@dotdo/firebase'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const app = initializeApp({ projectId: env.FIREBASE_PROJECT_ID })
    const db = getFirestore(app)

    const docRef = await addDoc(collection(db, 'requests'), {
      url: request.url,
      timestamp: Date.now(),
    })

    return new Response(JSON.stringify({ id: docRef.id }), {
      headers: { 'Content-Type': 'application/json' },
    })
  },
}
```

## API Reference

### App Functions

| Function | Description |
|----------|-------------|
| `initializeApp(config, name?)` | Initialize a Firebase app |
| `getApp(name?)` | Get an initialized app by name |
| `getApps()` | Get all initialized apps |
| `deleteApp(app)` | Delete an app instance |

### Firestore Functions

| Function | Description |
|----------|-------------|
| `getFirestore(app?)` | Get Firestore instance |
| `collection(firestore, path)` | Get collection reference |
| `doc(firestore, path)` | Get document reference |
| `addDoc(collection, data)` | Add document with auto ID |
| `setDoc(doc, data, options?)` | Set document data |
| `getDoc(doc)` | Get a document |
| `getDocs(query)` | Get documents from query |
| `updateDoc(doc, data)` | Update document fields |
| `deleteDoc(doc)` | Delete a document |
| `query(collection, ...constraints)` | Create a query |
| `where(field, op, value)` | Filter constraint |
| `orderBy(field, direction?)` | Sort constraint |
| `limit(count)` | Limit constraint |
| `onSnapshot(ref, callback)` | Listen for changes |
| `writeBatch(firestore)` | Create write batch |
| `runTransaction(firestore, fn)` | Run transaction |

### Realtime Database Functions

| Function | Description |
|----------|-------------|
| `getDatabase(app?)` | Get Database instance |
| `ref(database, path?)` | Get database reference |
| `child(ref, path)` | Get child reference |
| `push(ref)` | Push new child |
| `set(ref, value)` | Set data |
| `get(ref)` | Get data |
| `update(ref, values)` | Update multiple fields |
| `remove(ref)` | Remove data |
| `onValue(ref, callback)` | Listen for value changes |
| `onChildAdded(ref, callback)` | Listen for child additions |
| `off(ref, type?, callback?)` | Remove listeners |
| `runTransaction(ref, fn)` | Run transaction |

### Field Values

| Function | Description |
|----------|-------------|
| `serverTimestamp()` | Server timestamp sentinel |
| `deleteField()` | Delete field sentinel |
| `increment(n)` | Increment by n |
| `arrayUnion(...elements)` | Add elements to array |
| `arrayRemove(...elements)` | Remove elements from array |

### Data Types

| Class | Description |
|-------|-------------|
| `Timestamp` | Firestore timestamp |
| `GeoPoint` | Geographic coordinates |
| `FieldPath` | Document field path |
| `Bytes` | Binary data |

## Common Patterns

### Data Converter

```typescript
import { doc, getDoc, Timestamp } from '@dotdo/firebase'
import type { QueryDocumentSnapshot } from '@dotdo/firebase'

interface User {
  name: string
  age: number
  createdAt: Date
}

const userConverter = {
  toFirestore(user: User) {
    return {
      name: user.name,
      age: user.age,
      createdAt: Timestamp.fromDate(user.createdAt),
    }
  },
  fromFirestore(snapshot: QueryDocumentSnapshot): User {
    const data = snapshot.data()
    return {
      name: data.name,
      age: data.age,
      createdAt: data.createdAt.toDate(),
    }
  },
}

const userRef = doc(db, 'users/alice').withConverter(userConverter)
const snapshot = await getDoc(userRef)
const user: User = snapshot.data()! // Typed!
```

### Batch Writes

```typescript
import { writeBatch, doc, increment } from '@dotdo/firebase'

const batch = writeBatch(db)

// Multiple operations in one batch
batch.set(doc(db, 'users/alice'), { name: 'Alice' })
batch.set(doc(db, 'users/bob'), { name: 'Bob' })
batch.update(doc(db, 'counters/users'), { count: increment(2) })
batch.delete(doc(db, 'users/charlie'))

// Atomic commit
await batch.commit()
```

### Pagination

```typescript
import { query, collection, orderBy, limit, getDocs, startAfter } from '@dotdo/firebase'

// First page
const first = query(
  collection(db, 'users'),
  orderBy('createdAt'),
  limit(10)
)
const firstSnapshot = await getDocs(first)

// Get the last document
const lastDoc = firstSnapshot.docs[firstSnapshot.docs.length - 1]

// Next page
const next = query(
  collection(db, 'users'),
  orderBy('createdAt'),
  startAfter(lastDoc),
  limit(10)
)
const nextSnapshot = await getDocs(next)
```

### Real-time Chat

```typescript
import { ref, push, set, onChildAdded } from '@dotdo/firebase'

// Realtime Database
const messagesRef = ref(db, `chats/${chatId}/messages`)

// Send message
const newMessageRef = push(messagesRef)
await set(newMessageRef, {
  text: 'Hello!',
  sender: userId,
  timestamp: Date.now(),
})

// Listen for new messages
onChildAdded(messagesRef, (snapshot) => {
  const message = snapshot.val()
  console.log(`${message.sender}: ${message.text}`)
})
```

### Aggregation Queries

```typescript
const productsRef = collection(db, 'products')

// Count all products
const countSnapshot = await getCountFromServer(productsRef)
console.log('Total products:', countSnapshot.data().count)

// Multiple aggregations
const statsSnapshot = await getAggregateFromServer(productsRef, {
  totalValue: sum('price'),
  averagePrice: average('price'),
  productCount: count(),
})

const stats = statsSnapshot.data()
console.log('Total value:', stats.totalValue)
console.log('Average price:', stats.averagePrice)
console.log('Count:', stats.productCount)
```

## Error Handling

```typescript
import { FirestoreError } from '@dotdo/firebase'

try {
  await updateDoc(doc(db, 'nonexistent/doc'), { field: 'value' })
} catch (error) {
  if (error instanceof FirestoreError) {
    console.log('Code:', error.code)     // 'not-found'
    console.log('Message:', error.message)
  }
}
```

### Error Codes

| Code | Description |
|------|-------------|
| `cancelled` | Operation was cancelled |
| `not-found` | Document not found |
| `already-exists` | Document already exists |
| `permission-denied` | Permission denied |
| `aborted` | Transaction aborted |
| `invalid-argument` | Invalid argument |
| `resource-exhausted` | Quota exceeded |
| `unavailable` | Service unavailable |

## Architecture

```
+-------------------------------------------------------------+
|                    Your Application                          |
|                                                              |
|  const app = initializeApp({ projectId: 'my-project' })     |
|  const db = getFirestore(app)                                |
|  await addDoc(collection(db, 'users'), { name: 'Alice' })   |
+-------------------------------------------------------------+
                              |
              +---------------+---------------+
              |                               |
              v                               v
+-------------------------+     +-------------------------+
|   Production Mode        |     |     Local Mode          |
|   (Firebase)             |     |     (In-Memory)         |
+-------------------------+     +-------------------------+
|                         |     |                         |
|  -> Firebase APIs       |     |  -> DO SQLite storage   |
|  -> Real persistence    |     |  -> No network calls    |
|  -> Security rules      |     |  -> Instant responses   |
|  -> Multi-region sync   |     |  -> Real-time via       |
|                         |     |     Pusher compat       |
+-------------------------+     +-------------------------+
```

### Local Mode Benefits

- **Zero latency**: No network round-trips
- **No setup**: Works without Firebase project or emulator
- **Predictable**: No external dependencies
- **Testable**: Consistent behavior across test runs
- **Offline**: Works without internet

## Migration from Firebase SDK

### Package Change

```bash
# Remove
npm uninstall firebase

# Install
npm install @dotdo/firebase
```

### Import Change

```typescript
// Before
import { initializeApp } from 'firebase/app'
import { getFirestore, collection, addDoc } from 'firebase/firestore'
import { getDatabase, ref, set } from 'firebase/database'

// After
import { initializeApp } from '@dotdo/firebase'
import { getFirestore, collection, addDoc } from '@dotdo/firebase/firestore'
import { getDatabase, ref, set } from '@dotdo/firebase/database'

// Or unified import
import {
  initializeApp,
  getFirestore,
  collection,
  addDoc,
  getDatabase,
  ref,
  set,
} from '@dotdo/firebase'
```

### Code Compatibility

Your existing Firebase code should work unchanged:

```typescript
// This code works with both firebase and @dotdo/firebase
const app = initializeApp(config)
const db = getFirestore(app)

const docRef = await addDoc(collection(db, 'users'), {
  name: 'Alice',
  email: 'alice@example.com',
})

const snapshot = await getDoc(docRef)
console.log('User:', snapshot.data())
```

## Related

- [Pusher Integration](/docs/integrations/pusher) - Real-time updates via Pusher compat
- [Postgres Integration](/docs/integrations/postgres) - SQL database alternative
- [Compat SDKs](/docs/compat) - All API-compatible SDKs
