---
title: Cube.js
description: Cube.js-compatible semantic layer for analytics with schema definitions, query building, and caching.
---

# Cube.js

A Cube.js-compatible semantic layer for building analytics applications. Define cube schemas, build queries, and leverage pre-aggregation caching - all running on edge infrastructure.

```typescript
import { cube, CubeClient, QueryBuilder, createCubeAPI } from '@dotdo/cubejs'

// Define a cube schema
const Orders = cube('Orders', {
  sql: 'SELECT * FROM orders',
  measures: {
    count: { type: 'count' },
    totalAmount: { sql: 'amount', type: 'sum' },
  },
  dimensions: {
    id: { sql: 'id', type: 'number', primaryKey: true },
    status: { sql: 'status', type: 'string' },
    createdAt: { sql: 'created_at', type: 'time' },
  },
})

// Build and execute queries
const query = new QueryBuilder()
  .select('Orders.count', 'Orders.totalAmount')
  .dimensions('Orders.status')
  .build()

const client = new CubeClient({ apiToken: 'token', apiUrl: '/cubejs-api/v1' })
const result = await client.load(query)
```

## Why @dotdo/cubejs?

| Cube Cloud | @dotdo/cubejs |
|------------|---------------|
| Separate infrastructure | Runs on your edge workers |
| External data transfer | Data stays in your infrastructure |
| Usage-based pricing | Unlimited queries |
| Deployment complexity | Single package deployment |

## Features

### Schema Definition

- Cube schemas with measures, dimensions, joins
- Pre-aggregations for query acceleration
- Segments for reusable filters
- Refresh keys for cache invalidation

### Query Building

- Fluent query builder API
- Filters (equals, contains, gt, lt, etc.)
- Time dimensions with granularity
- Sorting and pagination

### API Compatibility

- REST API compatible with Cube.js clients
- Load, dry run, and meta endpoints
- SQL generation

## Quick Start

### Install

```bash
npm install @dotdo/cubejs
```

### Define Cubes

```typescript
import { cube } from '@dotdo/cubejs'

const Orders = cube('Orders', {
  sql: 'SELECT * FROM orders',

  measures: {
    count: {
      type: 'count',
    },
    totalAmount: {
      sql: 'amount',
      type: 'sum',
    },
    averageAmount: {
      sql: 'amount',
      type: 'avg',
    },
  },

  dimensions: {
    id: {
      sql: 'id',
      type: 'number',
      primaryKey: true,
    },
    status: {
      sql: 'status',
      type: 'string',
    },
    customerId: {
      sql: 'customer_id',
      type: 'number',
    },
    createdAt: {
      sql: 'created_at',
      type: 'time',
    },
  },

  segments: {
    completed: {
      sql: `status = 'completed'`,
    },
  },

  preAggregations: {
    ordersDaily: {
      type: 'rollup',
      measureReferences: ['count', 'totalAmount'],
      dimensionReferences: ['status'],
      timeDimensionReference: 'createdAt',
      granularity: 'day',
    },
  },
})
```

### Build Queries

```typescript
import { QueryBuilder, filter, and, or, timeDimension } from '@dotdo/cubejs'

// Simple query
const query = new QueryBuilder()
  .select('Orders.count', 'Orders.totalAmount')
  .dimensions('Orders.status')
  .build()

// Query with filters
const filteredQuery = new QueryBuilder()
  .select('Orders.count')
  .dimensions('Orders.status', 'Orders.customerId')
  .where('Orders.status', 'equals', 'completed')
  .timeDimension('Orders.createdAt', 'day', 'last 30 days')
  .orderBy('Orders.count', 'desc')
  .limit(100)
  .build()

// Complex filters
const complexQuery = new QueryBuilder()
  .select('Orders.totalAmount')
  .filters([
    and([
      filter('Orders.status', 'equals', 'completed'),
      or([
        filter('Orders.totalAmount', 'gt', 100),
        filter('Orders.customerId', 'set'),
      ]),
    ]),
  ])
  .build()
```

## Using the Client

```typescript
import { CubeClient } from '@dotdo/cubejs'

const client = new CubeClient({
  apiToken: 'your_api_token',
  apiUrl: 'https://cube.example.com/cubejs-api/v1',
})

// Load data
const result = await client.load({
  measures: ['Orders.count', 'Orders.totalAmount'],
  dimensions: ['Orders.status'],
  timeDimensions: [{
    dimension: 'Orders.createdAt',
    granularity: 'day',
    dateRange: 'last 30 days',
  }],
})

console.log(result.data)
// [
//   { 'Orders.status': 'completed', 'Orders.count': 150, 'Orders.totalAmount': 15000, ... },
//   { 'Orders.status': 'pending', 'Orders.count': 30, 'Orders.totalAmount': 3000, ... },
// ]

// Get metadata
const meta = await client.meta()
console.log(meta.cubes) // Available cubes and their members

// Dry run (get SQL without executing)
const dryRun = await client.dryRun(query)
console.log(dryRun.sql) // Generated SQL query
```

## Creating a Cube API

Deploy a Cube.js-compatible API endpoint:

```typescript
import { createCubeAPI, cube } from '@dotdo/cubejs'

// Define your cubes
const Orders = cube('Orders', { ... })
const Customers = cube('Customers', { ... })

// Create the API
const api = createCubeAPI({
  cubes: [Orders, Customers],
  apiToken: 'your_api_token',
  dataSource: async (sql) => {
    // Execute SQL against your database
    return db.query(sql)
  },
})

// Export for Cloudflare Workers
export default {
  fetch: api.fetch,
}
```

## Pre-Aggregations

Speed up queries with pre-aggregated data:

```typescript
const Orders = cube('Orders', {
  sql: 'SELECT * FROM orders',

  measures: {
    count: { type: 'count' },
    totalAmount: { sql: 'amount', type: 'sum' },
  },

  dimensions: {
    status: { sql: 'status', type: 'string' },
    createdAt: { sql: 'created_at', type: 'time' },
  },

  preAggregations: {
    // Daily rollup
    ordersByDay: {
      type: 'rollup',
      measureReferences: ['count', 'totalAmount'],
      dimensionReferences: ['status'],
      timeDimensionReference: 'createdAt',
      granularity: 'day',
      refreshKey: {
        every: '1 hour',
      },
    },

    // Original SQL (no aggregation)
    rawOrders: {
      type: 'originalSql',
      refreshKey: {
        sql: 'SELECT MAX(updated_at) FROM orders',
      },
    },
  },
})
```

### Pre-Aggregation Cache

```typescript
import { PreAggregationCache } from '@dotdo/cubejs'

const cache = new PreAggregationCache({
  storage: env.CUBEJS_KV,
  ttl: 3600, // 1 hour
})

// The API automatically uses the cache
const api = createCubeAPI({
  cubes: [Orders],
  cache,
  dataSource: async (sql) => db.query(sql),
})
```

## Joins

Define relationships between cubes:

```typescript
const Orders = cube('Orders', {
  sql: 'SELECT * FROM orders',

  joins: {
    Customers: {
      relationship: 'belongsTo',
      sql: `${CUBE}.customer_id = ${Customers}.id`,
    },
    Products: {
      relationship: 'hasMany',
      sql: `${CUBE}.id = ${Products}.order_id`,
    },
  },

  measures: { ... },
  dimensions: { ... },
})

// Query across joined cubes
const query = new QueryBuilder()
  .select('Orders.count')
  .dimensions('Customers.name', 'Customers.email')
  .build()
```

## SQL Generation

Generate SQL from queries:

```typescript
import { generateSQL, cube } from '@dotdo/cubejs'

const Orders = cube('Orders', {
  sql: 'SELECT * FROM orders',
  measures: {
    count: { type: 'count' },
  },
  dimensions: {
    status: { sql: 'status', type: 'string' },
  },
})

const sql = generateSQL({
  measures: ['Orders.count'],
  dimensions: ['Orders.status'],
  filters: [{
    member: 'Orders.status',
    operator: 'equals',
    values: ['completed'],
  }],
}, [Orders])

// SELECT
//   status AS "Orders.status",
//   COUNT(*) AS "Orders.count"
// FROM orders
// WHERE status = 'completed'
// GROUP BY 1
```

## Time Dimensions

```typescript
// Query with time dimension
const query = new QueryBuilder()
  .select('Orders.count', 'Orders.totalAmount')
  .timeDimension('Orders.createdAt', 'day', 'last 30 days')
  .build()

// Custom date range
const customQuery = new QueryBuilder()
  .select('Orders.count')
  .timeDimensions([{
    dimension: 'Orders.createdAt',
    granularity: 'week',
    dateRange: ['2024-01-01', '2024-03-31'],
  }])
  .build()

// Granularity options: second, minute, hour, day, week, month, quarter, year
```

## Error Handling

```typescript
import { CubeClient, CubeError, ValidationError, QueryError } from '@dotdo/cubejs'

try {
  const result = await client.load(query)
} catch (error) {
  if (error instanceof ValidationError) {
    console.log('Invalid query:', error.message)
  } else if (error instanceof QueryError) {
    console.log('Query execution failed:', error.message)
  } else if (error instanceof AuthenticationError) {
    console.log('Invalid API token')
  }
}
```

## API Reference

### cube() Function

```typescript
function cube(name: string, schema: CubeSchema): CubeSchema

interface CubeSchema {
  sql: string
  measures: Record<string, Measure>
  dimensions: Record<string, Dimension>
  joins?: Record<string, Join>
  segments?: Record<string, Segment>
  preAggregations?: Record<string, PreAggregation>
}
```

### QueryBuilder Class

```typescript
class QueryBuilder {
  select(...measures: string[]): QueryBuilder
  dimensions(...dimensions: string[]): QueryBuilder
  where(member: string, operator: FilterOperator, value: unknown): QueryBuilder
  filters(filters: Filter[]): QueryBuilder
  timeDimension(dimension: string, granularity: Granularity, dateRange: string): QueryBuilder
  timeDimensions(timeDimensions: TimeDimension[]): QueryBuilder
  orderBy(member: string, direction: 'asc' | 'desc'): QueryBuilder
  limit(n: number): QueryBuilder
  offset(n: number): QueryBuilder
  build(): CubeQuery
}
```

### CubeClient Class

```typescript
class CubeClient {
  constructor(options: CubeClientOptions)

  load(query: CubeQuery, options?: LoadOptions): Promise<QueryResult>
  meta(): Promise<MetaResult>
  dryRun(query: CubeQuery): Promise<DryRunResult>
}
```

## Types

```typescript
import type {
  // Schema types
  CubeSchema,
  Measure,
  MeasureType,
  Dimension,
  DimensionType,
  Join,
  JoinRelationship,
  PreAggregation,
  Segment,

  // Query types
  CubeQuery,
  Filter,
  FilterOperator,
  TimeDimension,
  Granularity,

  // Result types
  QueryResult,
  MetaResult,
  DryRunResult,
} from '@dotdo/cubejs'
```

## Related

- [ClickHouse](/docs/integrations/clickhouse) - OLAP database integration
- [DuckDB](/docs/integrations/duckdb) - Embedded analytics
- [Analytics](/docs/integrations/analytics) - Event tracking
