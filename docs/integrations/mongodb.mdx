---
title: MongoDB
description: MongoDB-compatible in-memory document store for edge environments and testing.
---

# MongoDB

MongoDB-compatible document store that runs entirely in-memory. Provides a familiar MongoDB API for edge environments (Cloudflare Workers) and testing scenarios where no external database is needed.

```typescript
import { DocumentStore } from '@dotdo/mongodb'

const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

await users.insertOne({ name: 'Alice', age: 30 })

const adults = await users.find({ age: { $gte: 18 } }).toArray()
```

## Why @dotdo/mongodb?

| MongoDB Driver | @dotdo/mongodb |
|----------------|----------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Requires MongoDB server | In-memory, no external dependencies |
| Network latency | Zero latency |
| Connection management | Stateless, instant startup |
| Complex test setup | Perfect for unit tests |

**This is an in-memory implementation** with a MongoDB-compatible API. Data does not persist between restarts. Ideal for testing, prototyping, and edge environments where you need document storage without external dependencies.

## Features

### Implemented (Core APIs)

**Collections**
- `insertOne()`, `insertMany()` - Insert documents
- `findOne()`, `find()` - Query documents with cursor support
- `updateOne()`, `updateMany()`, `replaceOne()` - Update documents
- `deleteOne()`, `deleteMany()` - Remove documents
- `findOneAndUpdate()`, `findOneAndDelete()`, `findOneAndReplace()` - Atomic operations
- `countDocuments()`, `estimatedDocumentCount()` - Count operations
- `distinct()` - Get distinct values

**Query Operators**
- Comparison: `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`, `$in`, `$nin`
- Logical: `$and`, `$or`, `$nor`, `$not`
- Element: `$exists`, `$type`
- Evaluation: `$regex`
- Array: `$all`, `$elemMatch`, `$size`

**Update Operators**
- Field: `$set`, `$unset`, `$inc`, `$mul`, `$min`, `$max`, `$setOnInsert`, `$currentDate`
- Array: `$push`, `$pull`, `$addToSet`, `$pop`
- Modifiers: `$each` (for `$push` and `$addToSet`)

**Aggregation Pipeline**
- `$match` - Filter documents
- `$group` - Group with accumulators (`$sum`, `$avg`, `$min`, `$max`, `$first`, `$last`, `$push`, `$addToSet`, `$count`)
- `$project` - Shape output documents
- `$sort` - Order results
- `$limit`, `$skip` - Pagination
- `$unwind` - Deconstruct arrays
- `$count` - Count documents
- `$addFields`, `$set` - Add computed fields
- `$facet` - Multiple pipelines
- `$bucket` - Categorize into buckets
- `$replaceRoot`, `$replaceWith` - Replace documents
- `$sample` - Random selection

**Indexes**
- Single field indexes
- Compound indexes
- Unique indexes
- Text indexes with BM25 scoring
- Sparse indexes

### Not Yet Implemented

- `$lookup` (cross-collection joins)
- `$graphLookup` (recursive lookups)
- `$geoNear`, `$geoWithin` (geospatial)
- `$merge`, `$out` (output stages)
- `$bucketAuto` (automatic bucketing)
- TTL indexes (expireAfterSeconds stored but expiration not enforced)
- Update operators: `$rename`, `$pullAll`
- Array modifiers: `$position`, `$slice`, `$sort`
- Change streams
- Transactions
- Sharding

## Quick Start

### Install

```bash
npm install @dotdo/mongodb
```

### Basic Usage

```typescript
import { DocumentStore, ObjectId } from '@dotdo/mongodb'

// Create a document store
const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

// Insert documents
const result = await users.insertOne({
  name: 'Alice',
  email: 'alice@example.com',
  age: 30,
  createdAt: new Date(),
})

console.log('Inserted:', result.insertedId)

// Find documents
const user = await users.findOne({ email: 'alice@example.com' })
console.log('Found:', user?.name)

// Update documents
await users.updateOne(
  { _id: result.insertedId },
  { $set: { age: 31 }, $inc: { loginCount: 1 } }
)

// Delete documents
await users.deleteOne({ _id: result.insertedId })
```

### Query with Operators

```typescript
// Find adults in specific cities
const results = await users.find({
  age: { $gte: 18 },
  city: { $in: ['NYC', 'LA', 'SF'] },
  $or: [
    { status: 'active' },
    { createdAt: { $gt: new Date('2024-01-01') } }
  ]
}).toArray()

// Using cursor methods
const cursor = users.find({ status: 'active' })
  .sort({ createdAt: -1 })
  .skip(10)
  .limit(20)
  .project({ name: 1, email: 1 })

for await (const doc of cursor) {
  console.log(doc.name)
}
```

### Aggregation Pipeline

```typescript
// Group users by city and calculate stats
const stats = await users.aggregate([
  { $match: { status: 'active' } },
  { $group: {
    _id: '$city',
    count: { $sum: 1 },
    avgAge: { $avg: '$age' },
    names: { $push: '$name' }
  }},
  { $sort: { count: -1 } },
  { $limit: 10 }
]).toArray()

// Multi-facet aggregation
const facets = await users.aggregate([
  { $facet: {
    byCity: [
      { $group: { _id: '$city', count: { $sum: 1 } } }
    ],
    byAge: [
      { $bucket: {
        groupBy: '$age',
        boundaries: [0, 18, 30, 50, 100],
        default: 'Other'
      }}
    ],
    recent: [
      { $sort: { createdAt: -1 } },
      { $limit: 5 },
      { $project: { name: 1, createdAt: 1 } }
    ]
  }}
]).toArray()
```

### Index Management

```typescript
// Create indexes
await users.createIndex({ email: 1 }, { unique: true })
await users.createIndex({ city: 1, age: -1 })
await users.createIndex({ bio: 'text' })

// List indexes
const indexes = await users.indexes()
console.log(indexes)

// Check if index exists
const hasEmailIndex = await users.indexExists('email_1')
```

## Inbound Mode - Using mongodb.do Locally

For testing and development, use the local document store - a complete in-memory MongoDB implementation:

```typescript
import { DocumentStore, Collection } from '@dotdo/mongodb'

// Create local store (no MongoDB server needed)
const store = new DocumentStore()
const db = store.db('testdb')
const users = db.collection('users')

// Full MongoDB API available locally
await users.insertOne({ name: 'Test User', age: 25 })

const doc = await users.findOne({ name: 'Test User' })
console.log(doc) // { _id: ObjectId(...), name: 'Test User', age: 25 }

// Aggregation works locally
const stats = await users.aggregate([
  { $group: { _id: null, total: { $sum: 1 } } }
]).toArray()
```

### Type-Safe Collections

```typescript
interface User {
  name: string
  email: string
  age: number
  tags?: string[]
}

// Type-safe collection
const users = db.collection<User>('users')

// TypeScript knows the document shape
await users.insertOne({
  name: 'Alice',
  email: 'alice@example.com',
  age: 30,
}) // Type-checked

const user = await users.findOne({ name: 'Alice' })
// user is WithId<User> | null
```

### ObjectId

```typescript
import { ObjectId } from '@dotdo/mongodb'

// Create new ObjectId
const id = new ObjectId()

// Parse from string
const parsed = new ObjectId('507f1f77bcf86cd799439011')

// Get timestamp
const timestamp = id.getTimestamp() // Date

// Compare ObjectIds
id.equals(parsed) // false

// Create from timestamp
const fromTime = ObjectId.createFromTime(Date.now() / 1000)
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { DocumentStore } from '@dotdo/mongodb'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const store = new DocumentStore()
    const db = store.db('api')
    const users = db.collection('users')

    const url = new URL(request.url)

    if (request.method === 'GET' && url.pathname === '/users') {
      const allUsers = await users.find({}).toArray()
      return Response.json(allUsers)
    }

    if (request.method === 'POST' && url.pathname === '/users') {
      const body = await request.json()
      const result = await users.insertOne(body)
      return Response.json({ id: result.insertedId })
    }

    return new Response('Not Found', { status: 404 })
  },
}
```

## API Reference

### DocumentStore

```typescript
const store = new DocumentStore(options?)

// Get a database
const db = store.db('mydb')

// List databases
const dbs = store.listDatabases() // [{ name: 'mydb' }, ...]

// Drop database
await store.dropDatabase('mydb')
```

### Database

```typescript
// Get collection
const collection = db.collection<T>('name')

// Create collection
const collection = await db.createCollection<T>('name')

// List collections
const list = await db.listCollections().toArray()

// Drop collection
await db.dropCollection('name')

// Drop database
await db.dropDatabase()
```

### Collection

```typescript
// Insert
await collection.insertOne(doc)
await collection.insertMany(docs, { ordered: true })

// Find
await collection.findOne(filter, options)
collection.find(filter, options)

// Update
await collection.updateOne(filter, update, { upsert: false })
await collection.updateMany(filter, update, { upsert: false })
await collection.replaceOne(filter, replacement, { upsert: false })

// Delete
await collection.deleteOne(filter)
await collection.deleteMany(filter)

// Atomic operations
await collection.findOneAndUpdate(filter, update, { returnDocument: 'after' })
await collection.findOneAndDelete(filter)
await collection.findOneAndReplace(filter, replacement, { returnDocument: 'after' })

// Count
await collection.countDocuments(filter)
await collection.estimatedDocumentCount()

// Distinct
await collection.distinct('fieldName', filter)

// Aggregate
collection.aggregate(pipeline, options)

// Indexes
await collection.createIndex(keys, options)
await collection.createIndexes([{ key, options }])
await collection.dropIndex('indexName')
await collection.dropIndexes()
await collection.indexes()
await collection.indexExists('indexName')
collection.listIndexes()

// Collection management
await collection.drop()
```

### Cursor

```typescript
const cursor = collection.find(filter)

// Iterate
for await (const doc of cursor) { ... }
await cursor.forEach(doc => { ... })

// Get all results
const docs = await cursor.toArray()

// Get next document
const doc = await cursor.next()
const hasMore = await cursor.hasNext()

// Chain methods
cursor
  .filter({ status: 'active' })
  .sort({ createdAt: -1 })
  .skip(10)
  .limit(20)
  .project({ name: 1, email: 1 })
  .map(doc => doc.name)

// Count
const count = await cursor.count()

// Close
await cursor.close()
```

## Error Handling

```typescript
import { MongoError, MongoDuplicateKeyError } from '@dotdo/mongodb'

try {
  await users.insertOne({ _id: existingId, name: 'Duplicate' })
} catch (error) {
  if (error instanceof MongoDuplicateKeyError) {
    console.log('Duplicate key:', error.keyValue)
    console.log('Key pattern:', error.keyPattern)
    console.log('Error code:', error.code) // 11000
  }
}
```

## Types

Full TypeScript support with comprehensive type definitions:

```typescript
// Value exports (classes)
import {
  ObjectId,
  MongoError,
  MongoDuplicateKeyError,
  DocumentStore,
  Collection,
} from '@dotdo/mongodb'

// Type exports
import type {
  // Core types
  Document,
  WithId,
  OptionalId,

  // Filter types
  Filter,
  FilterOperators,
  ComparisonOperators,
  LogicalOperators,
  ElementOperators,
  EvaluationOperators,
  ArrayOperators,
  Condition,

  // Update types
  UpdateFilter,
  UpdateOperators,
  ArrayUpdateOperators,

  // Projection and Sort
  Projection,
  Sort,
  SortDirection,

  // Pipeline types
  PipelineStage,
  MatchStage,
  GroupStage,
  ProjectStage,
  SortStage,
  LimitStage,
  SkipStage,
  UnwindStage,
  CountStage,
  AddFieldsStage,
  SetStage,
  FacetStage,
  BucketStage,
  ReplaceRootStage,
  ReplaceWithStage,
  SampleStage,

  // Index types
  IndexSpecification,
  CreateIndexOptions,
  IndexInfo,

  // Result types
  InsertOneResult,
  InsertManyResult,
  UpdateResult,
  DeleteResult,

  // Options types
  FindOptions,
  UpdateOptions,
  DeleteOptions,
  InsertOneOptions,
  InsertManyOptions,
  CountDocumentsOptions,
  AggregateOptions,
  FindOneAndUpdateOptions,
  FindOneAndDeleteOptions,
  FindOneAndReplaceOptions,

  // Cursor types
  FindCursor,
  AggregationCursor,

  // Interface types
  Collection as ICollection,
  Db as IDb,
  DocumentStoreOptions,
} from '@dotdo/mongodb'
```

## Architecture

```
+-------------------------------------------------------------+
|                    Your Application                          |
|                                                              |
|  const store = new DocumentStore()                           |
|  const users = store.db('myapp').collection('users')         |
|  await users.find({ status: 'active' }).toArray()            |
+-------------------------------------------------------------+
                              |
                              v
+-------------------------------------------------------------+
|   DocumentStore (In-Memory)                                  |
+-------------------------------------------------------------+
|                                                              |
|  -> In-memory storage (no persistence between restarts)      |
|  -> Zero latency                                             |
|  -> No external dependencies                                 |
|  -> Edge-compatible (Cloudflare Workers)                     |
|  -> Instant startup, no connection management                |
|                                                              |
+-------------------------------------------------------------+
```

### Benefits

- **Zero latency**: No network round-trips
- **No dependencies**: No MongoDB server required
- **Edge-compatible**: Runs on Cloudflare Workers
- **Instant startup**: No connection management
- **Predictable**: No external state
- **Testing**: Ideal for unit tests and local development

## Common Patterns

### Repository Pattern

```typescript
import { DocumentStore, Collection, ObjectId } from '@dotdo/mongodb'

interface User {
  name: string
  email: string
  createdAt: Date
}

class UserRepository {
  private collection: Collection<User>

  constructor(store: DocumentStore) {
    this.collection = store.db('app').collection<User>('users')
  }

  async create(user: Omit<User, 'createdAt'>): Promise<ObjectId> {
    const result = await this.collection.insertOne({
      ...user,
      createdAt: new Date(),
    })
    return result.insertedId
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.collection.findOne({ email })
  }

  async findActive(limit = 20): Promise<User[]> {
    return this.collection
      .find({ status: 'active' })
      .sort({ createdAt: -1 })
      .limit(limit)
      .toArray()
  }

  async updateLastLogin(id: ObjectId): Promise<void> {
    await this.collection.updateOne(
      { _id: id },
      { $set: { lastLogin: new Date() } }
    )
  }
}
```

### Pagination

```typescript
async function paginateUsers(page: number, pageSize: number) {
  const skip = (page - 1) * pageSize

  const [users, total] = await Promise.all([
    collection
      .find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(pageSize)
      .toArray(),
    collection.countDocuments({}),
  ])

  return {
    data: users,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
    total,
  }
}
```

### Upsert Pattern

```typescript
// Update if exists, insert if not
await collection.updateOne(
  { email: 'user@example.com' },
  {
    $set: { lastSeen: new Date() },
    $setOnInsert: { createdAt: new Date() },
    $inc: { visitCount: 1 },
  },
  { upsert: true }
)
```

## Migration from mongodb

### Import Change

```typescript
// Before: MongoDB driver
import { MongoClient, ObjectId } from 'mongodb'

// After: dotdo DocumentStore
import { DocumentStore, ObjectId } from '@dotdo/mongodb'
```

### Code Migration

Replace `MongoClient` with `DocumentStore`:

```typescript
// Before
const client = new MongoClient('mongodb://localhost:27017')
await client.connect()
const db = client.db('myapp')
const users = db.collection('users')

// After
const store = new DocumentStore()
const db = store.db('myapp')
const users = db.collection('users')

// All MongoDB operations work the same
await users.insertOne({ name: 'Alice', age: 30 })
const user = await users.findOne({ name: 'Alice' })
```

### Testing with DocumentStore

DocumentStore is ideal for unit tests - no external MongoDB required:

```typescript
import { DocumentStore } from '@dotdo/mongodb'

describe('UserRepository', () => {
  let store: DocumentStore
  let users: Collection<User>

  beforeEach(() => {
    // Fresh in-memory store for each test
    store = new DocumentStore()
    users = store.db('test').collection('users')
  })

  it('should create a user', async () => {
    const result = await users.insertOne({ name: 'Alice', age: 30 })
    expect(result.acknowledged).toBe(true)

    const user = await users.findOne({ _id: result.insertedId })
    expect(user?.name).toBe('Alice')
  })
})
```

Note: DocumentStore is an in-memory implementation. Data does not persist between restarts. For production use cases requiring persistence, you would need to use the actual MongoDB driver or another persistence layer.

## Related

- [Postgres Integration](/docs/integrations/postgres) - SQL database support
- [Algolia Integration](/docs/integrations/algolia) - Full-text search
- [Compat SDKs](/docs/compat) - All API-compatible SDKs
