---
title: Discord
description: Drop-in replacement for Discord.js with edge compatibility and webhook-based interactions.
---

# Discord

Drop-in replacement for Discord.js bot development. Your existing `discord.js` code works unchanged - just swap the import.

```typescript
// Before: Discord.js
import { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder } from 'discord.js'

// After: dotdo
import { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder } from '@dotdo/discord'

// Code stays the same
const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages],
})

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}`)
})

client.on('interactionCreate', async (interaction) => {
  if (!interaction.isChatInputCommand()) return

  if (interaction.commandName === 'ping') {
    await interaction.reply('Pong!')
  }
})

await client.login(env.DISCORD_BOT_TOKEN)
```

## Why @dotdo/discord?

| Discord.js | @dotdo/discord |
|------------|----------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| WebSocket gateway required | Webhook-based interactions |
| Always-on process needed | Serverless-first design |
| Complex scaling | Auto-scales with requests |
| Heavy dependency (~45MB) | Lightweight (~50KB) |

**This is a compatibility layer optimized for edge runtimes.** It uses Discord's HTTP-based Interactions API instead of the WebSocket gateway, making it perfect for serverless deployments. The API surface matches Discord.js for familiar patterns.

## Features

### Implemented

**Slash Commands**
- `SlashCommandBuilder` with all option types
- Subcommands and subcommand groups
- Permissions and DM settings
- Autocomplete support

**Message Components**
- `ButtonBuilder` with all button styles
- `StringSelectMenuBuilder` for dropdowns
- `ActionRowBuilder` for component layouts
- `ModalBuilder` and `TextInputBuilder`

**Embeds**
- `EmbedBuilder` with full customization
- Fields, author, footer, images
- Preset helpers (success, error, warning, info)

**REST API**
- Full REST client with rate limiting
- All Discord API routes
- Automatic retries

**Webhooks**
- `WebhookClient` for sending messages
- `WebhookManager` for bot-managed webhooks
- Webhook URL parsing helpers

**Interactions**
- Signature verification
- Response builders
- Type guards for interaction types

### Not Yet Implemented

- WebSocket Gateway (by design - use webhooks)
- Voice connections
- Sharding
- Caching/collections

## Quick Start

### Install

```bash
npm install @dotdo/discord
```

### Webhook-Based Bot (Recommended)

For Cloudflare Workers and edge runtimes, use the webhook-based interaction handler:

```typescript
import {
  InteractionType,
  InteractionResponseType,
  verifyInteraction,
  createMessageResponse,
  createPongResponse,
  SlashCommandBuilder,
  REST,
  Routes,
} from '@dotdo/discord'

// Worker entry point
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Verify the request is from Discord
    const isValid = await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)
    if (!isValid) {
      return new Response('Invalid signature', { status: 401 })
    }

    const interaction = await request.json()

    // Handle Discord's ping verification
    if (interaction.type === InteractionType.Ping) {
      return Response.json(createPongResponse())
    }

    // Handle slash commands
    if (interaction.type === InteractionType.ApplicationCommand) {
      const { name } = interaction.data

      if (name === 'ping') {
        return Response.json(createMessageResponse({
          content: 'Pong!',
          flags: 64, // Ephemeral
        }))
      }

      if (name === 'hello') {
        const user = interaction.member?.user ?? interaction.user
        return Response.json(createMessageResponse({
          content: `Hello, ${user.username}!`,
        }))
      }
    }

    return new Response('Unknown interaction', { status: 400 })
  },
}
```

### Register Slash Commands

```typescript
import { REST, Routes, SlashCommandBuilder } from '@dotdo/discord'

const commands = [
  new SlashCommandBuilder()
    .setName('ping')
    .setDescription('Check if the bot is alive'),

  new SlashCommandBuilder()
    .setName('hello')
    .setDescription('Get a friendly greeting'),

  new SlashCommandBuilder()
    .setName('echo')
    .setDescription('Echo a message')
    .addStringOption(option =>
      option
        .setName('message')
        .setDescription('The message to echo')
        .setRequired(true)
    ),
]

const rest = new REST({ version: '10' }).setToken(env.DISCORD_BOT_TOKEN)

// Register globally
await rest.put(Routes.applicationCommands(env.DISCORD_CLIENT_ID), {
  body: commands.map(c => c.toJSON()),
})

// Or register to a specific guild (faster for development)
await rest.put(
  Routes.applicationGuildCommands(env.DISCORD_CLIENT_ID, env.GUILD_ID),
  { body: commands.map(c => c.toJSON()) }
)
```

## Inbound - Handling Discord Interactions

### Interaction Verification

Discord requires signature verification for all incoming interactions:

```typescript
import { verifyInteraction } from '@dotdo/discord'

export async function handleRequest(request: Request, env: Env) {
  // Verify signature using your app's public key
  const isValid = await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)

  if (!isValid) {
    return new Response('Invalid signature', { status: 401 })
  }

  // Safe to process the interaction
  const interaction = await request.json()
  // ...
}
```

### Interaction Type Guards

```typescript
import {
  isSlashCommand,
  isButtonInteraction,
  isSelectMenuInteraction,
  isModalSubmit,
  isAutocomplete,
  getOption,
  getSelectedValues,
  getModalValues,
} from '@dotdo/discord'

// Check interaction type
if (isSlashCommand(interaction)) {
  const message = getOption<string>(interaction, 'message')
  // ...
}

if (isButtonInteraction(interaction)) {
  const customId = interaction.data.custom_id
  // ...
}

if (isSelectMenuInteraction(interaction)) {
  const selected = getSelectedValues(interaction)
  // ...
}

if (isModalSubmit(interaction)) {
  const values = getModalValues(interaction)
  // ...
}
```

### Response Builders

```typescript
import {
  createMessageResponse,
  createDeferredResponse,
  createUpdateResponse,
  createModalResponse,
  createAutocompleteResponse,
  InteractionResponseBuilder,
  EmbedBuilder,
} from '@dotdo/discord'

// Simple message
return Response.json(createMessageResponse('Hello!'))

// Ephemeral message
return Response.json(createMessageResponse({
  content: 'Only you can see this',
  flags: 64,
}))

// Deferred response (for long operations)
return Response.json(createDeferredResponse(true)) // true = ephemeral

// Update existing message (for buttons/selects)
return Response.json(createUpdateResponse({
  content: 'Button clicked!',
}))

// Show a modal
return Response.json(createModalResponse({
  custom_id: 'feedback_modal',
  title: 'Submit Feedback',
  components: [/* ... */],
}))

// Autocomplete suggestions
return Response.json(createAutocompleteResponse([
  { name: 'Option 1', value: 'opt1' },
  { name: 'Option 2', value: 'opt2' },
]))

// Rich response with builder
const embed = new EmbedBuilder()
  .setTitle('Server Info')
  .setColor(0x5865F2)
  .addFields(
    { name: 'Members', value: '1,234', inline: true },
    { name: 'Created', value: '2020-01-01', inline: true }
  )

const response = new InteractionResponseBuilder()
  .setContent('Here is the info:')
  .addEmbeds(embed.toJSON())
  .setEphemeral()

return Response.json({
  type: InteractionResponseType.ChannelMessageWithSource,
  data: response.toJSON(),
})
```

## Outbound - Sending Messages

### Using Webhooks

Send messages without user interaction using webhooks:

```typescript
import { WebhookClient, EmbedBuilder } from '@dotdo/discord'

const webhook = new WebhookClient({
  id: env.WEBHOOK_ID,
  token: env.WEBHOOK_TOKEN,
})

// Simple message
await webhook.send('Hello from webhook!')

// Rich message
const embed = new EmbedBuilder()
  .setTitle('New Alert')
  .setDescription('Something happened!')
  .setColor(0xFF0000)
  .setTimestamp()

await webhook.send({
  content: 'Alert!',
  embeds: [embed.toJSON()],
  username: 'Alert Bot',
  avatar_url: 'https://example.com/alert-icon.png',
})

// Get the sent message back
const message = await webhook.sendAndWait({
  content: 'This returns the message',
})
console.log('Message ID:', message.id)
```

### Webhook URL Helpers

```typescript
import { createWebhookFromUrl, sendWebhookMessage, sendWebhookEmbed } from '@dotdo/discord'

// Create client from URL
const webhook = createWebhookFromUrl(
  'https://discord.com/api/webhooks/123456789/token-here'
)
await webhook.send('Hello!')

// One-liner for simple messages
await sendWebhookMessage(
  env.WEBHOOK_URL,
  'Quick message!'
)

// One-liner for embeds
await sendWebhookEmbed(
  env.WEBHOOK_URL,
  [embed.toJSON()],
  { username: 'Custom Name' }
)
```

### REST API for Follow-ups

After deferring a response, use the REST API to send follow-ups:

```typescript
import { REST, Routes } from '@dotdo/discord'

// In your worker, after returning a deferred response
const rest = new REST({ version: '10' }).setToken(env.DISCORD_BOT_TOKEN)

// Do your long operation...
const result = await someSlowOperation()

// Edit the original deferred response
await rest.patch(
  Routes.webhookMessage(env.DISCORD_CLIENT_ID, interaction.token, '@original'),
  {
    body: {
      content: `Done! Result: ${result}`,
    },
  }
)

// Or send a follow-up message
await rest.post(
  Routes.webhookWithToken(env.DISCORD_CLIENT_ID, interaction.token),
  {
    body: {
      content: 'Here is additional info...',
    },
  }
)
```

## Building Components

### Slash Commands

```typescript
import {
  SlashCommandBuilder,
  PermissionFlagsBits,
  ChannelType,
} from '@dotdo/discord'

const command = new SlashCommandBuilder()
  .setName('config')
  .setDescription('Configure the bot')
  .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
  .setDMPermission(false)
  .addSubcommandGroup(group =>
    group
      .setName('channels')
      .setDescription('Channel settings')
      .addSubcommand(sub =>
        sub
          .setName('set')
          .setDescription('Set a channel')
          .addChannelOption(opt =>
            opt
              .setName('channel')
              .setDescription('The channel to set')
              .addChannelTypes(ChannelType.GuildText)
              .setRequired(true)
          )
      )
  )
  .addStringOption(opt =>
    opt
      .setName('prefix')
      .setDescription('Bot prefix')
      .setMinLength(1)
      .setMaxLength(5)
      .addChoices(
        { name: '!', value: '!' },
        { name: '?', value: '?' },
        { name: '.', value: '.' }
      )
  )
```

### Buttons

```typescript
import { ActionRowBuilder, ButtonBuilder, ButtonStyle } from '@dotdo/discord'

const row = new ActionRowBuilder<ButtonBuilder>()
  .addComponents(
    new ButtonBuilder()
      .setCustomId('approve')
      .setLabel('Approve')
      .setStyle(ButtonStyle.Success)
      .setEmoji({ name: 'âœ…' }),

    new ButtonBuilder()
      .setCustomId('deny')
      .setLabel('Deny')
      .setStyle(ButtonStyle.Danger),

    new ButtonBuilder()
      .setLabel('Documentation')
      .setStyle(ButtonStyle.Link)
      .setURL('https://docs.example.com')
  )
```

### Select Menus

```typescript
import { ActionRowBuilder, StringSelectMenuBuilder } from '@dotdo/discord'

const row = new ActionRowBuilder<StringSelectMenuBuilder>()
  .addComponents(
    new StringSelectMenuBuilder()
      .setCustomId('role_select')
      .setPlaceholder('Select your roles')
      .setMinValues(1)
      .setMaxValues(3)
      .addOptions(
        { label: 'Developer', value: 'dev', description: 'Access to dev channels' },
        { label: 'Designer', value: 'design', description: 'Access to design channels' },
        { label: 'Moderator', value: 'mod', description: 'Moderation permissions' }
      )
  )
```

### Modals

```typescript
import {
  ModalBuilder,
  ActionRowBuilder,
  TextInputBuilder,
  TextInputStyle,
} from '@dotdo/discord'

const modal = new ModalBuilder()
  .setCustomId('feedback_modal')
  .setTitle('Submit Feedback')
  .addComponents(
    new ActionRowBuilder<TextInputBuilder>()
      .addComponents(
        new TextInputBuilder()
          .setCustomId('title')
          .setLabel('Title')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Brief title for your feedback')
          .setRequired(true)
          .setMaxLength(100)
      ),
    new ActionRowBuilder<TextInputBuilder>()
      .addComponents(
        new TextInputBuilder()
          .setCustomId('description')
          .setLabel('Description')
          .setStyle(TextInputStyle.Paragraph)
          .setPlaceholder('Detailed feedback...')
          .setRequired(true)
          .setMinLength(10)
          .setMaxLength(1000)
      )
  )

// Show modal in response to button click
return Response.json({
  type: InteractionResponseType.Modal,
  data: modal.toJSON(),
})
```

### Embeds

```typescript
import {
  EmbedBuilder,
  EmbedColors,
  createSuccessEmbed,
  createErrorEmbed,
  createWarningEmbed,
  createInfoEmbed,
} from '@dotdo/discord'

const embed = new EmbedBuilder()
  .setTitle('Welcome to the Server!')
  .setURL('https://example.com')
  .setDescription('Thanks for joining our community.')
  .setColor(EmbedColors.Blurple)
  .setAuthor({
    name: 'Server Bot',
    iconURL: 'https://example.com/bot.png',
    url: 'https://example.com',
  })
  .setThumbnail('https://example.com/thumb.png')
  .setImage('https://example.com/banner.png')
  .addFields(
    { name: 'Rules', value: 'Read #rules', inline: true },
    { name: 'Help', value: 'Ask in #support', inline: true },
    { name: '\u200B', value: '\u200B' }, // Empty field for spacing
    { name: 'Getting Started', value: 'Check out our guide below!' }
  )
  .setFooter({ text: 'Powered by dotdo', iconURL: 'https://example.com/icon.png' })
  .setTimestamp()

// Preset embeds for common cases (require title and description)
const success = createSuccessEmbed('Success', 'Operation completed!')
const error = createErrorEmbed('Error', 'Something went wrong')
const warning = createWarningEmbed('Warning', 'Be careful!')
const info = createInfoEmbed('Info', 'Here is some information')
```

## API Reference

### REST Client

```typescript
import { REST, Routes, DiscordError } from '@dotdo/discord'

const rest = new REST({
  version: '10',        // API version (default: '10')
  timeout: 30000,       // Request timeout ms (default: 30000)
  retries: 3,           // Rate limit retries (default: 3)
}).setToken(env.DISCORD_BOT_TOKEN)

// HTTP methods
const user = await rest.get<User>(Routes.user('123456789'))
await rest.post(Routes.channelMessages('123'), { body: { content: 'Hi' } })
await rest.put(Routes.applicationCommands(clientId), { body: commands })
await rest.patch(Routes.guildMember(guildId, userId), { body: { nick: 'New Name' } })
await rest.delete(Routes.channelMessage(channelId, messageId))

// Error handling
try {
  await rest.get(Routes.user('invalid'))
} catch (error) {
  if (error instanceof DiscordError) {
    console.log('Code:', error.code)       // Discord error code
    console.log('Status:', error.status)   // HTTP status
    console.log('Message:', error.message) // Error message
  }
}
```

### Routes

```typescript
import { Routes } from '@dotdo/discord'

// Users
Routes.user(userId)
Routes.userMe()

// Channels
Routes.channel(channelId)
Routes.channelMessages(channelId)
Routes.channelMessage(channelId, messageId)
Routes.channelWebhooks(channelId)

// Guilds
Routes.guild(guildId)
Routes.guildMembers(guildId)
Routes.guildMember(guildId, userId)
Routes.guildRoles(guildId)

// Commands
Routes.applicationCommands(appId)
Routes.applicationGuildCommands(appId, guildId)

// Interactions
Routes.interactionCallback(interactionId, token)

// Webhooks
Routes.webhook(webhookId)
Routes.webhookWithToken(webhookId, token)
Routes.webhookMessage(webhookId, token, messageId)
```

### Type Reference

```typescript
import type {
  // Users & Members
  User,
  GuildMember,
  Role,

  // Channels & Guilds
  Channel,
  Guild,

  // Messages
  Message,
  Embed,
  EmbedField,
  Attachment,
  Component,

  // Interactions
  Interaction,
  InteractionData,
  CommandInteraction,
  ButtonInteraction,
  SelectMenuInteraction,
  ModalSubmitInteraction,

  // Webhooks
  Webhook,
  WebhookPayload,

  // Options
  ClientOptions,
  RESTOptions,
  RequestOptions,
} from '@dotdo/discord'
```

## Complete Worker Example

```typescript
import {
  InteractionType,
  InteractionResponseType,
  verifyInteraction,
  createMessageResponse,
  createPongResponse,
  createDeferredResponse,
  isSlashCommand,
  isButtonInteraction,
  getOption,
  REST,
  Routes,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
} from '@dotdo/discord'

interface Env {
  DISCORD_PUBLIC_KEY: string
  DISCORD_BOT_TOKEN: string
  DISCORD_CLIENT_ID: string
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Only accept POST requests
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 })
    }

    // Verify signature
    const isValid = await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)
    if (!isValid) {
      return new Response('Invalid signature', { status: 401 })
    }

    const interaction = await request.json()

    // Handle ping
    if (interaction.type === InteractionType.Ping) {
      return Response.json(createPongResponse())
    }

    // Handle slash commands
    if (isSlashCommand(interaction)) {
      switch (interaction.data.name) {
        case 'ping':
          return Response.json(createMessageResponse({
            content: `Pong! Latency: ${Date.now() - new Date(interaction.id).getTime()}ms`,
          }))

        case 'info':
          const embed = new EmbedBuilder()
            .setTitle('Bot Information')
            .setColor(0x5865F2)
            .addFields(
              { name: 'Runtime', value: 'Cloudflare Workers', inline: true },
              { name: 'SDK', value: '@dotdo/discord', inline: true }
            )
            .setTimestamp()

          const row = new ActionRowBuilder<ButtonBuilder>()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('refresh')
                .setLabel('Refresh')
                .setStyle(ButtonStyle.Primary)
            )

          return Response.json(createMessageResponse({
            embeds: [embed.toJSON()],
            components: [row.toJSON()],
          }))

        case 'slow':
          // Defer for long operations
          ctx.waitUntil(handleSlowCommand(interaction, env))
          return Response.json(createDeferredResponse())
      }
    }

    // Handle button clicks
    if (isButtonInteraction(interaction)) {
      if (interaction.data.custom_id === 'refresh') {
        return Response.json({
          type: InteractionResponseType.UpdateMessage,
          data: {
            content: `Refreshed at ${new Date().toISOString()}`,
          },
        })
      }
    }

    return new Response('Unknown interaction', { status: 400 })
  },
}

async function handleSlowCommand(interaction: any, env: Env) {
  // Simulate slow operation
  await new Promise(r => setTimeout(r, 3000))

  const rest = new REST().setToken(env.DISCORD_BOT_TOKEN)

  await rest.patch(
    Routes.webhookMessage(env.DISCORD_CLIENT_ID, interaction.token, '@original'),
    {
      body: {
        content: 'Slow operation completed!',
      },
    }
  )
}
```

## Migration from Discord.js

### Package Change

```bash
# Remove
npm uninstall discord.js

# Install
npm install @dotdo/discord
```

### Import Changes

```typescript
// Before
import { Client, REST, Routes, SlashCommandBuilder } from 'discord.js'

// After
import { Client, REST, Routes, SlashCommandBuilder } from '@dotdo/discord'
```

### Architecture Change

Discord.js uses a persistent WebSocket connection. For edge runtimes, switch to webhook-based interactions:

```typescript
// Before: discord.js with gateway
const client = new Client({ intents: [...] })

client.on('interactionCreate', async (interaction) => {
  if (interaction.isChatInputCommand()) {
    await interaction.reply('Pong!')
  }
})

await client.login(token)

// After: @dotdo/discord with webhooks
export default {
  async fetch(request: Request, env: Env) {
    if (!await verifyInteraction(request, env.DISCORD_PUBLIC_KEY)) {
      return new Response('Unauthorized', { status: 401 })
    }

    const interaction = await request.json()

    if (interaction.type === InteractionType.ApplicationCommand) {
      return Response.json(createMessageResponse('Pong!'))
    }
  },
}
```

## Related

- [Pusher Integration](/docs/integrations/pusher) - Real-time messaging
- [SendGrid Integration](/docs/integrations/sendgrid) - Email notifications
- [Compat SDKs](/docs/compat) - All API-compatible SDKs
