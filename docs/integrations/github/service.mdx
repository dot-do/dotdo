---
title: github.do
description: GitHub on the Edge — A fully managed GitHub integration platform running on Cloudflare Workers with webhook routing, App hosting, and workflow automation.
---

# github.do

**GitHub on the Edge** — A managed GitHub integration platform that runs entirely on Cloudflare Workers, with native webhook handling, GitHub App hosting, and automated workflows.

```typescript
import { GitHubApp } from 'github.do'

export default GitHubApp({
  on: {
    'push': async (ctx) => {
      console.log('Push to:', ctx.payload.ref)
    },
    'pull_request.opened': async (ctx) => {
      await ctx.github.issues.addLabels(['needs-review'])
      await ctx.github.pulls.requestReviewers(['lead-dev'])
    },
    'issues.opened': async (ctx) => {
      await ctx.github.issues.createComment('Thanks for opening this issue!')
    },
  },
})
```

<Callout type="info">
Looking for Octokit compatibility? See [@dotdo/github](/docs/integrations/github/package) for a drop-in Octokit replacement.
</Callout>

## Why github.do?

Traditional GitHub integrations require managing webhooks, OAuth flows, and App authentication. github.do eliminates all of that by providing a managed platform on Cloudflare's edge network:

- **Zero Infrastructure** — No servers to manage, no webhook endpoints to configure
- **Global by Default** — Handlers run at the edge, close to GitHub's servers
- **GitHub App Hosting** — Managed App installation, authentication, and token refresh
- **Declarative Webhooks** — Event handlers with automatic signature verification
- **Durable Workflows** — Long-running automations with retries and state management
- **Serverless Economics** — Pay only for what you use, scale to zero

## Features

### Core Platform

| Feature | Description |
|---------|-------------|
| **GitHub App Hosting** | Managed App installation, private key storage, JWT authentication |
| **Webhook Routing** | Declarative event handlers with automatic signature verification |
| **OAuth Flow** | Built-in OAuth for user authorization with token management |
| **REST API Client** | Full GitHub API coverage with automatic rate limiting |
| **Installation Tokens** | Automatic token generation and refresh for App installations |

### Automation

| Feature | Description |
|---------|-------------|
| **Workflow Triggers** | Trigger GitHub Actions workflows with durable retries |
| **Auto-Labeling** | Rule-based issue and PR labeling |
| **Auto-Review** | Automatic reviewer assignment based on file paths |
| **Status Checks** | Create and update commit status checks |
| **Deployments** | Create deployment events and status updates |

### Connectivity

| Feature | Description |
|---------|-------------|
| **Webhook Handlers** | Typed event handlers for all GitHub events |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |
| **Scheduled Jobs** | Cron-based repository automation |
| **Real-time Sync** | Bidirectional sync with GitHub repositories |

## Installation

```bash
npm install github.do
```

## Quick Start

### Deploy a GitHub App

```typescript
// src/index.ts
import { GitHubApp } from 'github.do'

export default GitHubApp({
  // Event handlers
  on: {
    'installation.created': async (ctx) => {
      console.log('App installed on:', ctx.payload.installation.account.login)
    },

    'push': async (ctx) => {
      const { ref, commits, repository } = ctx.payload
      console.log(`Push to ${ref} with ${commits.length} commits`)

      // Trigger a workflow
      await ctx.github.actions.createWorkflowDispatch({
        workflow_id: 'ci.yml',
        ref: 'main',
      })
    },

    'pull_request.opened': async (ctx) => {
      const { pull_request } = ctx.payload

      // Add labels based on files
      const files = await ctx.github.pulls.listFiles(pull_request.number)
      const labels = inferLabels(files)

      await ctx.github.issues.addLabels(pull_request.number, labels)

      // Request reviewers
      await ctx.github.pulls.requestReviewers(pull_request.number, {
        reviewers: ['lead-dev'],
      })

      // Post a comment
      await ctx.github.issues.createComment(pull_request.number,
        `Thanks for the PR! A reviewer has been assigned.`
      )
    },

    'issues.opened': async (ctx) => {
      const { issue } = ctx.payload

      // Auto-label based on title
      if (issue.title.toLowerCase().includes('bug')) {
        await ctx.github.issues.addLabels(issue.number, ['bug', 'triage'])
      }
    },
  },
})
```

### Wrangler Configuration

```jsonc
// wrangler.jsonc
{
  "name": "my-github-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "vars": {
    "GITHUB_APP_ID": "123456",
    "GITHUB_WEBHOOK_SECRET": "your-webhook-secret"
  },
  "secrets": ["GITHUB_PRIVATE_KEY"]
}
```

### Deploy

```bash
# Set the private key secret
npx wrangler secret put GITHUB_PRIVATE_KEY

# Deploy
npx wrangler deploy
```

## Examples

### Auto-Review Assignment

Automatically assign reviewers based on file paths:

```typescript
import { GitHubApp } from 'github.do'

const CODEOWNERS = {
  'packages/api/': ['api-team'],
  'packages/ui/': ['frontend-team'],
  'packages/db/': ['database-team'],
  'docs/': ['docs-team'],
}

export default GitHubApp({
  on: {
    'pull_request.opened': async (ctx) => {
      const { pull_request } = ctx.payload

      const files = await ctx.github.pulls.listFiles(pull_request.number)
      const reviewers = new Set<string>()

      for (const file of files) {
        for (const [path, owners] of Object.entries(CODEOWNERS)) {
          if (file.filename.startsWith(path)) {
            owners.forEach(r => reviewers.add(r))
          }
        }
      }

      if (reviewers.size > 0) {
        await ctx.github.pulls.requestReviewers(pull_request.number, {
          team_reviewers: [...reviewers],
        })
      }
    },
  },
})
```

### CI/CD Status Checks

Create status checks for external CI/CD:

```typescript
import { GitHubApp } from 'github.do'

export default GitHubApp({
  on: {
    'push': async (ctx) => {
      const { after: sha, repository } = ctx.payload

      // Create pending status
      await ctx.github.repos.createCommitStatus(sha, {
        state: 'pending',
        context: 'deploy/staging',
        description: 'Deployment in progress...',
      })

      try {
        // Trigger deployment (e.g., to Cloudflare Workers)
        await deployToStaging(repository.name, sha)

        // Update to success
        await ctx.github.repos.createCommitStatus(sha, {
          state: 'success',
          context: 'deploy/staging',
          description: 'Deployed successfully',
          target_url: `https://staging.example.com`,
        })
      } catch (error) {
        // Update to failure
        await ctx.github.repos.createCommitStatus(sha, {
          state: 'failure',
          context: 'deploy/staging',
          description: `Deployment failed: ${error.message}`,
        })
      }
    },
  },
})
```

### Release Automation

Automate releases based on tags:

```typescript
import { GitHubApp } from 'github.do'

export default GitHubApp({
  on: {
    'push': async (ctx) => {
      const { ref, repository } = ctx.payload

      // Only handle version tags
      if (!ref.startsWith('refs/tags/v')) return

      const version = ref.replace('refs/tags/', '')

      // Create GitHub release
      await ctx.github.repos.createRelease({
        tag_name: version,
        name: `Release ${version}`,
        body: await generateChangelog(version),
        draft: false,
        prerelease: version.includes('-'),
      })

      // Trigger npm publish workflow
      await ctx.github.actions.createWorkflowDispatch({
        workflow_id: 'publish.yml',
        ref: 'main',
        inputs: { version },
      })
    },
  },
})
```

### Issue Triage Bot

Automatic issue triage and routing:

```typescript
import { GitHubApp } from 'github.do'

const LABEL_RULES = [
  { pattern: /bug|broken|error|crash/i, label: 'bug' },
  { pattern: /feature|enhancement|request/i, label: 'enhancement' },
  { pattern: /docs|documentation|typo/i, label: 'documentation' },
  { pattern: /question|help|how to/i, label: 'question' },
]

export default GitHubApp({
  on: {
    'issues.opened': async (ctx) => {
      const { issue } = ctx.payload
      const text = `${issue.title} ${issue.body}`

      // Auto-label
      const labels = LABEL_RULES
        .filter(rule => rule.pattern.test(text))
        .map(rule => rule.label)

      if (labels.length > 0) {
        await ctx.github.issues.addLabels(issue.number, labels)
      }

      // Add triage label if no labels matched
      if (labels.length === 0) {
        await ctx.github.issues.addLabels(issue.number, ['needs-triage'])
      }

      // Welcome message for first-time contributors
      const isFirstIssue = await ctx.github.issues.isFirstTimeContributor(issue.user.login)
      if (isFirstIssue) {
        await ctx.github.issues.createComment(issue.number,
          `Thanks for opening your first issue, @${issue.user.login}! ` +
          `We'll review it shortly.`
        )
      }
    },

    'issues.labeled': async (ctx) => {
      const { issue, label } = ctx.payload

      // Route high-priority issues
      if (label.name === 'priority-high') {
        await ctx.github.issues.addAssignees(issue.number, ['oncall-engineer'])
      }
    },
  },
})
```

### Scheduled Repository Maintenance

Run scheduled jobs for repository maintenance:

```typescript
import { GitHubApp, scheduled } from 'github.do'

export default GitHubApp({
  on: {
    // Regular event handlers
    'issues.opened': async (ctx) => { /* ... */ },
  },

  // Scheduled jobs
  scheduled: {
    // Close stale issues every day at midnight
    '0 0 * * *': async (ctx) => {
      const staleIssues = await ctx.github.issues.list({
        state: 'open',
        labels: 'stale',
        per_page: 100,
      })

      for (const issue of staleIssues) {
        await ctx.github.issues.createComment(issue.number,
          'This issue has been automatically closed due to inactivity.'
        )
        await ctx.github.issues.update(issue.number, { state: 'closed' })
      }
    },

    // Mark issues as stale after 30 days
    '0 1 * * *': async (ctx) => {
      const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)

      const oldIssues = await ctx.github.issues.list({
        state: 'open',
        since: cutoff.toISOString(),
        per_page: 100,
      })

      for (const issue of oldIssues) {
        if (new Date(issue.updated_at) < cutoff) {
          await ctx.github.issues.addLabels(issue.number, ['stale'])
        }
      }
    },
  },
})
```

## Architecture

```
+-----------------------------------------------------------------------+
|                        Client Applications                             |
+---------------+---------------+---------------+-----------------------+
|   GitHub      |   Webhooks    |   OAuth       |  Scheduled Jobs       |
|   REST API    |   (Events)    |   (Users)     |  (Cron)               |
+---------------+---------------+---------------+-----------------------+
|                         github.do Worker (Edge)                        |
+-----------------------------------------------------------------------+
|  Event Router  |  App Auth   |  Token Cache  |  Rate Limiter          |
+-----------------------------------------------------------------------+
|                      Durable Objects (State)                           |
+-------------------+---------------------------------------------------+
|     KV            |           Secrets                                  |
|  (Token Cache)    |    (Private Keys, Webhook Secrets)                 |
+-------------------+---------------------------------------------------+
```

github.do handles the complexity of GitHub App authentication:

1. **Webhook Verification** — Automatic signature verification for all incoming webhooks
2. **JWT Generation** — Creates JWTs signed with your App's private key
3. **Installation Tokens** — Generates and caches installation access tokens
4. **Rate Limiting** — Automatic handling of GitHub's rate limits with retries
5. **Token Refresh** — Automatically refreshes tokens before expiration

## Configuration

### Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `GITHUB_APP_ID` | Yes | Your GitHub App ID |
| `GITHUB_PRIVATE_KEY` | Yes | Your App's private key (PEM format) |
| `GITHUB_WEBHOOK_SECRET` | Yes | Webhook secret for signature verification |
| `GITHUB_CLIENT_ID` | For OAuth | OAuth App client ID |
| `GITHUB_CLIENT_SECRET` | For OAuth | OAuth App client secret |

### With OAuth

```jsonc
{
  "vars": {
    "GITHUB_APP_ID": "123456",
    "GITHUB_CLIENT_ID": "Iv1.abc123",
    "GITHUB_WEBHOOK_SECRET": "your-webhook-secret"
  },
  "secrets": ["GITHUB_PRIVATE_KEY", "GITHUB_CLIENT_SECRET"]
}
```

### OAuth Flow

```typescript
import { GitHubApp, oauth } from 'github.do'

export default GitHubApp({
  oauth: {
    // OAuth callback handler
    callback: async (ctx) => {
      const { access_token, token_type } = ctx.tokens
      const user = await ctx.github.users.getAuthenticated()

      // Store user session
      await ctx.session.set('user', user)

      return Response.redirect('/dashboard')
    },

    // Scopes to request
    scopes: ['repo', 'read:user'],
  },

  on: {
    // Webhook handlers...
  },
})
```

## API Reference

### GitHubApp Factory

```typescript
import { GitHubApp } from 'github.do'

export default GitHubApp({
  on: { /* event handlers */ },
  scheduled: { /* cron handlers */ },
  oauth: { /* OAuth config */ },
})
```

### Event Context

Event handlers receive a context object with:

```typescript
interface GitHubContext {
  // The webhook event payload
  payload: WebhookPayload

  // Pre-authenticated GitHub client for the installation
  github: GitHubClient

  // Installation details
  installation: Installation

  // Repository details (if applicable)
  repository?: Repository

  // Event metadata
  event: string
  action?: string
  deliveryId: string

  // Environment bindings
  env: Env
}
```

### GitHub Client

The `ctx.github` client provides typed methods for all GitHub APIs:

```typescript
// Repositories
await ctx.github.repos.get()
await ctx.github.repos.update({ description: 'Updated' })
await ctx.github.repos.createCommitStatus(sha, { state: 'success' })

// Issues
await ctx.github.issues.list({ state: 'open' })
await ctx.github.issues.create({ title: 'Bug', body: '...' })
await ctx.github.issues.addLabels(number, ['bug'])
await ctx.github.issues.createComment(number, 'Comment text')

// Pull Requests
await ctx.github.pulls.list({ state: 'open' })
await ctx.github.pulls.create({ title: 'PR', head: 'feature', base: 'main' })
await ctx.github.pulls.requestReviewers(number, { reviewers: ['user'] })
await ctx.github.pulls.merge(number, { merge_method: 'squash' })

// Actions
await ctx.github.actions.createWorkflowDispatch({ workflow_id: 'ci.yml', ref: 'main' })
await ctx.github.actions.listWorkflowRuns({ workflow_id: 'ci.yml' })
```

### Webhook Events

All GitHub webhook events are supported with typed payloads:

| Event | Actions |
|-------|---------|
| `push` | - |
| `pull_request` | `opened`, `closed`, `synchronize`, `reopened`, `edited`, etc. |
| `issues` | `opened`, `closed`, `edited`, `labeled`, `assigned`, etc. |
| `issue_comment` | `created`, `edited`, `deleted` |
| `workflow_run` | `requested`, `in_progress`, `completed` |
| `check_run` | `created`, `completed`, `rerequested` |
| `release` | `created`, `published`, `released` |
| `installation` | `created`, `deleted`, `suspend`, `unsuspend` |
| `*` | Catch-all for any event |

## Development

```bash
# Install dependencies
npm install

# Run locally with wrangler
npm run dev

# Test with ngrok for webhooks
ngrok http 8787

# Deploy to Cloudflare
npm run deploy
```

### Local Testing

Use the GitHub webhook simulator for local testing:

```bash
# Simulate a push event
curl -X POST http://localhost:8787/webhooks/github \
  -H "Content-Type: application/json" \
  -H "X-GitHub-Event: push" \
  -H "X-Hub-Signature-256: sha256=..." \
  -d '{"ref": "refs/heads/main", ...}'
```

## Related

- [@dotdo/github](/docs/integrations/github/package) - Octokit-compatible package
- [Events Overview](/docs/events) - Event handling patterns
- [Workflows](/docs/workflows) - Durable workflow automation
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
