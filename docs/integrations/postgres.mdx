---
title: PostgreSQL Integration
description: Drop-in replacement for pg (node-postgres) backed by Durable Objects, plus EdgePostgres for full Postgres with pgvector on the edge.
---

# PostgreSQL Integration

Two complementary Postgres solutions for Cloudflare Workers:

1. **@dotdo/postgres** - Drop-in `pg` replacement backed by DO SQLite. Same API, your code works unchanged.
2. **@dotdo/edge-postgres** - Full Postgres (PGLite WASM) with pgvector, checkpointing, and vector quantization.

```typescript
// Option 1: pg-compatible (simple)
import { Client } from '@dotdo/postgres'

const client = new Client('postgres://localhost/mydb')
await client.connect()
const { rows } = await client.query('SELECT * FROM users WHERE id = $1', [1])
await client.end()

// Option 2: EdgePostgres (full Postgres + pgvector)
import { EdgePostgres } from '@dotdo/edge-postgres'

const db = new EdgePostgres(ctx, env, {
  pglite: { extensions: ['pgvector'] }
})

const similar = await db.query(`
  SELECT id, embedding <=> $1 AS distance
  FROM documents
  ORDER BY distance LIMIT 10
`, [queryEmbedding])
```

## Why @dotdo/postgres?

| pg (Node.js) | @dotdo/postgres | @dotdo/edge-postgres |
|--------------|-----------------|----------------------|
| Requires Node.js | Works in Workers | Works in Workers |
| External Postgres server | Backed by DO SQLite | Full Postgres (PGLite WASM) |
| Network latency | Edge-local | Edge-local |
| pgvector support | No | Yes |

## Quick Start

### Install

```bash
# pg-compatible layer
npm install @dotdo/postgres

# Full EdgePostgres
npm install @dotdo/edge-postgres
```

### pg-Compatible Client

```typescript
import { Client, Pool } from '@dotdo/postgres'

// Simple client
const client = new Client({
  host: 'localhost',
  database: 'mydb',
  user: 'postgres',
  password: 'secret',
})

await client.connect()

// Parameterized query
const { rows } = await client.query(
  'SELECT * FROM users WHERE id = $1',
  [1]
)

// INSERT with RETURNING
const { rows: newUser } = await client.query(
  'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
  ['Alice', 'alice@example.com']
)

await client.end()
```

### Connection Pool

```typescript
import { Pool } from '@dotdo/postgres'

const pool = new Pool({
  connectionString: 'postgres://user:pass@localhost/mydb',
  max: 20,
  idleTimeoutMillis: 30000,
})

// Simple query (auto-checkout)
const { rows } = await pool.query('SELECT * FROM users')

// Manual checkout for transactions
const client = await pool.connect()
try {
  await client.query('BEGIN')
  await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1])
  await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2])
  await client.query('COMMIT')
} catch (e) {
  await client.query('ROLLBACK')
  throw e
} finally {
  client.release()
}

await pool.end()
```

## Inbound (Drop-in Replacement)

Your existing `pg` code works unchanged - just swap the import:

```typescript
// Before
import { Client, Pool } from 'pg'

// After
import { Client, Pool } from '@dotdo/postgres'

// Code stays exactly the same
const client = new Client()
await client.connect()
const result = await client.query('SELECT $1::text as message', ['Hello'])
console.log(result.rows[0].message) // Hello
```

### ORMs and Query Builders

```typescript
// Drizzle ORM
import { drizzle } from 'drizzle-orm/node-postgres'
import { Pool } from '@dotdo/postgres'

const pool = new Pool({ connectionString: process.env.DATABASE_URL })
const db = drizzle(pool)

// Kysely
import { Kysely, PostgresDialect } from 'kysely'
import { Pool } from '@dotdo/postgres'

const db = new Kysely({
  dialect: new PostgresDialect({
    pool: new Pool({ connectionString: process.env.DATABASE_URL }),
  }),
})
```

## Transactions

```typescript
import { Client } from '@dotdo/postgres'

const client = new Client()
await client.connect()

// Standard transaction
await client.query('BEGIN')
try {
  await client.query('INSERT INTO orders (user_id, total) VALUES ($1, $2)', [1, 99.99])
  await client.query('UPDATE inventory SET count = count - 1 WHERE product_id = $1', [42])
  await client.query('COMMIT')
} catch (e) {
  await client.query('ROLLBACK')
  throw e
}

await client.end()
```

## Error Handling

```typescript
import { Client, DatabaseError, ConnectionError } from '@dotdo/postgres'

const client = new Client()
await client.connect()

try {
  await client.query('SELECT * FROM nonexistent_table')
} catch (e) {
  if (e instanceof DatabaseError) {
    console.log('SQLSTATE:', e.code)      // '42P01' (undefined_table)
    console.log('Severity:', e.severity)   // 'ERROR'
    console.log('Message:', e.message)
  }
}

// Common SQLSTATE codes
// 23505 - unique_violation (duplicate key)
// 42P01 - undefined_table (table not found)
// 42P07 - duplicate_table (table already exists)
// 42601 - syntax_error (SQL syntax error)
// 23502 - not_null_violation
```

## Type Constants

```typescript
import { types } from '@dotdo/postgres'

types.BOOL      // 16
types.INT2      // 21
types.INT4      // 23
types.INT8      // 20
types.FLOAT4    // 700
types.FLOAT8    // 701
types.TEXT      // 25
types.VARCHAR   // 1043
types.JSON      // 114
types.JSONB     // 3802
types.UUID      // 2950
types.DATE      // 1082
types.TIME      // 1083
types.TIMESTAMP // 1114
types.NUMERIC   // 1700
```

## Utilities

```typescript
// Escape strings for SQL
client.escapeLiteral("it's a test")     // "'it''s a test'"
client.escapeIdentifier('column"name')  // '"column""name"'

// Native bindings (simulated)
import { native } from '@dotdo/postgres'
const { Client, Pool } = native()
```

---

## EdgePostgres (Full Postgres on Edge)

For AI agents, semantic search, and complex queries, use EdgePostgres - full Postgres with pgvector running in Durable Objects via PGLite WASM.

### Basic Usage

```typescript
import { EdgePostgres } from '@dotdo/edge-postgres'

class MyAgent extends DurableObject {
  db = new EdgePostgres(this.ctx, this.env)

  async setup() {
    await this.db.exec(`
      CREATE TABLE documents (
        id TEXT PRIMARY KEY,
        content TEXT,
        embedding vector(1536)
      );

      CREATE INDEX ON documents
      USING hnsw (embedding vector_cosine_ops);
    `)
  }

  async remember(content: string, embedding: number[]) {
    await this.db.query(
      'INSERT INTO documents (id, content, embedding) VALUES ($1, $2, $3)',
      [crypto.randomUUID(), content, embedding]
    )
  }

  async recall(queryEmbedding: number[], limit = 5) {
    return this.db.query(`
      SELECT content, 1 - (embedding <=> $1) AS similarity
      FROM documents
      ORDER BY embedding <=> $1
      LIMIT $2
    `, [queryEmbedding, limit])
  }
}
```

### Vector Search with pgvector

```typescript
const db = new EdgePostgres(ctx, env, {
  pglite: { extensions: ['pgvector'] }
})

// Create table with vector column
await db.exec(`
  CREATE EXTENSION IF NOT EXISTS vector;

  CREATE TABLE documents (
    id TEXT PRIMARY KEY,
    content TEXT,
    embedding vector(1536)
  );

  CREATE INDEX ON documents
  USING hnsw (embedding vector_cosine_ops);
`)

// Insert with embedding
await db.query(
  'INSERT INTO documents VALUES ($1, $2, $3)',
  ['doc-1', 'Hello world', embedding]
)

// Semantic search (cosine similarity)
const results = await db.query(`
  SELECT id, content, 1 - (embedding <=> $1) AS similarity
  FROM documents
  ORDER BY embedding <=> $1
  LIMIT 10
`, [queryEmbedding])

// L2 distance search
const nearest = await db.query(`
  SELECT id, embedding <-> $1 AS distance
  FROM documents
  ORDER BY distance
  LIMIT 5
`, [queryEmbedding])
```

### Transactions

```typescript
await db.transaction(async (tx) => {
  await tx.query(
    'UPDATE accounts SET balance = balance - $1 WHERE id = $2',
    [100, 'acc-1']
  )
  await tx.query(
    'UPDATE accounts SET balance = balance + $1 WHERE id = $2',
    [100, 'acc-2']
  )
  // Automatically committed if no error
  // Automatically rolled back on error
})
```

### Checkpointing

Save database state to durable storage for crash recovery.

```typescript
const db = new EdgePostgres(ctx, env)

// Make changes
await db.query('INSERT INTO users VALUES ($1, $2)', ['user-1', 'Alice'])

// Checkpoint (state is now durable)
await db.checkpoint()

// On cold start, state is restored from checkpoint
```

### Query Options

```typescript
// Query with timeout
const result = await db.query(
  'SELECT * FROM large_table',
  [],
  { timeout: 5000 }  // 5 second timeout
)

// Query with session token for consistency
const result = await db.query(
  'SELECT * FROM users WHERE id = $1',
  [id],
  { sessionToken: previousResult.sessionToken }
)
```

### Vector Quantization (Memory Optimization)

4x memory reduction with scalar (int8) quantization.

```typescript
const db = new EdgePostgres(ctx, env, {
  quantization: {
    type: 'scalar',        // int8 quantization (4x compression)
    storeOriginal: false,  // Don't keep float32 copies
    calibrationSamples: 1000,
  }
})

// Calibrate from existing vectors
const stats = await db.calibrateQuantization('documents', 'embedding', 1000)
console.log(`Compression: ${stats.compressionRatio}x`)
console.log(`Memory saved: ${stats.savingsPercent}%`)

// Get memory stats
const memory = await db.getVectorMemoryStats('documents', 'embedding')
console.log(`Original: ${memory.originalBytes} bytes`)
console.log(`Quantized: ${memory.quantizedBytes} bytes`)
```

### HNSW Index Tracking

Track HNSW index creation for persistence across restarts.

```typescript
// Create index
await db.exec(`CREATE INDEX idx ON docs USING hnsw (embedding vector_cosine_ops)`)

// Track for persistence
await db.trackHNSWIndex('docs', 'idx', 'embedding', {
  metric: 'cosine',
  m: 16,
  efConstruction: 64
})

// Get tracked indexes
const indexes = db.getHNSWIndexes()
```

### Hybrid Search Analysis

Analyze queries combining vector search with SQL filters.

```typescript
const db = new EdgePostgres(ctx, env, {
  hybridSearch: {
    strategy: 'auto',           // 'pre-filter', 'post-filter', 'parallel'
    selectivityThreshold: 0.1,
    maxCandidates: 1000,
  }
})

// Analyze hybrid query
const analysis = db.analyzeHybridQuery(`
  SELECT * FROM documents
  WHERE category = 'tech'
  ORDER BY embedding <=> $1
  LIMIT 10
`)

console.log(analysis.recommendedStrategy) // 'pre-filter'
console.log(analysis.reason)              // 'Low selectivity - pre-filter to reduce vector scan'
```

## EdgePostgres Configuration

```typescript
interface EdgePostgresConfig {
  // PGLite WASM configuration
  pglite?: {
    extensions?: string[]  // e.g., ['pgvector']
    initialMemory?: number // Initial WASM memory in bytes
  }

  // Vector quantization for memory optimization
  quantization?: {
    type: 'scalar' | 'binary' | 'none'
    storeOriginal?: boolean
    calibrationSamples?: number
  }

  // Hybrid search optimization
  hybridSearch?: {
    strategy: 'auto' | 'pre-filter' | 'post-filter' | 'parallel'
    selectivityThreshold?: number
    maxCandidates?: number
  }
}
```

## API Comparison

### @dotdo/postgres vs pg

| Feature | @dotdo/postgres | pg |
|---------|-----------------|-----|
| Client API | Yes | Yes |
| Pool API | Yes | Yes |
| Parameterized queries | Yes | Yes |
| Transactions | Yes | Yes |
| Connection events | Yes | Yes |
| COPY commands | No | Yes |
| Cursors | Partial | Yes |
| Pub/Sub (LISTEN/NOTIFY) | No | Yes |
| SSL/TLS | N/A (internal) | Yes |
| Native bindings | Simulated | Yes |

### EdgePostgres Features

| Feature | DO SQLite | EdgePostgres |
|---------|-----------|--------------|
| Vector search | No | Yes (pgvector) |
| JSON operators | Basic | Full (`->`, `->>`, `@>`) |
| Full-text search | FTS5 | Yes |
| Postgres ecosystem | No | Yes |

## Memory Budget

128MB Workers limit breakdown for EdgePostgres:

```
V8 Isolate              ~15MB
PGLite WASM              ~3MB
PGLite heap             ~20MB  (configurable)
pgvector HNSW           ~10MB  (per 100K vectors)
Query buffers           ~10MB
----------------------------------------
Total (OLTP)            ~58MB
```

## Migration from pg

### Package Change

```bash
# Remove
npm uninstall pg @types/pg

# Install
npm install @dotdo/postgres
```

### Import Change

```typescript
// Before
import { Client, Pool } from 'pg'

// After
import { Client, Pool } from '@dotdo/postgres'

// All your existing code works unchanged
const client = new Client()
await client.connect()
const result = await client.query('SELECT $1::text as message', ['Hello'])
console.log(result.rows[0].message)
```

### Configuration Compatibility

Your existing connection configuration works unchanged:

```typescript
// Connection string (works with both)
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
})

// Object config (works with both)
const client = new Client({
  host: 'localhost',
  port: 5432,
  database: 'mydb',
  user: 'postgres',
  password: 'secret',
})
```

## Related

- [Databases Overview](/docs/compat/databases) - All database SDK implementations
- [Vector Search](/docs/compat/vector) - Semantic/embedding search
- [Hot Tier Storage](/docs/storage/hot-tier) - DO SQLite for edge queries
