---
title: nats.do
description: Edge-native NATS-compatible messaging platform on Cloudflare Workers with Durable Object SQLite storage.
---

# nats.do

**NATS on the Edge** — A NATS-compatible messaging platform that runs entirely on Cloudflare Workers, with native JetStream, KV Store, and serverless-first design.

```typescript
import { connect, StringCodec } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    const nc = await connect({ env })
    const sc = StringCodec()

    // Publish event
    nc.publish('orders.created', sc.encode(JSON.stringify({
      orderId: '123',
      amount: 99.99
    })))

    // Request/reply
    const response = await nc.request('inventory.check', sc.encode('SKU-001'), {
      timeout: 5000
    })

    return new Response(response.data)
  }
}
```

<Callout type="info">
Looking for nats.js compatibility or need to connect to real NATS servers? See [@dotdo/nats](/docs/integrations/nats/package) for a drop-in replacement.
</Callout>

## Why nats.do?

Traditional NATS requires managing servers, clusters, and TCP connections. nats.do eliminates all of that by running directly on Cloudflare's edge network:

- **Zero Infrastructure** — No NATS servers to manage, no connection limits, no cold starts
- **Global by Default** — Messages and streams live at the edge, close to your users
- **NATS Compatible** — Familiar pub/sub, request/reply, JetStream, and KV APIs
- **Serverless Native** — No TCP connections required, works in any serverless environment
- **Serverless Economics** — Pay only for what you use, scale to zero

## Features

### Core Messaging

| Feature | Description |
|---------|-------------|
| **Pub/Sub** | Publish and subscribe to subjects with wildcard support (`*`, `>`) |
| **Request/Reply** | Synchronous request/response pattern with automatic inbox generation |
| **Queue Groups** | Load-balanced message distribution across subscribers |
| **Message Headers** | Custom metadata on messages |
| **Subject Wildcards** | Pattern matching with `*` (single token) and `>` (multi-token) |

### JetStream (Persistent Messaging)

| Feature | Description |
|---------|-------------|
| **Streams** | Durable message storage with configurable retention |
| **Consumers** | Push and pull consumers with acknowledgment policies |
| **Deduplication** | Message ID-based deduplication |
| **Replay** | Replay messages from any point (beginning, sequence, time) |
| **At-Least-Once** | Guaranteed delivery with explicit acknowledgment |

### KV Store

| Feature | Description |
|---------|-------------|
| **Key-Value** | Distributed key-value store with versioning |
| **Watch** | Real-time notifications on key changes |
| **History** | Access previous revisions of keys |
| **TTL** | Time-to-live for automatic key expiration |
| **CAS** | Compare-and-swap for optimistic locking |

### Connectivity

| Feature | Description |
|---------|-------------|
| **HTTP/RPC** | JSON-RPC over HTTP with request batching |
| **WebSocket** | Persistent connections for real-time applications |
| **Service Bindings** | Zero-latency Worker-to-Worker communication |

## Installation

```bash
npm install nats.do
```

## Quick Start

### Deploy to Cloudflare Workers

```typescript
// src/index.ts
import { NatsEntrypoint, NatsPubSubDO, NatsJetStreamDO, NatsKVDO } from 'nats.do'

export { NatsPubSubDO, NatsJetStreamDO, NatsKVDO }
export default NatsEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-nats-do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [
      { "name": "NATS_PUBSUB", "class_name": "NatsPubSubDO" },
      { "name": "NATS_JETSTREAM", "class_name": "NatsJetStreamDO" },
      { "name": "NATS_KV", "class_name": "NatsKVDO" }
    ]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["NatsPubSubDO", "NatsJetStreamDO", "NatsKVDO"] }]
}
```

```bash
npx wrangler deploy
```

## Examples

### Pub/Sub Messaging

```typescript
import { connect, StringCodec } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    const nc = await connect({ env })
    const sc = StringCodec()

    // Subscribe to events
    const sub = nc.subscribe('events.>')

    // Process messages in background
    ;(async () => {
      for await (const msg of sub) {
        console.log(`[${msg.subject}]: ${sc.decode(msg.data)}`)
      }
    })()

    // Publish events
    nc.publish('events.user.signup', sc.encode(JSON.stringify({
      userId: 'user-123',
      email: 'alice@example.com'
    })))

    nc.publish('events.order.created', sc.encode(JSON.stringify({
      orderId: 'order-456',
      amount: 99.99
    })))

    return new Response('Events published')
  }
}
```

### Request/Reply Services

```typescript
import { connect, StringCodec } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    const nc = await connect({ env })
    const sc = StringCodec()

    // Register a service
    const sub = nc.subscribe('inventory.check', { queue: 'inventory-service' })

    ;(async () => {
      for await (const msg of sub) {
        const sku = sc.decode(msg.data)
        const stock = await checkInventory(sku)
        msg.respond(sc.encode(JSON.stringify({ sku, stock })))
      }
    })()

    // Call the service
    const response = await nc.request('inventory.check', sc.encode('SKU-001'), {
      timeout: 5000
    })

    const result = JSON.parse(sc.decode(response.data))
    return Response.json(result)
  }
}
```

### JetStream Persistent Messaging

```typescript
import { connect, AckPolicy, DeliverPolicy, RetentionPolicy } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    const nc = await connect({ env })
    const jsm = await nc.jetstreamManager()
    const js = nc.jetstream()

    // Create a stream
    await jsm.streams.add({
      name: 'ORDERS',
      subjects: ['orders.*'],
      retention: RetentionPolicy.Limits,
      max_msgs: 100000,
      max_bytes: 100 * 1024 * 1024 // 100MB
    })

    // Publish with acknowledgment
    const ack = await js.publish('orders.created', JSON.stringify({
      orderId: 'order-789',
      customer: 'alice@example.com',
      items: [{ sku: 'WIDGET-001', qty: 2 }]
    }))

    console.log(`Published to ${ack.stream} at sequence ${ack.seq}`)

    // Create a durable consumer
    await jsm.consumers.add('ORDERS', {
      durable_name: 'order-processor',
      ack_policy: AckPolicy.Explicit,
      deliver_policy: DeliverPolicy.All
    })

    // Consume messages
    const consumer = await js.consumers.get('ORDERS', 'order-processor')
    const messages = await consumer.fetch({ max_messages: 10 })

    for await (const msg of messages) {
      console.log(`Processing: ${msg.subject}`)
      await processOrder(msg.json())
      msg.ack()
    }

    return new Response('Orders processed')
  }
}
```

### KV Store

```typescript
import { connect, StringCodec } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    const nc = await connect({ env })
    const js = nc.jetstream()
    const sc = StringCodec()

    // Create or get KV bucket
    const kv = await js.views.kv('sessions')

    // Store session data
    const revision = await kv.put('session:user-123', sc.encode(JSON.stringify({
      userId: 'user-123',
      loggedIn: true,
      lastAccess: Date.now()
    })))

    // Read session
    const entry = await kv.get('session:user-123')
    if (entry) {
      const session = JSON.parse(sc.decode(entry.value))
      console.log('Session:', session)
    }

    // Watch for changes
    const watch = await kv.watch({ key: 'session.*' })
    ;(async () => {
      for await (const entry of watch) {
        console.log(`Session ${entry.key} ${entry.operation}`)
      }
    })()

    // Update with CAS
    try {
      await kv.update('session:user-123', sc.encode('...'), entry.revision)
    } catch (e) {
      console.log('Concurrent modification detected')
    }

    // Delete session
    await kv.delete('session:user-123')

    return new Response('KV operations complete')
  }
}
```

### Real-Time WebSocket

```typescript
import { connect, StringCodec } from 'nats.do'

export default {
  async fetch(request: Request, env: Env) {
    // Upgrade to WebSocket
    const [client, server] = Object.values(new WebSocketPair())

    server.accept()

    const nc = await connect({ env })
    const sc = StringCodec()

    // Subscribe and forward to WebSocket
    const sub = nc.subscribe('chat.*')

    ;(async () => {
      for await (const msg of sub) {
        server.send(JSON.stringify({
          subject: msg.subject,
          data: sc.decode(msg.data)
        }))
      }
    })()

    // Handle incoming WebSocket messages
    server.addEventListener('message', async (event) => {
      const { subject, data } = JSON.parse(event.data as string)
      nc.publish(subject, sc.encode(data))
    })

    server.addEventListener('close', async () => {
      await sub.unsubscribe()
      await nc.close()
    })

    return new Response(null, { status: 101, webSocket: client })
  }
}
```

## HTTP API Endpoints

nats.do exposes a REST API for external access:

### Pub/Sub Endpoints

- `POST /publish/:subject` - Publish a message
- `POST /request/:subject` - Request/reply
- `GET /subscribe/:subject` - Subscribe (SSE stream)

### JetStream Endpoints

- `POST /jetstream/streams` - Create stream
- `GET /jetstream/streams` - List streams
- `GET /jetstream/streams/:name` - Get stream info
- `DELETE /jetstream/streams/:name` - Delete stream
- `POST /jetstream/streams/:name/publish` - Publish to stream
- `POST /jetstream/streams/:name/consumers` - Create consumer
- `GET /jetstream/streams/:name/consumers/:consumer/fetch` - Fetch messages
- `POST /jetstream/streams/:name/consumers/:consumer/ack` - Acknowledge

### KV Endpoints

- `PUT /kv/:bucket/:key` - Put value
- `GET /kv/:bucket/:key` - Get value
- `DELETE /kv/:bucket/:key` - Delete key
- `GET /kv/:bucket/keys` - List keys
- `GET /kv/:bucket/:key/history` - Get key history

### Health Endpoints

- `GET /` - Service info
- `GET /health` - Health check

## Architecture

```
+---------------------------------------------------------------------+
|                       Client Applications                            |
+-------------+-------------+-------------+---------------------------+
|    HTTP     |  WebSocket  |   Service   |       nats.do SDK         |
|    RPC      |  Real-time  |   Binding   |   (Worker internal)       |
+-------------+-------------+-------------+---------------------------+
|                         nats.do Worker (Edge)                        |
+-------------+-------------------+-------------------+-----------------+
|  Pub/Sub    |    JetStream      |     KV Store      |   Router        |
|  Handler    |    Handler        |     Handler       |                 |
+-------------+-------------------+-------------------+-----------------+
|             Durable Objects (SQLite Storage)                         |
+-------------+-------------------+-------------------+-----------------+
| NatsPubSubDO | NatsJetStreamDO  |    NatsKVDO       |                 |
+-------------+-------------------+-------------------+-----------------+
```

nats.do routes NATS operations to the appropriate Durable Objects:

1. **Pub/Sub** — Ephemeral messaging via `NatsPubSubDO`
2. **JetStream** — Persistent streams via `NatsJetStreamDO` with SQLite
3. **KV Store** — Key-value operations via `NatsKVDO` with SQLite

## Configuration

### Environment Type

```typescript
interface Env {
  NATS_PUBSUB: DurableObjectNamespace
  NATS_JETSTREAM: DurableObjectNamespace
  NATS_KV: DurableObjectNamespace
}
```

### Stream Configuration

```typescript
interface StreamConfig {
  name: string                    // Stream name
  subjects: string[]              // Subject patterns
  retention?: RetentionPolicy     // limits, interest, workqueue
  max_msgs?: number               // Max messages
  max_bytes?: number              // Max bytes
  max_age?: number                // Max message age (nanoseconds)
  max_msg_size?: number           // Max message size
  discard?: DiscardPolicy         // old, new
  duplicate_window?: number       // Dedup window (nanoseconds)
}
```

### Consumer Configuration

```typescript
interface ConsumerConfig {
  durable_name?: string           // Durable consumer name
  ack_policy: AckPolicy           // none, all, explicit
  deliver_policy: DeliverPolicy   // all, last, new, by_start_sequence, by_start_time
  opt_start_seq?: number          // Start sequence (with by_start_sequence)
  opt_start_time?: string         // Start time (with by_start_time)
  filter_subject?: string         // Filter messages by subject
  max_deliver?: number            // Max delivery attempts
  ack_wait?: number               // Ack timeout (nanoseconds)
}
```

## API Reference

### Connection

```typescript
connect(options?: ConnectionOptions): Promise<NatsConnection>
```

| Option | Type | Description |
|--------|------|-------------|
| `env` | `Env` | Worker environment with DO bindings |
| `name` | `string` | Connection name for debugging |

### NatsConnection

| Method | Description |
|--------|-------------|
| `publish(subject, data?, options?)` | Publish message |
| `subscribe(subject, options?)` | Subscribe to subject |
| `request(subject, data?, options?)` | Request/reply |
| `flush()` | Flush pending messages |
| `drain()` | Drain subscriptions |
| `close()` | Close connection |
| `jetstream()` | Get JetStream client |
| `jetstreamManager()` | Get JetStream manager |

### JetStream

| Method | Description |
|--------|-------------|
| `publish(subject, data?, options?)` | Publish to stream |
| `consumers.get(stream, consumer)` | Get consumer |
| `views.kv(bucket)` | Get KV store |

### JetStreamManager

| Method | Description |
|--------|-------------|
| `streams.add(config)` | Create stream |
| `streams.update(name, config)` | Update stream |
| `streams.delete(name)` | Delete stream |
| `streams.info(name)` | Get stream info |
| `streams.list()` | List streams |
| `streams.purge(name)` | Purge messages |
| `consumers.add(stream, config)` | Create consumer |
| `consumers.delete(stream, name)` | Delete consumer |
| `consumers.info(stream, name)` | Get consumer info |
| `consumers.list(stream)` | List consumers |

### KV

| Method | Description |
|--------|-------------|
| `put(key, value)` | Store value |
| `get(key)` | Get value |
| `create(key, value)` | Create if not exists |
| `update(key, value, revision)` | Update with CAS |
| `delete(key)` | Delete key |
| `purge(key)` | Purge history |
| `keys(filter?)` | List keys |
| `watch(options?)` | Watch changes |
| `history(key)` | Get history |
| `status()` | Get bucket status |

## Use Cases

### Event-Driven Microservices

```typescript
// Order Service publishes events
nc.publish('orders.created', orderData)
nc.publish('orders.paid', paymentData)

// Notification Service subscribes
nc.subscribe('orders.>', { queue: 'notifications' })

// Inventory Service subscribes
nc.subscribe('orders.created', { queue: 'inventory' })
```

### Real-Time Collaboration

```typescript
// Document changes via JetStream
await js.publish('docs.doc-123.changes', changeData)

// Clients watch via KV
const kv = await js.views.kv('cursors')
const watch = await kv.watch({ key: 'doc-123.*' })
```

### Task Queues

```typescript
// Work queue stream
await jsm.streams.add({
  name: 'TASKS',
  subjects: ['tasks.*'],
  retention: RetentionPolicy.Workqueue
})

// Workers compete for tasks
await jsm.consumers.add('TASKS', {
  durable_name: 'workers',
  ack_policy: AckPolicy.Explicit,
  max_deliver: 3
})
```

### Session Management

```typescript
// Store sessions in KV with TTL
const kv = await js.views.kv('sessions', {
  ttl: 3600 * 1000 * 1000 * 1000 // 1 hour in nanoseconds
})

await kv.put('session:abc123', sessionData)
```

## Development

```bash
# Install dependencies
npm install

# Run locally
npm run dev

# Run tests
npm test

# Type check
npm run typecheck

# Deploy to Cloudflare
npm run deploy
```

## Related

- [@dotdo/nats](/docs/integrations/nats/package) - nats.js-compatible package
- [Kafka Integration](/docs/integrations/kafka) - Event streaming
- [Pusher Integration](/docs/integrations/pusher) - Real-time messaging
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
