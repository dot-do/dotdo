---
title: Weaviate
description: Drop-in replacement for the Weaviate TypeScript client with edge compatibility and semantic search backed by EdgeVec.
---

import { Callout } from 'fumadocs-ui/components/callout'

<Callout type="info">
  **Roadmap Feature:** This integration is planned but not yet implemented. The API shown here represents the target design. [Contribute](https://github.com/dot-do/dotdo) to help build it.
</Callout>

# Weaviate

Drop-in replacement for the official Weaviate TypeScript client. Your existing `weaviate-ts-client` code works unchanged - just swap the import.

```typescript
// Before: Weaviate
import weaviate from 'weaviate-ts-client'

// After: dotdo
import weaviate from '@dotdo/weaviate'

// Code stays the same
const client = weaviate.client({
  host: 'localhost:8080',
})

await client.schema.classCreator().withClass({
  class: 'Article',
  vectorizer: 'none',
  properties: [
    { name: 'title', dataType: ['text'] },
    { name: 'content', dataType: ['text'] },
  ],
}).do()

const results = await client.graphql.get()
  .withClassName('Article')
  .withFields('title content _additional { distance }')
  .withNearVector({ vector: queryEmbedding })
  .withLimit(10)
  .do()
```

## Why @dotdo/weaviate?

| Weaviate Cloud | @dotdo/weaviate |
|----------------|-----------------|
| JVM-based infrastructure | Edge-compatible (Cloudflare Workers) |
| Requires Weaviate cluster | Runs entirely on Durable Objects |
| Network latency to cluster | Zero latency in local mode |
| GC pauses during heavy load | Predictable performance |
| Complex cluster management | Single DO instance per namespace |
| Expensive at scale | Pay-per-request pricing |

**This is a compatibility layer.** It provides a Weaviate-compatible API backed by EdgeVec for HNSW vector search and FTS5 for BM25 keyword search. Your data lives in Durable Object storage - not proxied to Weaviate servers.

## Features

### Implemented (Core APIs)

**Schema Operations**
- `schema.classCreator()` - Create class with properties and vector config
- `schema.classGetter()` - Get class definition
- `schema.classDeleter()` - Delete class
- `schema.getter()` - List all classes
- `schema.propertyCreator()` - Add property to existing class

**Data Operations**
- `data.creator()` - Create object with properties and vector
- `data.getterById()` - Retrieve object by ID
- `data.updater()` - Update object properties
- `data.merger()` - Partial update (merge properties)
- `data.deleter()` - Delete object

**Batch Operations**
- `batch.objectsBatcher()` - Bulk create objects
- `batch.objectsDeleter()` - Bulk delete with filter

**GraphQL Search**
- `graphql.get()` - Query objects with all search methods
- `graphql.aggregate()` - Aggregate counts with filters

**Search Methods**
- `nearVector` - Vector similarity search
- `nearObject` - Find similar to existing object
- `nearText` - Semantic text search (simplified)
- `bm25` - Keyword search with BM25 scoring
- `hybrid` - Combined vector + keyword search with alpha weighting

**Filtering & Sorting**
- Where filters: `Equal`, `NotEqual`, `GreaterThan`, `LessThan`, `Like`, `IsNull`, `ContainsAny`, `ContainsAll`
- Boolean operators: `And`, `Or`
- Sorting by property (ascending/descending)
- Pagination with `limit` and `offset`

**Additional Fields**
- `id`, `vector`, `distance`, `certainty`, `score`
- `creationTimeUnix`, `lastUpdateTimeUnix`

### Not Yet Implemented

- Cross-references between objects
- Multi-tenancy with tenant isolation
- Generative modules (`generate` field)
- Reranking modules
- Auto-vectorization (use external embeddings)
- Geo-spatial queries
- Backup/restore APIs

## Quick Start

### Install

```bash
npm install @dotdo/weaviate
```

### Create Schema

```typescript
import weaviate from '@dotdo/weaviate'

const client = weaviate.client({ host: 'localhost:8080' })

// Create a class for products
await client.schema.classCreator().withClass({
  class: 'Product',
  description: 'E-commerce product catalog',
  vectorizer: 'none', // Using external embeddings
  vectorIndexConfig: {
    distance: 'cosine',
    ef: 256,
    efConstruction: 128,
  },
  properties: [
    { name: 'name', dataType: ['text'] },
    { name: 'description', dataType: ['text'] },
    { name: 'category', dataType: ['text'] },
    { name: 'price', dataType: ['number'] },
    { name: 'inStock', dataType: ['boolean'] },
    { name: 'tags', dataType: ['text[]'] },
  ],
}).do()
```

### Add Objects with Vectors

```typescript
// Single object
await client.data.creator()
  .withClassName('Product')
  .withId('product-uuid-1')
  .withVector(embedding) // Your 1536-dim embedding
  .withProperties({
    name: 'Wireless Headphones',
    description: 'Premium noise-cancelling Bluetooth headphones',
    category: 'electronics',
    price: 299.99,
    inStock: true,
    tags: ['audio', 'wireless', 'premium'],
  })
  .do()

// Batch import
const results = await client.batch.objectsBatcher()
  .withClassName('Product')
  .withObjects([
    {
      id: 'product-2',
      vector: embedding2,
      properties: { name: 'Running Shoes', category: 'sports', price: 129.99 },
    },
    {
      id: 'product-3',
      vector: embedding3,
      properties: { name: 'Yoga Mat', category: 'sports', price: 39.99 },
    },
  ])
  .do()

console.log(results) // [{ id: '...', status: 'SUCCESS' }, ...]
```

### Semantic Search

```typescript
// Find products similar to a query embedding
const results = await client.graphql.get()
  .withClassName('Product')
  .withFields('name description price _additional { id distance certainty }')
  .withNearVector({
    vector: queryEmbedding,
    certainty: 0.7, // Minimum similarity threshold
  })
  .withLimit(10)
  .do()

for (const product of results.data.Get.Product) {
  console.log(`${product.name}: ${product._additional.certainty}`)
}
```

### Hybrid Search (Vector + Keywords)

```typescript
// Combine semantic understanding with keyword matching
const results = await client.graphql.get()
  .withClassName('Product')
  .withFields('name description _additional { score }')
  .withHybrid({
    query: 'wireless audio headphones',
    vector: queryEmbedding,
    alpha: 0.5, // 0 = pure keyword, 1 = pure vector
  })
  .withWhere({
    operator: 'And',
    operands: [
      { operator: 'Equal', path: ['category'], valueText: 'electronics' },
      { operator: 'LessThan', path: ['price'], valueNumber: 300 },
    ],
  })
  .withLimit(10)
  .do()
```

### BM25 Keyword Search

```typescript
// Pure keyword search with BM25 scoring
const results = await client.graphql.get()
  .withClassName('Product')
  .withFields('name description _additional { score }')
  .withBm25({
    query: 'noise cancelling bluetooth',
    properties: ['name', 'description'], // Limit to specific fields
  })
  .withLimit(10)
  .do()
```

### Find Similar Objects

```typescript
// Find products similar to an existing product
const similar = await client.graphql.get()
  .withClassName('Product')
  .withFields('name price _additional { distance }')
  .withNearObject({
    id: 'product-uuid-1',
    distance: 0.3, // Maximum distance threshold
  })
  .withLimit(5)
  .do()
```

### Filtering

```typescript
// Complex where filters
const filtered = await client.graphql.get()
  .withClassName('Product')
  .withFields('name category price')
  .withWhere({
    operator: 'And',
    operands: [
      {
        operator: 'Or',
        operands: [
          { operator: 'Equal', path: ['category'], valueText: 'electronics' },
          { operator: 'Equal', path: ['category'], valueText: 'audio' },
        ],
      },
      { operator: 'GreaterThan', path: ['price'], valueNumber: 50 },
      { operator: 'Equal', path: ['inStock'], valueBoolean: true },
    ],
  })
  .withSort({ path: ['price'], order: 'asc' })
  .do()

// Like operator for pattern matching
const patternMatch = await client.graphql.get()
  .withClassName('Product')
  .withFields('name')
  .withWhere({
    operator: 'Like',
    path: ['name'],
    valueText: '*Wireless*',
  })
  .do()
```

### Aggregations

```typescript
// Count objects matching criteria
const stats = await client.graphql.aggregate()
  .withClassName('Product')
  .withFields('meta { count }')
  .withWhere({
    operator: 'Equal',
    path: ['category'],
    valueText: 'electronics',
  })
  .do()

const count = stats.data.Aggregate.Product[0].meta.count
console.log(`Electronics products: ${count}`)
```

## Inbound Mode - Using EdgeVec Locally

For development and testing, the client runs entirely in-memory with no external dependencies.

```typescript
import weaviate from '@dotdo/weaviate'

// Create local client (no Weaviate cluster needed)
const client = weaviate.client({
  host: 'localhost:8080', // Used for namespacing only
})

// Full Weaviate API available locally
await client.schema.classCreator().withClass({
  class: 'Document',
  vectorizer: 'none',
  properties: [
    { name: 'title', dataType: ['text'] },
    { name: 'content', dataType: ['text'] },
  ],
}).do()

// Insert with vectors
await client.data.creator()
  .withClassName('Document')
  .withProperties({ title: 'Getting Started', content: 'Welcome to the docs' })
  .withVector([0.1, 0.2, 0.3, ...])
  .do()

// Search works locally
const results = await client.graphql.get()
  .withClassName('Document')
  .withFields('title content')
  .withNearVector({ vector: queryVector })
  .withLimit(10)
  .do()
```

### Edge Worker Deployment

```typescript
// worker.ts
import weaviate from '@dotdo/weaviate'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const client = weaviate.client({ host: env.WEAVIATE_HOST })
    const url = new URL(request.url)
    const query = url.searchParams.get('q')

    // Embed the query (using your embedding service)
    const embedding = await embedText(query)

    // Semantic search
    const results = await client.graphql.get()
      .withClassName('KnowledgeBase')
      .withFields('title content url _additional { distance }')
      .withNearVector({ vector: embedding, certainty: 0.7 })
      .withLimit(5)
      .do()

    return Response.json(results.data.Get.KnowledgeBase)
  },
}
```

## Outbound Mode - Connecting to Real Weaviate

For production scenarios requiring a full Weaviate cluster.

```typescript
import weaviate from '@dotdo/weaviate'

// Future: Configure outbound proxy to Weaviate Cloud
const client = weaviate.client({
  scheme: 'https',
  host: 'my-cluster.weaviate.network',
  apiKey: env.WEAVIATE_API_KEY,
  headers: {
    'X-OpenAI-Api-Key': env.OPENAI_API_KEY, // For auto-vectorization
  },
})
```

## API Reference

### weaviate.client(config)

Create a new Weaviate-compatible client.

```typescript
const client = weaviate.client({
  scheme: 'https',           // URL scheme (default: 'http')
  host: 'localhost:8080',    // Weaviate host
  apiKey: 'your-api-key',    // Optional API key
  headers: {},               // Additional headers
})
```

### Schema Operations

```typescript
// Create class
await client.schema.classCreator()
  .withClass({
    class: 'MyClass',
    description: 'Class description',
    vectorizer: 'none',
    vectorIndexType: 'hnsw',
    vectorIndexConfig: {
      distance: 'cosine',  // 'cosine' | 'dot' | 'l2-squared'
      ef: 256,
      efConstruction: 128,
      maxConnections: 64,
    },
    invertedIndexConfig: {
      bm25: { b: 0.75, k1: 1.2 },
      indexTimestamps: true,
    },
    properties: [
      {
        name: 'fieldName',
        dataType: ['text'],  // 'text', 'int', 'number', 'boolean', 'date', etc.
        description: 'Field description',
        indexFilterable: true,
        indexSearchable: true,
        tokenization: 'word',
      },
    ],
  })
  .do()

// Get class
const classConfig = await client.schema.classGetter()
  .withClassName('MyClass')
  .do()

// List all classes
const schema = await client.schema.getter().do()
console.log(schema.classes)

// Delete class
await client.schema.classDeleter()
  .withClassName('MyClass')
  .do()

// Add property to existing class
await client.schema.propertyCreator()
  .withClassName('MyClass')
  .withProperty({ name: 'newField', dataType: ['text'] })
  .do()
```

### Data Operations

```typescript
// Create object
const obj = await client.data.creator()
  .withClassName('MyClass')
  .withId('custom-uuid')          // Optional, auto-generated if omitted
  .withProperties({ field: 'value' })
  .withVector([0.1, 0.2, ...])    // Optional external vector
  .withTenant('tenant-id')        // Optional multi-tenancy
  .do()

// Get object by ID
const found = await client.data.getterById()
  .withClassName('MyClass')
  .withId('object-id')
  .withAdditional(['id', 'vector', 'creationTimeUnix'])
  .do()

// Update object (full replace)
await client.data.updater()
  .withClassName('MyClass')
  .withId('object-id')
  .withProperties({ field: 'new value' })
  .withVector([0.4, 0.5, ...])
  .do()

// Merge object (partial update)
await client.data.merger()
  .withClassName('MyClass')
  .withId('object-id')
  .withProperties({ field: 'updated' })
  .do()

// Delete object
await client.data.deleter()
  .withClassName('MyClass')
  .withId('object-id')
  .do()
```

### Batch Operations

```typescript
// Batch create
const results = await client.batch.objectsBatcher()
  .withClassName('MyClass')
  .withObjects([
    { id: 'id-1', properties: { ... }, vector: [...] },
    { id: 'id-2', properties: { ... }, vector: [...] },
  ])
  .do()

// Batch delete with filter
const deleteResult = await client.batch.objectsDeleter()
  .withClassName('MyClass')
  .withWhere({
    operator: 'LessThan',
    path: ['score'],
    valueNumber: 0.5,
  })
  .do()

console.log(`Deleted ${deleteResult.successful} objects`)
```

### GraphQL Get

```typescript
const response = await client.graphql.get()
  .withClassName('MyClass')
  .withFields('field1 field2 _additional { id distance certainty score vector }')

  // Pagination
  .withLimit(10)
  .withOffset(0)

  // Vector search
  .withNearVector({ vector: [...], certainty: 0.8 })
  .withNearObject({ id: 'object-id', distance: 0.3 })
  .withNearText({ concepts: ['semantic search'] })

  // Keyword search
  .withBm25({ query: 'keyword search', properties: ['title', 'content'] })

  // Hybrid search
  .withHybrid({
    query: 'search query',
    vector: [...],
    alpha: 0.5,
    properties: ['title'],
  })

  // Filtering
  .withWhere({
    operator: 'And',
    operands: [
      { operator: 'Equal', path: ['field'], valueText: 'value' },
      { operator: 'GreaterThan', path: ['score'], valueNumber: 0.5 },
    ],
  })

  // Sorting
  .withSort([
    { path: ['field'], order: 'asc' },
    { path: ['score'], order: 'desc' },
  ])

  .do()
```

### GraphQL Aggregate

```typescript
const response = await client.graphql.aggregate()
  .withClassName('MyClass')
  .withFields('meta { count }')
  .withWhere({
    operator: 'Equal',
    path: ['category'],
    valueText: 'tech',
  })
  .do()
```

## Types

Full TypeScript support with Weaviate-compatible type definitions.

```typescript
import type {
  // Client types
  WeaviateClientConfig,
  WeaviateClient,

  // Schema types
  WeaviateClass,
  WeaviateSchema,
  WeaviateProperty,
  WeaviateDataType,
  WeaviateVectorizer,
  VectorIndexConfig,
  InvertedIndexConfig,

  // Object types
  WeaviateObject,
  WeaviateAdditional,

  // Search types
  NearVectorParams,
  NearTextParams,
  NearObjectParams,
  Bm25Params,
  HybridParams,

  // Filter types
  WhereFilter,
  WhereOperator,
  SortSpec,

  // Response types
  GraphQLResponse,
  BatchResult,
  BatchDeleteResult,
} from '@dotdo/weaviate'
```

## Architecture

```
+-------------------------------------------------------------+
|                    Your Application                          |
|                                                              |
|  const client = weaviate.client({ host: '...' })            |
|  await client.graphql.get().withNearVector({...}).do()      |
+-------------------------------------------------------------+
                              |
              +---------------+---------------+
              |                               |
              v                               v
+-------------------------+     +-------------------------+
|   Local Mode            |     |   Outbound Mode         |
|   (Default)             |     |   (Future)              |
+-------------------------+     +-------------------------+
|                         |     |                         |
|  EdgeVec HNSW           |     |  -> Weaviate Cloud      |
|  (Vector similarity)    |     |                         |
|                         |     |  -> Self-hosted         |
|  FTS5 BM25              |     |     Weaviate            |
|  (Keyword search)       |     |                         |
|                         |     |                         |
|  DO SQLite Storage      |     |                         |
|  (Persistence)          |     |                         |
|                         |     |                         |
+-------------------------+     +-------------------------+
```

### Local Mode Benefits

- **Zero latency**: No network round-trips to external cluster
- **No infrastructure**: No Weaviate cluster to manage
- **Edge-native**: Runs in Cloudflare Workers
- **Cost-effective**: No cluster costs
- **Predictable**: No JVM GC pauses
- **Testable**: Easy unit testing without mocks

## Common Patterns

### RAG with Weaviate

```typescript
async function ragQuery(question: string) {
  // Embed the question
  const questionEmbedding = await embed(question)

  // Find relevant documents
  const results = await client.graphql.get()
    .withClassName('Document')
    .withFields('title content _additional { certainty }')
    .withNearVector({ vector: questionEmbedding, certainty: 0.7 })
    .withLimit(5)
    .do()

  // Build context
  const context = results.data.Get.Document
    .map(doc => `## ${doc.title}\n${doc.content}`)
    .join('\n\n')

  // Generate answer
  return await complete({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: `Answer based on:\n\n${context}` },
      { role: 'user', content: question },
    ],
  })
}
```

### E-commerce Product Search

```typescript
async function searchProducts(query: string, filters: ProductFilters) {
  const embedding = await embed(query)

  return await client.graphql.get()
    .withClassName('Product')
    .withFields('name description price imageUrl rating _additional { score }')
    .withHybrid({
      query,
      vector: embedding,
      alpha: 0.6, // Favor semantic understanding
    })
    .withWhere({
      operator: 'And',
      operands: [
        filters.category && {
          operator: 'Equal',
          path: ['category'],
          valueText: filters.category,
        },
        filters.maxPrice && {
          operator: 'LessThanEqual',
          path: ['price'],
          valueNumber: filters.maxPrice,
        },
        { operator: 'Equal', path: ['inStock'], valueBoolean: true },
      ].filter(Boolean),
    })
    .withSort({ path: ['rating'], order: 'desc' })
    .withLimit(20)
    .do()
}
```

### Document Q&A

```typescript
async function answerFromDocs(question: string, source?: string) {
  const embedding = await embed(question)

  const whereFilter = source ? {
    operator: 'Equal',
    path: ['source'],
    valueText: source,
  } : undefined

  const results = await client.graphql.get()
    .withClassName('DocumentChunk')
    .withFields('content source page _additional { distance }')
    .withNearVector({ vector: embedding })
    .withWhere(whereFilter)
    .withLimit(3)
    .do()

  return results.data.Get.DocumentChunk
}
```

## API Coverage

| API | Coverage | Notes |
|-----|----------|-------|
| Schema CRUD | Full | Create, get, delete classes |
| Properties | Full | Add properties to classes |
| Data CRUD | Full | Create, read, update, delete objects |
| Batch Operations | Full | Bulk create and delete |
| nearVector | Full | Vector similarity search |
| nearObject | Full | Find similar to existing |
| nearText | Partial | Simplified keyword matching |
| BM25 | Full | Keyword search with scoring |
| Hybrid | Full | Vector + keyword fusion |
| Where Filters | Full | All operators supported |
| Sorting | Full | Single and multi-field |
| Aggregations | Partial | Count only |
| Cross-references | Not yet | |
| Multi-tenancy | Not yet | |
| Generative | Not yet | |
| Reranking | Not yet | |

## Error Handling

```typescript
import weaviate, { WeaviateError, WeaviateConnectionError, WeaviateNotFoundError } from '@dotdo/weaviate'

const client = weaviate.client({ host: 'localhost:8080' })

try {
  const results = await client.graphql.get()
    .withClassName('NonExistentClass')
    .withFields('name')
    .do()
} catch (error) {
  if (error instanceof WeaviateNotFoundError) {
    console.error('Class or object not found:', error.message)
  } else if (error instanceof WeaviateConnectionError) {
    console.error('Connection failed:', error.message)
  } else if (error instanceof WeaviateError) {
    console.error('Weaviate error:', error.message)
    console.error('Status:', error.statusCode)
  }
}

// Handle schema errors
try {
  await client.schema.classCreator().withClass({
    class: 'ExistingClass', // Already exists
    properties: [{ name: 'title', dataType: ['text'] }],
  }).do()
} catch (error) {
  if (error instanceof WeaviateError && error.statusCode === 422) {
    console.error('Schema validation error - class may already exist')
  }
}
```

### Error Types

| Error | Description |
|-------|-------------|
| `WeaviateError` | Base error class for all Weaviate errors |
| `WeaviateConnectionError` | Connection or network failures |
| `WeaviateNotFoundError` | Class or object not found (404) |
| `WeaviateValidationError` | Schema or query validation error (422) |
| `WeaviateAuthError` | Authentication or authorization failure (401/403) |

## Migration from Weaviate SDK

### Package Change

```bash
# Remove
npm uninstall weaviate-ts-client

# Install
npm install @dotdo/weaviate
```

### Import Change

```typescript
// Before
import weaviate from 'weaviate-ts-client'

// After
import weaviate from '@dotdo/weaviate'
```

### Code Compatibility

Your existing Weaviate code works unchanged:

```typescript
// This code works with both weaviate-ts-client and @dotdo/weaviate
const client = weaviate.client({ host: 'localhost:8080' })

await client.schema.classCreator().withClass({
  class: 'Article',
  vectorizer: 'none',
  properties: [
    { name: 'title', dataType: ['text'] },
    { name: 'content', dataType: ['text'] },
  ],
}).do()

await client.data.creator()
  .withClassName('Article')
  .withProperties({ title: 'My Article', content: 'Content here' })
  .withVector([0.1, 0.2, 0.3])
  .do()

const results = await client.graphql.get()
  .withClassName('Article')
  .withFields('title content _additional { distance }')
  .withNearVector({ vector: queryEmbedding })
  .withLimit(10)
  .do()
```

## Related

- [Vector Compat Overview](/docs/compat/vector) - All vector SDK implementations
- [Elasticsearch Integration](/docs/integrations/elasticsearch) - Full-text search
- [Algolia Integration](/docs/integrations/algolia) - Search-as-a-service compat
- [Pinecone Integration](/docs/integrations/pinecone) - Another vector database option
