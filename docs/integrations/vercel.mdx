---
title: Vercel Integration
description: Deploy to Vercel with Edge Functions, KV, and Blob storage backed by Cloudflare infrastructure
---

# Vercel Integration

Compatibility layer for Vercel's platform primitives. Deploy your Vercel applications to dotdo infrastructure, or use Vercel-compatible APIs backed by Cloudflare.

```typescript
// Before: Vercel
import { kv } from '@vercel/kv'
import { put, list } from '@vercel/blob'

// After: dotdo
import { kv } from '@dotdo/vercel/kv'
import { put, list } from '@dotdo/vercel/blob'

// Code stays the same
await kv.set('user:123', { name: 'Alice' })
const user = await kv.get('user:123')

const blob = await put('avatar.png', imageData, { access: 'public' })
```

## Why vercel.do?

| Vercel | vercel.do |
|--------|-----------|
| 100ms cold starts (Functions) | 0ms cold starts (V8 isolates) |
| Regional execution | Edge-local (300+ cities) |
| Per-request pricing | Flat resource pricing |
| Vendor lock-in to Vercel | Portable to any infrastructure |
| Separate KV/Blob infrastructure | Unified with your DO data |
| 1MB Edge Config limit | Unlimited config via DO |

**This is a compatibility layer.** Your data lives in Cloudflare infrastructure (KV, R2, Durable Objects) - not proxied to Vercel. The same API surface, backed by edge-native primitives.

## Features

### Implemented

**Edge Functions**
- Request/Response handling
- `waitUntil()` for background tasks
- `next()` for middleware chains
- Environment variable access
- Geo and IP headers

**Vercel KV (Redis-compatible)**
- `get()`, `set()`, `del()`, `exists()`
- `mget()`, `mset()`, `incr()`, `decr()`
- `hget()`, `hset()`, `hgetall()`, `hdel()`
- `lpush()`, `rpush()`, `lpop()`, `rpop()`, `lrange()`
- `sadd()`, `srem()`, `smembers()`, `sismember()`
- `zadd()`, `zrem()`, `zrange()`, `zscore()`
- `expire()`, `ttl()`, `persist()`
- `scan()`, `keys()` with pattern matching

**Vercel Blob**
- `put()` - Upload blobs
- `del()` - Delete blobs
- `list()` - List blobs with pagination
- `head()` - Get blob metadata
- `copy()` - Copy blobs
- Access control (public/private)
- Multipart uploads

**Edge Config**
- `get()`, `getAll()`, `has()`
- `digest()` for cache invalidation
- Type-safe configuration

### Not Yet Implemented

- Vercel Analytics
- Vercel Web Vitals
- Vercel Cron Jobs (use `$.every()` instead)
- ISR (Incremental Static Regeneration)
- Image Optimization API
- OG Image Generation (use `@cloudflare/workers-og`)

## Installation

```bash
npm install @dotdo/vercel
```

## Quick Start

### Edge Functions

```typescript
import { EdgeFunction } from '@dotdo/vercel'

export default EdgeFunction(async (request) => {
  const { geo, ip } = request

  return Response.json({
    country: geo?.country,
    city: geo?.city,
    ip: ip,
    message: 'Hello from the edge!',
  })
})
```

### Middleware

```typescript
import { middleware, next, rewrite, redirect } from '@dotdo/vercel'

export default middleware(async (request) => {
  // Authentication check
  const token = request.headers.get('Authorization')
  if (!token) {
    return redirect('/login')
  }

  // A/B testing
  const bucket = request.cookies.get('ab-bucket')
  if (!bucket) {
    const newBucket = Math.random() > 0.5 ? 'a' : 'b'
    const response = next()
    response.cookies.set('ab-bucket', newBucket)
    return response
  }

  // Rewrite based on experiment
  if (bucket.value === 'b') {
    return rewrite('/experiments/new-homepage')
  }

  return next()
})
```

### Vercel KV

```typescript
import { kv } from '@dotdo/vercel/kv'

// String operations
await kv.set('user:123', JSON.stringify({ name: 'Alice' }))
const user = await kv.get('user:123')

// With expiration (seconds)
await kv.set('session:abc', 'data', { ex: 3600 })

// Increment counters
await kv.incr('pageviews')
await kv.incrby('score', 10)

// Hash operations
await kv.hset('user:123', { name: 'Alice', email: 'alice@example.com' })
const userData = await kv.hgetall('user:123')

// List operations (queues)
await kv.lpush('tasks', 'task-1', 'task-2')
const task = await kv.rpop('tasks')

// Sorted sets (leaderboards)
await kv.zadd('leaderboard', { score: 100, member: 'player1' })
const topPlayers = await kv.zrange('leaderboard', 0, 9, { rev: true })
```

### Vercel Blob

```typescript
import { put, del, list, head, copy } from '@dotdo/vercel/blob'

// Upload a blob
const blob = await put('avatars/user-123.png', imageData, {
  access: 'public',
  contentType: 'image/png',
})

console.log(blob.url)        // https://...blob.vercel-storage.com/avatars/user-123.png
console.log(blob.pathname)   // avatars/user-123.png
console.log(blob.size)       // 12345

// Upload from stream
const response = await fetch('https://example.com/image.png')
const blob = await put('images/external.png', response.body, {
  access: 'public',
})

// Get blob metadata
const metadata = await head('avatars/user-123.png')
console.log(metadata.contentType)  // image/png
console.log(metadata.uploadedAt)   // Date

// List blobs
const { blobs, cursor } = await list({
  prefix: 'avatars/',
  limit: 100,
})

for (const blob of blobs) {
  console.log(blob.pathname, blob.size)
}

// Pagination
let cursor: string | undefined
do {
  const result = await list({ cursor, limit: 1000 })
  for (const blob of result.blobs) {
    console.log(blob.pathname)
  }
  cursor = result.cursor
} while (cursor)

// Copy blob
const copied = await copy('avatars/user-123.png', 'backups/user-123.png', {
  access: 'public',
})

// Delete blob
await del('avatars/old-avatar.png')

// Delete multiple
await del(['temp/file1.txt', 'temp/file2.txt'])
```

### Edge Config

```typescript
import { get, getAll, has } from '@dotdo/vercel/edge-config'

// Get a single value
const featureFlag = await get<boolean>('feature_new_dashboard')

// Get multiple values
const config = await getAll<{
  feature_new_dashboard: boolean
  api_rate_limit: number
  allowed_origins: string[]
}>(['feature_new_dashboard', 'api_rate_limit', 'allowed_origins'])

// Check if key exists
if (await has('maintenance_mode')) {
  return new Response('Site under maintenance', { status: 503 })
}

// Type-safe with schema
import { z } from 'zod'

const ConfigSchema = z.object({
  featureFlags: z.object({
    newDashboard: z.boolean(),
    betaFeatures: z.array(z.string()),
  }),
  limits: z.object({
    rateLimit: z.number(),
    maxFileSize: z.number(),
  }),
})

const config = await get('app_config', { schema: ConfigSchema })
// TypeScript knows the shape of config
```

## API Reference

### Edge Functions

```typescript
import { EdgeFunction, EdgeRequest, EdgeResponse } from '@dotdo/vercel'

// EdgeRequest extends Request with:
interface EdgeRequest extends Request {
  geo?: {
    city?: string
    country?: string
    region?: string
    latitude?: string
    longitude?: string
  }
  ip?: string
  nextUrl: URL
  cookies: RequestCookies
}

// EdgeFunction signature
type EdgeFunction = (
  request: EdgeRequest,
  context: EdgeContext
) => Response | Promise<Response>

interface EdgeContext {
  waitUntil(promise: Promise<unknown>): void
}
```

### Vercel KV

```typescript
import { kv, createClient } from '@dotdo/vercel/kv'

// Use default client
await kv.set('key', 'value')

// Create custom client
const client = createClient({
  url: env.KV_REST_API_URL,
  token: env.KV_REST_API_TOKEN,
})

// Set options
interface SetOptions {
  ex?: number    // Expire in seconds
  px?: number    // Expire in milliseconds
  exat?: number  // Expire at Unix timestamp (seconds)
  pxat?: number  // Expire at Unix timestamp (ms)
  nx?: boolean   // Only set if not exists
  xx?: boolean   // Only set if exists
}

await kv.set('key', 'value', { ex: 3600, nx: true })

// Scan with pattern
const [cursor, keys] = await kv.scan(0, { match: 'user:*', count: 100 })
```

### Vercel Blob

```typescript
import { put, del, list, head, copy } from '@dotdo/vercel/blob'

// Put options
interface PutOptions {
  access: 'public' | 'private'
  contentType?: string
  cacheControlMaxAge?: number
  addRandomSuffix?: boolean  // Default: true
  token?: string             // Override default token
}

const blob = await put('path/file.txt', data, {
  access: 'public',
  contentType: 'text/plain',
  cacheControlMaxAge: 31536000,
  addRandomSuffix: false,
})

// List options
interface ListOptions {
  prefix?: string
  limit?: number  // Default: 1000
  cursor?: string
  token?: string
}

// Blob response
interface PutBlobResult {
  url: string
  downloadUrl: string
  pathname: string
  contentType: string
  contentDisposition: string
  size: number
  uploadedAt: Date
}
```

### Edge Config

```typescript
import { get, getAll, has, digest } from '@dotdo/vercel/edge-config'

// Get with fallback
const value = await get('key', { default: 'fallback' })

// Get cache digest for invalidation
const configDigest = await digest()
// Use in cache key: `cache:${configDigest}:mydata`

// Connection options
interface EdgeConfigOptions {
  connectionString?: string  // Override EDGE_CONFIG env
  token?: string
}
```

## Inbound - Vercel SDK Compatibility

Works as a drop-in replacement for Vercel SDKs:

```typescript
// Existing Vercel code works unchanged
import { kv } from '@dotdo/vercel/kv'  // Instead of @vercel/kv

await kv.set('user:123', { name: 'Alice' })
await kv.hset('session', { userId: '123', role: 'admin' })
await kv.zadd('leaderboard', { score: 100, member: 'player1' })
```

Works with Vercel ecosystem tools:

```typescript
// next.js API routes
import { kv } from '@dotdo/vercel/kv'

export async function GET(request: Request) {
  const data = await kv.get('my-key')
  return Response.json(data)
}

// next.js middleware
import { middleware, next } from '@dotdo/vercel'

export default middleware(async (request) => {
  // Rate limiting
  const ip = request.ip ?? '127.0.0.1'
  const rateKey = `rate:${ip}`

  const count = await kv.incr(rateKey)
  if (count === 1) {
    await kv.expire(rateKey, 60)
  }

  if (count > 100) {
    return new Response('Too Many Requests', { status: 429 })
  }

  return next()
})
```

## Outbound - What Runs Underneath

Your data lives in Cloudflare infrastructure:

```
Vercel API                     dotdo Backend
-----------                    -------------
@vercel/kv          ->         Cloudflare KV + Durable Objects
@vercel/blob        ->         Cloudflare R2
@vercel/edge-config ->         Durable Object SQLite
Edge Functions      ->         Cloudflare Workers
```

### KV Implementation

Vercel KV is Redis-compatible. The dotdo implementation uses:

```typescript
// Simple keys: Cloudflare KV for global reads
await env.KV.put('user:123', JSON.stringify(data))
await env.KV.get('user:123')

// Complex operations: Durable Objects for consistency
class KVStore extends DO {
  async hset(key: string, fields: Record<string, string>) {
    // SQLite for hash storage
    await this.db.exec(`
      INSERT OR REPLACE INTO hashes (key, field, value)
      VALUES (?, ?, ?)
    `, [key, field, value])
  }

  async zadd(key: string, members: { score: number; member: string }[]) {
    // SQLite for sorted set storage
    for (const { score, member } of members) {
      await this.db.exec(`
        INSERT OR REPLACE INTO zsets (key, member, score)
        VALUES (?, ?, ?)
      `, [key, member, score])
    }
  }
}
```

### Blob Implementation

Vercel Blob maps directly to Cloudflare R2:

```typescript
// put() -> R2.put()
const blob = await env.R2_BUCKET.put(pathname, data, {
  httpMetadata: {
    contentType: options.contentType,
    cacheControl: `max-age=${options.cacheControlMaxAge}`,
  },
})

// list() -> R2.list()
const { objects, cursor } = await env.R2_BUCKET.list({
  prefix: options.prefix,
  limit: options.limit,
  cursor: options.cursor,
})
```

### Why R2 Over Vercel Blob?

| Feature | Vercel Blob | Cloudflare R2 |
|---------|-------------|---------------|
| Egress fees | $0.15/GB after free tier | **Free** |
| Storage | $0.03/GB/month | $0.015/GB/month |
| Regions | Single region | Global edge |
| API | Proprietary | S3-compatible |

## Migration from Vercel

### Package Changes

```bash
# Remove Vercel packages
npm uninstall @vercel/kv @vercel/blob @vercel/edge-config

# Install dotdo
npm install @dotdo/vercel
```

### Import Changes

```typescript
// Before
import { kv } from '@vercel/kv'
import { put, list } from '@vercel/blob'
import { get } from '@vercel/edge-config'

// After
import { kv } from '@dotdo/vercel/kv'
import { put, list } from '@dotdo/vercel/blob'
import { get } from '@dotdo/vercel/edge-config'
```

### Environment Variables

```bash
# Before (Vercel)
KV_REST_API_URL=https://...
KV_REST_API_TOKEN=...
BLOB_READ_WRITE_TOKEN=...
EDGE_CONFIG=...

# After (dotdo) - auto-configured from bindings
# Add to wrangler.jsonc:
```

```json title="wrangler.jsonc"
{
  "vars": {
    "KV_REST_API_URL": "local"  // Uses DO storage
  },
  "kv_namespaces": [
    { "binding": "VERCEL_KV", "id": "..." }
  ],
  "r2_buckets": [
    { "binding": "VERCEL_BLOB", "bucket_name": "vercel-blob" }
  ],
  "durable_objects": {
    "bindings": [
      { "name": "EDGE_CONFIG", "class_name": "EdgeConfigDO" }
    ]
  }
}
```

### Data Migration

```typescript
import { kv as vercelKV } from '@vercel/kv'
import { kv as dotdoKV } from '@dotdo/vercel/kv'
import { list as vercelList } from '@vercel/blob'
import { put as dotdoPut } from '@dotdo/vercel/blob'

// Migrate KV data
async function migrateKV() {
  let cursor = 0
  do {
    const [nextCursor, keys] = await vercelKV.scan(cursor, { count: 100 })
    cursor = nextCursor

    for (const key of keys) {
      const value = await vercelKV.get(key)
      const ttl = await vercelKV.ttl(key)

      if (ttl > 0) {
        await dotdoKV.set(key, value, { ex: ttl })
      } else {
        await dotdoKV.set(key, value)
      }
    }
  } while (cursor !== 0)
}

// Migrate Blob data
async function migrateBlobs() {
  let cursor: string | undefined
  do {
    const { blobs, cursor: nextCursor } = await vercelList({ cursor })
    cursor = nextCursor

    for (const blob of blobs) {
      const response = await fetch(blob.url)
      await dotdoPut(blob.pathname, response.body, {
        access: 'public',
        contentType: blob.contentType,
      })
    }
  } while (cursor)
}
```

## Common Patterns

### Session Storage

```typescript
import { kv } from '@dotdo/vercel/kv'

async function createSession(userId: string): Promise<string> {
  const sessionId = crypto.randomUUID()
  await kv.hset(`session:${sessionId}`, {
    userId,
    createdAt: Date.now().toString(),
    lastActivity: Date.now().toString(),
  })
  await kv.expire(`session:${sessionId}`, 86400) // 24 hours
  return sessionId
}

async function getSession(sessionId: string) {
  const session = await kv.hgetall(`session:${sessionId}`)
  if (!session) return null

  // Update last activity
  await kv.hset(`session:${sessionId}`, {
    lastActivity: Date.now().toString(),
  })
  await kv.expire(`session:${sessionId}`, 86400)

  return session
}
```

### Rate Limiting

```typescript
import { kv } from '@dotdo/vercel/kv'

async function checkRateLimit(
  identifier: string,
  limit: number = 100,
  window: number = 60
): Promise<{ allowed: boolean; remaining: number; reset: number }> {
  const key = `rate:${identifier}`
  const now = Math.floor(Date.now() / 1000)

  const count = await kv.incr(key)
  if (count === 1) {
    await kv.expire(key, window)
  }

  const ttl = await kv.ttl(key)

  return {
    allowed: count <= limit,
    remaining: Math.max(0, limit - count),
    reset: now + ttl,
  }
}
```

### File Uploads

```typescript
import { put, del } from '@dotdo/vercel/blob'
import { kv } from '@dotdo/vercel/kv'

async function uploadAvatar(userId: string, file: File) {
  // Delete old avatar
  const oldUrl = await kv.get(`avatar:${userId}`)
  if (oldUrl) {
    await del(oldUrl)
  }

  // Upload new avatar
  const blob = await put(`avatars/${userId}/${file.name}`, file, {
    access: 'public',
    contentType: file.type,
    addRandomSuffix: true,
  })

  // Store URL
  await kv.set(`avatar:${userId}`, blob.url)

  return blob.url
}
```

### Feature Flags

```typescript
import { get, has } from '@dotdo/vercel/edge-config'
import { kv } from '@dotdo/vercel/kv'

async function isFeatureEnabled(
  feature: string,
  userId?: string
): Promise<boolean> {
  // Check global kill switch
  if (await has('disable_all_features')) {
    return false
  }

  // Check feature-specific config
  const config = await get<{
    enabled: boolean
    percentage?: number
    allowedUsers?: string[]
  }>(`feature:${feature}`)

  if (!config) return false
  if (!config.enabled) return false

  // Check user allowlist
  if (config.allowedUsers?.includes(userId ?? '')) {
    return true
  }

  // Percentage rollout
  if (config.percentage !== undefined && userId) {
    const hash = await hashUserId(userId, feature)
    return hash < config.percentage
  }

  return config.enabled
}

async function hashUserId(userId: string, feature: string): Promise<number> {
  const data = new TextEncoder().encode(`${userId}:${feature}`)
  const hash = await crypto.subtle.digest('SHA-256', data)
  const view = new DataView(hash)
  return view.getUint32(0) % 100
}
```

## Types

```typescript
import type {
  // Edge Function types
  EdgeFunction,
  EdgeRequest,
  EdgeResponse,
  EdgeContext,
  RequestCookies,
  ResponseCookies,
  Geo,

  // KV types
  KVClient,
  SetOptions,
  ScanOptions,
  ZAddOptions,
  ZRangeOptions,

  // Blob types
  PutOptions,
  ListOptions,
  HeadResult,
  PutBlobResult,
  ListBlobResult,
  BlobInfo,

  // Edge Config types
  EdgeConfigClient,
  EdgeConfigOptions,
  GetOptions,
} from '@dotdo/vercel'
```

## Error Handling

```typescript
import { kv } from '@dotdo/vercel/kv'
import { put } from '@dotdo/vercel/blob'
import {
  VercelError,
  KVError,
  BlobError,
  EdgeConfigError,
} from '@dotdo/vercel'

try {
  await kv.set('key', 'value')
} catch (error) {
  if (error instanceof KVError) {
    console.error('KV error:', error.message, error.code)
  }
}

try {
  await put('file.txt', data, { access: 'public' })
} catch (error) {
  if (error instanceof BlobError) {
    switch (error.code) {
      case 'PAYLOAD_TOO_LARGE':
        console.error('File too large')
        break
      case 'INVALID_TOKEN':
        console.error('Invalid blob token')
        break
      default:
        console.error('Blob error:', error.message)
    }
  }
}
```

## Related

- [Redis Integration](/docs/integrations/redis) - Full Redis compatibility
- [S3 Integration](/docs/integrations/s3) - S3-compatible object storage
- [Deployment](/docs/deployment) - Edge deployment overview
- [Durable Objects](/docs/architecture/durable-objects) - Stateful edge compute
