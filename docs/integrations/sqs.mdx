---
title: "SQS"
description: "Drop-in replacement for @aws-sdk/client-sqs with edge compatibility and in-memory storage."
---

# SQS

Drop-in replacement for @aws-sdk/client-sqs v3. Your existing AWS SQS code works unchanged - just swap the import.

```typescript
// Before: AWS SDK
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs'

// After: dotdo
import { SQSClient, SendMessageCommand } from '@dotdo/sqs'

// Code stays the same
const client = new SQSClient({ region: 'us-east-1' })
await client.send(new SendMessageCommand({
  QueueUrl: 'https://sqs.us-east-1.amazonaws.com/123456789/my-queue',
  MessageBody: JSON.stringify({ event: 'user.created' }),
}))
```

## Prerequisites

Before integrating SQS with dotdo, you need:

### 1. Choose Your Backend

dotdo SQS supports two modes:
- **In-memory**: For testing and development (default)
- **Durable Objects**: For production edge queuing

### 2. AWS Credentials (Optional)

If proxying to real SQS:
1. Create IAM credentials with SQS access
2. Configure access key and secret

### 3. Environment Setup

```bash
# For AWS SQS proxy mode
AWS_ACCESS_KEY_ID=AKIAEXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
AWS_REGION=us-east-1
```

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `AWS_ACCESS_KEY_ID` | No | AWS access key (for proxy mode) |
| `AWS_SECRET_ACCESS_KEY` | No | AWS secret key (for proxy mode) |
| `AWS_REGION` | No | AWS region (default: us-east-1) |

## Why @dotdo/sqs?

| @aws-sdk/client-sqs | @dotdo/sqs |
|---------------------|------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| AWS infrastructure required | In-memory or Durable Objects |
| Network latency | Local testing |
| AWS costs | Zero cost for local queues |

**This is a compatibility layer.** It can either run entirely locally for testing or be backed by Durable Objects for production edge queuing.

## Features

### Implemented

**Queue Operations**
- `CreateQueueCommand` - Create queues
- `DeleteQueueCommand` - Delete queues
- `ListQueuesCommand` - List queues
- `GetQueueUrlCommand` - Get queue URL
- `GetQueueAttributesCommand` - Get attributes
- `SetQueueAttributesCommand` - Set attributes
- `PurgeQueueCommand` - Purge messages

**Message Operations**
- `SendMessageCommand` - Send single message
- `SendMessageBatchCommand` - Send batch (up to 10)
- `ReceiveMessageCommand` - Receive messages
- `DeleteMessageCommand` - Delete message
- `DeleteMessageBatchCommand` - Delete batch
- `ChangeMessageVisibilityCommand` - Change visibility
- `ChangeMessageVisibilityBatchCommand` - Batch visibility

**Queue Features**
- Standard queues
- FIFO queues (.fifo suffix)
- Message visibility timeout
- Delay queues
- Long polling
- Message attributes
- MD5 hash verification

**Tags**
- `TagQueueCommand` - Add tags
- `UntagQueueCommand` - Remove tags
- `ListQueueTagsCommand` - List tags

### Not Yet Implemented

- Dead letter queues (DLQ)
- Redrive policies
- Server-side encryption

## Quick Start

### Install

```bash
npm install @dotdo/sqs
```

### Basic Usage

```typescript
import {
  SQSClient,
  CreateQueueCommand,
  SendMessageCommand,
  ReceiveMessageCommand,
  DeleteMessageCommand,
} from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

// Create a queue
const { QueueUrl } = await client.send(new CreateQueueCommand({
  QueueName: 'my-queue',
}))

// Send a message
const sendResult = await client.send(new SendMessageCommand({
  QueueUrl,
  MessageBody: JSON.stringify({
    event: 'order.created',
    orderId: '12345',
  }),
  MessageAttributes: {
    EventType: {
      DataType: 'String',
      StringValue: 'order.created',
    },
  },
}))

console.log('MessageId:', sendResult.MessageId)

// Receive messages
const { Messages } = await client.send(new ReceiveMessageCommand({
  QueueUrl,
  MaxNumberOfMessages: 10,
  WaitTimeSeconds: 20, // Long polling
  MessageAttributeNames: ['All'],
}))

// Process and delete messages
if (Messages) {
  for (const message of Messages) {
    console.log('Processing:', message.Body)

    // Delete after processing
    await client.send(new DeleteMessageCommand({
      QueueUrl,
      ReceiptHandle: message.ReceiptHandle!,
    }))
  }
}
```

### FIFO Queues

```typescript
import {
  SQSClient,
  CreateQueueCommand,
  SendMessageCommand,
} from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

// Create FIFO queue (name must end with .fifo)
const { QueueUrl } = await client.send(new CreateQueueCommand({
  QueueName: 'orders.fifo',
  Attributes: {
    FifoQueue: 'true',
    ContentBasedDeduplication: 'true',
  },
}))

// Send with message group ID for ordering
await client.send(new SendMessageCommand({
  QueueUrl,
  MessageBody: JSON.stringify({ orderId: '456' }),
  MessageGroupId: 'customer-123', // Messages in same group are ordered
  // MessageDeduplicationId is auto-generated if ContentBasedDeduplication is true
}))
```

### Batch Operations

```typescript
import {
  SQSClient,
  SendMessageBatchCommand,
  DeleteMessageBatchCommand,
} from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

// Send batch of messages
const { Successful, Failed } = await client.send(new SendMessageBatchCommand({
  QueueUrl,
  Entries: [
    { Id: '1', MessageBody: 'First message' },
    { Id: '2', MessageBody: 'Second message', DelaySeconds: 10 },
    { Id: '3', MessageBody: 'Third message' },
  ],
}))

console.log('Sent:', Successful?.length)
console.log('Failed:', Failed?.length)

// Delete batch of messages
await client.send(new DeleteMessageBatchCommand({
  QueueUrl,
  Entries: Messages!.map((m, i) => ({
    Id: `${i}`,
    ReceiptHandle: m.ReceiptHandle!,
  })),
}))
```

## Configuration

### Client Options

```typescript
import { SQSClient, type SQSClientConfig } from '@dotdo/sqs'

const config: SQSClientConfig = {
  // AWS-compatible config
  region: 'us-east-1',
  credentials: {
    accessKeyId: 'AKIAEXAMPLE',
    secretAccessKey: 'SECRET',
  },
}

const client = new SQSClient(config)
```

## Inbound - Local Development

For local development and testing, queues are stored in memory:

```typescript
import {
  SQSClient,
  CreateQueueCommand,
  SendMessageCommand,
  _clearAll,
} from '@dotdo/sqs'

// Create client (in-memory by default)
const client = new SQSClient({ region: 'us-east-1' })

// Create queue and send messages
const { QueueUrl } = await client.send(new CreateQueueCommand({
  QueueName: 'test-queue',
}))

await client.send(new SendMessageCommand({
  QueueUrl,
  MessageBody: 'test message',
}))

// Clear all queues between tests
_clearAll()
```

## Outbound - Production

For production, queues are backed by Durable Objects:

```typescript
// worker.ts
import {
  SQSClient,
  CreateQueueCommand,
  SendMessageCommand,
  ReceiveMessageCommand,
} from '@dotdo/sqs'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const client = new SQSClient({ region: 'us-east-1' })

    // Create queue (idempotent)
    const { QueueUrl } = await client.send(new CreateQueueCommand({
      QueueName: 'events',
    }))

    // Send message
    await client.send(new SendMessageCommand({
      QueueUrl,
      MessageBody: JSON.stringify({
        type: 'request',
        path: new URL(request.url).pathname,
      }),
    }))

    return new Response('Queued')
  },
}
```

## Message Visibility

Control message visibility timeout:

```typescript
import {
  SQSClient,
  ReceiveMessageCommand,
  ChangeMessageVisibilityCommand,
} from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

// Receive with custom visibility timeout
const { Messages } = await client.send(new ReceiveMessageCommand({
  QueueUrl,
  VisibilityTimeout: 60, // 60 seconds to process
}))

// Extend visibility if processing takes longer
if (Messages?.[0]) {
  await client.send(new ChangeMessageVisibilityCommand({
    QueueUrl,
    ReceiptHandle: Messages[0].ReceiptHandle!,
    VisibilityTimeout: 120, // Extend to 120 seconds
  }))
}
```

## Error Handling

```typescript
import {
  SQSClient,
  SendMessageCommand,
  QueueDoesNotExist,
  ReceiptHandleIsInvalid,
  SQSServiceException,
} from '@dotdo/sqs'

const client = new SQSClient({ region: 'us-east-1' })

try {
  await client.send(new SendMessageCommand({
    QueueUrl: 'https://sqs.us-east-1.amazonaws.com/123/nonexistent',
    MessageBody: 'test',
  }))
} catch (error) {
  if (error instanceof QueueDoesNotExist) {
    console.log('Queue not found')
  } else if (error instanceof ReceiptHandleIsInvalid) {
    console.log('Invalid receipt handle')
  } else if (error instanceof SQSServiceException) {
    console.log('SQS error:', error.name, error.message)
  }
}
```

### Common Error Classes

| Error | Description |
|-------|-------------|
| `QueueDoesNotExist` | Queue URL not found |
| `QueueNameExists` | Queue name already exists |
| `ReceiptHandleIsInvalid` | Invalid receipt handle |
| `MessageNotInflight` | Message not currently in flight |
| `TooManyEntriesInBatchRequest` | Batch exceeds 10 entries |
| `EmptyBatchRequest` | Batch has no entries |
| `BatchEntryIdsNotDistinct` | Duplicate IDs in batch |
| `PurgeQueueInProgress` | Purge already running |

## TypeScript Types

Full TypeScript support with AWS SDK types:

```typescript
import type {
  // Client config
  SQSClientConfig,
  Credentials,

  // Queue types
  QueueAttributeName,
  QueueAttributes,

  // Message types
  Message,
  MessageAttributeValue,
  MessageAttributes,
  SendMessageBatchRequestEntry,
  BatchResultErrorEntry,

  // Command inputs/outputs
  CreateQueueCommandInput,
  CreateQueueCommandOutput,
  SendMessageCommandInput,
  SendMessageCommandOutput,
  ReceiveMessageCommandInput,
  ReceiveMessageCommandOutput,

  // Metadata
  ResponseMetadata,
} from '@dotdo/sqs'
```

## Workflow Integration

Use SQS with dotdo workflows for durable messaging:

```typescript
import { $ } from 'dotdo'
import { SQSClient, SendMessageCommand, ReceiveMessageCommand } from '@dotdo/sqs'

export class OrderQueue {
  sqs = new SQSClient({ region: 'us-east-1' })
  queueUrl = 'https://sqs.us-east-1.amazonaws.com/123/orders'

  async enqueueOrder(order: Order) {
    // Durable message send
    await $.do(() =>
      this.sqs.send(new SendMessageCommand({
        QueueUrl: this.queueUrl,
        MessageBody: JSON.stringify(order),
        MessageAttributes: {
          Priority: {
            DataType: 'String',
            StringValue: order.priority,
          },
        },
      }))
    )
  }

  async processOrders() {
    const { Messages } = await this.sqs.send(new ReceiveMessageCommand({
      QueueUrl: this.queueUrl,
      MaxNumberOfMessages: 10,
      WaitTimeSeconds: 20,
    }))

    for (const message of Messages || []) {
      const order = JSON.parse(message.Body!)
      await $.do(() => this.processOrder(order))
    }
  }
}
```

## Migration from @aws-sdk/client-sqs

### 1. Package Change

```bash
# Remove AWS SDK
npm uninstall @aws-sdk/client-sqs

# Install dotdo package
npm install @dotdo/sqs
```

### 2. Import Change

```typescript
// Before
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs'

// After
import { SQSClient, SendMessageCommand } from '@dotdo/sqs'
```

### 3. Code Compatibility

Your existing code should work unchanged. The API surface matches AWS SDK v3.

## Related

- [Kafka Integration](/docs/integrations/kafka) - Apache Kafka
- [Redis Integration](/docs/integrations/redis) - Redis Pub/Sub
- [Compat SDKs Overview](/docs/compat) - All API-compatible SDKs
