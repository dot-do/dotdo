---
title: "@dotdo/trigger"
description: Drop-in replacement for @trigger.dev/sdk with edge compatibility and in-memory execution for testing.
---

# @dotdo/trigger

Drop-in replacement for `@trigger.dev/sdk/v3`. Your existing Trigger.dev code works unchanged - just swap the import.

```typescript
// Before: Trigger.dev
import { task, wait, retry } from '@trigger.dev/sdk/v3'

// After: dotdo
import { task, wait, retry } from '@dotdo/trigger'

// Code stays the same
export const helloWorld = task({
  id: 'hello-world',
  run: async (payload: { name: string }) => {
    await wait.for({ seconds: 5 })
    return `Hello, ${payload.name}!`
  },
})
```

<Callout type="info">
Looking for managed edge execution? See [trigger.do](/docs/integrations/trigger/service) for production deployments with durable storage and zero cold starts.
</Callout>

## Why @dotdo/trigger?

| @trigger.dev/sdk | @dotdo/trigger |
|------------------|----------------|
| Requires Trigger.dev infrastructure | Runs entirely in-memory |
| Network latency to API | Zero latency (local) |
| Complex dev/test setup | Perfect for unit tests |
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Payloads leave your infra | Data stays local |

**This is a compatibility layer** for testing and development. For production, configure a durable backend like CF Workflows or Durable Objects.

## Installation

```bash
npm install @dotdo/trigger
```

## Features

### Implemented (Full v3 API)

**Task Definition**
- `task()` - Create tasks with full configuration
- `schedules()` - Cron-triggered scheduled tasks
- `configure()` - Global configuration

**Trigger Methods**
- `trigger()` - Fire and forget
- `triggerAndWait()` - Await completion
- `batchTrigger()` - Batch fire and forget
- `batchTriggerAndWait()` - Batch await

**Context Operations**
- `ctx.run()` - Step memoization with replay
- `ctx.run.id`, `ctx.attempt.number` - Run context
- `ctx.task.id`, `ctx.task.version` - Task metadata

**Configuration**
- Retry configuration (exponential, linear, presets)
- Queue configuration (concurrency, rate limits)
- Machine presets
- Lifecycle hooks (onStart, onSuccess, onFailure)
- Middleware support

**Utilities**
- `wait.for()`, `wait.until()` - Durable waits
- `retry.preset()`, `retry.exponential()`, `retry.linear()` - Retry helpers
- `queue.create()` - Queue configuration
- `abort()` - Graceful task abort

**Run Handles**
- `handle.status()` - Get run status
- `handle.result()` - Poll for result
- `handle.cancel()` - Cancel execution

## Quick Start

### Define a Task

```typescript
import { task, wait } from '@dotdo/trigger'

export const helloWorld = task({
  id: 'hello-world',
  run: async (payload: { name: string }) => {
    await wait.for({ seconds: 5 })
    return `Hello, ${payload.name}!`
  },
})
```

### Trigger and Forget

```typescript
const { id, handle } = await helloWorld.trigger({ name: 'World' })

console.log('Run ID:', id)

// Later, check status or get result
const status = await handle.status()  // 'PENDING' | 'EXECUTING' | 'COMPLETED' | 'FAILED'
const result = await handle.result()  // Polls until complete
```

### Trigger and Wait

```typescript
const result = await helloWorld.triggerAndWait({ name: 'World' })

if (result.ok) {
  console.log('Output:', result.output)  // "Hello, World!"
} else {
  console.error('Failed:', result.error.message)
}
```

## Task Configuration

Full task configuration with all options:

```typescript
import { task, retry } from '@dotdo/trigger'

interface OrderPayload {
  orderId: string
  userId: string
  items: Array<{ productId: string; quantity: number }>
}

interface OrderResult {
  orderId: string
  status: 'processed' | 'failed'
  processedAt: Date
}

export const processOrder = task<OrderPayload, OrderResult>({
  id: 'process-order',
  version: '1.0.0',

  // Retry configuration
  retry: {
    maxAttempts: 5,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 30000,
    factor: 2,
    randomize: true,
  },

  // Queue configuration
  queue: {
    name: 'orders',
    concurrencyLimit: 10,
  },

  // Machine resources
  machine: {
    preset: 'medium',
  },

  // Maximum duration
  maxDuration: 60000,  // 1 minute

  // Lifecycle hooks
  onStart: async (payload, ctx) => {
    console.log(`Starting task ${ctx.task.id}`)
  },

  onSuccess: async (payload, output, ctx) => {
    console.log(`Task completed:`, output)
  },

  onFailure: async (payload, error, ctx) => {
    console.error(`Task failed:`, error.message)
  },

  run: async (payload, { ctx }) => {
    return {
      orderId: payload.orderId,
      status: 'processed',
      processedAt: new Date(),
    }
  },
})
```

## Context Operations (ctx.run)

Execute sub-steps with automatic memoization and replay:

```typescript
export const complexWorkflow = task({
  id: 'complex-workflow',
  run: async (payload, { ctx }) => {
    // Each step is memoized - on replay, cached results are returned
    const user = await ctx.run('fetch-user', async () => {
      return await db.users.findById(payload.userId)
    })

    const order = await ctx.run('create-order', async () => {
      return await db.orders.create({
        userId: user.id,
        items: payload.items,
      })
    })

    // Steps can depend on previous step results
    const payment = await ctx.run('process-payment', async () => {
      return await stripe.charges.create({
        amount: order.total,
        customer: user.stripeId,
      })
    })

    // Access run context
    console.log('Run ID:', ctx.run.id)
    console.log('Attempt:', ctx.attempt.number)
    console.log('Is test:', ctx.run.isTest)

    return { orderId: order.id, paymentId: payment.id }
  },
})
```

## Batch Operations

### Batch Trigger

```typescript
const { runs } = await processOrder.batchTrigger([
  { orderId: '1', userId: 'user_1', items: [] },
  { orderId: '2', userId: 'user_2', items: [] },
  { orderId: '3', userId: 'user_3', items: [] },
])

// Each run has its own handle
runs.forEach(run => console.log(run.id))
```

### Batch Trigger and Wait

```typescript
const { runs } = await processOrder.batchTriggerAndWait([
  { orderId: '1', userId: 'user_1', items: [] },
  { orderId: '2', userId: 'user_2', items: [] },
])

const successful = runs.filter(r => r.ok)
const failed = runs.filter(r => !r.ok)
```

## Trigger Options

```typescript
await processOrder.trigger(payload, {
  // Idempotency - prevent duplicate processing
  idempotencyKey: `order-${payload.orderId}`,
  idempotencyKeyTTL: '24h',

  // Delay execution
  delay: '5m',  // or delay: 300000 (ms) or delay: new Date('2024-12-25')

  // Tags for filtering/querying
  tags: ['high-priority', 'vip-customer'],

  // Queue override
  queue: { name: 'priority-orders', concurrencyLimit: 5 },

  // Concurrency control
  concurrencyKey: `user-${payload.userId}`,

  // Override max attempts
  maxAttempts: 10,

  // Custom metadata
  metadata: { source: 'api', version: '2.0' },
})
```

## Wait Utilities

Durable wait operations that persist across restarts:

```typescript
import { wait } from '@dotdo/trigger'

// Wait for a duration
await wait.for({ seconds: 30 })
await wait.for({ minutes: 5 })
await wait.for({ hours: 2 })
await wait.for({ days: 1 })

// Combine units
await wait.for({ hours: 1, minutes: 30 })

// Wait until a specific time
await wait.until(new Date('2024-12-25T00:00:00Z'))
```

## Retry Utilities

```typescript
import { retry } from '@dotdo/trigger'

// Use presets
const defaultRetry = retry.preset('default')      // 3 attempts, exponential backoff
const aggressiveRetry = retry.preset('aggressive') // 10 attempts, faster backoff
const patientRetry = retry.preset('patient')       // 5 attempts, longer delays

// Exponential backoff
const exponential = retry.exponential(5, {
  minTimeout: 1000,   // Start at 1s
  maxTimeout: 60000,  // Cap at 60s
})

// Linear backoff (constant delay)
const linear = retry.linear(3, 5000)  // 3 attempts, 5s between each

// Apply to task
export const myTask = task({
  id: 'my-task',
  retry: retry.exponential(5),
  run: async (payload) => {
    // ...
  },
})
```

## Queue Utilities

```typescript
import { queue, task } from '@dotdo/trigger'

// Create a queue configuration
const orderQueue = queue.create('orders', {
  concurrency: 10,  // Max 10 concurrent executions
  rateLimit: {
    limit: 100,
    period: '1m',   // 100 per minute
  },
})

// Apply to task
export const processOrder = task({
  id: 'process-order',
  queue: orderQueue,
  run: async (payload) => {
    // At most 10 running concurrently, 100/min
  },
})
```

## Middleware

Extend task functionality with middleware:

```typescript
import { task, type TaskMiddleware } from '@dotdo/trigger'

const loggingMiddleware: TaskMiddleware = {
  name: 'logging',

  // Called once when worker starts
  init: async () => {
    console.log('Logging middleware initialized')
  },

  // Transform payload before enqueueing
  onEnqueue: async (payload) => {
    console.log('Enqueueing task:', payload)
    return payload
  },

  // Called before task execution
  beforeRun: async (payload, ctx) => {
    console.log(`Starting ${ctx.task.id} (run: ${ctx.run.id})`)
  },

  // Called after successful execution
  afterRun: async (payload, output, ctx) => {
    console.log(`Completed ${ctx.task.id}:`, output)
  },

  // Called on error
  onError: async (payload, error, ctx) => {
    console.error(`Failed ${ctx.task.id}:`, error.message)
  },
}

export const processOrder = task({
  id: 'process-order',
  middleware: [loggingMiddleware],
  run: async (payload) => {
    // ...
  },
})
```

## Scheduled Tasks

Create cron-triggered tasks:

```typescript
import { schedules } from '@dotdo/trigger'

export const dailyReport = schedules({
  id: 'daily-report',
  cron: '0 9 * * MON-FRI',  // Weekdays at 9 AM
  timezone: 'America/New_York',

  run: async (payload, { ctx }) => {
    const report = await generateReport()
    await sendEmail(report)
    return { sentAt: new Date() }
  },
})
```

## Abort Utility

Gracefully abort task execution without retries:

```typescript
import { abort, AbortTaskRunError } from '@dotdo/trigger'

export const validateOrder = task({
  id: 'validate-order',
  run: async (payload) => {
    if (!payload.orderId) {
      // Immediately abort - no retries
      abort('Missing orderId')
    }

    const order = await fetchOrder(payload.orderId)

    if (order.status === 'cancelled') {
      abort('Order has been cancelled')
    }

    return { valid: true }
  },
})
```

## Testing

@dotdo/trigger is ideal for unit tests - no external infrastructure required:

```typescript
import { describe, it, expect } from 'vitest'
import { task } from '@dotdo/trigger'

describe('my task', () => {
  it('should process payload', async () => {
    const myTask = task({
      id: 'test-task',
      run: async (payload: { x: number }) => payload.x * 2,
    })

    const result = await myTask.triggerAndWait({ x: 5 })

    expect(result.ok).toBe(true)
    expect(result.output).toBe(10)
  })

  it('should handle errors', async () => {
    const failingTask = task({
      id: 'failing-task',
      run: async () => {
        throw new Error('Task failed')
      },
    })

    const result = await failingTask.triggerAndWait({})

    expect(result.ok).toBe(false)
    expect(result.error?.message).toBe('Task failed')
  })
})
```

### Configure In-Memory Storage

For development and testing, configure in-memory storage:

```typescript
import { task, configure } from '@dotdo/trigger'
import { InMemoryStepStorage } from '@dotdo/workflows/runtime'

// Configure in-memory storage for local development
configure({
  storage: new InMemoryStepStorage(),
})

// Tasks execute immediately in-process
const result = await myTask.triggerAndWait({ value: 42 })
console.log(result.output)
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { task, configure } from '@dotdo/trigger'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const processRequest = task({
      id: 'process-request',
      run: async (payload: { url: string }) => {
        const data = await fetch(payload.url).then(r => r.json())
        return { processed: true, data }
      },
    })

    const result = await processRequest.triggerAndWait({
      url: 'https://api.example.com/data',
    })

    return Response.json(result)
  },
}
```

## API Reference

### Task Factory

| Function | Parameters | Returns | Description |
|----------|------------|---------|-------------|
| `task<P, O>(config)` | `TaskConfig<P, O>` | `Task<P, O>` | Create a new task |
| `schedules<P, O>(config)` | `ScheduledTaskConfig<P, O>` | `Task<P, O>` | Create a scheduled task |
| `configure(config)` | `GlobalConfig` | `void` | Set global configuration |

### TaskConfig Options

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `id` | `string` | required | Unique task identifier |
| `version` | `string` | - | Task version |
| `retry` | `RetryConfig` | - | Retry configuration |
| `queue` | `QueueConfig` | - | Queue configuration |
| `machine` | `MachineConfig` | - | Resource allocation |
| `maxDuration` | `number` | - | Maximum run duration (ms) |
| `middleware` | `TaskMiddleware[]` | - | Middleware chain |
| `onStart` | `(payload, ctx) => void` | - | Start lifecycle hook |
| `onSuccess` | `(payload, output, ctx) => void` | - | Success lifecycle hook |
| `onFailure` | `(payload, error, ctx) => void` | - | Failure lifecycle hook |
| `handleError` | `(payload, error, ctx) => void` | - | Custom error handler |
| `init` | `() => void` | - | Worker initialization |
| `cleanup` | `() => void` | - | Worker cleanup |
| `run` | `(payload, { ctx }) => output` | required | Task implementation |

### Task Instance Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `trigger(payload, opts?)` | `TPayload, TriggerOptions?` | `Promise<TriggerResult>` | Fire and forget |
| `triggerAndWait(payload, opts?)` | `TPayload, TriggerOptions?` | `Promise<TaskRunResult<O>>` | Await completion |
| `batchTrigger(items, opts?)` | `TPayload[], TriggerOptions?` | `Promise<{ runs: TriggerResult[] }>` | Batch trigger |
| `batchTriggerAndWait(items, opts?)` | `TPayload[], TriggerOptions?` | `Promise<{ runs: TaskRunResult<O>[] }>` | Batch await |

### TaskRunHandle

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `id` | `string` | Run identifier |
| `result()` | `Promise<unknown>` | Poll for result |
| `status()` | `Promise<TaskRunStatus>` | Get current status |
| `cancel()` | `Promise<void>` | Cancel the run |

### TaskRunStatus

```typescript
type TaskRunStatus =
  | 'PENDING'
  | 'QUEUED'
  | 'EXECUTING'
  | 'COMPLETED'
  | 'FAILED'
  | 'CANCELED'
  | 'TIMED_OUT'
```

### TaskContext Properties

| Property | Type | Description |
|----------|------|-------------|
| `run` | `TaskRunContext` | Run context (also callable for ctx.run) |
| `run.id` | `string` | Unique run identifier |
| `run.tags` | `string[]` | Run tags |
| `run.isTest` | `boolean` | Whether this is a test run |
| `run.createdAt` | `Date` | When run was created |
| `run.startedAt` | `Date` | When execution started |
| `run.idempotencyKey` | `string?` | Idempotency key if provided |
| `task.id` | `string` | Task identifier |
| `task.version` | `string?` | Task version |
| `attempt.id` | `string` | Attempt identifier |
| `attempt.number` | `number` | Attempt number (1-indexed) |

### Wait Utilities

| Method | Parameters | Description |
|--------|------------|-------------|
| `wait.for(duration)` | `{ seconds?, minutes?, hours?, days? }` | Wait for duration |
| `wait.until(date)` | `Date` | Wait until specific time |

### Retry Utilities

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `retry.preset(name)` | `'default' \| 'aggressive' \| 'patient'` | `RetryConfig` | Get preset config |
| `retry.exponential(max, opts?)` | `number, { minTimeout?, maxTimeout? }` | `RetryConfig` | Exponential backoff |
| `retry.linear(max, delay)` | `number, number` | `RetryConfig` | Linear backoff |

### Queue Utilities

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `queue.create(name, opts?)` | `string, { concurrency?, rateLimit? }` | `QueueConfig` | Create queue config |

### Error Classes

| Class | Description |
|-------|-------------|
| `AbortTaskRunError` | Thrown by `abort()` to stop execution without retry |

## Migration from @trigger.dev/sdk

### Package Change

```bash
# Remove
npm uninstall @trigger.dev/sdk

# Install
npm install @dotdo/trigger
```

### Import Change

```typescript
// Before
import { task, wait, retry, queue } from '@trigger.dev/sdk/v3'

// After
import { task, wait, retry, queue } from '@dotdo/trigger'

// Code compatibility - no changes needed
```

## Related

- [trigger.do](/docs/integrations/trigger/service) - Managed edge background jobs
- [Workflows Overview](/docs/workflows) - Workflow primitives and DSL
- [Events Overview](/docs/events) - Event-driven patterns
