---
title: Firebase
description: Choose between @dotdo/firebase (OSS package) and firebase.do (managed edge service) for your Firebase needs.
---

# Firebase Integration

dotdo provides two ways to work with Firebase-compatible APIs:

| | @dotdo/firebase | firebase.do |
|---|-----------------|-------------|
| **Type** | OSS npm package | Managed edge service |
| **Storage** | In-memory | Durable Object SQLite |
| **Persistence** | None (resets on restart) | Full durability |
| **Use case** | Testing, prototyping | Production workloads |
| **Infrastructure** | Zero | Zero (we manage it) |
| **Install** | `npm install @dotdo/firebase` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/firebase - In-memory, great for tests
import { initializeApp, getFirestore, collection, addDoc } from '@dotdo/firebase'

const app = initializeApp({ projectId: 'test' })
const db = getFirestore(app)
await addDoc(collection(db, 'users'), { name: 'Alice' })
// Data lost on restart
```

```typescript
// firebase.do - Persistent edge database
import { initializeApp, getFirestore, collection, addDoc } from 'firebase.do'

const app = initializeApp({ projectId: 'my-app' })
const db = getFirestore(app)
await addDoc(collection(db, 'users'), { name: 'Alice' })
// Data persists globally
```

## When to Use Each

### Use @dotdo/firebase when:

- **Unit testing** - Fast, isolated tests without external dependencies
- **Prototyping** - Quick iteration without infrastructure setup
- **Edge functions** - Need Firebase API but no persistence required
- **CI/CD pipelines** - Tests that need Firebase semantics without emulators

<Callout type="info">
@dotdo/firebase is a complete in-memory Firebase implementation. Perfect for tests and development, but data doesn't persist between restarts.
</Callout>

### Use firebase.do when:

- **Production applications** - Real user data that must persist
- **Global edge deployment** - Data close to users worldwide
- **Real-time features** - Live updates via Pusher compat layer
- **Firebase migration** - Drop-in replacement for existing Firebase code

<Callout type="info">
firebase.do is Firebase on the Edge - a fully managed service running on Cloudflare's global network with zero infrastructure to manage.
</Callout>

## Feature Comparison

| Feature | @dotdo/firebase | firebase.do |
|---------|-----------------|-------------|
| Firestore CRUD | Full | Full |
| Realtime Database | Full | Full |
| Queries & Filters | Full (12+ operators) | Full (12+ operators) |
| Real-time Listeners | Local only | Global via Pusher compat |
| Transactions | Full | Full ACID |
| Batch Writes | Full | Full |
| Field Values | Full | Full |
| Aggregation | Full | Full |
| Firebase Auth | - | Coming soon |
| Firebase Storage | - | Coming soon |
| Security Rules | - | Coming soon |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/firebase/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/firebase</h3>
    <p className="text-sm text-muted-foreground">In-memory Firebase for testing and development</p>
  </a>
  <a href="/docs/integrations/firebase/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">firebase.do</h3>
    <p className="text-sm text-muted-foreground">Managed Firebase on the edge for production</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/firebase` for development, then deploy to `firebase.do` for production:

```typescript
// Development (package)
import { initializeApp, getFirestore, collection, addDoc } from '@dotdo/firebase'

const app = initializeApp({ projectId: 'local-test' })
const db = getFirestore(app)

// Production (service) - same API!
import { initializeApp, getFirestore, collection, addDoc } from 'firebase.do'

const app = initializeApp({ projectId: 'my-app' })
const db = getFirestore(app)

// Your application code stays the same
await addDoc(collection(db, 'users'), { name: 'Alice', email: 'alice@example.com' })
```

Both packages share the same Firebase-compatible API, making migration seamless.

## Architecture Comparison

### @dotdo/firebase

```
+------------------------------------------+
|            Your Application               |
|                                          |
|  import { ... } from '@dotdo/firebase'   |
+------------------------------------------+
                    |
        +-----------+-----------+
        |                       |
        v                       v
+---------------+     +------------------+
|  Local Mode   |     | Production Mode  |
|  (In-memory)  |     | (Real Firebase)  |
+---------------+     +------------------+
```

### firebase.do

```
+------------------------------------------+
|            Your Application               |
|                                          |
|  import { ... } from 'firebase.do'       |
+------------------------------------------+
                    |
                    v
+------------------------------------------+
|           firebase.do Worker             |
+------------------------------------------+
|  FirestoreDO  |  RealtimeDO  |  AuthDO   |
+------------------------------------------+
|        Durable Object SQLite             |
+------------------------------------------+
|              Pusher Compat               |
|          (Real-time Updates)             |
+------------------------------------------+
```

Both approaches support the same Firebase patterns (Firestore, Realtime Database, real-time listeners) - choose based on whether you need local testing or production edge deployment.
