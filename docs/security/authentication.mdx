---
title: Authentication
description: Federated identity for humans and AI agents with org.ai
---

# Authentication

Identity that works for humans and AI. Every actor in your system is verifiable.

## org.ai Identity

org.ai provides federated identity across the dotdo ecosystem. One identity system for humans, agents, and organizations.

```typescript
import { auth } from 'org.ai'

// Verify any incoming request
const user = await auth.verify(request)

if (user.type === 'human') {
  // Human authenticated via org.ai
  console.log(`Human: ${user.email}`)
} else if (user.type === 'agent') {
  // AI agent with verifiable identity
  console.log(`Agent: ${user.name}`) // e.g., "Tom"
}
```

## Why org.ai?

Traditional auth systems assume humans. When AI agents start taking actions - sending emails, opening PRs, making purchases - you need answers:

- Was this action taken by a human or an agent?
- Which agent? Acting on whose behalf?
- What permissions were granted?

org.ai answers all of these.

## User Object

When you verify a request, you get a user object:

```typescript
interface User {
  id: string           // Unique identifier
  type: 'human' | 'agent'
  email: string        // Real email (tom@agents.do for agents)
  name: string         // Display name
  organization?: string // Org membership
  roles: string[]      // Assigned roles
  metadata: Record<string, unknown>
}
```

## Human Authentication

Humans authenticate through standard OAuth flows:

```typescript
import { auth } from 'org.ai'

// Redirect to org.ai login
export function login(request: Request) {
  return auth.redirect({
    callbackUrl: '/auth/callback',
    scopes: ['read', 'write'],
  })
}

// Handle the callback
export async function callback(request: Request) {
  const user = await auth.handleCallback(request)

  // Create session
  const session = await createSession(user)

  return redirect('/', {
    headers: { 'Set-Cookie': session.cookie },
  })
}
```

## Agent Identity

Agents have real identity - not just API keys. Each named agent has:

| Property | Example |
|----------|---------|
| Email | `tom@agents.do` |
| GitHub | `@tom-do` |
| Avatar | Consistent across platforms |
| Org membership | Can belong to your organization |

```typescript
import { tom } from 'agents.do'

// Tom's actions are traceable
const review = await tom`review this PR`

// The PR comment shows @tom-do, not "AI Assistant"
```

## Verifying Requests

Every API endpoint should verify the caller:

```typescript
export async function handleRequest(request: Request) {
  const user = await auth.verify(request)

  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  // Check specific conditions
  if (user.type === 'agent' && !user.roles.includes('api-access')) {
    return new Response('Agent not authorized for API access', {
      status: 403
    })
  }

  // Proceed with verified user
  return handleAuthorizedRequest(request, user)
}
```

## Token Types

org.ai issues different token types for different contexts:

| Token Type | Use Case | Lifetime |
|------------|----------|----------|
| **Access Token** | API requests | 1 hour |
| **Refresh Token** | Token renewal | 30 days |
| **Agent Token** | Agent-to-agent calls | Per-task |
| **Service Token** | Backend services | Configurable |

```typescript
// Refresh an expired token
const newTokens = await auth.refresh(refreshToken)
```

## Multi-Tenant Authentication

For SaaS applications, scope authentication to tenants:

```typescript
const user = await auth.verify(request, {
  tenant: 'acme-corp',
})

// User must be member of acme-corp organization
if (!user) {
  return new Response('Not a member of this organization', {
    status: 403
  })
}
```

## Session Management

```typescript
import { auth, sessions } from 'org.ai'

// Create a session after authentication
const session = await sessions.create(user, {
  expiresIn: '7d',
  metadata: { loginIp: request.ip },
})

// Validate session on subsequent requests
const user = await sessions.validate(sessionToken)

// Revoke session (logout)
await sessions.revoke(sessionToken)

// Revoke all sessions for a user
await sessions.revokeAll(user.id)
```

## Authentication Events

Track authentication events for security monitoring:

```typescript
$.on.Auth.success(async ($, { user, method }) => {
  await $.audit.log('auth.success', {
    user: user.id,
    method, // 'oauth', 'token', 'api-key'
    ip: $.request.ip,
  })
})

$.on.Auth.failure(async ($, { reason, ip }) => {
  await $.audit.log('auth.failure', { reason, ip })

  // Alert on suspicious patterns
  if (await detectBruteForce(ip)) {
    await $.alert.security('Potential brute force attack', { ip })
  }
})
```

## Best Practices

### Always Verify

Never assume a request is authenticated. Always verify.

```typescript
// Good
const user = await auth.verify(request)
if (!user) return unauthorized()

// Bad - assuming authentication
const userId = request.headers.get('X-User-Id') // Forgeable!
```

### Use Short-Lived Tokens

Access tokens should expire quickly. Use refresh tokens for longer sessions.

### Log Authentication Events

Every login, logout, and failure should be logged for security audits.

### Scope Agent Permissions

Don't give agents blanket access. Scope their permissions to what they need.

```typescript
import { tom } from 'agents.do'

// Tom can only access code review functions
const scopedTom = tom.withScope(['code.read', 'pr.comment'])
```

## Related

- [Authorization](/docs/security/authorization) - Role-based access control
- [Vault](/docs/security/vault) - Secure credential storage
- [Human Escalation](/docs/humans) - When to involve humans
