---
title: Authorization
description: Role-based permissions and access control for humans and agents
---

# Authorization

Define what each actor can do. Same rules for humans and agents.

## The Basics

Authorization in dotdo uses a simple pattern: Nouns and Verbs.

```typescript
$.authorize({
  'Customer.read': ['user', 'admin'],
  'Customer.write': ['admin'],
  'Order.create': ['user', 'admin'],
  'Refund.approve': ['finance', 'admin'],
})
```

When a user with the `user` role tries to read a Customer, it works. When they try to write, it fails.

## Role-Based Access Control

Roles are collections of permissions. Users and agents are assigned roles.

```typescript
// Define roles
const roles = {
  user: ['Customer.read', 'Order.create', 'Order.read'],
  finance: ['Refund.approve', 'Payment.read', 'Payment.write'],
  admin: ['*'], // Full access
}

// Assign roles to users
await $.users.assignRole('user_123', 'finance')

// Check role membership
if (user.roles.includes('finance')) {
  // Can approve refunds
}
```

## Permission Format

Permissions follow the `Noun.verb` pattern:

| Permission | Meaning |
|------------|---------|
| `Customer.read` | Read customer data |
| `Customer.write` | Create or update customers |
| `Customer.delete` | Delete customers |
| `Order.create` | Create new orders |
| `Refund.approve` | Approve refund requests |
| `*` | All permissions (admin) |

## Declarative Authorization

Define your entire permission structure upfront:

```typescript
$.authorize({
  // Customer operations
  'Customer.read': ['user', 'support', 'admin'],
  'Customer.write': ['support', 'admin'],
  'Customer.delete': ['admin'],

  // Order operations
  'Order.read': ['user', 'support', 'admin'],
  'Order.create': ['user', 'admin'],
  'Order.cancel': ['support', 'admin'],

  // Financial operations
  'Payment.read': ['finance', 'admin'],
  'Payment.refund': ['finance', 'admin'],
  'Refund.approve': ['senior-finance', 'admin'],

  // System operations
  'System.configure': ['admin'],
  'Audit.read': ['compliance', 'admin'],
})
```

## Checking Permissions

### In Event Handlers

```typescript
$.on.Customer.update(async ($, { customerId, data }) => {
  // Permission is checked automatically based on $.authorize config
  // If user lacks Customer.write, this handler won't execute

  await $.db.customers.update(customerId, data)
})
```

### Manual Checks

```typescript
$.on.Refund.request(async ($, { amount, orderId }) => {
  // Dynamic permission check
  if (amount > 10000) {
    const canApprove = await $.can('Refund.approve')

    if (!canApprove) {
      return $.escalate.to('senior-finance', {
        reason: 'High-value refund requires senior approval',
        amount,
        orderId,
      })
    }
  }

  await processRefund(orderId, amount)
})
```

### In API Routes

```typescript
export async function updateCustomer(request: Request) {
  const user = await auth.verify(request)

  if (!await $.can('Customer.write', user)) {
    return new Response('Forbidden', { status: 403 })
  }

  // Proceed with update
}
```

## Agent Permissions

Agents follow the same permission model as humans. Assign roles to agents just like users.

```typescript
import { ralph, tom, sally } from 'agents.do'

// Ralph can build but not deploy
await $.agents.assignRole('ralph', 'developer')

// Tom can review and merge
await $.agents.assignRole('tom', 'tech-lead')

// Sally can access customer data for sales
await $.agents.assignRole('sally', 'sales')
```

Define what each agent role can do:

```typescript
$.authorize({
  // Developer role
  'Code.write': ['developer', 'tech-lead'],
  'PR.create': ['developer', 'tech-lead'],

  // Tech lead additions
  'PR.merge': ['tech-lead'],
  'Deploy.staging': ['tech-lead'],
  'Deploy.production': ['admin'],

  // Sales role
  'Customer.read': ['sales', 'support', 'admin'],
  'Lead.create': ['sales'],
  'Deal.update': ['sales'],
})
```

## Resource-Level Permissions

Sometimes you need permissions scoped to specific resources:

```typescript
$.authorize({
  // Project-scoped permissions
  'Project.read': async (user, projectId) => {
    return await isProjectMember(user.id, projectId)
  },

  // Ownership-based permissions
  'Order.cancel': async (user, orderId) => {
    const order = await $.db.orders.get(orderId)
    return order.userId === user.id || user.roles.includes('admin')
  },
})
```

## Permission Inheritance

Build permission hierarchies:

```typescript
const roleHierarchy = {
  admin: ['manager', 'user'],      // Admin inherits from manager and user
  manager: ['user'],               // Manager inherits from user
  user: [],                        // Base role
}

// Admin automatically gets all user and manager permissions
```

## Conditional Permissions

Permissions can depend on context:

```typescript
$.authorize({
  'Refund.approve': async (user, context) => {
    // Amount-based rules
    if (context.amount <= 100) {
      return user.roles.includes('support')
    }
    if (context.amount <= 1000) {
      return user.roles.includes('finance')
    }
    return user.roles.includes('senior-finance')
  },
})
```

## Audit Trail

Every permission check is logged:

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "actor": {
    "type": "human",
    "id": "user_123",
    "email": "alice@example.com"
  },
  "permission": "Refund.approve",
  "resource": "refund_456",
  "result": "denied",
  "reason": "User lacks senior-finance role",
  "context": {
    "amount": 15000
  }
}
```

## Common Patterns

### Tiered Access

```typescript
$.authorize({
  // Read: many roles
  'Analytics.read': ['analyst', 'manager', 'exec', 'admin'],

  // Write: fewer roles
  'Analytics.configure': ['manager', 'admin'],

  // Delete: most restrictive
  'Analytics.delete': ['admin'],
})
```

### Feature Flags as Permissions

```typescript
$.authorize({
  'Feature.beta-dashboard': ['beta-tester', 'admin'],
  'Feature.new-checkout': ['ab-test-group-b', 'admin'],
})

// In your code
if (await $.can('Feature.beta-dashboard')) {
  return <BetaDashboard />
}
```

### Time-Based Permissions

```typescript
$.authorize({
  'Deploy.production': async (user) => {
    // No production deploys on weekends
    const day = new Date().getDay()
    if (day === 0 || day === 6) {
      return user.roles.includes('oncall')
    }
    return user.roles.includes('developer')
  },
})
```

## Best Practices

### Principle of Least Privilege

Give the minimum permissions needed. Start restrictive, add as needed.

```typescript
// Good: Specific permissions
await $.agents.assignRole('ralph', 'code-writer')

// Bad: Overly broad
await $.agents.assignRole('ralph', 'admin')
```

### Audit Regularly

Review who has what permissions. Remove stale access.

```typescript
// List all users with admin role
const admins = await $.users.withRole('admin')

// List all permissions for a user
const permissions = await $.users.permissions('user_123')
```

### Fail Closed

When in doubt, deny. Never assume a user has permission.

```typescript
// Good: Explicit check
if (!await $.can('Resource.action')) {
  return forbidden()
}

// Bad: Assuming permission
// (no check at all)
```

## Related

- [Authentication](/docs/security/authentication) - Identity verification
- [Vault](/docs/security/vault) - Secure credential storage
- [Human Escalation](/docs/humans/escalation) - Escalating for approval
