---
title: Security Hardening Guide
description: Technical security best practices, OWASP guidelines, and deployment checklists for dotdo applications
---

# Security Hardening Guide

This guide provides technical security hardening practices for dotdo applications. It covers implementation details, common vulnerabilities, and deployment checklists aligned with OWASP guidelines.

## OWASP Top 10 Coverage

dotdo provides built-in protections for the OWASP Top 10 vulnerabilities:

| OWASP Category | dotdo Protection | Implementation |
|----------------|------------------|----------------|
| A01: Broken Access Control | RBAC, tenant isolation | `$auth` static config, `checkOrgAccess()` |
| A02: Cryptographic Failures | JWT signing, HTTPS | `createAuthMiddleware()`, secure cookies |
| A03: Injection | Parameterized queries | Drizzle ORM, input validation |
| A04: Insecure Design | Auth middleware | `requireAuth`, defense in depth |
| A05: Security Misconfiguration | Production requirements | JWT secret required in prod |
| A06: Vulnerable Components | Dependency management | Regular updates, audit logs |
| A07: Auth Failures | better-auth, rate limiting | Session management, API keys |
| A08: Data Integrity Failures | Request signing | HMAC validation, nonce checking |
| A09: Logging Failures | Structured logging | Audit trails, security events |
| A10: SSRF | URL validation | Domain allowlists, redirect validation |

---

## JWT Token Security

### Mandatory Security Checks

The auth layer (`objects/transport/auth-layer.ts`) enforces critical protections:

```typescript
// CRITICAL: Always reject unsigned tokens (algorithm confusion attack)
// This is checked BEFORE signature verification to prevent alg:none bypass
if (!header.alg || header.alg.toLowerCase() === 'none') {
  return {
    success: false,
    error: 'Token validation failed: unsigned tokens not allowed',
    statusCode: 401,
  }
}

// CRITICAL: Signature verification is MANDATORY
// If no secret is configured, reject all tokens
if (!jwtSecret) {
  return {
    success: false,
    error: 'Token validation failed: signature verification required',
    statusCode: 401,
  }
}

// Verify signature using constant-time comparison
const isValid = await verifyJWTSignature(token, jwtSecret, header.alg)
if (!isValid) {
  return { success: false, error: 'Token validation failed: invalid signature' }
}
```

### Production Requirements

```typescript
// In production (NODE_ENV=production), jwtSecret is REQUIRED
// This throws if attempting to create middleware without a secret
const isProduction = process.env.NODE_ENV === 'production'

if (isProduction && !jwtSecret) {
  throw new Error(
    'JWT secret is required in production. ' +
    'Set the jwtSecret option or configure NODE_ENV=development for testing.'
  )
}
```

### Secure Token Generation

```typescript
async function generateToken(userId: string): Promise<string> {
  const header = { alg: 'HS256', typ: 'JWT' }
  const now = Math.floor(Date.now() / 1000)
  const payload = {
    sub: userId,
    iat: now,
    exp: now + 3600,        // 1 hour expiration
    iss: 'https://id.org.ai',
    aud: 'dotdo',
  }

  // Use Web Crypto API for HMAC-SHA256 signing
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(jwtSecret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )

  const signatureBuffer = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(signatureInput)
  )

  return `${b64Header}.${b64Payload}.${b64Signature}`
}
```

---

## Input Validation

### Form Validation

The validation module (`lib/human/validation.ts`) provides comprehensive input validation:

```typescript
import { validateForm, validateSchema, HumanValidationError } from 'dotdo/lib/human/validation'

const form: FormDefinition = {
  fields: [
    {
      name: 'email',
      type: 'string',
      required: true,
      validation: async (value) => {
        // Custom validation logic
        if (!value.includes('@')) return 'Invalid email format'
        if (value.length > 254) return 'Email too long'
        return true
      }
    },
    {
      name: 'amount',
      type: 'number',
      required: true,
      validation: (value) => {
        if (value < 0) return 'Amount must be positive'
        if (value > 1000000) return 'Amount exceeds maximum'
        return true
      }
    },
    {
      name: 'category',
      type: 'select',
      options: ['sales', 'support', 'billing'], // Allowlist
      required: true,
    }
  ]
}

const result = await validateForm(form, userInput, true)
if (!result.valid) {
  throw result.error // HumanValidationError with field names
}
```

### Path Traversal Prevention

The `AuthorizedR2Client` (`lib/storage/authorized-r2.ts`) prevents path traversal:

```typescript
// Path validation patterns
const SAFE_PATH_SEGMENT = /^[a-zA-Z0-9_\-\.]+$/
const TRAVERSAL_PATTERN = /\.\./

private validateSegment(segment: string, name: string): void {
  if (TRAVERSAL_PATTERN.test(segment)) {
    throw new Error(`Path traversal detected in ${name}`)
  }
}

private buildPath(...segments: (string | undefined)[]): string {
  const filtered = segments.filter((s): s is string => Boolean(s))

  // Validate ALL segments for path traversal
  for (const segment of filtered) {
    if (TRAVERSAL_PATTERN.test(segment)) {
      throw new Error('Path traversal detected')
    }
  }

  return filtered.join('/').replace(/\/+/g, '/')
}
```

### SQL Injection Prevention

Always use parameterized queries with Drizzle ORM:

```typescript
// SAFE: Parameterized query - user input is escaped
const user = await db.query.users.findFirst({
  where: (t, { eq }) => eq(t.email, userInput)
})

// SAFE: Using Drizzle schema with proper types
await db.insert(schema.users).values({
  id: crypto.randomUUID(),
  email: sanitizedEmail,
  createdAt: new Date(),
})

// DANGEROUS: Never use raw string interpolation
// const result = await db.execute(sql`SELECT * FROM users WHERE email = '${userInput}'`)
```

---

## API Key Security

### Key Format Validation

```typescript
async function validateApiKey(key: string): Promise<AuthContext | null> {
  // Validate format with strict regex
  const isStandardFormat = key.match(/^dk_live_[a-f0-9]{32}$/)
  const isPremiumFormat = key.match(/^dk_live_premium_[a-f0-9]{32}$/)

  if (!isStandardFormat && !isPremiumFormat) {
    return null // Invalid format
  }

  // Check revocation status
  if (key.includes('revoked')) {
    return null
  }

  // Use custom validator if provided
  if (validator) {
    const info = await validator(key)
    if (!info || info.revoked) return null
    // Build auth context from validated key info
  }

  return authContext
}
```

### Rate Limiting Configuration

```typescript
// better-auth API key configuration
apiKey({
  defaultPrefix: 'sk_',
  rateLimit: {
    enabled: true,
    timeWindow: 1000 * 60 * 60, // 1 hour window
    maxRequests: 1000,          // 1000 requests per hour
  },
})

// Method-level rate limiting via $auth
static $auth = {
  sensitiveEndpoint: {
    requireAuth: true,
    rateLimit: { requests: 10, window: '1m' }
  },
  normalEndpoint: {
    requireAuth: true,
    rateLimit: { requests: 100, window: '1h' }
  }
}
```

---

## Request Signing (HMAC)

### Signature Validation

```typescript
export async function validateRequestSignature(
  request: { timestamp: string; body: string; signature: string },
  secret: string,
  options?: { timestampTolerance?: number }
): Promise<{ valid: boolean; error?: string }> {
  const tolerance = options?.timestampTolerance ?? 5 * 60 * 1000 // 5 minutes

  // Validate timestamp to prevent replay attacks
  const timestamp = parseInt(request.timestamp, 10)
  const now = Date.now()

  if (isNaN(timestamp)) {
    return { valid: false, error: 'Invalid timestamp' }
  }

  if (Math.abs(now - timestamp) > tolerance) {
    return { valid: false, error: 'Stale timestamp' }
  }

  // Parse and validate signature format
  const signatureMatch = request.signature.match(/^v1=(.+)$/)
  if (!signatureMatch) {
    return { valid: false, error: 'Invalid signature format' }
  }

  // Compute expected signature using HMAC-SHA256
  const signatureInput = `${request.timestamp}.${request.body}`
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )

  const expectedSignature = await crypto.subtle.sign('HMAC', key, encoder.encode(signatureInput))

  // Compare signatures (Web Crypto provides timing-safe comparison)
  if (providedSignature !== btoa(String.fromCharCode(...new Uint8Array(expectedSignature)))) {
    return { valid: false, error: 'Invalid signature' }
  }

  return { valid: true }
}
```

### Nonce-Based Replay Prevention

```typescript
// Check for duplicate nonces
const nonce = request.headers.get('X-Nonce')
if (nonce) {
  if (nonceStorage) {
    if (await nonceStorage.has(nonce)) {
      return {
        success: false,
        error: 'Duplicate nonce - potential replay attack',
        statusCode: 401,
      }
    }
    await nonceStorage.add(nonce, Date.now() + 60000) // 1 minute expiry
  } else {
    // In-memory fallback with cleanup
    if (usedNonces.has(nonce)) {
      return { success: false, error: 'Duplicate nonce' }
    }
    usedNonces.add(nonce)
    if (usedNonces.size > 10000) {
      usedNonces.clear() // Prevent memory exhaustion
    }
  }
}
```

---

## Cross-Domain Security

### Open Redirect Prevention

```typescript
// auth/config.ts - Validate redirect URLs against allowed patterns
async function validateDomain(
  domain: string,
  patterns: string[],
  resolveTenantNs: (domain: string) => Promise<string | null>
): Promise<boolean> {
  // Check against explicit patterns
  for (const pattern of patterns) {
    if (matchDomainPattern(domain, pattern)) {
      return true
    }
  }

  // Check if it's a verified custom domain
  const tenantNs = await resolveTenantNs(domain)
  return tenantNs !== null
}

function matchDomainPattern(domain: string, pattern: string): boolean {
  // Convert wildcard pattern to regex (escape dots, convert * to [^.]+)
  const regex = new RegExp(
    '^' + pattern.replace(/\./g, '\\.').replace(/\*/g, '[^.]+') + '$'
  )
  return regex.test(domain)
}
```

### Cross-Domain Token Exchange

```typescript
// Generate one-time token with short expiry
async function generateCrossDomainToken(db, sessionId: string): Promise<string> {
  const token = crypto.randomUUID()

  await db.insert(schema.verifications).values({
    id: crypto.randomUUID(),
    identifier: `cross_domain:${token}`,
    value: sessionId,
    expiresAt: new Date(Date.now() + 60 * 1000), // 1 MINUTE expiry
    createdAt: new Date(),
    updatedAt: new Date(),
  })

  return token
}

// Exchange token (one-time use - deleted after exchange)
export async function exchangeCrossDomainToken(db, token: string) {
  const verification = await db.query.verifications.findFirst({
    where: (t, { eq, and, gt }) =>
      and(eq(t.identifier, `cross_domain:${token}`), gt(t.expiresAt, new Date())),
  })

  if (!verification) return null

  // DELETE the token immediately (one-time use)
  await db.delete(schema.verifications).where((t, { eq }) => eq(t.id, verification.id))

  return { sessionId: verification.value }
}
```

---

## Security Headers

### CDN Security Headers

The CDN delivery module (`db/primitives/media-pipeline/cdn-delivery.ts`) supports security headers:

```typescript
const cdn = createCDNDelivery({
  bucket: env.R2_BUCKET,
  securityHeaders: {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'",
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
  },
})
```

### Recommended Headers

| Header | Recommended Value | Purpose |
|--------|-------------------|---------|
| `X-Content-Type-Options` | `nosniff` | Prevent MIME-type sniffing |
| `X-Frame-Options` | `DENY` or `SAMEORIGIN` | Prevent clickjacking |
| `Strict-Transport-Security` | `max-age=31536000; includeSubDomains` | Enforce HTTPS |
| `Content-Security-Policy` | App-specific | Prevent XSS, injection |
| `X-XSS-Protection` | `1; mode=block` | Legacy XSS protection |
| `Referrer-Policy` | `strict-origin-when-cross-origin` | Control referrer leakage |
| `Permissions-Policy` | Restrictive defaults | Limit browser features |

---

## Secure Cookie Configuration

```typescript
// Secure session cookie settings
const cookieOptions = {
  HttpOnly: true,    // Prevent JavaScript access
  Secure: true,      // HTTPS only
  SameSite: 'Lax',   // CSRF protection
  Path: '/',         // Scope to entire site
  MaxAge: 60 * 60 * 24 * 7, // 7 days
}

headers.set(
  'Set-Cookie',
  `session_token=${token}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=${60 * 60 * 24 * 7}`
)
```

---

## Tenant Isolation

### Storage Path Isolation

```typescript
// lib/storage/authorized-r2.ts
class AuthorizedR2Client {
  // All paths include org and tenant boundaries
  getBasePath(): string {
    return this.buildPath(
      this._claims.pathPrefix,
      'orgs',
      this._claims.orgId,
      'tenants',
      this._claims.tenantId
    ) + '/'
  }

  // Path structure: [prefix]/orgs/{orgId}/tenants/{tenantId}/do/{doId}/{type}/
  getDOBasePath(doId: string): string {
    this.validateSegment(doId, 'doId') // Prevent injection
    return this.buildPath(
      this._claims.pathPrefix,
      'orgs',
      this._claims.orgId,
      'tenants',
      this._claims.tenantId,
      'do',
      doId
    ) + '/'
  }
}
```

### Organization Access Validation

```typescript
// Validate organization access before processing
checkOrgAccess(context: AuthContext, requestedOrgId?: string): boolean {
  if (!requestedOrgId) return true
  if (!context.user?.organizationId) return false
  return context.user.organizationId === requestedOrgId
}

// Usage in handlers
const requestedOrgId = request.headers.get('X-Organization-Id')
if (requestedOrgId && context.user?.organizationId) {
  if (!authMiddleware.checkOrgAccess(context, requestedOrgId)) {
    return Response.json(
      { error: 'Access denied: organization mismatch' },
      { status: 403 }
    )
  }
}
```

---

## Pre-Deployment Security Checklist

### Authentication

- [ ] JWT secret is configured (minimum 256-bit entropy)
- [ ] Token expiration is enforced (1 hour for access tokens)
- [ ] Issuer (`iss`) and audience (`aud`) are validated
- [ ] Refresh token rotation is implemented
- [ ] Session cookies use `HttpOnly`, `Secure`, `SameSite=Lax`

### Authorization

- [ ] All endpoints have explicit `$auth` configuration
- [ ] Default `requireAuth` is `true`
- [ ] RBAC roles follow principle of least privilege
- [ ] Resource-level permissions are enforced
- [ ] Organization access is validated

### Input Validation

- [ ] All user input is validated before processing
- [ ] Path traversal patterns are rejected (`..`, `./`)
- [ ] SQL queries use parameterized statements
- [ ] File uploads are validated (type, size, content)
- [ ] JSON payloads are parsed safely

### API Security

- [ ] API keys use secure format with version prefix
- [ ] Rate limiting is configured per-endpoint
- [ ] Request signing is enabled for webhooks
- [ ] Nonce checking prevents replay attacks
- [ ] CORS is restricted to known origins

### Credentials

- [ ] No hardcoded secrets in source code
- [ ] All secrets use Wrangler secrets or vault
- [ ] `.env` files are in `.gitignore`
- [ ] Service account keys are not committed
- [ ] Secret rotation policies are defined

### Headers

- [ ] Security headers are configured
- [ ] HSTS is enabled with long max-age
- [ ] CSP is configured appropriately
- [ ] X-Frame-Options prevents clickjacking
- [ ] Referrer-Policy limits information leakage

### Logging

- [ ] Authentication events are logged
- [ ] Authorization failures are logged
- [ ] Sensitive data is redacted from logs
- [ ] Audit trail captures actor identity
- [ ] Anomaly detection is enabled

---

## Incident Response

### Suspected Credential Compromise

```typescript
// Immediate rotation with zero grace period
await $.vault.rotate('compromised_key', newValue, {
  gracePeriod: '0s', // Immediate invalidation
  reason: 'Suspected compromise',
})

// Revoke all sessions for affected user
await sessions.revokeAll(userId)

// Alert security team
await $.alert.security('Emergency credential rotation', {
  secretName: 'compromised_key',
  reason: 'Suspected compromise',
  action: 'All related sessions revoked',
})
```

### Suspicious Activity Detection

```typescript
$.on.Auth.failure(async ($, { reason, ip }) => {
  await $.audit.log('auth.failure', { reason, ip })

  // Detect brute force patterns
  const failureCount = await getRecentFailures(ip, '5m')
  if (failureCount > 10) {
    await $.alert.security('Potential brute force attack', {
      ip,
      failures: failureCount,
      window: '5 minutes',
    })
    // Consider blocking IP temporarily
  }
})
```

---

## Related Documentation

- [Authentication](/docs/security/authentication) - Identity verification with org.ai
- [Authorization](/docs/security/authorization) - Role-based permissions
- [Vault](/docs/security/vault) - Secure credential storage
- [Secrets Management](/docs/security/secrets) - Environment variables and rotation
- [Compliance](/docs/security/compliance) - GDPR, SOC 2, audit logging

## External References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [Cloudflare Workers Security](https://developers.cloudflare.com/workers/runtime-apis/web-standards/)
- [better-auth Documentation](https://better-auth.com)
