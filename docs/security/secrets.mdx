---
title: Secrets Management
description: Environment variables, vault integration, and automatic secret rotation
---

# Secrets Management

Secrets belong in one place. Not in code, not in env files, not in logs.

## Overview

Managing secrets across environments, services, and deployments is hard. dotdo provides a unified approach: store secrets in the Vault, inject them at runtime, rotate them automatically. Your code never sees raw credentials in config files.

## Environment Variables

### The Problem with Env Vars

Environment variables seem convenient, but they leak:

- Logged by process managers
- Visible in `ps` output
- Inherited by child processes
- Included in error reports

### Migration to Vault

Move from env vars to Vault for better security:

```typescript
// Before: secrets in environment
const stripeKey = process.env.STRIPE_KEY
const dbUrl = process.env.DATABASE_URL

// After: secrets from vault
const stripeKey = await $.vault.get('stripe_key')
const dbUrl = await $.vault.get('database_url')
```

### Automatic Injection

Configure secrets to inject automatically:

```typescript
// wrangler.jsonc or configuration
export default {
  secrets: {
    inject: [
      { name: 'STRIPE_KEY', vault: 'stripe_key' },
      { name: 'DATABASE_URL', vault: 'database_url' },
    ],
  },
}
```

```typescript
// Secrets available as vault-backed env vars
const stripe = new Stripe(process.env.STRIPE_KEY)
// Actually fetches from vault, not real env var
```

### Environment-Specific Secrets

Different secrets for different environments:

```typescript
// Store per-environment
await $.vault.set('database_url', prodUrl, { env: 'production' })
await $.vault.set('database_url', stagingUrl, { env: 'staging' })
await $.vault.set('database_url', localUrl, { env: 'development' })

// Retrieval uses current environment
const dbUrl = await $.vault.get('database_url')
// Returns appropriate URL based on DOTDO_ENV
```

## Vault Integration

### Storing Secrets

```typescript
// Simple secret
await $.vault.set('api_key', 'sk_live_...')

// With metadata
await $.vault.set('stripe_key', key, {
  description: 'Stripe production API key',
  owner: 'payments-team',
  rotateAfter: '90d',
  tags: ['production', 'payment', 'critical'],
})

// Bulk storage
await $.vault.setMany({
  stripe_key: process.env.STRIPE_KEY,
  sendgrid_key: process.env.SENDGRID_KEY,
  twilio_key: process.env.TWILIO_KEY,
})
```

### Retrieving Secrets

```typescript
// Single secret
const key = await $.vault.get('stripe_key')

// Multiple secrets
const secrets = await $.vault.getMany([
  'stripe_key',
  'sendgrid_key',
  'database_url',
])

// With metadata
const { value, metadata } = await $.vault.getWithMetadata('stripe_key')
console.log(metadata.lastRotated)
```

### Secret References

Pass references instead of values for better security:

```typescript
// Create a reference
const stripeRef = $.vault.ref('stripe_key')

// Pass to functions - no value in memory yet
await processPayment(stripeRef, amount)

// Resolve when needed
async function processPayment(keyRef, amount) {
  const key = await keyRef.resolve()
  const stripe = new Stripe(key)
  await stripe.charges.create({ amount })
}
```

### Access Control

Limit which services can access which secrets:

```typescript
$.vault.authorize({
  // Payment service only
  'stripe_key': ['payment-service'],
  'payment_gateway_key': ['payment-service'],

  // Email service only
  'sendgrid_key': ['email-service'],
  'mailgun_key': ['email-service'],

  // Shared database
  'database_url': ['api-server', 'worker', 'admin'],

  // Admin only
  'master_key': ['admin'],
})
```

## Secret Rotation

### Rotation Policies

Configure automatic rotation:

```typescript
// Set rotation policy on storage
await $.vault.set('api_key', key, {
  rotateAfter: '30d',
  notifyBefore: '7d',
})

// Check rotation status
const status = await $.vault.rotationStatus('api_key')
// {
//   needsRotation: false,
//   expiresIn: '23d',
//   lastRotated: '2024-01-01T00:00:00Z',
//   nextRotation: '2024-01-31T00:00:00Z'
// }
```

### Automatic Rotation

Implement rotation handlers for zero-downtime updates:

```typescript
$.on.Vault.rotationDue(async ($, { secretName }) => {
  switch (secretName) {
    case 'stripe_key':
      await rotateStripeKey($)
      break
    case 'database_password':
      await rotateDatabasePassword($)
      break
    default:
      await $.alert.ops(`Manual rotation needed: ${secretName}`)
  }
})

async function rotateStripeKey($) {
  // 1. Generate new key via Stripe API
  const newKey = await stripe.apiKeys.create({
    name: `production-${Date.now()}`,
  })

  // 2. Store new key (old still valid)
  await $.vault.set('stripe_key', newKey.secret, {
    rotateAfter: '90d',
  })

  // 3. Verify new key works
  await stripe.customers.list({ limit: 1 })

  // 4. Revoke old key
  await stripe.apiKeys.revoke(oldKeyId)

  await $.audit.log('secret.rotated', { secretName: 'stripe_key' })
}
```

### Rotation Grace Period

Handle transitions gracefully:

```typescript
// During rotation, both old and new keys work
await $.vault.rotate('api_key', newValue, {
  gracePeriod: '1h', // Old key valid for 1 hour
})

// Your code continues working during transition
const key = await $.vault.get('api_key')
// Returns new key, but old key also accepted
```

### Monitoring Rotation

```typescript
// Get all secrets needing rotation
const stale = await $.vault.needsRotation()
// ['old_api_key', 'legacy_token']

// Get secrets expiring soon
const expiring = await $.vault.expiringSoon('7d')
// [{ name: 'stripe_key', expiresIn: '5d' }]

// Alert on missed rotations
$.on.Vault.rotationOverdue(async ($, { secretName, daysOverdue }) => {
  await $.alert.security('Secret rotation overdue', {
    secretName,
    daysOverdue,
    severity: daysOverdue > 30 ? 'critical' : 'high',
  })
})
```

## External Vault Integration

### HashiCorp Vault

```typescript
import { connectVault } from 'dotdo/vault'

await connectVault({
  provider: 'hashicorp',
  address: 'https://vault.example.com',
  auth: {
    method: 'kubernetes', // or 'token', 'approle', 'aws'
    role: 'dotdo-production',
  },
})

// Secrets now fetch from HashiCorp Vault
const secret = await $.vault.get('database/creds/readonly')
```

### AWS Secrets Manager

```typescript
import { connectVault } from 'dotdo/vault'

await connectVault({
  provider: 'aws-secrets-manager',
  region: 'us-east-1',
  // Uses IAM role automatically
})

// Access AWS secrets
const dbCreds = await $.vault.get('prod/database')
```

### Azure Key Vault

```typescript
import { connectVault } from 'dotdo/vault'

await connectVault({
  provider: 'azure-keyvault',
  vaultUrl: 'https://my-vault.vault.azure.net',
  // Uses managed identity
})
```

### Google Secret Manager

```typescript
import { connectVault } from 'dotdo/vault'

await connectVault({
  provider: 'gcp-secret-manager',
  project: 'my-gcp-project',
  // Uses workload identity
})
```

## Secret Injection Patterns

### At Build Time

```typescript
// dotdo.config.ts
export default {
  build: {
    secrets: {
      // Inject at build, not runtime (use sparingly)
      PUBLIC_API_URL: await $.vault.get('public_api_url'),
    },
  },
}
```

### At Deploy Time

```typescript
// Deploy with secrets injected
await $.deploy({
  secrets: [
    'stripe_key',
    'database_url',
    'sendgrid_key',
  ],
  environment: 'production',
})
```

### At Runtime (Recommended)

```typescript
// Best practice: fetch secrets at runtime
export default {
  async fetch(request, env) {
    const stripeKey = await $.vault.get('stripe_key')
    // Fresh secret on every deployment
  },
}
```

## Audit Trail

Every secret access is logged:

```typescript
// Access logs
{
  "timestamp": "2024-01-15T10:30:00Z",
  "actor": {
    "type": "service",
    "id": "payment-service",
    "environment": "production"
  },
  "action": "vault.get",
  "secret": "stripe_key",
  "result": "success"
}

// Rotation logs
{
  "timestamp": "2024-01-15T10:30:00Z",
  "actor": {
    "type": "system",
    "id": "rotation-scheduler"
  },
  "action": "vault.rotate",
  "secret": "api_key",
  "result": "success",
  "details": {
    "gracePeriod": "1h",
    "previousVersion": "v3",
    "newVersion": "v4"
  }
}
```

Monitor for anomalies:

```typescript
$.on.Vault.access(async ($, { secretName, actor, unusual }) => {
  if (unusual) {
    await $.alert.security('Unusual secret access', {
      secretName,
      actor,
      reason: unusual.reason,
      // e.g., "First access from this service"
      // e.g., "Access outside normal hours"
    })
  }
})
```

## Best Practices

### Never Hardcode Secrets

```typescript
// Bad
const stripe = new Stripe('sk_live_abc123')

// Good
const stripe = new Stripe(await $.vault.get('stripe_key'))
```

### Use Least Privilege

```typescript
// Create separate secrets for different access levels
await $.vault.set('db_readonly', readonlyConnectionString)
await $.vault.set('db_readwrite', readwriteConnectionString)
await $.vault.set('db_admin', adminConnectionString)

// Grant minimum required access
$.vault.authorize({
  'db_readonly': ['api-server', 'analytics'],
  'db_readwrite': ['api-server'],
  'db_admin': ['migration-runner'],
})
```

### Rotate on Suspicion

```typescript
// If you suspect a leak, rotate immediately
await $.vault.rotate('compromised_key', newValue, {
  gracePeriod: '0s', // Immediate invalidation
  reason: 'Suspected compromise',
})

await $.alert.security('Emergency secret rotation', {
  secretName: 'compromised_key',
  reason: 'Suspected compromise',
})
```

### Test Rotation

```typescript
// Regularly test rotation works
$.every.week(async ($) => {
  const testSecret = await $.vault.get('rotation_test_key')

  await $.vault.rotate('rotation_test_key', `test-${Date.now()}`, {
    gracePeriod: '5m',
  })

  // Verify new secret works
  const newSecret = await $.vault.get('rotation_test_key')
  if (newSecret === testSecret) {
    await $.alert.ops('Rotation test failed')
  }
})
```

## Related

- [Vault](/docs/security/vault) - Core vault functionality
- [Encryption](/docs/security/encryption) - Data encryption at rest and in transit
- [Compliance](/docs/security/compliance) - Regulatory requirements for secret management
