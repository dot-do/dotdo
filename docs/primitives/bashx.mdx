---
title: bashx - Shell Without VMs
description: Safe shell execution with AST analysis and tiered execution
---

# bashx - Shell Without VMs

Your agents need to run `npm install`, `ffmpeg`, and `python`. They can't spawn processes in V8 isolates. We built a shell.

bashx provides shell execution with AST-based safety analysis. Commands are parsed with tree-sitter, classified by risk, and routed to appropriate executors. Native file operations use fsx directly. Heavy computation runs in containers.

## Quick Start

```typescript
// Template literal syntax
const result = await $.bash`npm install && npm run build`

// Check result
if (result.exitCode === 0) {
  console.log('Build succeeded:', result.stdout)
} else {
  console.error('Build failed:', result.stderr)
}
```

## Execution Methods

### exec - Run and Wait

```typescript
// Basic execution
const result = await $.bash.exec('npm', ['test'])
console.log(`Exit code: ${result.exitCode}`)
console.log(`Output: ${result.stdout}`)

// With options
const result = await $.bash.exec('python', ['analyze.py'], {
  cwd: '/app/scripts',
  env: { PYTHONPATH: '/app/lib' },
  timeout: 30000
})

// Template literal (same as exec)
const result = await $.bash`npm run lint`
```

### spawn - Long-running Processes

```typescript
// Start process without waiting
const handle = await $.bash.spawn('npm', ['run', 'watch'])

// Read output as it arrives
handle.stdout.on('data', (chunk) => {
  console.log('Output:', chunk)
})

handle.stderr.on('data', (chunk) => {
  console.error('Error:', chunk)
})

// Wait for completion
const exitCode = await handle.wait()

// Or kill early
handle.kill('SIGTERM')
```

## AST-Based Safety Analysis

Every command is parsed and analyzed before execution:

```typescript
// Check if command is dangerous
const analysis = $.bash.analyze('rm -rf /')

console.log(analysis.dangerous)     // true
console.log(analysis.reason)        // "Recursive delete of root directory"
console.log(analysis.classification) // "destructive"
console.log(analysis.tier)          // "blocked"
```

### Safety Classifications

| Classification | Description | Action |
|---------------|-------------|--------|
| `safe` | Read-only operations | Execute immediately |
| `write` | File modifications | Execute with logging |
| `network` | External connections | Execute with monitoring |
| `destructive` | Data deletion | Requires confirmation |
| `system` | OS-level changes | Blocked by default |

### Confirmation for Dangerous Commands

```typescript
// This is blocked by default
const result = await $.bash`rm -rf temp/`
// result.blocked === true
// result.requiresConfirm === true

// Explicitly confirm dangerous operations
const result = await $.bash.exec('rm', ['-rf', 'temp/'], {
  confirm: true  // "Yes, I know what I'm doing"
})
```

## Tiered Execution

bashx implements a 4-tier execution model that automatically routes commands to the optimal executor:

```
┌────────────────────────────────────────────────────────────────────────────────┐
│                              Command Input                                      │
│                        $.bash`cat config.json`                                  │
└─────────────────────────────────┬──────────────────────────────────────────────┘
                                  │
                                  ▼
┌────────────────────────────────────────────────────────────────────────────────┐
│                         AST Parser (tree-sitter-bash WASM)                      │
│                       Parse → Classify → Safety Check → Route                   │
└─────────────────────────────────┬──────────────────────────────────────────────┘
                                  │
       ┌──────────────┬───────────┴───────────┬──────────────┐
       ▼              ▼                       ▼              ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│   Tier 1     │ │   Tier 2     │ │   Tier 3     │ │   Tier 4     │
│   Native     │ │   RPC        │ │   Loaders    │ │   Sandbox    │
├──────────────┤ ├──────────────┤ ├──────────────┤ ├──────────────┤
│ cat, ls, grep│ │ jq.do        │ │ esbuild      │ │ docker, ps   │
│ mkdir, rm    │ │ npm.do       │ │ prettier     │ │ gcc, python  │
│ curl, echo   │ │ git.do       │ │ typescript   │ │ apt, sudo    │
├──────────────┤ ├──────────────┤ ├──────────────┤ ├──────────────┤
│ Uses $.fs    │ │ HTTP RPC     │ │ Dynamic npm  │ │ Linux VM     │
│ < 1ms        │ │ 10-50ms      │ │ 50-200ms     │ │ 100ms+       │
└──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘
```

### How Tier Selection Works

When you run a command, bashx:

1. **Parses the command** using tree-sitter-bash WASM into an AST
2. **Extracts the command name** and arguments from the AST
3. **Classifies the command** based on its requirements
4. **Routes to the appropriate tier** based on availability and capability

```typescript
// Tier selection is automatic and transparent
await $.bash`cat data.json`           // Tier 1: Native (uses $.fs)
await $.bash`jq '.users[]' data.json` // Tier 1: Native jq implementation
await $.bash`npm install`             // Tier 2: RPC to npm.do (or Tier 4 sandbox)
await $.bash`docker ps`               // Tier 4: Sandbox only
```

### Tier 1: Native In-Worker Execution

The fastest tier - commands execute directly in the V8 isolate with no external calls.

**File operations (via fsx):**
```typescript
// These use $.fs internally - no subprocess!
await $.bash`cat config.json`        // $.fs.read('config.json')
await $.bash`ls -la src/`            // $.fs.list('src/')
await $.bash`head -n 10 data.csv`    // $.fs.read() + slice
await $.bash`mkdir -p uploads/2024`  // $.fs.mkdir({ recursive: true })
await $.bash`rm -rf temp/`           // $.fs.rm('temp/', { recursive: true })
await $.bash`cp src/a.ts src/b.ts`   // $.fs.copy('src/a.ts', 'src/b.ts')
```

**Data processing (native implementations):**
```typescript
// Native JavaScript implementations, not WASM
await $.bash`jq '.name' package.json`  // Native jq parser
await $.bash`yq '.services' config.yml` // Native YAML processor
await $.bash`base64 -d encoded.txt`    // Native base64
await $.bash`sha256sum file.bin`       // Web Crypto API
```

**HTTP (via fetch API):**
```typescript
// curl/wget use native fetch
await $.bash`curl https://api.example.com/data`
await $.bash`wget -O output.json https://example.com/data`
```

**Text processing (native implementations):**
```typescript
await $.bash`echo "hello" | sed 's/e/a/g'`  // Native sed
await $.bash`sort data.txt | uniq`          // Native sort/uniq
await $.bash`wc -l file.txt`                // Native wc
```

| Command Category | Examples | Implementation |
|-----------------|----------|----------------|
| File read | cat, head, tail, ls, stat | $.fs operations |
| File write | mkdir, rm, cp, mv, touch | $.fs operations |
| Text processing | sort, uniq, tr, cut, wc | Native JS |
| Data processing | jq, yq, base64, envsubst | Native parsers |
| Crypto | sha256sum, md5sum, uuidgen | Web Crypto API |
| HTTP | curl, wget | fetch API |
| Math | bc, expr, seq | Native JS |

### Tier 2: RPC Service Bindings

For commands that need external services but don't require full Linux:

```typescript
// These call external .do services via HTTP RPC
await $.bash`npm install lodash`  // RPC to npm.do
await $.bash`git status`          // RPC to git.do
```

Default RPC services:
- **jq.do** - jq processing (fallback if native is insufficient)
- **npm.do** - npm, npx, pnpm, yarn, bun
- **git.do** - git operations

### Tier 3: Worker Loaders (Dynamic npm)

For npm packages that can be dynamically loaded into Workers:

```typescript
// These load npm packages at runtime via worker_loaders
await $.bash`prettier --write src/*.ts`
await $.bash`eslint src/`
await $.bash`tsc --build`
```

Available modules: esbuild, typescript, prettier, eslint, zod, ajv, yaml, lodash, date-fns, uuid

### Tier 4: Sandbox Execution

For commands requiring true Linux capabilities:

```typescript
// These require a Linux sandbox (Cloudflare Containers or external)
await $.bash`docker build -t myapp .`
await $.bash`python train.py --epochs 100`
await $.bash`gcc -o main main.c`
await $.bash`apt install libpng-dev`
```

**Sandbox-only commands:**
- System/process: ps, kill, top, htop
- Network: ping, ssh, nc, netstat
- Containers: docker, kubectl, podman
- Compilers: gcc, clang, rustc, cargo, go
- Runtimes: python, ruby, perl
- Package managers: apt, yum, brew

### Security Isolation by Tier

| Tier | Isolation Level | Attack Surface |
|------|-----------------|----------------|
| 1 - Native | V8 isolate | Minimal (same as DO) |
| 2 - RPC | Network boundary | Service trust |
| 3 - Loader | V8 isolate | npm package trust |
| 4 - Sandbox | Full VM/container | Linux kernel |

### Tier Configuration

```typescript
const executor = new TieredExecutor({
  // Tier 1: Native filesystem capability
  fs: fsCapability,

  // Tier 2: RPC service bindings
  rpcBindings: {
    jq: { endpoint: 'https://jq.do', commands: ['jq'] },
    npm: { endpoint: env.NPM_SERVICE, commands: ['npm', 'npx'] },
  },

  // Tier 3: Worker loader bindings
  workerLoaders: {
    build: { load: (m) => import(m), modules: ['esbuild', 'prettier'] },
  },

  // Tier 4: Sandbox SDK binding
  sandbox: {
    execute: async (cmd, opts) => {
      return await env.CONTAINER.run(cmd, opts)
    }
  },

  // Prefer faster tiers when multiple can handle the command
  preferFaster: true,  // Default: true
})
```

## Piping and Composition

```typescript
// Pipes work naturally
const result = await $.bash`cat data.json | jq '.users[]' | head -5`

// Command substitution
const version = await $.bash`node --version`
const result = await $.bash`echo "Node ${version.stdout.trim()}"`

// Conditionals
await $.bash`test -f config.json && cat config.json || echo "no config"`
```

## Environment Variables

```typescript
// Set for single command
const result = await $.bash.exec('node', ['app.js'], {
  env: {
    NODE_ENV: 'production',
    API_KEY: env.API_KEY
  }
})

// Template with interpolation
const port = 3000
await $.bash`PORT=${port} npm start`
```

## Working Directory

```typescript
// Change working directory
const result = await $.bash.exec('npm', ['test'], {
  cwd: '/app/packages/core'
})

// Or use cd in the command
await $.bash`cd packages/core && npm test`
```

## Timeouts

```typescript
// Default timeout is 60 seconds
const result = await $.bash.exec('npm', ['install'], {
  timeout: 120000  // 2 minutes
})

// Handle timeout
if (result.timedOut) {
  console.error('Command timed out')
}
```

## Real-World Examples

### Build Pipeline

```typescript
async function buildAndDeploy() {
  // Install dependencies
  await $.bash`npm ci`

  // Run tests
  const testResult = await $.bash`npm test`
  if (testResult.exitCode !== 0) {
    throw new Error('Tests failed')
  }

  // Build
  await $.bash`npm run build`

  // Deploy
  await $.bash`npm run deploy`
}
```

### Video Processing

```typescript
async function processVideo(input: string) {
  // Get video info
  const probe = await $.bash`ffprobe -v quiet -print_format json -show_format ${input}`
  const info = JSON.parse(probe.stdout)

  // Transcode
  await $.bash`ffmpeg -i ${input} -c:v libx264 -crf 23 -preset medium output.mp4`

  // Generate thumbnail
  await $.bash`ffmpeg -i ${input} -ss 00:00:01 -vframes 1 thumbnail.jpg`

  return { duration: info.format.duration }
}
```

### Python Script Execution

```typescript
async function analyzeData(dataPath: string) {
  // Run Python analysis
  const result = await $.bash`python analyze.py --input ${dataPath} --output results.json`

  if (result.exitCode !== 0) {
    throw new Error(`Analysis failed: ${result.stderr}`)
  }

  // Read results
  const results = await $.fs.read('results.json')
  return JSON.parse(results)
}
```

## Error Handling

```typescript
import { BashError } from 'dotdo/errors'

try {
  await $.bash`npm run build`
} catch (error) {
  if (error instanceof BashError) {
    console.error(`Command failed: ${error.command}`)
    console.error(`Exit code: ${error.exitCode}`)
    console.error(`Stderr: ${error.stderr}`)
  }
}

// Or check result directly
const result = await $.bash`npm run build`
if (result.exitCode !== 0) {
  console.error('Build failed:', result.stderr)
}
```

## Type Definitions

```typescript
interface BashResult {
  stdout: string
  stderr: string
  exitCode: number
  timedOut?: boolean
  blocked?: boolean
  requiresConfirm?: boolean
}

interface ExecOptions {
  cwd?: string
  env?: Record<string, string>
  timeout?: number
  confirm?: boolean
}

interface SpawnHandle {
  stdout: {
    on(event: 'data', callback: (chunk: string) => void): void
  }
  stderr: {
    on(event: 'data', callback: (chunk: string) => void): void
  }
  wait(): Promise<number>
  kill(signal?: string): void
}

interface SafetyAnalysis {
  dangerous: boolean
  reason?: string
  classification: 'safe' | 'write' | 'network' | 'destructive' | 'system'
  tier: 'native' | 'wasm' | 'container' | 'blocked'
}
```

## Configuration

Configure the executor when adding bashx to your DO:

```typescript
class BuildAgent extends withBash(withFs(DO), {
  // Executor factory - called when $.bash is first accessed
  executor: (instance) => ({
    execute: async (cmd, opts) => {
      // Route to Cloudflare Containers
      return await instance.env.CONTAINER.run(cmd, opts)
    }
  }),

  // Optional: integrate with fsx for native file ops
  fs: (instance) => instance.$.fs,

  // Enable native operations (default: true)
  useNativeOps: true
}) {
  // ...
}
```

## Security Considerations

1. **AST Analysis** - Commands are parsed and analyzed, not just string-matched
2. **Blocklist** - Dangerous patterns are blocked by default
3. **Confirmation** - Destructive operations require explicit opt-in
4. **Sandboxing** - Container execution is isolated
5. **Resource Limits** - Timeouts prevent runaway processes

## Technical Details

For implementation details, architecture decisions, and contributor documentation:

- **[bashx README](https://github.com/dotdo/dotdo/blob/main/primitives/bashx/README.md)** - Package documentation with 1,400+ tests, AST-based safety analysis using tree-sitter-bash WASM, tiered execution model, MCP integration, and core library (@dotdo/bashx)
- **[bashx CLAUDE.md](https://github.com/dotdo/dotdo/blob/main/primitives/bashx/CLAUDE.md)** - Developer guidance for working with the bashx codebase

### Key Implementation Files

| Directory | Purpose |
|-----------|---------|
| `src/ast/` | AST parsing and analysis (tree-sitter WASM) |
| `src/mcp/` | MCP tool definition (single `bash` tool) |
| `core/safety/` | Safety analysis, classification, intent extraction |
| `core/escape/` | Shell escaping utilities (POSIX-compliant) |
| `core/classify/` | Input classification (command vs natural language) |

## Next Steps

- [fsx](/docs/primitives/fsx) - Filesystem used by native operations
- [gitx](/docs/primitives/gitx) - Run git hooks and pre-commit scripts
- [Capabilities](/docs/sdk/capabilities) - Add bash to your DOs
