---
title: circuit-breaker - Fault Tolerance
description: Protect against cascading failures with circuit breaker pattern, bulkhead, and retry policies
---

# circuit-breaker - Fault Tolerance

Stop cascading failures before they take down your system. The circuit breaker trips when a service fails repeatedly, giving it time to recover.

The circuit-breaker primitive provides the full circuit breaker pattern with sliding window failure tracking, fallback handlers, health checking, bulkhead isolation, and configurable retry policies.

## Quick Start

```typescript
import { CircuitBreaker } from 'dotdo/primitives/circuit-breaker'

const breaker = new CircuitBreaker({
  failureThreshold: 5,    // Open after 5 failures
  resetTimeout: 30000,    // Try again after 30 seconds
  name: 'external-api'
})

// Wrap external calls
const result = await breaker.execute(async () => {
  return await fetch('https://api.example.com/data')
})
```

## Circuit States

```
     ┌──────────────────────────────────────────────────┐
     │                                                  │
     ▼                                                  │
┌─────────┐  failures >= threshold  ┌────────┐         │
│ CLOSED  │ ─────────────────────▶  │  OPEN  │         │
│ (OK)    │                         │(Failed)│         │
└─────────┘                         └────────┘         │
     ▲                                   │             │
     │                                   │ timeout     │
     │ success                           ▼             │
     │                            ┌───────────┐        │
     └─────────────────────────── │ HALF-OPEN │ ───────┘
                                  │  (Test)   │  failure
                                  └───────────┘
```

| State | Description |
|-------|-------------|
| `closed` | Normal operation, requests pass through |
| `open` | Circuit tripped, requests fail immediately |
| `half-open` | Testing recovery, one request allowed |

## Configuration

```typescript
const breaker = new CircuitBreaker({
  // Required
  failureThreshold: 5,    // Failures before opening
  resetTimeout: 30000,    // Ms to wait before half-open

  // Optional
  name: 'my-service',     // For logging/registry

  // Sliding window for accurate failure tracking
  slidingWindow: {
    windowSize: 60000,    // 1 minute window
    minRequests: 10       // Need 10 requests before tripping
  },

  // Fallback when circuit is open
  fallback: {
    handler: () => ({ cached: true, data: fallbackData }),
    timeout: 5000         // Fallback timeout
  },

  // Periodic health checking
  healthCheck: {
    interval: 5000,       // Check every 5 seconds
    checker: async () => {
      const res = await fetch('https://api.example.com/health')
      return res.ok
    }
  },

  // Limit concurrent executions
  bulkhead: {
    maxConcurrent: 10,    // Max parallel requests
    queueSize: 50,        // Queue when at capacity
    queueTimeout: 5000    // Queue timeout in ms
  },

  // Retry before recording failure
  retryPolicy: {
    maxRetries: 3,
    baseDelay: 100,
    maxDelay: 5000,
    backoffMultiplier: 2,
    retryableErrors: (err) => err.message.includes('timeout')
  }
})
```

## Sliding Window

Track failures over a time window for more accurate circuit tripping.

```typescript
import { SlidingWindow } from 'dotdo/primitives/circuit-breaker'

const window = new SlidingWindow({
  windowSize: 60000,  // 1 minute
  minRequests: 10     // Need 10 requests to evaluate
})

window.recordSuccess()
window.recordFailure()

console.log(window.getFailureRate())  // 0.0 - 1.0
console.log(window.hasMinimumRequests())  // true when >= minRequests
```

## Fallback Handlers

Provide alternative behavior when the circuit is open.

```typescript
import { FallbackHandler } from 'dotdo/primitives/circuit-breaker'

const fallback = new FallbackHandler({
  handler: async () => {
    // Return cached data, default value, or degraded response
    return { status: 'degraded', data: cachedData }
  },
  timeout: 5000  // Optional fallback timeout
})

// Used automatically when circuit is open
const breaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 30000,
  fallback: {
    handler: () => fallbackData
  }
})
```

## Bulkhead Pattern

Limit concurrent executions to prevent resource exhaustion.

```typescript
import { Bulkhead, BulkheadFullError, QueueTimeoutError } from 'dotdo/primitives/circuit-breaker'

const bulkhead = new Bulkhead({
  maxConcurrent: 10,    // Max parallel executions
  queueSize: 50,        // Queue additional requests
  queueTimeout: 5000    // Timeout for queued requests
})

try {
  const result = await bulkhead.execute(async () => {
    return await expensiveOperation()
  })
} catch (err) {
  if (err instanceof BulkheadFullError) {
    // Queue is full, reject immediately
  }
  if (err instanceof QueueTimeoutError) {
    // Request waited too long in queue
  }
}

// Monitor utilization
console.log(`Active: ${bulkhead.getActiveCount()}`)
console.log(`Queued: ${bulkhead.getQueueSize()}`)
```

## Retry Policy

Retry transient failures before recording as circuit failure.

```typescript
import { RetryPolicy } from 'dotdo/primitives/circuit-breaker'

const retry = new RetryPolicy({
  maxRetries: 3,
  baseDelay: 100,        // Initial delay in ms
  maxDelay: 5000,        // Max delay after backoff
  backoffMultiplier: 2,  // Exponential backoff
  retryableErrors: (err) => {
    // Only retry specific errors
    return err.message.includes('timeout') ||
           err.message.includes('ECONNRESET')
  }
})

// Retries automatically: 100ms, 200ms, 400ms
const result = await retry.execute(async () => {
  return await unreliableOperation()
})
```

## Health Checking

Proactive health monitoring to speed recovery.

```typescript
import { HealthChecker } from 'dotdo/primitives/circuit-breaker'

const checker = new HealthChecker({
  interval: 5000,  // Check every 5 seconds
  checker: async () => {
    const res = await fetch('https://api.example.com/health')
    return res.ok
  }
})

checker.onRecovery(() => {
  console.log('Service recovered!')
})

checker.start()
// ... later
checker.stop()
```

## Event Handling

React to circuit state changes and events.

```typescript
const breaker = new CircuitBreaker({ ... })

// State change callback
breaker.onStateChange((from, to, stats) => {
  console.log(`Circuit ${from} -> ${to}`)
  console.log(`Stats: ${JSON.stringify(stats)}`)

  if (to === 'open') {
    alertOps('Circuit breaker tripped!')
  }
})

// Event callbacks
breaker.on('success', (event, data) => {
  metrics.increment('circuit.success')
})

breaker.on('failure', (event, data) => {
  metrics.increment('circuit.failure')
  console.log('Failed:', data.error)
})

breaker.on('rejected', (event, data) => {
  metrics.increment('circuit.rejected')
})

breaker.on('fallback', () => {
  metrics.increment('circuit.fallback')
})
```

## Circuit Registry

Manage multiple circuit breakers.

```typescript
import { CircuitBreakerRegistry } from 'dotdo/primitives/circuit-breaker'

const registry = new CircuitBreakerRegistry()

// Get or create circuit breakers by name
const paymentCircuit = registry.getOrCreate('payments', {
  failureThreshold: 3,
  resetTimeout: 60000
})

const shippingCircuit = registry.getOrCreate('shipping', {
  failureThreshold: 5,
  resetTimeout: 30000
})

// List all circuits
console.log(registry.list())  // ['payments', 'shipping']

// Get aggregated stats
const allStats = registry.getAllStats()
// {
//   payments: { state: 'closed', failures: 0, ... },
//   shipping: { state: 'half-open', failures: 3, ... }
// }

// Reset all circuits
registry.resetAll()

// Remove a circuit
registry.remove('shipping')
```

## Statistics

Track circuit breaker metrics.

```typescript
const stats = breaker.getStats()
// {
//   failures: 2,           // Current failure count
//   successes: 100,        // Current success count
//   lastFailure: 1704067200000,  // Timestamp
//   state: 'closed',
//   totalRequests: 102,    // All-time requests
//   totalSuccesses: 100,   // All-time successes
//   totalFailures: 2,      // All-time failures
//   totalRejected: 0,      // Rejected when open
//   totalFallbacks: 0      // Fallback invocations
// }
```

## Error Types

```typescript
import {
  CircuitOpenError,
  BulkheadFullError,
  QueueTimeoutError
} from 'dotdo/primitives/circuit-breaker'

try {
  await breaker.execute(operation)
} catch (err) {
  if (err instanceof CircuitOpenError) {
    // Circuit is open, request was rejected
    console.log(`Circuit ${err.circuitName} is open`)
  }
}
```

## Manual Control

```typescript
// Force open the circuit
breaker.open()

// Force close/reset the circuit
breaker.reset()

// Check current state
const state = breaker.getState()  // 'closed' | 'open' | 'half-open'

// Cleanup (stop health checker)
breaker.destroy()
```

## Real-World Example

```typescript
import { CircuitBreaker } from 'dotdo/primitives/circuit-breaker'

// Payment service circuit breaker
const paymentCircuit = new CircuitBreaker({
  name: 'stripe-api',
  failureThreshold: 3,
  resetTimeout: 30000,

  slidingWindow: {
    windowSize: 60000,
    minRequests: 5
  },

  fallback: {
    handler: () => ({
      success: false,
      error: 'Payment service temporarily unavailable'
    })
  },

  bulkhead: {
    maxConcurrent: 20,
    queueSize: 100,
    queueTimeout: 10000
  },

  retryPolicy: {
    maxRetries: 2,
    baseDelay: 500,
    backoffMultiplier: 2,
    retryableErrors: (err) =>
      err.message.includes('rate_limit') ||
      err.message.includes('timeout')
  }
})

async function processPayment(amount: number, card: string) {
  return paymentCircuit.execute(async () => {
    const response = await fetch('https://api.stripe.com/v1/charges', {
      method: 'POST',
      headers: { Authorization: `Bearer ${STRIPE_KEY}` },
      body: JSON.stringify({ amount, source: card })
    })

    if (!response.ok) {
      throw new Error(`Stripe error: ${response.status}`)
    }

    return response.json()
  })
}
```

## Next Steps

- [rate-limiter](/docs/primitives/rate-limiter) - Protect services from overload
- [health-checker](/docs/primitives/health-checker) - Monitor service health
- [cache-manager](/docs/primitives/cache-manager) - Cache to reduce load on protected services
