---
title: channel - Unified Pub/Sub
description: Single abstraction replacing EventEmitter, Pusher, Socket.IO, and Ably for real-time communication
---

# channel - Unified Pub/Sub

One interface for all pub/sub needs. Replaces Node EventEmitter, Pusher, Socket.IO, and Ably with a single, unified abstraction that works everywhere.

## Quick Start

```typescript
import { createChannel } from 'dotdo/primitives/channel'

// Create a channel
const channel = createChannel<ChatMessage>('chat:room-123')

// Subscribe to events
const subscription = channel.subscribe('message', (data, event) => {
  console.log(`${data.user}: ${data.text}`)
})

// Publish messages
await channel.publish('message', {
  user: 'alice',
  text: 'Hello, world!'
})

// Unsubscribe when done
subscription.unsubscribe()
```

## Channel Types

### Public Channels

Default channels accessible by all subscribers:

```typescript
const publicChannel = createChannel('announcements', { type: 'public' })

await publicChannel.publish('update', {
  message: 'New feature released!'
})
```

### Private Channels

Require authentication to subscribe:

```typescript
const privateChannel = createChannel('user:123:notifications', {
  type: 'private'
})

// Only authenticated users can subscribe
```

### Presence Channels

Track who is connected:

```typescript
const presenceChannel = createChannel<Message>('room:456', {
  type: 'presence'
})

// Join with member info
await presenceChannel.presence?.join({
  id: 'user-123',
  name: 'Alice',
  avatar: 'https://...'
})

// List current members
for await (const member of presenceChannel.presence!.members()) {
  console.log(`${member.name} is online`)
}

// Handle join/leave events
presenceChannel.presence?.onJoin((member) => {
  console.log(`${member.name} joined`)
})

presenceChannel.presence?.onLeave((member) => {
  console.log(`${member.name} left`)
})

// Leave the channel
await presenceChannel.presence?.leave()
```

## Event Subscriptions

### Single Event

```typescript
channel.subscribe('order:created', (order) => {
  processNewOrder(order)
})
```

### Wildcard

Subscribe to all events:

```typescript
channel.subscribe('*', (data, eventName) => {
  console.log(`Event: ${eventName}`, data)
})
```

### Unsubscribe

```typescript
const sub = channel.subscribe('update', handler)

// Using the subscription object
sub.unsubscribe()

// Or via channel
channel.unsubscribe(sub)
```

## Backpressure Control

Handle high-volume message streams:

```typescript
const highVolumeChannel = createChannel('metrics')

// Set buffer capacity
highVolumeChannel.buffer(1000)

// Drop oldest when full (default)
highVolumeChannel.dropOldest()

// Or drop newest
highVolumeChannel.dropNewest()
```

Messages are buffered when no subscribers are present:

```typescript
// Messages published while no subscribers
await channel.publish('event', data1)
await channel.publish('event', data2)

// Later, subscriber receives buffered messages
channel.subscribe('event', handler) // Gets data1, data2
```

## Message Persistence

Persist messages for replay:

```typescript
const persistentChannel = createChannel('audit-log')

persistentChannel.persistent({
  maxMessages: 10000,  // Keep last 10k messages
  maxAge: 86400000     // Or 24 hours, whichever comes first
})

// Publish messages (automatically persisted)
await persistentChannel.publish('action', { type: 'login', userId: '123' })

// Replay to new subscriber
persistentChannel.replayTo(handler, {
  event: 'action',
  since: Date.now() - 3600000 // Last hour
})
```

## Typed Channels

Full TypeScript support:

```typescript
interface OrderEvent {
  orderId: string
  status: 'created' | 'paid' | 'shipped' | 'delivered'
  timestamp: Date
}

const orderChannel = createChannel<OrderEvent>('orders')

// Type-safe publishing
await orderChannel.publish('status', {
  orderId: 'ord-123',
  status: 'shipped',
  timestamp: new Date()
})

// Type-safe subscription
orderChannel.subscribe('status', (data) => {
  // data is typed as OrderEvent
  console.log(`Order ${data.orderId} is now ${data.status}`)
})
```

## Integration with DOs

Use channels within Durable Objects:

```typescript
class ChatRoom extends DO {
  private channel = createChannel<ChatMessage>('chat:' + this.id)

  async join(userId: string) {
    await this.channel.presence?.join({
      id: userId,
      joinedAt: new Date()
    })
  }

  async sendMessage(userId: string, text: string) {
    await this.channel.publish('message', {
      userId,
      text,
      timestamp: new Date()
    })
  }

  async getOnlineUsers() {
    const users = []
    for await (const member of this.channel.presence!.members()) {
      users.push(member)
    }
    return users
  }
}
```

## Real-World Examples

### Live Dashboard

```typescript
const dashboardChannel = createChannel<Metric>('dashboard:metrics')

// Backend publishes metrics
setInterval(async () => {
  await dashboardChannel.publish('cpu', { value: getCpuUsage() })
  await dashboardChannel.publish('memory', { value: getMemoryUsage() })
  await dashboardChannel.publish('requests', { value: getRequestRate() })
}, 1000)

// Frontend subscribes
dashboardChannel.subscribe('*', (metric, type) => {
  updateChart(type, metric.value)
})
```

### Collaborative Editing

```typescript
const docChannel = createChannel<Operation>('doc:abc123', {
  type: 'presence'
})

// Track cursor positions
await docChannel.presence?.join({
  id: currentUser.id,
  cursor: { line: 0, col: 0 },
  color: '#ff0000'
})

// Broadcast operations
await docChannel.publish('operation', {
  type: 'insert',
  position: 42,
  text: 'Hello'
})

// Subscribe to remote changes
docChannel.subscribe('operation', (op) => {
  applyRemoteOperation(op)
})
```

### Event Bus

```typescript
// Create application-wide event bus
const eventBus = createChannel('app:events')

// Different services publish to the bus
await eventBus.publish('user:created', { id: 'u123', email: '...' })
await eventBus.publish('order:placed', { id: 'o456', total: 99.99 })
await eventBus.publish('payment:completed', { orderId: 'o456' })

// Services subscribe to events they care about
eventBus.subscribe('user:created', sendWelcomeEmail)
eventBus.subscribe('order:placed', updateInventory)
eventBus.subscribe('payment:completed', shipOrder)
```

## Type Definitions

```typescript
interface Channel<T = unknown> {
  name: string
  type: ChannelType

  publish(event: string, data: T): Promise<void>
  subscribe(event: string | '*', handler: Handler<T>): Subscription
  unsubscribe(subscription: Subscription): void

  buffer(capacity: number): this
  dropOldest(): this
  dropNewest(): this
  persistent(config: PersistenceConfig): this

  presence?: Presence
}

type ChannelType = 'public' | 'private' | 'presence'

interface Handler<T> {
  (data: T, event?: string): void
}

interface Subscription {
  id: string
  unsubscribe(): void
}

interface Presence {
  members(): AsyncIterable<Member>
  join(member: Member): Promise<void>
  leave(): Promise<void>
  onJoin(handler: Handler<Member>): Subscription
  onLeave(handler: Handler<Member>): Subscription
}

interface Member {
  id: string
  [key: string]: unknown
}

interface PersistenceConfig {
  maxMessages?: number
  maxAge?: number  // milliseconds
}
```

## Comparison

| Feature | @dotdo/channel | EventEmitter | Pusher | Socket.IO |
|---------|----------------|--------------|--------|-----------|
| Typed events | Yes | No | No | No |
| Presence | Yes | No | Yes | Yes |
| Persistence | Yes | No | No | No |
| Backpressure | Yes | No | No | No |
| Edge runtime | Yes | No | Client only | No |
| Single API | Yes | - | - | - |

## Next Steps

- [machine](/docs/primitives/machine) - State machines that emit channel events
- [workflow-orchestrator](/docs/primitives/workflow-orchestrator) - Workflows that publish progress
- [Capabilities](/docs/sdk/capabilities) - Add channels to your DOs
