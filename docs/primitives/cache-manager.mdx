---
title: cache-manager - Intelligent Caching
description: Multi-strategy caching with LRU, LFU, FIFO eviction, tiered storage, and tag-based invalidation
---

# cache-manager - Intelligent Caching

High-performance caching with multiple eviction strategies. LRU, LFU, FIFO, tiered caching, and smart invalidation patterns.

The cache-manager primitive provides in-memory caching with TTL support, multiple eviction policies, tag-based invalidation, cache warming, and multi-tier caching for optimized access patterns.

## Quick Start

```typescript
import { CacheManager, LRUCache } from 'dotdo/primitives/cache-manager'

// Basic cache with TTL
const cache = new CacheManager({
  ttl: 60000  // 1 minute default TTL
})

cache.set('user:123', userData)
const user = cache.get('user:123')

// LRU cache with max size
const lruCache = new LRUCache({
  maxSize: 1000,
  ttl: 300000  // 5 minutes
})
```

## Cache Strategies

### CacheManager (Basic)

Simple cache with TTL expiration. No automatic eviction.

```typescript
import { CacheManager } from 'dotdo/primitives/cache-manager'

const cache = new CacheManager({
  ttl: 60000  // Default TTL for all entries
})

// Set with default TTL
cache.set('key', value)

// Set with custom TTL
cache.set('key', value, { ttl: 120000 })

// Set with tags for invalidation
cache.set('product:123', product, {
  tags: ['products', 'category:electronics']
})
```

### LRU Cache (Least Recently Used)

Evicts the least recently accessed entry when at capacity. Best for general-purpose caching.

```typescript
import { LRUCache } from 'dotdo/primitives/cache-manager'

const cache = new LRUCache({
  maxSize: 1000,  // Max entries
  ttl: 300000     // 5 minute default TTL
})

cache.set('key', value)

// Get moves entry to "most recently used"
const value = cache.get('key')

// When full, oldest accessed entry is evicted
```

### LFU Cache (Least Frequently Used)

Evicts the least frequently accessed entry. Best when some items are much more popular than others.

```typescript
import { LFUCache } from 'dotdo/primitives/cache-manager'

const cache = new LFUCache({
  maxSize: 1000,
  ttl: 300000
})

// Access count increases with each get()
cache.get('popular-key')  // count: 1
cache.get('popular-key')  // count: 2
cache.get('popular-key')  // count: 3

// When full, lowest count entry is evicted
// Ties broken by insertion order (oldest evicted)
```

### FIFO Cache (First In, First Out)

Evicts the oldest inserted entry. Simple and predictable.

```typescript
import { FIFOCache } from 'dotdo/primitives/cache-manager'

const cache = new FIFOCache({
  maxSize: 1000,
  ttl: 300000
})

cache.set('a', 1)  // First in
cache.set('b', 2)
cache.set('c', 3)

// Access doesn't affect eviction order
cache.get('a')  // Still first to be evicted

// When full, 'a' (first inserted) is evicted
```

## Get or Set

Atomically get or compute values. Prevents thundering herd.

```typescript
// Sync factory
const value = cache.getOrSet('key', () => {
  return expensiveComputation()
})

// Async factory with deduplication
const data = await cache.getOrSet('user:123', async () => {
  // Only one request even if called concurrently
  return await fetchUser(123)
}, { ttl: 60000 })
```

## Tag-Based Invalidation

Invalidate groups of related entries efficiently.

```typescript
import { CacheManager, TagInvalidator } from 'dotdo/primitives/cache-manager'

const cache = new CacheManager()
const invalidator = new TagInvalidator(cache)

// Set entries with tags
cache.set('product:1', product1, { tags: ['products', 'category:electronics'] })
cache.set('product:2', product2, { tags: ['products', 'category:clothing'] })
cache.set('user:1', user1, { tags: ['users'] })

// Invalidate by tag
const count = invalidator.invalidate({ tags: ['products'] })
// count = 2, both products deleted, user untouched

// Invalidate by prefix
invalidator.invalidate({ prefix: 'product:' })

// Invalidate by regex
invalidator.invalidate({ regex: /^user:\d+$/ })
```

## Tiered Cache

Multiple cache layers with automatic promotion.

```typescript
import { TieredCache, LRUCache, CacheManager } from 'dotdo/primitives/cache-manager'

// Hot tier: small, fast LRU
const hotTier = new LRUCache({ maxSize: 100 })

// Warm tier: larger capacity
const warmTier = new LRUCache({ maxSize: 1000 })

const tiered = new TieredCache([
  {
    name: 'hot',
    cache: hotTier,
    promoteOnAccess: true  // Promote from lower tier on access
  },
  {
    name: 'warm',
    cache: warmTier,
    promoteOnAccess: false
  }
])

// Set goes to first tier
tiered.set('key', value)

// Get checks tiers in order, promotes on hit
const value = tiered.get('key')

// Manually demote to lower tier
tiered.demote('key')

// Aggregated stats from all tiers
const stats = tiered.stats()
```

## Cache Warming

Pre-populate cache for known access patterns.

```typescript
import { CacheWarmer, LRUCache } from 'dotdo/primitives/cache-manager'

const cache = new LRUCache({ maxSize: 10000 })
const warmer = new CacheWarmer(cache)

// Warm cache with list of keys
const result = await warmer.warm(
  ['user:1', 'user:2', 'user:3', 'user:4', 'user:5'],
  async (key) => {
    const id = key.split(':')[1]
    return await fetchUser(id)
  },
  { ttl: 300000 }
)

console.log(result)
// { total: 5, success: 5, failed: 0 }
```

## Statistics

Track cache performance.

```typescript
const stats = cache.stats()
// {
//   hits: 1234,        // Successful gets
//   misses: 100,       // Failed gets
//   hitRate: 0.925,    // hits / (hits + misses)
//   size: 500,         // Current entry count
//   evictions: 200,    // Evicted due to capacity
//   expirations: 50    // Expired by TTL
// }
```

## Serialization

Serialize cache values for external storage.

```typescript
import { JSONSerializer, MsgPackSerializer } from 'dotdo/primitives/cache-manager'

// JSON serializer (human readable)
const json = new JSONSerializer()
const str = json.serialize({ name: 'test', count: 42 })
const obj = json.deserialize(str)

// MsgPack serializer (compact binary)
const msgpack = new MsgPackSerializer()
const bytes = msgpack.serialize({ name: 'test', count: 42 })
const obj2 = msgpack.deserialize(bytes)

// MsgPack is more compact for complex objects
```

## Cache Options

Per-entry options when setting values.

```typescript
interface CacheOptions {
  ttl?: number           // Time to live in ms
  tags?: string[]        // Tags for invalidation
  priority?: number      // Optional priority hint
}

cache.set('key', value, {
  ttl: 60000,
  tags: ['users', 'vip'],
  priority: 1
})
```

## API Reference

### Common Methods

| Method | Description |
|--------|-------------|
| `get(key)` | Get value or undefined |
| `set(key, value, options?)` | Set value with options |
| `has(key)` | Check if key exists |
| `delete(key)` | Remove entry |
| `clear()` | Remove all entries |
| `keys()` | Get all valid keys |
| `size()` | Get entry count |
| `stats()` | Get statistics |
| `getOrSet(key, factory, options?)` | Get or compute value |

## Real-World Example

```typescript
import { TieredCache, LRUCache, TagInvalidator, CacheManager } from 'dotdo/primitives/cache-manager'

// Build tiered cache
const memoryCache = new LRUCache({ maxSize: 1000, ttl: 60000 })
const diskCache = new CacheManager({ ttl: 3600000 })

const cache = new TieredCache([
  { name: 'memory', cache: memoryCache, promoteOnAccess: true },
  { name: 'disk', cache: diskCache }
])

// Product catalog caching
async function getProduct(id: string) {
  return cache.getOrSet(`product:${id}`, async () => {
    const product = await db.products.findById(id)
    return product
  }, {
    tags: ['products', `category:${product.category}`],
    ttl: 300000
  })
}

// Invalidate on product update
async function updateProduct(id: string, data: ProductData) {
  await db.products.update(id, data)

  // Invalidate this product and related caches
  const invalidator = new TagInvalidator(memoryCache)
  invalidator.invalidate({ prefix: `product:${id}` })
}

// Invalidate entire category on sale
async function startCategorySale(category: string) {
  const invalidator = new TagInvalidator(memoryCache)
  invalidator.invalidate({ tags: [`category:${category}`] })
}
```

## Strategy Comparison

| Strategy | Best For | Pros | Cons |
|----------|----------|------|------|
| LRU | General use | Adapts to access patterns | Extra bookkeeping |
| LFU | Skewed popularity | Keeps hot items | Slow to adapt |
| FIFO | Simple, predictable | Low overhead | Ignores access patterns |

## Best Practices

1. **Use LRU** as the default strategy - it adapts well to most workloads
2. **Use LFU** when you have clearly popular items (e.g., trending products)
3. **Use tiered caching** for different access patterns (hot/warm/cold)
4. **Set appropriate TTLs** - balance freshness vs performance
5. **Use tags** for efficient group invalidation
6. **Monitor hit rates** - aim for > 90% for frequently accessed data

## Next Steps

- [rate-limiter](/docs/primitives/rate-limiter) - Protect cache from thundering herd
- [circuit-breaker](/docs/primitives/circuit-breaker) - Handle cache backend failures
- [validation-engine](/docs/primitives/validation-engine) - Validate cached data
