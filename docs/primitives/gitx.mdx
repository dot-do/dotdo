---
title: gitx - Git on R2
description: Git protocol implementation using R2 for blob storage and Durable Objects for refs
---

# gitx - Git on R2

Your agents need version control. They can't shell out to `git`. We built Git from scratch.

gitx implements the Git object model on Cloudflare R2. Blobs, trees, and commits are content-addressable objects in R2. Refs live in Durable Object metadata. SHA-1 hashing uses `crypto.subtle`.

## Quick Start

```typescript
// Configure git binding (done in DO initialization)
$.git.configure({
  repo: 'org/repo',
  branch: 'main',
  r2: env.R2_BUCKET
})

// Sync from R2 object store
await $.git.sync()

// Make changes
await $.fs.write('src/feature.ts', newCode)

// Stage and commit
await $.git.add('src/feature.ts')
await $.git.commit('feat: add new feature')

// Push to R2
await $.git.push()
```

## Configuration

Configure the git binding for your Durable Object:

```typescript
// In your DO initialization
$.git.configure({
  repo: 'org/repo',
  branch: 'main',
  r2: env.R2_BUCKET,
  path: 'packages/core'  // Optional: subdirectory
})

// Check binding
const binding = $.git.binding
console.log(`Tracking ${binding.repo}@${binding.branch}`)
console.log(`Current commit: ${binding.commit}`)
```

## Core Operations

### Status

```typescript
const status = await $.git.status()

console.log(`Branch: ${status.branch}`)
console.log(`HEAD: ${status.head}`)
console.log(`Clean: ${status.clean}`)

// Staged files ready to commit
for (const file of status.staged) {
  console.log(`Staged: ${file}`)
}

// Modified but not staged
for (const file of status.unstaged) {
  console.log(`Modified: ${file}`)
}
```

### Staging Files

```typescript
// Stage single file
await $.git.add('src/index.ts')

// Stage multiple files
await $.git.add(['src/a.ts', 'src/b.ts', 'tests/a.test.ts'])

// Stage all changes
await $.git.add('.')

// Stage by pattern
await $.git.add('src/**/*.ts')
```

### Committing

```typescript
// Simple commit
const result = await $.git.commit('feat: implement feature')
console.log(`Created commit: ${result.hash}`)

// Commit with options
await $.git.commit('fix: resolve bug', {
  author: 'Agent Ralph <ralph@agents.do>',
  allowEmpty: false
})
```

### Sync and Push

```typescript
// Pull latest changes from R2
const syncResult = await $.git.sync()
console.log(`Fetched ${syncResult.objectsFetched} objects`)
console.log(`Wrote ${syncResult.filesWritten} files`)
console.log(`Now at: ${syncResult.commit}`)

// Push local changes to R2
const pushResult = await $.git.push()
console.log(`Pushed ${pushResult.objectsPushed} objects`)
```

## How It Works

### Git Object Model

Git stores everything as content-addressable objects. gitx implements a three-tier storage system:

```
┌────────────────────────────────────────────────────────────────────────────┐
│                          gitx Tiered Storage                                │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────┐    ┌─────────────────────┐    ┌──────────────────┐   │
│   │   Hot Tier      │    │     Warm Tier       │    │    Cold Tier     │   │
│   │   (SQLite)      │    │     (R2 Loose)      │    │   (R2 Packfiles) │   │
│   ├─────────────────┤    ├─────────────────────┤    ├──────────────────┤   │
│   │ • Recent commits│    │ • Loose objects     │    │ • Pack files     │   │
│   │ • Active refs   │    │ • Full history      │    │ • Delta compress │   │
│   │ • Object cache  │    │ • Large blobs       │    │ • Archived data  │   │
│   │ • < 5ms access  │    │ • 50-100ms access   │    │ • 100-500ms      │   │
│   └─────────────────┘    └─────────────────────┘    └──────────────────┘   │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      DO Metadata (Refs)                              │  │
│   │  refs/heads/main -> fedcba9876...                                    │  │
│   │  refs/heads/feature-branch -> 1234567890...                          │  │
│   │  HEAD -> ref: refs/heads/main                                        │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────────────┘
```

### R2 Object Layout

Objects are stored in R2 using the standard Git two-character prefix for efficient listing:

```
git/objects/                         # Warm tier - loose objects
  ab/
    cdef1234567890abcdef1234567890abcdef12  (blob)
  12/
    34567890abcdef1234567890abcdef12345678  (tree)
  fe/
    dcba9876543210fedcba9876543210fedcba98  (commit)

git/objects/packs/                   # Cold tier - packfiles
  pack-abc123.pack   (delta-compressed objects)
  pack-abc123.idx    (pack index for fast lookup)
```

### Tier Configuration

```typescript
const storage = new TieredStorage({
  r2: env.GIT_OBJECTS,
  sql: ctx.storage.sql,
  hotTierMaxBytes: 50 * 1024 * 1024,    // 50MB in SQLite
  hotTierMaxObjectSize: 1 * 1024 * 1024, // 1MB max per object
  promotionThreshold: 3,                 // Promote after 3 accesses
  demotionAgeDays: 7                     // Demote after 7 days
})
```

| Setting | Default | Description |
|---------|---------|-------------|
| `hotTierMaxBytes` | 50 MB | Total SQLite cache capacity |
| `hotTierMaxObjectSize` | 1 MB | Max size for hot tier objects |
| `promotionThreshold` | 3 | Accesses before promotion |
| `demotionAgeDays` | 7 | Days before demotion |

### Object Access Path

When you request a Git object, gitx checks tiers in order:

```
1. Hot tier (SQLite)    → If found: return immediately (< 5ms)
                        → If miss: continue to warm tier

2. Warm tier (R2 loose) → If found: return, maybe promote
                        → If miss: continue to cold tier

3. Cold tier (R2 pack)  → Parse packfile at offset
                        → Return and maybe promote to warm
```

### SHA-1 via crypto.subtle

Every object is hashed to compute its address:

```typescript
// How gitx computes SHA-1
async function hashObject(type: string, data: Uint8Array): Promise<string> {
  const header = new TextEncoder().encode(`${type} ${data.length}\0`)
  const full = new Uint8Array([...header, ...data])

  const hash = await crypto.subtle.digest('SHA-1', full)
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
}
```

### Packfile Storage (Cold Tier)

For efficient storage, gitx can pack warm objects into packfiles:

```typescript
// Create a packfile from warm tier objects
const result = await storage.createPackfile(shas)
console.log(`Created ${result.packId} with ${result.objectCount} objects`)
console.log(`Size: ${result.size} bytes (delta compressed)`)
```

Packfiles use Git's standard format:
- **OFS_DELTA and REF_DELTA compression** - Objects stored as deltas against similar objects
- **MIDX support** - Multi-pack indexes for efficient lookup
- **Automatic packing** - Via maintenance or manual trigger

## Diff and Log

```typescript
// View diff of working changes (placeholder implementation)
const diff = await $.git.diff()
console.log(diff)

// Commit history (returns current commit only)
const commits = await $.git.log({ limit: 10 })
for (const commit of commits) {
  console.log(`${commit.hash.slice(0, 7)} ${commit.message}`)
}
```

Note: `diff()` and `log()` have placeholder implementations. Full diff output and commit traversal are not yet available.

## Working with Remotes

gitx uses R2 as its primary "remote" storage, but can sync with external Git hosts like GitHub and GitLab.

### R2 as Primary Remote

By default, all Git operations store objects in R2:

```typescript
// Configure R2 as the remote
$.git.configure({
  repo: 'org/repo',
  branch: 'main',
  r2: env.R2_BUCKET,
})

// sync() fetches from R2, push() writes to R2
await $.git.sync()   // R2 -> local
await $.git.push()   // local -> R2
```

### GitHub Integration

gitx can sync bidirectionally with GitHub:

```typescript
// Configure GitHub as secondary remote
$.git.configure({
  repo: 'org/repo',
  branch: 'main',
  r2: env.R2_BUCKET,
  github: {
    token: env.GITHUB_TOKEN,
    syncOnPush: true  // Auto-sync to GitHub on push
  }
})

// Push syncs to both R2 and GitHub
await $.git.push()  // Writes to R2, then pushes to GitHub
```

### Clone/Pull/Push Mechanics

**Clone (initial sync):**
```typescript
// First sync fetches all objects from R2 (or GitHub)
const result = await $.git.sync()
// result.objectsFetched - number of Git objects downloaded
// result.filesWritten - files extracted to working directory
// result.commit - current HEAD commit
```

**Pull (incremental sync):**
```typescript
// Subsequent syncs only fetch new objects
await $.git.sync()  // Fetches objects not in local store
```

**Push (upload changes):**
```typescript
// Stage, commit, then push
await $.git.add('src/feature.ts')
await $.git.commit('feat: add feature')

const result = await $.git.push()
// result.objectsPushed - number of objects uploaded
// result.commit - pushed commit hash
```

### Wire Protocol

gitx implements Git's smart HTTP protocol for external remotes:

```
┌─────────────────────────────────────────────────────────────┐
│                    Git Wire Protocol                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Capability negotiation (protocol v2)                     │
│     Client: "want abc123, have def456"                       │
│     Server: "ACK def456"                                     │
│                                                              │
│  2. Pack transfer                                            │
│     Server sends packfile with requested objects             │
│     Delta compression reduces transfer size                  │
│                                                              │
│  3. Reference update                                         │
│     Client: "update refs/heads/main old-sha new-sha"         │
│     Server: "ok refs/heads/main"                             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Consistency and Multi-Agent Collaboration

Multiple agents can work on the same repository via R2:

```typescript
// Agent 1: Make changes and push
await agent1.$.fs.write('src/a.ts', codeA)
await agent1.$.git.add('src/a.ts')
await agent1.$.git.commit('feat: add A')
await agent1.$.git.push()

// Agent 2: Sync to see Agent 1's changes
await agent2.$.git.sync()
// Now agent2 sees the new commit and files

// Agent 2: Add more changes
await agent2.$.fs.write('src/b.ts', codeB)
await agent2.$.git.add('src/b.ts')
await agent2.$.git.commit('feat: add B')
await agent2.$.git.push()
```

**Consistency guarantees:**
- **R2 read-after-write** - Once a push completes, all agents see the new objects
- **Refs in DO metadata** - Branch pointers are strongly consistent per-DO
- **No concurrent conflicts** - Each DO has its own working directory

Note: Branch operations (`checkout`, `branch`, `merge`, `rebase`) are not yet implemented. Multi-agent workflows currently operate on a single branch.

## Error Handling

Git operations throw standard `Error` objects with descriptive messages:

```typescript
try {
  await $.git.push()
} catch (error) {
  // Check error message for specific conditions
  const message = (error as Error).message

  if (message.includes('not configured')) {
    console.log('R2 bucket not configured')
  } else if (message.includes('No commits to push')) {
    console.log('Nothing to push - commit first')
  } else if (message.includes('Nothing to commit')) {
    console.log('No staged changes')
  } else {
    throw error
  }
}
```

## Type Definitions

```typescript
interface GitBinding {
  repo: string
  branch: string
  path?: string
  commit?: string
  lastSync?: Date
}

interface GitStatus {
  branch: string
  head?: string
  staged: string[]
  unstaged: string[]
  untracked?: string[]
  clean: boolean
}

interface GitCommitResult {
  hash: string
}

interface SyncResult {
  success: boolean
  objectsFetched: number
  filesWritten: number
  commit?: string
  error?: string
}

interface PushResult {
  success: boolean
  objectsPushed: number
  commit?: string
  error?: string
}
```

## Performance

| Operation | Time | Notes |
|-----------|------|-------|
| status | < 5ms | Local DO state |
| add (single file) | < 2ms | Local staging |
| commit | 10-50ms | Create objects, hash |
| sync (100 objects) | 200-500ms | R2 parallel fetch |
| push (10 objects) | 100-300ms | R2 parallel put |

## Comparison to Git CLI

| Feature | @dotdo/gitx | Git CLI |
|---------|-------------|---------|
| Object storage | R2 bucket | Local `.git/` |
| Ref storage | DO metadata | Local files |
| Network protocol | R2 API | SSH/HTTPS |
| Hashing | crypto.subtle | libgit2 |
| Edge deployment | Yes | No |
| Multi-agent | Native R2 consistency | Needs coordination |

## Technical Details

For implementation details, architecture decisions, and contributor documentation:

- **[gitx README](https://github.com/dotdo/dotdo/blob/main/primitives/gitx/README.md)** - Package documentation with 5,600+ tests, full Git protocol implementation (pack files, delta compression, smart HTTP), tiered storage architecture, MCP tools, and CLI reference

### Key Implementation Details

| Feature | Implementation |
|---------|----------------|
| SHA-1 hashing | `crypto.subtle` (Web Crypto API) |
| Object storage | R2 with two-character prefix layout |
| Refs storage | Durable Object metadata |
| Pack engine | OFS_DELTA and REF_DELTA compression, MIDX support |
| Wire protocol | Smart HTTP with capability negotiation |

## Next Steps

- [fsx](/docs/primitives/fsx) - The filesystem that gitx tracks
- [bashx](/docs/primitives/bashx) - Run git hooks and build scripts
- [Capabilities](/docs/sdk/capabilities) - Add git to your DOs
