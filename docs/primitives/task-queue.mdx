---
title: task-queue - Background Jobs
description: Priority-based job queue with retries, scheduling, progress tracking, and dead letter support
---

# task-queue - Background Jobs

Run background jobs with priority ordering, automatic retries, progress tracking, and scheduling. Built for durable execution.

The task-queue primitive provides a complete job processing system with configurable concurrency, multiple retry strategies, cron scheduling, task cancellation, and dead letter queue for failed tasks.

## Quick Start

```typescript
import { TaskQueue } from 'dotdo/primitives/task-queue'

const queue = new TaskQueue({
  concurrency: 3,    // Process 3 tasks at once
  retries: 2,        // Retry failed tasks twice
  timeout: 30000     // 30 second timeout
})

// Register handler for task type
queue.registerHandler('send-email', async (task, ctx) => {
  const { to, subject, body } = task.payload as EmailPayload
  await sendEmail(to, subject, body)
})

// Enqueue a task
await queue.enqueue({
  type: 'send-email',
  payload: { to: 'user@example.com', subject: 'Hello', body: '...' },
  priority: 10  // Higher priority runs first
})

// Start processing
await queue.process()
```

## Configuration

```typescript
const queue = new TaskQueue({
  // Concurrency
  concurrency: 5,           // Max parallel tasks (default: 1)

  // Retries
  retries: 3,               // Max retry attempts (default: 3)

  // Timeout
  timeout: 60000,           // Task timeout in ms (default: 30000)

  // Backoff strategy
  backoff: {
    type: 'exponential',    // 'fixed' | 'linear' | 'exponential'
    delay: 1000,            // Base delay in ms
    factor: 2,              // Multiplier for exponential
    maxDelay: 60000         // Maximum delay
  },

  // Dead letter queue
  deadLetter: {
    maxAge: 7 * 24 * 60 * 60 * 1000,  // Retain for 7 days
    handler: async (task) => {
      await alertOps('Task failed permanently', task)
    }
  }
})
```

## Task Handlers

### Basic Handler

```typescript
queue.registerHandler('process-order', async (task, ctx) => {
  const order = task.payload as Order
  await processOrder(order)
  return { success: true }
})
```

### Progress Tracking

```typescript
queue.registerHandler('export-data', async (task, ctx) => {
  const records = await getRecords()

  for (let i = 0; i < records.length; i++) {
    await exportRecord(records[i])

    // Report progress
    ctx.progress(i + 1, records.length, `Processing record ${i + 1}`)
  }

  return { exported: records.length }
})

// Monitor progress
const progress = queue.getProgress(taskId)
// { taskId, current: 50, total: 100, percentage: 50, message: 'Processing record 50' }
```

### Cancellation Support

```typescript
queue.registerHandler('long-running', async (task, ctx) => {
  const items = task.payload as Item[]

  for (const item of items) {
    // Check if task was cancelled
    if (ctx.signal.aborted) {
      throw new Error('Task cancelled')
    }

    await processItem(item)
  }
})

// Cancel a running task
await queue.cancel(taskId, { force: true })
```

## Enqueueing Tasks

### Basic Enqueue

```typescript
const taskId = await queue.enqueue({
  type: 'send-email',
  payload: { to: 'user@example.com', subject: 'Hello' }
})
```

### Priority

```typescript
// Higher priority tasks run first
await queue.enqueue({
  type: 'urgent-notification',
  payload: data,
  priority: 100  // Default is 0
})

await queue.enqueue({
  type: 'background-sync',
  payload: data,
  priority: -10  // Lower priority
})
```

### Custom Task ID

```typescript
await queue.enqueue({
  id: 'user-123-welcome-email',  // Custom ID
  type: 'send-email',
  payload: { to: 'user@example.com' }
})
```

## Scheduling

### One-Time Schedule

```typescript
// Run at a specific time
await queue.schedule({
  runAt: new Date('2024-01-15T09:00:00Z'),
  task: {
    type: 'send-reminder',
    payload: { userId: 'user-123' }
  }
})
```

### Cron Schedule

```typescript
// Run on a cron schedule
await queue.schedule({
  cron: '0 9 * * *',  // Every day at 9 AM
  task: {
    type: 'daily-report',
    payload: { reportType: 'sales' }
  }
})

// Every minute
await queue.schedule({
  cron: '* * * * *',
  task: { type: 'health-check', payload: {} }
})
```

## Queue Control

### Pause and Resume

```typescript
// Pause processing (tasks stay in queue)
queue.pause()

// Resume processing
queue.resume()

// Check if paused
console.log(queue.isPaused)  // true/false
```

### Stop Processing

```typescript
// Stop the queue (waits for running tasks to complete)
await queue.stop()
```

### Task Status

```typescript
const status = await queue.getStatus(taskId)
// 'pending' | 'running' | 'completed' | 'failed' | 'cancelled'
```

## Events

```typescript
// Task lifecycle events
queue.on('task:enqueued', (task) => {
  console.log(`Task ${task.id} enqueued`)
})

queue.on('task:started', (task) => {
  console.log(`Task ${task.id} started`)
})

queue.on('task:completed', (data) => {
  console.log(`Task ${data.id} completed:`, data.result)
})

queue.on('task:failed', (data) => {
  console.error(`Task ${data.id} failed:`, data.error)
})

queue.on('task:retry', (data) => {
  console.log(`Task ${data.id} retry #${data.attempt}, next delay: ${data.nextDelay}ms`)
})

queue.on('task:cancelled', (task) => {
  console.log(`Task ${task.id} cancelled`)
})

queue.on('task:deadletter', (task) => {
  console.error(`Task ${task.id} moved to dead letter queue`)
})

// Progress events
queue.on('task:progress', (progress) => {
  console.log(`Task ${progress.taskId}: ${progress.percentage}% - ${progress.message}`)
})

// Queue events
queue.on('queue:empty', () => {
  console.log('Queue is empty')
})

queue.on('queue:paused', () => {
  console.log('Queue paused')
})

queue.on('queue:resumed', () => {
  console.log('Queue resumed')
})
```

## Dead Letter Queue

Handle permanently failed tasks.

```typescript
// Get dead letter queue
const dlq = queue.deadLetterQueue

// List failed tasks
const failedTasks = dlq.list()
// [{ task, error, addedAt }, ...]

// Get specific task
const entry = dlq.get(taskId)

// Retry a task from DLQ
await queue.retryFromDeadLetter(taskId)

// Process all DLQ tasks with custom handler
await dlq.process()  // Uses deadLetter.handler from config

// Cleanup old entries
dlq.cleanup()  // Removes entries older than maxAge

// DLQ size
console.log(dlq.size)  // Number of failed tasks
```

## Backoff Strategies

```typescript
// Fixed delay: 1000ms, 1000ms, 1000ms
{ type: 'fixed', delay: 1000 }

// Linear: 1000ms, 2000ms, 3000ms
{ type: 'linear', delay: 1000 }

// Exponential: 1000ms, 2000ms, 4000ms, 8000ms (capped at maxDelay)
{ type: 'exponential', delay: 1000, factor: 2, maxDelay: 60000 }
```

## Supporting Classes

### Priority Queue

```typescript
import { PriorityQueue } from 'dotdo/primitives/task-queue'

const pq = new PriorityQueue<Task>((a, b) => b.priority - a.priority)

pq.enqueue(task1)
pq.enqueue(task2)

const highest = pq.dequeue()  // Highest priority
const next = pq.peek()        // Preview without removing
const removed = pq.remove(t => t.id === 'abc')

console.log(pq.size)
```

### Concurrency Limiter

```typescript
import { ConcurrencyLimiter } from 'dotdo/primitives/task-queue'

const limiter = new ConcurrencyLimiter(5)  // Max 5 concurrent

// Automatically waits if at capacity
const result = await limiter.run(async () => {
  return await expensiveOperation()
})

console.log(limiter.running)  // Current count
```

### Retry Manager

```typescript
import { RetryManager } from 'dotdo/primitives/task-queue'

const retry = new RetryManager({
  maxRetries: 3,
  backoff: { type: 'exponential', delay: 1000, factor: 2, maxDelay: 30000 }
})

const result = await retry.execute(async () => {
  return await unreliableOperation()
})

const delay = retry.calculateDelay(2)  // Delay for attempt 2
```

## Real-World Example

```typescript
import { TaskQueue } from 'dotdo/primitives/task-queue'

const queue = new TaskQueue({
  concurrency: 10,
  retries: 3,
  timeout: 120000,  // 2 minutes
  backoff: { type: 'exponential', delay: 1000, factor: 2, maxDelay: 60000 },
  deadLetter: {
    maxAge: 7 * 24 * 60 * 60 * 1000,
    handler: async (task) => {
      await slack.send('#alerts', `Task ${task.id} failed permanently`)
    }
  }
})

// Email sending
queue.registerHandler('email', async (task, ctx) => {
  const { template, to, data } = task.payload as EmailTask
  const html = await renderTemplate(template, data)
  await sendEmail({ to, html })
})

// Image processing
queue.registerHandler('process-image', async (task, ctx) => {
  const { imageUrl, sizes } = task.payload as ImageTask

  for (let i = 0; i < sizes.length; i++) {
    if (ctx.signal.aborted) throw new Error('Cancelled')

    ctx.progress(i, sizes.length, `Generating ${sizes[i]}`)
    await generateThumbnail(imageUrl, sizes[i])
  }
})

// Webhook delivery with retries
queue.registerHandler('webhook', async (task, ctx) => {
  const { url, payload } = task.payload as WebhookTask

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  })

  if (!response.ok) {
    throw new Error(`Webhook failed: ${response.status}`)
  }
})

// Monitor events
queue.on('task:failed', (data) => {
  metrics.increment('queue.task.failed', { type: data.type })
})

queue.on('task:completed', (data) => {
  metrics.timing('queue.task.duration', data.result.duration)
})

// Start processing
await queue.process()

// Enqueue tasks
await queue.enqueue({
  type: 'email',
  payload: { template: 'welcome', to: 'user@example.com', data: { name: 'John' } },
  priority: 10
})

await queue.enqueue({
  type: 'process-image',
  payload: { imageUrl: 'https://...', sizes: ['thumb', 'medium', 'large'] },
  priority: 5
})
```

## Next Steps

- [event-emitter](/docs/primitives/event-emitter) - Trigger tasks from events
- [rate-limiter](/docs/primitives/rate-limiter) - Limit task execution rate
- [circuit-breaker](/docs/primitives/circuit-breaker) - Handle external service failures
