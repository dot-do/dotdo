---
title: Database
description: Data persistence, querying, and edge-native storage
---

# Database

dotdo provides edge-native database primitives with support for SQL, document, vector, and time-series workloads. All implementations are backed by Durable Objects SQLite for edge-native execution.

## SQL Databases

Drop-in replacements for popular SQL database client libraries.

### PostgreSQL (pg)

```typescript
import { Client, Pool } from 'db/compat/sql/postgres'

const client = new Client({ host: 'localhost' })
await client.connect()

const result = await client.query('SELECT * FROM users WHERE active = $1', [true])
console.log(result.rows)

await client.end()
```

### MySQL

```typescript
import { createConnection, createPool } from 'db/compat/sql/mysql'

const conn = await createConnection({ host: 'localhost', database: 'mydb' })
const [rows] = await conn.execute('SELECT * FROM users WHERE status = ?', ['active'])
```

### Turso / libSQL

```typescript
import { createClient } from 'db/compat/sql/turso'

const client = createClient({ url: 'libsql://my-db.turso.io' })
const result = await client.execute('SELECT * FROM users')
```

**Supported SQL adapters:** PostgreSQL, MySQL, Turso, PlanetScale, Neon, TiDB, CockroachDB, DuckDB, DuckDB-WASM

## Document Databases

MongoDB-compatible API backed by DO SQLite with JSON storage.

### MongoDB

```typescript
import { createClient, ObjectId } from 'db/compat/nosql/mongo'

const client = createClient('mongodb://localhost:27017')
await client.connect()

const db = client.db('mydb')
const users = db.collection('users')

// Insert
await users.insertOne({ name: 'Alice', status: 'active' })

// Query with filters
const activeUsers = await users.find({ status: 'active' }).toArray()

// Aggregation pipeline
const stats = await users.aggregate([
  { $match: { status: 'active' } },
  { $group: { _id: '$role', count: { $sum: 1 } } }
]).toArray()
```

**Supported NoSQL adapters:** MongoDB, CouchDB, Firebase, Convex, DynamoDB

## Vector Search

EdgeVec provides HNSW-based vector search via a service binding.

```typescript
// EdgeVec runs as a separate worker with WASM
// Access via env.EDGEVEC service binding

// Create an index
const result = await env.EDGEVEC.createIndex('my-namespace', 'products', {
  dimensions: 1536,
  metric: 'cosine'
})

// Insert vectors
await env.EDGEVEC.insert('my-namespace', 'products', [
  { id: 'prod-1', values: embedding, metadata: { category: 'electronics' } },
  { id: 'prod-2', values: embedding2, metadata: { category: 'clothing' } }
])

// Search
const searchResult = await env.EDGEVEC.search(
  'my-namespace',
  'products',
  queryEmbedding,
  { k: 10 }
)

if (searchResult.success) {
  console.log(searchResult.results) // [{ id, score, metadata }]
}
```

EdgeVec supports:
- Distance metrics: `cosine`, `euclidean`, `dot`
- Batch search for multiple queries
- Metadata filtering
- Persistence to DO storage

## Time-Series

InfluxDB v2 compatible API for time-series data.

```typescript
import { createClient, Point } from 'db/compat/influxdb'

const client = createClient({ org: 'my-org' })

// Write with Point builder
const writeApi = client.getWriteApi('my-org', 'metrics')
writeApi.writePoint(
  Point.measurement('cpu')
    .tag('host', 'server01')
    .floatField('usage', 0.64)
    .timestamp(Date.now())
)
await writeApi.close()

// Or write line protocol directly
await client.writeLineProtocol('metrics', 'cpu,host=server01 usage=0.64')

// Query with Flux
const queryApi = client.getQueryApi('my-org')
const rows = await queryApi.collectRows(`
  from(bucket: "metrics")
    |> range(start: -1h)
    |> filter(fn: (r) => r._measurement == "cpu")
    |> mean()
`)
```

Supports aggregations: mean, sum, count, min, max, first, last, median, stddev

## Edge Storage

- **SQLite on DO**: Transactional storage in Durable Objects
- **R2**: Object storage for large files and Parquet archives
- **KV**: Global key-value for caching

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│  DO SQLite (Hot Index Layer)         R2 Iceberg (Cold Data)            │
│  ┌────────────────────────────┐     ┌────────────────────────────────┐ │
│  │ Index Columns:              │     │ Full Data:                     │ │
│  │ • _ids (all IDs)            │     │ • things/type=User/*.parquet   │ │
│  │ • _types (all types)        │────▶│ • things/type=Order/*.parquet  │ │
│  │ • bloom:data.email          │     │ • relationships/*.parquet      │ │
│  │ • minmax:createdAt          │     │                                │ │
│  └────────────────────────────┘     └────────────────────────────────┘ │
│  \<1ms access, ~100MB index          ~100ms access, unlimited storage   │
└─────────────────────────────────────────────────────────────────────────┘
```

## Core Components

### Things & Versioning

The foundational entity storage with append-only versioning:

```typescript
import { ThingsStore } from 'db/stores'

const things = new ThingsStore(ctx)

// Create versioned entity
const user = await things.create({
  $type: 'User',
  name: 'Alice',
  data: { email: 'alice@example.com' }
})

// Time-travel queries
const oldVersion = await things.get('abc123', { version: 1 })
```

[Learn more about Things](/docs/database/things)

### Store Accessors

Typed APIs for Things, Relationships, Actions, Events, Search, and Objects:

```typescript
import { ThingsStore, RelationshipsStore, EventsStore } from 'db/stores'

const things = new ThingsStore(ctx)
const relationships = new RelationshipsStore(ctx)
const events = new EventsStore(ctx)
```

[Learn more about Store Accessors](/docs/database/stores)

### Query Engine

Unified query primitive for Document, Analytics, Search, and Graph workloads:

```typescript
import { MongoQueryParser, PredicateCompiler, ExecutionEngine } from 'db/primitives/query-engine'

const parser = new MongoQueryParser()
const ast = parser.parse({ age: { $gt: 21 }, status: 'active' })
```

[Learn more about the Query Engine](/docs/database/query-engine)

### Database Primitives

Core building blocks including temporal stores, columnar storage, and streaming:

```typescript
import { createTemporalStore, createColumnStore, WindowManager } from 'db/primitives'
```

[Learn more about Database Primitives](/docs/database/primitives)

### JSON Indexes

Expression indexes on JSON fields for fast structured data queries:

```typescript
import { createJsonIndex, syncNounIndexes } from 'db/json-indexes'

await createJsonIndex(db, { table: 'things', path: 'email', typeId: 1 })
```

[Learn more about JSON Indexes](/docs/database/json-indexes)

### Iceberg Storage

Apache Iceberg format for cold storage with fast point lookups:

```typescript
import { IcebergReader } from 'db/iceberg'

const reader = new IcebergReader(env.R2)
const record = await reader.getRecord({
  table: 'do_resources',
  partition: { ns: 'myapp.do', type: 'Function' },
  id: 'processPayment'
})
```

[Learn more about Iceberg Storage](/docs/database/iceberg)

### EdgeVec Vector Database

HNSW-based vector search with quantization and R2 persistence:

[Learn more about EdgeVec](/docs/database/edgevec)

## Related

- [Storage](/docs/storage) - Hot, warm, and cold storage tiers architecture
- [Storage: Hot Tier](/docs/storage/hot-tier) - DO SQLite for active working sets
- [Storage: Warm Tier](/docs/storage/warm-tier) - R2 + Iceberg/Parquet for cross-DO queries
- [Storage: Cold Tier](/docs/storage/cold-tier) - ClickHouse + R2 Archive for analytics
- [Compat: Databases](/docs/compat/databases) - Database compatibility layers
