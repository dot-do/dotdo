---
title: Database Proxy (DBPromise)
description: Promise pipelining for efficient database operations with fluent query building
---

# Database Proxy (DBPromise)

The `db/proxy` module implements Cap'n Proto-style promise pipelining for database operations. This enables chaining multiple operations without awaiting intermediate results, reducing network round trips.

## Overview

Traditional database access requires awaiting each operation:

```typescript
// Traditional: 3 network round trips
const lead = await db.getLead('lead-123')
const company = await db.getCompany(lead.companyId)
const contacts = await db.getContacts(company.id)
```

With promise pipelining, the entire pipeline executes in one round trip:

```typescript
// Pipelined: 1 network round trip
const contacts = await db.Lead
  .get('lead-123')
  .expand('company')
  .expand('contacts')
```

## Architecture

```
+------------------------------------------------------------------+
|  db.Lead                    (DBProxy)                             |
|  - Property access creates EntityAccessor                         |
+----------------------------+-------------------------------------+
                             |
                             v
+----------------------------+-------------------------------------+
|  EntityAccessor                                                   |
|  - get(id), list(), find(), search()                              |
|  - create(), update(), delete()                                   |
|  - Template literal: db.Lead`who closed deals?`                   |
+----------------------------+-------------------------------------+
                             |
                             v
+----------------------------+-------------------------------------+
|  DBPromise                                                        |
|  - Accumulates operations (filter, sort, limit, expand)           |
|  - Executes lazily when awaited                                   |
|  - Results cached (memoized)                                      |
+------------------------------------------------------------------+
```

## Quick Start

```typescript
import { createDBProxy } from 'db/proxy'

class MyDO extends DOBase {
  get db() {
    return createDBProxy(this)
  }

  async process() {
    // Fluent query building
    const results = await this.db.Lead
      .filter(lead => lead.status === 'active')
      .orderBy('score', 'desc')
      .limit(10)

    // Natural language query
    const deals = await this.db.Lead`who closed deals this month?`
  }
}
```

## DBPromise API

### Filtering

```typescript
// Predicate function
const active = await db.User
  .filter(user => user.status === 'active' && user.age >= 18)

// Field equality
const admins = await db.User
  .where('role', 'admin')

// Operators
const highValue = await db.Customer
  .whereOp('revenue', 'gte', 100000)
  .whereOp('status', 'in', ['active', 'premium'])
```

#### Available Operators

| Operator | Description | Example |
|----------|-------------|---------|
| `eq` | Equal | `whereOp('status', 'eq', 'active')` |
| `neq` | Not equal | `whereOp('deleted', 'neq', true)` |
| `gt` | Greater than | `whereOp('score', 'gt', 80)` |
| `gte` | Greater than or equal | `whereOp('age', 'gte', 18)` |
| `lt` | Less than | `whereOp('count', 'lt', 10)` |
| `lte` | Less than or equal | `whereOp('price', 'lte', 100)` |
| `in` | In set | `whereOp('category', 'in', ['A', 'B'])` |
| `nin` | Not in set | `whereOp('status', 'nin', ['deleted'])` |
| `contains` | String contains | `whereOp('name', 'contains', 'Smith')` |
| `startsWith` | String starts with | `whereOp('email', 'startsWith', 'admin')` |
| `endsWith` | String ends with | `whereOp('domain', 'endsWith', '.com')` |

### Transformation

```typescript
// Map results
const names = await db.User
  .map(user => ({ $id: user.$id, displayName: `${user.firstName} ${user.lastName}` }))

// Select specific fields
const summary = await db.Order
  .select('$id', 'total', 'status')

// Expand relationships
const leadWithCompany = await db.Lead
  .expand('company')
  .expand('contacts')
```

### Ordering

```typescript
// Custom comparator
const sorted = await db.Product
  .sort((a, b) => b.price - a.price)

// Field-based ordering
const recent = await db.Order
  .orderBy('createdAt', 'desc')

// Multiple sorts
const complex = await db.Lead
  .orderBy('priority', 'desc')
  .orderBy('createdAt', 'asc')
```

### Pagination

```typescript
// Limit results
const top10 = await db.Lead.limit(10)

// Offset-based pagination
const page2 = await db.Lead
  .offset(20)
  .limit(10)

// Cursor-based pagination
const afterId = await db.Lead
  .after('last-cursor-id')
  .limit(10)

// Paginate helper with cursor
const page = await db.Lead.paginate({
  limit: 10,
  cursor: previousCursor
})
const results = await page
const nextCursor = await page.nextCursor
```

### Aggregation

```typescript
// Count results
const total = await db.User
  .filter(u => u.active)
  .count()

// Get first result
const first = await db.Order
  .orderBy('createdAt', 'desc')
  .first()

// Check existence
const hasAdmins = await db.User
  .where('role', 'admin')
  .exists()
```

### Batch Processing

Process items with concurrency control and crash recovery:

```typescript
const result = await db.Lead
  .filter(lead => lead.status === 'new')
  .forEach(async (lead, index) => {
    await sendEmail(lead.email, 'Welcome!')
  }, {
    // Concurrency control
    concurrency: 5,

    // Retry configuration
    maxRetries: 3,
    retryDelay: 1000,  // Exponential backoff

    // Crash recovery
    persist: true,
    resume: 'previous-run-id',  // Resume from failed run

    // Batch size for fetching
    batchSize: 100,

    // Progress callback
    onProgress: (progress) => {
      console.log(`${progress.completed}/${progress.total}`)
      console.log(`Rate: ${progress.rate.toFixed(1)} items/sec`)
      console.log(`ETA: ${Math.round(progress.eta / 1000)}s`)
    },

    // Error handling
    onError: (error, item, attempt) => {
      if (error.message.includes('rate limit')) {
        return 'retry'  // Retry with backoff
      }
      if (error.message.includes('invalid email')) {
        return 'skip'   // Skip this item
      }
      return 'abort'    // Stop processing
    }
  })

console.log(`Completed: ${result.completed}`)
console.log(`Failed: ${result.failed}`)
console.log(`Skipped: ${result.skipped}`)
console.log(`Duration: ${result.duration}ms`)
console.log(`Run ID: ${result.runId}`)  // For resumption
```

#### ForEach Progress

```typescript
interface ForEachProgress {
  total: number       // Total items to process
  completed: number   // Successfully processed
  failed: number      // Failed after all retries
  skipped: number     // Skipped items
  inProgress: number  // Currently processing
  rate: number        // Items per second
  eta: number         // Estimated time remaining (ms)
  runId: string       // Run ID for resumption
}
```

## EntityAccessor

Access entities by type via the proxy:

```typescript
// Get single entity
const lead = await db.Lead.get('lead-123')

// List entities
const leads = await db.Lead.list({
  limit: 100,
  offset: 0,
  orderBy: 'createdAt',
  order: 'desc'
})

// Find with criteria
const active = await db.Lead.find({
  status: 'active',
  score: { $gt: 50 }
})

// Search by text
const matches = await db.Lead.search('enterprise sales', {
  limit: 10,
  type: 'semantic'  // 'text' | 'semantic' | 'hybrid'
})

// Create
const newLead = await db.Lead.create({
  name: 'Acme Corp',
  status: 'new'
})

// Update
const updated = await db.Lead.update('lead-123', {
  status: 'qualified'
})

// Delete
const deleted = await db.Lead.delete('lead-123')
```

### Natural Language Queries

Query using template literals:

```typescript
// Simple query
const deals = await db.Lead`who closed deals this month?`

// With interpolation
const region = 'West Coast'
const topLeads = await db.Lead`top 10 leads by revenue in ${region}`

// Complex query
const year = 2024
const status = 'active'
const report = await db.Order`
  summarize orders where status is ${status}
  from ${year} grouped by quarter
`
```

### Async Iteration

```typescript
for await (const user of db.User) {
  console.log(user.name)
}
```

## Lazy Execution

Operations are accumulated and executed only when awaited:

```typescript
// No database calls yet
const pipeline = db.Lead
  .filter(l => l.active)
  .orderBy('score', 'desc')
  .limit(10)

// Execution happens here
const results = await pipeline
```

### Memoization

Results are cached after first execution:

```typescript
const query = db.Lead.limit(10)

const first = await query   // Executes query
const second = await query  // Returns cached result
```

### Immutability

Each operation creates a new DBPromise:

```typescript
const base = db.Lead.filter(l => l.active)
const topTen = base.limit(10)      // New DBPromise
const sorted = base.orderBy('score')  // New DBPromise from same base

// base is unchanged
```

## Relationship Expansion

Define and resolve relationships:

```typescript
// Relationships defined in data source
const relationships = new Map([
  ['company', {
    name: 'company',
    targetType: 'Company',
    cardinality: 'one',
    foreignKey: 'companyId'
  }],
  ['contacts', {
    name: 'contacts',
    targetType: 'Contact',
    cardinality: 'many',
    verb: 'has_contact'
  }]
])

// Expand in query
const leadWithCompany = await db.Lead
  .get('lead-123')
  .expand('company')

// Nested expansion
const full = await db.Lead
  .expand('company.employees')
  .expand('contacts')
```

## Type Safety

DBPromise preserves types through the chain:

```typescript
interface Lead extends ThingEntity {
  status: string
  score: number
  company?: Company
}

const leads: Lead[] = await db.Lead
  .filter((lead: Lead) => lead.score > 50)
  .orderBy('score')

// Type-safe field access
const lead = await db.Lead.first()
if (lead) {
  console.log(lead.status)  // Type: string
}
```

## Custom Data Source

Implement DBPromiseDataSource for custom backends:

```typescript
import { DBPromise, DBPromiseDataSource } from 'db/proxy'

class CustomDataSource implements DBPromiseDataSource {
  async fetchAll(): Promise<ThingEntity[]> {
    return this.api.fetchEntities()
  }

  async fetchPage(options: {
    limit: number
    offset?: number
    after?: string
  }): Promise<ThingEntity[]> {
    return this.api.fetchPage(options)
  }

  async count(): Promise<number> {
    return this.api.count()
  }

  getEntityType(): string {
    return 'CustomEntity'
  }

  // Optional: for crash recovery
  async persistProgress(tracker: ForEachProgress): Promise<void> {
    await this.storage.save(tracker.runId, tracker)
  }

  async loadProgress(runId: string): Promise<{ completedIds: string[] } | null> {
    return this.storage.load(runId)
  }

  // Optional: for relationship expansion
  getRelationships(): Map<string, RelationshipDefinition> {
    return this.relationships
  }

  async resolveRelationship(
    item: ThingEntity,
    relationName: string
  ): Promise<ThingEntity | ThingEntity[] | null> {
    const rel = this.relationships.get(relationName)
    if (!rel) return null
    return this.api.fetchRelated(item.$id, rel)
  }
}

// Use custom data source
const dataSource = new CustomDataSource(api)
const query = new DBPromise(dataSource)
  .filter(item => item.active)
  .limit(10)
```

## Error Handling

```typescript
import { NotImplementedError } from 'db/proxy'

try {
  const result = await db.Lead
    .expand('company')  // May throw if not implemented
} catch (error) {
  if (error instanceof NotImplementedError) {
    console.log(`Feature not implemented: ${error.method}`)
    // Fallback to manual join
    const lead = await db.Lead.get('lead-123')
    const company = await db.Company.get(lead.companyId)
  }
}
```

## Related

- [Store Accessors](/docs/database/stores) - Underlying store APIs
- [Things & Versioning](/docs/database/things) - Entity storage
- [Query Engine](/docs/database/query-engine) - Query optimization
- [Cap'n Web RPC](/docs/rpc/capnweb) - Promise pipelining protocol
