---
title: Domain Primitives
description: Commerce, analytics, notifications, and other domain-specific database primitives
---

# Domain Primitives

The `db/primitives` module includes domain-specific building blocks for common business applications. These primitives are designed to work with DO SQLite and integrate with the broader dotdo data layer.

## Commerce

E-commerce primitives for cart, catalog, inventory, pricing, and orders.

### Cart Engine

Shopping cart with rules, discounts, and persistence:

```typescript
import { CartEngine, Cart, CartItem } from 'db/primitives/commerce'

const engine = new CartEngine({
  taxCalculator: taxService,
  discountEngine: discounts
})

// Create cart
const cart = await engine.create({
  customerId: 'cust-123',
  currency: 'USD'
})

// Add items
await engine.addItem(cart.id, {
  productId: 'prod-widget',
  quantity: 2,
  unitPrice: 49.99
})

// Apply discount code
await engine.applyDiscount(cart.id, 'SAVE20')

// Calculate totals
const summary = await engine.calculate(cart.id)
// { subtotal, discount, tax, total, items }

// Checkout
const order = await engine.checkout(cart.id, {
  paymentMethod: 'card',
  shippingAddress: { ... }
})
```

### Catalog

Product catalog with variants and categories:

```typescript
import { CatalogStore, Product, Variant } from 'db/primitives/commerce'

const catalog = new CatalogStore(db)

// Create product
const product = await catalog.createProduct({
  name: 'T-Shirt',
  description: 'Premium cotton t-shirt',
  category: 'apparel',
  basePrice: 29.99
})

// Add variants
await catalog.addVariant(product.id, {
  sku: 'TSHIRT-BLK-M',
  attributes: { color: 'black', size: 'M' },
  price: 29.99,
  stock: 100
})

// Search products
const shirts = await catalog.search({
  query: 't-shirt',
  category: 'apparel',
  priceRange: { min: 20, max: 50 },
  inStock: true
})

// Get with variants
const full = await catalog.getProduct(product.id, {
  includeVariants: true
})
```

### Inventory

Stock management with reservations:

```typescript
import { InventoryStore, StockLevel, Reservation } from 'db/primitives/commerce'

const inventory = new InventoryStore(db)

// Set stock level
await inventory.setStock('SKU-123', {
  available: 100,
  reserved: 0,
  warehouse: 'WAREHOUSE-1'
})

// Reserve stock (for cart)
const reservation = await inventory.reserve('SKU-123', {
  quantity: 2,
  expiresAt: Date.now() + 15 * 60 * 1000,  // 15 minutes
  cartId: 'cart-456'
})

// Confirm reservation (on checkout)
await inventory.confirm(reservation.id)

// Release expired reservations
await inventory.releaseExpired()

// Check availability
const available = await inventory.checkAvailability([
  { sku: 'SKU-123', quantity: 2 },
  { sku: 'SKU-456', quantity: 1 }
])
```

### Pricing

Dynamic pricing with rules:

```typescript
import { PricingEngine, PriceRule } from 'db/primitives/commerce'

const pricing = new PricingEngine()

// Define pricing rules
pricing.addRule({
  name: 'volume-discount',
  condition: (ctx) => ctx.quantity >= 10,
  discount: { type: 'percentage', value: 10 }
})

pricing.addRule({
  name: 'member-discount',
  condition: (ctx) => ctx.customer?.tier === 'premium',
  discount: { type: 'percentage', value: 5 }
})

pricing.addRule({
  name: 'flash-sale',
  condition: (ctx) => ctx.product.tags.includes('flash-sale'),
  discount: { type: 'fixed', value: 10 }
})

// Calculate price
const price = await pricing.calculate({
  product: { id: 'prod-1', basePrice: 100, tags: ['flash-sale'] },
  quantity: 15,
  customer: { tier: 'premium' }
})
// { original: 100, final: 76.5, discounts: [...] }
```

### Orders

Order lifecycle management:

```typescript
import { OrderStore, Order, OrderStatus } from 'db/primitives/commerce'

const orders = new OrderStore(db)

// Create order from cart
const order = await orders.create({
  customerId: 'cust-123',
  items: cartItems,
  shipping: { address: '...', method: 'standard' },
  payment: { method: 'card', transactionId: 'txn-456' }
})

// Update status
await orders.updateStatus(order.id, 'processing')
await orders.updateStatus(order.id, 'shipped', {
  trackingNumber: 'TRACK123'
})

// Query orders
const recent = await orders.list({
  customerId: 'cust-123',
  status: ['pending', 'processing'],
  since: '2024-01-01'
})

// Order history
const history = await orders.getStatusHistory(order.id)
```

### Tax

Tax calculation with jurisdiction support:

```typescript
import { TaxCalculator, TaxJurisdiction } from 'db/primitives/commerce'

const tax = new TaxCalculator()

// Register jurisdictions
tax.addJurisdiction({
  code: 'CA',
  name: 'California',
  rate: 0.0725,
  rules: [
    { category: 'food', rate: 0 },
    { category: 'clothing', rate: 0.0725 }
  ]
})

// Calculate tax
const result = await tax.calculate({
  items: [
    { amount: 100, category: 'electronics' },
    { amount: 50, category: 'food' }
  ],
  jurisdiction: 'CA'
})
// { subtotal: 150, tax: 7.25, total: 157.25, breakdown: [...] }
```

## Analytics

Analytics collection and processing primitives.

### Analytics Collector

Event collection with batching:

```typescript
import { AnalyticsCollector } from 'db/primitives/analytics-collector'

const collector = new AnalyticsCollector({
  batchSize: 100,
  flushInterval: 5000,
  destination: pipeline
})

// Track events
collector.track({
  event: 'page_view',
  properties: {
    path: '/products',
    referrer: 'https://google.com'
  },
  userId: 'user-123',
  timestamp: Date.now()
})

// Flush manually
await collector.flush()

// Get metrics
const metrics = collector.getMetrics()
// { eventsTracked, eventsFlushed, errors }
```

### Destination Router

Route events to multiple destinations:

```typescript
import { DestinationRouter, Destination } from 'db/primitives/analytics-collector'

const router = new DestinationRouter()

// Add destinations
router.addDestination('warehouse', {
  filter: (event) => true,  // All events
  transform: (event) => event,
  send: async (batch) => {
    await dataWarehouse.ingest(batch)
  }
})

router.addDestination('crm', {
  filter: (event) => event.event.startsWith('customer.'),
  transform: (event) => ({
    type: event.event,
    data: event.properties
  }),
  send: async (batch) => {
    await crm.sync(batch)
  }
})

// Route event
await router.route(event)
```

### Business Event Store

Event sourcing for business events:

```typescript
import { BusinessEventStore, EventLinker } from 'db/primitives/business-event-store'

const eventStore = new BusinessEventStore(db)

// Append event
await eventStore.append({
  streamId: 'order-123',
  type: 'OrderPlaced',
  data: { items: [...], total: 199.99 },
  metadata: { userId: 'user-456', correlationId: 'req-789' }
})

// Read stream
const events = await eventStore.readStream('order-123')

// Read all events of type
const orderEvents = await eventStore.readByType('OrderPlaced', {
  since: '2024-01-01',
  limit: 1000
})

// Link events (for correlation)
const linker = new EventLinker(eventStore)
await linker.link('order-123', 'payment-456', 'triggered_by')
```

## Notifications

Multi-channel notification delivery.

### Notification Router

Route notifications to channels:

```typescript
import { NotificationRouter, Channel } from 'db/primitives/notifications'

const router = new NotificationRouter()

// Register channels
router.registerChannel('email', emailChannel)
router.registerChannel('sms', smsChannel)
router.registerChannel('push', pushChannel)

// Define routing rules
router.addRule({
  condition: (notification) => notification.priority === 'urgent',
  channels: ['sms', 'push', 'email']
})

router.addRule({
  condition: (notification) => notification.type === 'marketing',
  channels: ['email']
})

// Send notification
await router.send({
  type: 'order_confirmation',
  recipient: 'user-123',
  data: { orderId: 'order-456', total: 99.99 },
  priority: 'normal'
})
```

## Sync

Bidirectional data synchronization.

### Conflict Detector

Detect and resolve sync conflicts:

```typescript
import { ConflictDetector, createConflictDetector } from 'db/primitives/sync'

const detector = createConflictDetector({
  strategy: 'last-write-wins',  // or 'first-write-wins', 'manual'
  fieldComparators: {
    price: (a, b) => Math.max(a, b),  // Custom: highest price wins
    quantity: (a, b) => a + b          // Custom: sum quantities
  }
})

// Detect conflicts
const result = detector.diff(localRecord, remoteRecord, baseRecord)

if (result.hasConflicts) {
  for (const conflict of result.conflicts) {
    console.log(`Conflict on ${conflict.field}:`)
    console.log(`  Local: ${conflict.localValue}`)
    console.log(`  Remote: ${conflict.remoteValue}`)
    console.log(`  Base: ${conflict.baseValue}`)
  }

  // Auto-resolve
  const resolved = detector.resolve(result)
}
```

## DAG Scheduler

Workflow orchestration with dependencies.

```typescript
import { createDAG, task, createRetryPolicy } from 'db/primitives/dag-scheduler'

// Define tasks
const fetchData = task('fetch-data', async (ctx) => {
  return await fetch(ctx.input.url)
})

const processData = task('process-data', async (ctx) => {
  const data = ctx.deps['fetch-data'].result
  return transform(data)
})

const saveResults = task('save-results', async (ctx) => {
  const processed = ctx.deps['process-data'].result
  await db.insert(processed)
})

// Create DAG
const pipeline = createDAG({
  name: 'data-pipeline',
  tasks: [fetchData, processData, saveResults],
  edges: [
    { from: 'fetch-data', to: 'process-data' },
    { from: 'process-data', to: 'save-results' }
  ],
  retryPolicy: createRetryPolicy({
    maxAttempts: 3,
    backoff: { type: 'exponential', initial: 1000, max: 30000 }
  })
})

// Execute
const run = await pipeline.execute({
  url: 'https://api.example.com/data'
})

console.log(run.status)  // 'completed' | 'failed' | 'running'
```

### Cron Triggers

Schedule DAG execution:

```typescript
import { createCronTrigger, createDAGScheduleManager } from 'db/primitives/dag-scheduler'

const scheduler = createDAGScheduleManager({
  alarmScheduler: ctx.storage.alarm
})

// Register DAG with schedule
scheduler.register(pipeline, {
  schedule: '0 0 * * *',  // Daily at midnight
  timezone: 'America/New_York'
})

// Get next execution time
const next = scheduler.getNextExecution(pipeline.name)
```

### Sensors

Wait for external conditions:

```typescript
import { createSensor } from 'db/primitives/dag-scheduler'

const fileSensor = createSensor({
  name: 'wait-for-file',
  check: async () => {
    const exists = await env.R2.head('data/input.csv')
    return exists !== null
  },
  interval: 60000,   // Check every minute
  timeout: 3600000   // 1 hour timeout
})

const dag = createDAG({
  tasks: [fileSensor, processTask],
  edges: [{ from: 'wait-for-file', to: 'process' }]
})
```

## Semantic Layer

Business metrics and dimensions.

```typescript
import { SemanticLayer, Metric, Dimension } from 'db/primitives/semantic-layer'

const layer = new SemanticLayer()

// Define dimensions
layer.addDimension({
  name: 'product_category',
  table: 'products',
  column: 'category',
  hierarchy: ['category', 'subcategory']
})

// Define metrics
layer.addMetric({
  name: 'total_revenue',
  expression: 'SUM(orders.amount)',
  format: 'currency'
})

layer.addMetric({
  name: 'avg_order_value',
  expression: 'AVG(orders.amount)',
  format: 'currency'
})

// Query using semantic model
const result = await layer.query({
  metrics: ['total_revenue', 'avg_order_value'],
  dimensions: ['product_category'],
  filters: [{ dimension: 'order_date', operator: 'gte', value: '2024-01-01' }]
})
```

## Related

- [Database Primitives](/docs/database/primitives) - Core primitives
- [Store Accessors](/docs/database/stores) - CRUD operations
- [Query Engine](/docs/database/query-engine) - Query optimization
- [Workflows](/docs/workflows) - Durable execution
