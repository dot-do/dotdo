---
title: Persistence
description: Save and load EdgeVec indices to R2 with chunked storage, compression, and incremental backups.
---

# Persistence

EdgeVec provides robust persistence to Cloudflare R2 with chunked storage, optional compression, checksum validation, and backup management.

## Quick Start

```typescript
import { HNSWPersistence } from 'db/edgevec/persistence'

// Create persistence handler
const persistence = new HNSWPersistence(env.R2_BUCKET, {
  compression: 'gzip',
  maxChunkSizeMB: 10,
  validateChecksum: true
})

// Save index
await persistence.save('my-index', index, {
  description: 'Product embeddings',
  version: '1.0'
})

// Load index
const loadedIndex = await persistence.load('my-index')

// List backups
const backups = await persistence.listBackups('my-index')

// Load specific backup
const oldIndex = await persistence.loadBackup('my-index', backups[1].timestamp)
```

## Persistence Options

```typescript
interface PersistenceOptions {
  /** Compression algorithm (default: 'none') */
  compression?: 'none' | 'gzip'

  /** Max chunk size in MB (default: 10) */
  maxChunkSizeMB?: number

  /** Whether to validate checksum on load (default: true) */
  validateChecksum?: boolean
}
```

### Compression

Enable gzip compression for smaller storage:

```typescript
const persistence = new HNSWPersistence(bucket, {
  compression: 'gzip'
})
```

Compression ratios vary by data:
- Random vectors: ~5-10% reduction
- Clustered vectors: ~20-40% reduction
- With metadata: ~30-50% reduction

### Chunking

Large indices are split into chunks for reliable upload:

```typescript
const persistence = new HNSWPersistence(bucket, {
  maxChunkSizeMB: 10  // Split at 10MB
})
```

Benefits:
- Parallel upload/download
- Resume failed transfers
- Stay within R2 limits

## Index Manifest

Each saved index creates a manifest with metadata:

```typescript
interface IndexManifest {
  /** Index name */
  name: string
  /** Creation timestamp */
  createdAt: number
  /** Last update timestamp */
  updatedAt: number
  /** Number of vectors */
  vectorCount: number
  /** Vector dimensions */
  dimensions: number
  /** Index configuration */
  config: {
    M: number
    efConstruction: number
    metric: string
  }
  /** Data chunks */
  chunks: Array<{
    key: string
    sizeBytes: number
    checksum: string
  }>
  /** Has metadata */
  hasMetadata: boolean
  /** Custom metadata */
  indexMetadata?: Record<string, unknown>
  /** Version */
  version: string
}
```

Access manifest:

```typescript
const manifest = await persistence.getManifest('my-index')
if (manifest) {
  console.log(`Vectors: ${manifest.vectorCount}`)
  console.log(`Dimensions: ${manifest.dimensions}`)
  console.log(`Last updated: ${new Date(manifest.updatedAt)}`)
}
```

## R2 Storage Structure

Indices are stored with this structure:

```
edgevec/
  {index-name}/
    {timestamp}/
      chunk_0.bin
      chunk_1.bin
      ...
  {index-name}_manifest.json
```

Example:

```
edgevec/
  products/
    1704067200000/
      chunk_0.bin    (10MB)
      chunk_1.bin    (10MB)
      chunk_2.bin    (5MB)
    1704153600000/
      chunk_0.bin    (11MB)
      ...
  products_manifest.json
```

## Operations

### Save Index

```typescript
// Basic save
await persistence.save('products', index)

// With custom metadata
await persistence.save('products', index, {
  version: '2.1',
  description: 'Product embeddings with new categories',
  modelVersion: 'text-embedding-3-small'
})
```

### Load Index

```typescript
// Load latest
const index = await persistence.load('products')

// Returns HNSWIndex or FilteredHNSWIndex based on hasMetadata flag
if ('getMetadata' in index) {
  // FilteredHNSWIndex with metadata support
  const meta = index.getMetadata('prod-1')
}
```

### Incremental Save

For frequent updates, use incremental saves:

```typescript
// Currently does full save
// Future: delta encoding for changed vectors
await persistence.saveIncremental('products', index)
```

### Backup Management

```typescript
// List all backups
const backups = await persistence.listBackups('products')
for (const backup of backups) {
  console.log(`${new Date(backup.timestamp)}: ${backup.vectorCount} vectors, ${backup.sizeBytes} bytes`)
}

// Load specific backup
const oldIndex = await persistence.loadBackup('products', backups[2].timestamp)

// Delete index and all backups
await persistence.delete('products')
```

## Checksum Validation

Checksums ensure data integrity:

```typescript
const persistence = new HNSWPersistence(bucket, {
  validateChecksum: true  // Default
})

try {
  const index = await persistence.load('products')
} catch (error) {
  if (error.message.includes('Checksum mismatch')) {
    // Data corrupted - try older backup
    const backups = await persistence.listBackups('products')
    const index = await persistence.loadBackup('products', backups[1].timestamp)
  }
}
```

Checksums are SHA-256 hashes (when crypto.subtle available) or fallback to simple checksum.

## Serialization Formats

### Binary Format

Compact binary format for production:

```typescript
// HNSWIndex
const buffer = index.serialize()
const loaded = HNSWIndexImpl.deserialize(buffer)

// FilteredHNSWIndex
const buffer = filteredIndex.serialize()
const loaded = FilteredHNSWIndexImpl.deserialize(buffer)
```

Binary format structure:
```
[JSON header length (4 bytes)]
[JSON header: config, nodes, entry point]
[Vector data: id-length, id, vector float32s...]
```

### JSON Format

Human-readable format for debugging:

```typescript
// Export
const json = index.toJSON()
await storage.put('index.json', JSON.stringify(json, null, 2))

// Import
const data = await storage.get('index.json')
const loaded = HNSWIndexImpl.fromJSON(JSON.parse(data))
```

JSON structure:
```json
{
  "config": {
    "dimensions": 1536,
    "M": 16,
    "efConstruction": 200,
    "metric": "cosine"
  },
  "nodes": {
    "doc-1": { "level": 2, "neighbors": [["doc-2", "doc-3"], ["doc-2"], []] }
  },
  "vectors": {
    "doc-1": [0.1, 0.2, ...1536 values]
  },
  "entryPoint": "doc-1",
  "metadata": {
    "doc-1": { "category": "tech" }
  }
}
```

## Durable Object Integration

EdgeVecDO handles persistence automatically:

```typescript
export class EdgeVecDO {
  private persistence: HNSWPersistence

  constructor(state: DurableObjectState, env: Env) {
    this.persistence = new HNSWPersistence(env.R2_BUCKET)
    this.state = state
  }

  async initialize(config: EdgeVecDOConfig) {
    // Try to load existing index
    try {
      this.index = await this.persistence.load(config.namespace)
      console.log(`Loaded ${this.index.size()} vectors`)
    } catch {
      // Create new index
      this.index = createFilteredIndex({
        dimensions: config.dimension,
        M: config.M,
        efConstruction: config.efConstruction,
        metric: config.metric
      })
    }
  }

  // Periodic persistence via alarm
  async alarm() {
    await this.persistence.save(this.namespace, this.index)
    // Schedule next backup
    await this.state.storage.setAlarm(Date.now() + 60000)
  }
}
```

## Compression Implementation

Uses Web Streams API for compression:

```typescript
async function compress(data: Uint8Array): Promise<Uint8Array> {
  if (typeof CompressionStream !== 'undefined') {
    const stream = new CompressionStream('gzip')
    const writer = stream.writable.getWriter()
    writer.write(data)
    writer.close()

    const chunks: Uint8Array[] = []
    const reader = stream.readable.getReader()
    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      chunks.push(value)
    }

    return concatenate(chunks)
  }

  // Fallback: no compression
  return data
}

async function decompress(data: Uint8Array): Promise<Uint8Array> {
  if (typeof DecompressionStream !== 'undefined') {
    const stream = new DecompressionStream('gzip')
    // ... similar to compress
  }
  return data
}
```

## Error Handling

```typescript
try {
  await persistence.save('products', index)
} catch (error) {
  if (error.message.includes('R2')) {
    // R2 error - retry with backoff
  }
  if (error.message.includes('size')) {
    // Index too large - reduce chunk size
  }
}

try {
  const index = await persistence.load('products')
} catch (error) {
  if (error.message.includes('not found')) {
    // Index doesn't exist
  }
  if (error.message.includes('Checksum')) {
    // Data corruption
  }
  if (error.message.includes('Chunk')) {
    // Missing chunk - try backup
  }
}
```

## Best Practices

### Backup Strategy

```typescript
// Scheduled backups via cron trigger
export default {
  async scheduled(event, env) {
    const persistence = new HNSWPersistence(env.R2_BUCKET)

    // Get all index namespaces
    const namespaces = await getActiveNamespaces(env)

    for (const ns of namespaces) {
      // Load from DO
      const stub = env.EDGEVEC_DO.get(env.EDGEVEC_DO.idFromName(ns))
      const index = await stub.getIndex()

      // Save to R2
      await persistence.save(ns, index, {
        backupType: 'scheduled',
        timestamp: event.scheduledTime
      })
    }
  }
}
```

### Backup Retention

```typescript
async function cleanOldBackups(persistence: HNSWPersistence, name: string, keepDays: number) {
  const backups = await persistence.listBackups(name)
  const cutoff = Date.now() - keepDays * 24 * 60 * 60 * 1000

  for (const backup of backups) {
    if (backup.timestamp < cutoff) {
      // Delete old backup chunks
      await bucket.delete(`edgevec/${name}/${backup.timestamp}/`)
    }
  }
}
```

### Pre-warming

Load indices before traffic:

```typescript
export default {
  async fetch(request, env) {
    // Ensure index is loaded
    await ensureIndexLoaded(env)
    // Handle request
    return handleRequest(request, env)
  }
}

let indexPromise: Promise<void> | null = null

async function ensureIndexLoaded(env: Env) {
  if (!indexPromise) {
    indexPromise = loadAllIndices(env)
  }
  await indexPromise
}
```

## Performance

| Operation | Time (10K vectors) | Time (100K vectors) |
|-----------|-------------------|---------------------|
| Save (uncompressed) | ~200ms | ~2s |
| Save (gzip) | ~400ms | ~4s |
| Load (uncompressed) | ~150ms | ~1.5s |
| Load (gzip) | ~300ms | ~3s |
| Checksum validation | ~50ms | ~500ms |

## Related

- [EdgeVec Overview](/docs/database/edgevec) - Full system documentation
- [HNSW Indexing](/docs/database/edgevec/hnsw) - Index structure
- [Quantization](/docs/database/edgevec/quantization) - Memory optimization
- [Filtering](/docs/database/edgevec/filtering) - Metadata filters
