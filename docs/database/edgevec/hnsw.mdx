---
title: HNSW Indexing
description: Hierarchical Navigable Small World graph for approximate nearest neighbor search in EdgeVec.
---

# HNSW Indexing

EdgeVec uses the Hierarchical Navigable Small World (HNSW) algorithm for approximate nearest neighbor (ANN) search. HNSW provides logarithmic search complexity with excellent recall rates.

## How HNSW Works

HNSW builds a multi-layer graph where:

1. **Layer 0** contains all vectors with dense connections
2. **Higher layers** contain fewer vectors with sparse connections
3. **Search** starts at top layer and navigates down

```
Layer 3:  [A]
           |
Layer 2:  [A]----[B]
           |      |
Layer 1:  [A]----[B]----[C]
           |      |      |
Layer 0:  [A]-[D]-[B]-[E]-[C]-[F]
```

## Configuration

### HNSWConfig

```typescript
interface HNSWConfig {
  /** Number of dimensions in vectors */
  dimensions: number
  /** Max connections per node on layers > 0 (default: 16) */
  M?: number
  /** Size of dynamic candidate list during construction (default: 200) */
  efConstruction?: number
  /** Distance metric (default: 'cosine') */
  metric?: 'cosine' | 'l2' | 'dot'
}
```

### Parameter Guide

**M (connections per node)**

Controls the graph connectivity:
- Lower M = faster insert, less memory, lower recall
- Higher M = slower insert, more memory, better recall

| M | Memory/vector | Insert time | Search recall |
|---|---------------|-------------|---------------|
| 8 | ~128 bytes | Fastest | ~90% |
| 16 | ~256 bytes | Fast | ~95% |
| 32 | ~512 bytes | Moderate | ~98% |
| 64 | ~1KB | Slow | ~99% |

**efConstruction (build quality)**

Controls index quality during construction:
- Higher values = better graph quality, slower build
- Must be >= M

```typescript
// High quality index (slower build)
const config = { dimensions: 1536, M: 32, efConstruction: 400 }

// Fast build (lower quality)
const config = { dimensions: 1536, M: 16, efConstruction: 100 }
```

**ef (search quality)**

Controls search accuracy at query time:
- Higher values = better recall, slower search
- Must be >= k (number of results)

```typescript
// High recall search
const results = index.search(query, { k: 10, ef: 200 })

// Fast search (lower recall)
const results = index.search(query, { k: 10, ef: 40 })
```

## Creating an Index

```typescript
import { createHNSWIndex } from 'db/edgevec/hnsw'

// Create index for 1536-dim vectors with cosine similarity
const index = createHNSWIndex({
  dimensions: 1536,
  M: 16,
  efConstruction: 200,
  metric: 'cosine'
})

// Insert vectors
index.insert('vec-1', new Float32Array(embedding1))
index.insert('vec-2', new Float32Array(embedding2))
index.insert('vec-3', new Float32Array(embedding3))

// Search
const results = index.search(queryVector, { k: 5, ef: 100 })
for (const result of results) {
  console.log(`${result.id}: ${result.score}`)
}
```

## Distance Functions

### Cosine Similarity

Measures angle between vectors. Best for normalized embeddings.

```typescript
// Returns similarity score from -1 to 1
// 1 = identical, 0 = orthogonal, -1 = opposite
function cosineSimilarity(a: Float32Array, b: Float32Array): number {
  let dot = 0, normA = 0, normB = 0
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i]
    normA += a[i] * a[i]
    normB += b[i] * b[i]
  }
  return dot / (Math.sqrt(normA) * Math.sqrt(normB))
}
```

### L2 (Euclidean) Distance

Measures straight-line distance. Best for spatial data.

```typescript
// Returns distance from 0 to infinity
// 0 = identical, higher = more different
function l2Distance(a: Float32Array, b: Float32Array): number {
  let sum = 0
  for (let i = 0; i < a.length; i++) {
    const diff = a[i] - b[i]
    sum += diff * diff
  }
  return Math.sqrt(sum)
}
```

### Dot Product

Measures magnitude-weighted alignment. Best for MIPS.

```typescript
// Returns product from -infinity to infinity
// Higher = more similar (for normalized vectors)
function dotProduct(a: Float32Array, b: Float32Array): number {
  let dot = 0
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i]
  }
  return dot
}
```

## Index Operations

### Insert

Inserts a vector into the index:

```typescript
// Insert with ID
index.insert('document-1', new Float32Array(embedding))

// Update existing (same ID replaces vector)
index.insert('document-1', new Float32Array(newEmbedding))
```

Time complexity: O(log N * efConstruction)

### Search

Finds k nearest neighbors:

```typescript
const results = index.search(queryVector, {
  k: 10,    // Number of results
  ef: 100   // Search quality (higher = better recall)
})

// Results are sorted by score (best first)
for (const { id, score } of results) {
  console.log(`${id}: ${score}`)
}
```

Time complexity: O(log N * ef)

### Delete

Removes a vector from the index:

```typescript
const deleted = index.delete('document-1')
// Returns true if vector existed and was deleted
```

Note: Delete performance degrades with many deletions. Consider rebuilding for bulk deletes.

### Accessors

```typescript
// Get index size
const count = index.size()

// Get dimensions
const dims = index.dimensions()

// Check if ID exists
const exists = index.has('document-1')

// Get vector by ID
const vector = index.getVector('document-1')

// Get node info (for debugging)
const node = index.getNode('document-1')
console.log(node.level, node.neighbors)

// Get entry point
const entry = index.getEntryPoint()
```

## Statistics

Get index statistics for monitoring:

```typescript
const stats = index.getStats()

console.log(`
  Size: ${stats.size}
  Dimensions: ${stats.dimensions}
  Max Level: ${stats.maxLevel}
  Layer Distribution: ${stats.layerDistribution}
  Avg Connections: ${stats.avgConnections}
  Memory: ${stats.memoryBytes / 1024 / 1024} MB
`)
```

### HNSWStats

```typescript
interface HNSWStats {
  /** Total number of vectors */
  size: number
  /** Vector dimensions */
  dimensions: number
  /** Maximum layer in the graph */
  maxLevel: number
  /** Number of nodes at each layer */
  layerDistribution: number[]
  /** Average connections at each layer */
  avgConnections: number[]
  /** Estimated memory usage in bytes */
  memoryBytes: number
}
```

## Serialization

### JSON Format

```typescript
// Export to JSON
const json = index.toJSON()

// Save to storage
await storage.put('index', JSON.stringify(json))

// Load from JSON
const loaded = HNSWIndexImpl.fromJSON(json)
```

### Binary Format

More compact for large indices:

```typescript
// Serialize to ArrayBuffer
const buffer = index.serialize()

// Save to R2
await r2.put('index.bin', buffer)

// Deserialize
const loaded = HNSWIndexImpl.deserialize(buffer)
```

## Graph Structure

### HNSWNode

Each node stores:

```typescript
interface HNSWNode {
  /** Node ID */
  id: string
  /** Max layer this node exists on */
  level: number
  /** Neighbors at each layer [layer0, layer1, ...] */
  neighbors: string[][]
}
```

### Level Generation

Levels are randomly assigned using exponential distribution:

```typescript
// Probability of level l = (1/M)^l
function generateLevel(): number {
  const r = Math.random()
  return Math.floor(-Math.log(r) * ml) // ml = 1/ln(M)
}
```

This ensures:
- Most nodes at level 0
- ~1/M nodes at level 1
- ~1/M^2 nodes at level 2
- etc.

## Search Algorithm

The HNSW search algorithm:

```
function search(query, k, ef):
  // Start at entry point
  current = entryPoint

  // Greedy search from top to layer 1
  for level = maxLevel downto 1:
    current = greedySearchAtLevel(query, current, level)

  // Beam search at layer 0
  candidates = searchLayer(query, current, ef, layer=0)

  // Return top k
  return candidates.slice(0, k)
```

### Greedy Search (Upper Layers)

Fast navigation to approximate region:

```typescript
function greedySearchAtLevel(query, startId, level) {
  let current = startId
  let currentDist = distance(query, vectors.get(current))

  while (true) {
    let changed = false
    for (const neighbor of nodes.get(current).neighbors[level]) {
      const dist = distance(query, vectors.get(neighbor))
      if (isBetter(dist, currentDist)) {
        current = neighbor
        currentDist = dist
        changed = true
      }
    }
    if (!changed) break
  }

  return current
}
```

### Beam Search (Layer 0)

Thorough search with candidate management:

```typescript
function searchLayer(query, entryId, ef, level) {
  const visited = new Set([entryId])
  const candidates = new MinHeap()
  const results = new MaxHeap()

  candidates.push({ id: entryId, dist: distance(query, entry) })
  results.push(candidates.peek())

  while (candidates.size > 0) {
    const current = candidates.pop()

    // Stop if worst result is better than best candidate
    if (results.size >= ef && isBetter(results.peek().dist, current.dist)) {
      break
    }

    // Explore neighbors
    for (const neighbor of nodes.get(current.id).neighbors[level]) {
      if (visited.has(neighbor)) continue
      visited.add(neighbor)

      const dist = distance(query, vectors.get(neighbor))

      if (results.size < ef || isBetter(dist, results.peek().dist)) {
        candidates.push({ id: neighbor, dist })
        results.push({ id: neighbor, dist })
        if (results.size > ef) results.pop()
      }
    }
  }

  return results.toSortedArray()
}
```

## Tuning for Workloads

### High Recall (Search Quality)

```typescript
const index = createHNSWIndex({
  dimensions: 1536,
  M: 48,              // More connections
  efConstruction: 400, // Better graph quality
  metric: 'cosine'
})

// Search with high ef
const results = index.search(query, { k: 10, ef: 300 })
```

### High Throughput (Speed)

```typescript
const index = createHNSWIndex({
  dimensions: 1536,
  M: 12,              // Fewer connections
  efConstruction: 100, // Faster build
  metric: 'cosine'
})

// Search with low ef
const results = index.search(query, { k: 10, ef: 50 })
```

### Memory Constrained

```typescript
const index = createHNSWIndex({
  dimensions: 1536,
  M: 8,               // Minimum connections
  efConstruction: 64, // Minimum quality
  metric: 'cosine'
})
```

## Related

- [EdgeVec Overview](/docs/database/edgevec) - Full system documentation
- [Quantization](/docs/database/edgevec/quantization) - Memory optimization
- [Filtering](/docs/database/edgevec/filtering) - Metadata filtering
