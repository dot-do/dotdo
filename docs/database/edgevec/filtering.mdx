---
title: Metadata Filtering
description: MongoDB-style metadata filters for vector search in EdgeVec.
---

# Metadata Filtering

EdgeVec supports rich metadata filtering during vector search, using MongoDB-style query operators. Filter results by metadata before or after the similarity search.

## Quick Start

```typescript
// Insert vectors with metadata
await env.EDGEVEC.insert('my-ns', 'products', [
  {
    id: 'prod-1',
    values: embedding1,
    metadata: {
      category: 'electronics',
      brand: 'Apple',
      price: 999,
      inStock: true,
      tags: ['smartphone', 'premium']
    }
  },
  {
    id: 'prod-2',
    values: embedding2,
    metadata: {
      category: 'clothing',
      brand: 'Nike',
      price: 79,
      inStock: true,
      tags: ['shoes', 'sports']
    }
  }
])

// Search with filter
const results = await env.EDGEVEC.search('my-ns', 'products', queryVector, {
  k: 10,
  filter: {
    category: 'electronics',
    price: { $lte: 1000 }
  }
})
```

## Filter Operators

### Comparison Operators

```typescript
// $eq - Equal (implicit for direct values)
{ category: 'electronics' }
{ category: { $eq: 'electronics' } }

// $ne - Not equal
{ status: { $ne: 'discontinued' } }

// $gt - Greater than
{ price: { $gt: 100 } }

// $gte - Greater than or equal
{ price: { $gte: 100 } }

// $lt - Less than
{ stock: { $lt: 10 } }

// $lte - Less than or equal
{ rating: { $lte: 4.5 } }
```

### Set Operators

```typescript
// $in - Value in array
{ category: { $in: ['electronics', 'computers'] } }

// $nin - Value not in array
{ brand: { $nin: ['Unknown', 'Generic'] } }

// $contains - Array contains value
{ tags: { $contains: 'premium' } }
```

### Existence Operator

```typescript
// $exists - Field exists
{ discount: { $exists: true } }
{ couponCode: { $exists: false } }
```

### Logical Operators

```typescript
// $and - All conditions must match
{
  $and: [
    { category: 'electronics' },
    { price: { $lt: 500 } },
    { inStock: true }
  ]
}

// $or - Any condition must match
{
  $or: [
    { brand: 'Apple' },
    { brand: 'Samsung' }
  ]
}

// $not - Negate condition
{
  $not: { status: 'discontinued' }
}
```

### Combined Example

```typescript
const filter = {
  $and: [
    { category: { $in: ['electronics', 'computers'] } },
    {
      $or: [
        { price: { $lt: 500 } },
        { discount: { $exists: true } }
      ]
    },
    { inStock: true },
    { $not: { brand: 'Generic' } }
  ]
}

const results = await index.search(query, { k: 10, filter })
```

## FilteredHNSWIndex API

The FilteredHNSWIndex extends HNSW with metadata support:

```typescript
import { createFilteredIndex, FilteredHNSWIndex } from 'db/edgevec/filtered-search'

// Create filtered index
const index = createFilteredIndex({
  dimensions: 1536,
  M: 16,
  efConstruction: 200,
  metric: 'cosine'
})

// Insert with metadata
index.insert('doc-1', vector1, {
  category: 'tech',
  author: 'alice',
  date: '2024-01-15',
  views: 1000
})

// Get metadata
const meta = index.getMetadata('doc-1')
// { category: 'tech', author: 'alice', ... }

// Update metadata (full replace)
index.updateMetadata('doc-1', {
  category: 'tech',
  author: 'alice',
  date: '2024-01-15',
  views: 1500
})

// Patch metadata (merge)
index.patchMetadata('doc-1', { views: 2000 })
// Now: { category: 'tech', author: 'alice', date: '2024-01-15', views: 2000 }

// Search with filter
const results = index.search(queryVector, {
  k: 10,
  ef: 100,
  filter: { category: 'tech', views: { $gt: 500 } }
})
```

## Filter Modes

EdgeVec supports two filtering strategies:

### Post-Filter (Default)

Search first, then filter results. Best for high selectivity filters.

```typescript
const results = index.search(query, {
  k: 10,
  filter: { category: 'electronics' },
  filterMode: 'post'  // or 'auto'
})
```

Algorithm:
1. Fetch k * 5 candidates from HNSW
2. Filter by metadata
3. Return top k matches

Pros: Fast for selective filters
Cons: May return fewer than k results

### Pre-Filter

Filter candidates first, then search among filtered. Best for low selectivity.

```typescript
const results = index.search(query, {
  k: 10,
  filter: { category: 'rare-category' },
  filterMode: 'pre'
})
```

Algorithm:
1. Scan all metadata for matches
2. Search HNSW limited to matching IDs
3. Return top k matches

Pros: Guaranteed k results (if enough match)
Cons: Slower for broad filters

### Auto Mode

Automatically chooses strategy based on filter characteristics:

```typescript
const results = index.search(query, {
  k: 10,
  filter: { category: 'electronics' },
  filterMode: 'auto'  // Default
})
```

Heuristics:
- Use post-filter for simple equality filters
- Use pre-filter for complex boolean expressions
- Consider filter selectivity estimates

## Type Definitions

### MetadataFilter

```typescript
type FilterOperator =
  | '$eq' | '$ne'
  | '$gt' | '$gte' | '$lt' | '$lte'
  | '$in' | '$nin'
  | '$contains' | '$exists'
  | '$and' | '$or' | '$not'

type FilterValue =
  | string | number | boolean | null
  | { [K in FilterOperator]?: unknown }

interface MetadataFilter {
  [key: string]: FilterValue | MetadataFilter[] | undefined
  $and?: MetadataFilter[]
  $or?: MetadataFilter[]
  $not?: MetadataFilter
}
```

### FilteredSearchOptions

```typescript
interface FilteredSearchOptions extends SearchOptions {
  /** Metadata filter */
  filter?: MetadataFilter
  /** Filter mode: 'pre' filters before search, 'post' filters after */
  filterMode?: 'pre' | 'post' | 'auto'
}
```

## Serialization

Filtered indices include metadata in serialization:

```typescript
// Serialize (includes metadata)
const buffer = index.serialize()

// Deserialize
const loaded = FilteredHNSWIndexImpl.deserialize(buffer)

// Or JSON format
const json = index.toJSON()
// { config, nodes, vectors, metadata }

const loadedJson = FilteredHNSWIndexImpl.fromJSON(json)
```

## Performance Considerations

### Index Design

Consider these patterns for optimal filter performance:

**High Cardinality Fields**
```typescript
// Good - few unique values, fast scan
{ status: { $in: ['active', 'pending'] } }

// Slower - many unique values
{ userId: 'specific-user-id' }
```

**Compound Filters**
```typescript
// Put most selective condition first
{
  $and: [
    { status: 'rare-status' },     // Most selective first
    { category: 'common-category' } // Less selective second
  ]
}
```

### Memory Usage

Metadata is stored in a Map alongside vectors:
- ~100 bytes per document for typical metadata
- Consider omitting large text fields

```typescript
// Store reference, not full content
{
  id: 'doc-1',
  values: embedding,
  metadata: {
    contentId: 'content-123',  // Reference to full content
    category: 'blog',
    wordCount: 500
  }
}
```

### Filter Complexity

Simpler filters are faster:

| Filter Type | Relative Speed |
|-------------|----------------|
| Single equality | 1x (fastest) |
| Range comparison | 1.2x |
| $in with 5 values | 1.5x |
| $and with 3 clauses | 2x |
| Nested $or/$and | 3-5x |

## Common Patterns

### Multi-Tenant Search

```typescript
// Tenant isolation via filter
const results = await index.search(query, {
  k: 10,
  filter: { tenantId: currentTenant }
})
```

### Time-Range Search

```typescript
// Documents from last 7 days
const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000
const results = await index.search(query, {
  k: 10,
  filter: {
    timestamp: { $gte: weekAgo }
  }
})
```

### Category + Price Filter

```typescript
// E-commerce search
const results = await index.search(productQueryVector, {
  k: 20,
  filter: {
    $and: [
      { category: selectedCategory },
      { price: { $gte: minPrice, $lte: maxPrice } },
      { inStock: true }
    ]
  }
})
```

### Access Control

```typescript
// Documents user can access
const results = await index.search(query, {
  k: 10,
  filter: {
    $or: [
      { isPublic: true },
      { ownerId: userId },
      { sharedWith: { $contains: userId } }
    ]
  }
})
```

## Evaluation Functions

The filter evaluation logic:

```typescript
function evaluateFilter(
  metadata: Record<string, unknown> | undefined,
  filter: MetadataFilter
): boolean {
  if (!metadata) return false

  // Compound operators
  if (filter.$and) {
    return filter.$and.every(f => evaluateFilter(metadata, f))
  }
  if (filter.$or) {
    return filter.$or.some(f => evaluateFilter(metadata, f))
  }
  if (filter.$not) {
    return !evaluateFilter(metadata, filter.$not)
  }

  // Field-level evaluation
  for (const [key, value] of Object.entries(filter)) {
    if (key.startsWith('$')) continue

    const fieldValue = metadata[key]

    // Direct value comparison (implicit $eq)
    if (typeof value !== 'object' || value === null) {
      if (fieldValue !== value) return false
      continue
    }

    // Operator comparison
    const ops = value as Record<string, unknown>

    if ('$eq' in ops && fieldValue !== ops.$eq) return false
    if ('$ne' in ops && fieldValue === ops.$ne) return false
    if ('$gt' in ops && !(fieldValue > ops.$gt)) return false
    if ('$gte' in ops && !(fieldValue >= ops.$gte)) return false
    if ('$lt' in ops && !(fieldValue < ops.$lt)) return false
    if ('$lte' in ops && !(fieldValue <= ops.$lte)) return false
    if ('$in' in ops && !ops.$in.includes(fieldValue)) return false
    if ('$nin' in ops && ops.$nin.includes(fieldValue)) return false
    if ('$contains' in ops && !fieldValue?.includes(ops.$contains)) return false
    if ('$exists' in ops && (fieldValue !== undefined) !== ops.$exists) return false
  }

  return true
}
```

## Related

- [EdgeVec Overview](/docs/database/edgevec) - Full system documentation
- [HNSW Indexing](/docs/database/edgevec/hnsw) - Graph-based search
- [Quantization](/docs/database/edgevec/quantization) - Memory optimization
- [Persistence](/docs/database/edgevec/persistence) - R2 backup
