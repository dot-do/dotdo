---
title: Store Accessors
description: Typed store APIs for Things, Relationships, Actions, Events, Search, and Objects
---

# Store Accessors

Store Accessors provide a unified API for data operations within Durable Objects. Each store handles a specific domain with full CRUD operations.

## Overview

All stores share a common context:

```typescript
interface StoreContext {
  db: DODatabase<AppSchema>
  ns: string              // Namespace (DO identity)
  currentBranch: string   // Active branch
  env: {
    DO?: DurableObjectNamespace
    PIPELINE?: Pipeline
    AI?: AIBinding
    R2_SQL?: R2SQLBinding
  }
  typeCache: Map<string, number>
}
```

## ThingsStore

CRUD operations for versioned entities.

```typescript
const things = new ThingsStore(ctx)

// Create
const user = await things.create({
  $type: 'User',
  name: 'Alice',
  data: { email: 'alice@example.com' }
})

// Read
const current = await things.get('abc123')
const atVersion = await things.get('abc123', { version: 3 })

// List
const users = await things.list({
  type: 'User',
  limit: 100,
  where: { 'data.status': 'active' }
})

// Update (creates new version)
await things.update('abc123', { data: { status: 'premium' } })

// Delete (soft by default)
await things.delete('abc123')

// Version history
const versions = await things.versions('abc123')
```

See [Things & Versioning](/docs/database/things) for details.

## RelationshipsStore

Manage typed connections between Things.

```typescript
const relationships = new RelationshipsStore(ctx)

// Create relationship
await relationships.create({
  verb: 'follows',
  from: 'user/alice',
  to: 'user/bob',
  data: { since: '2024-01-01' }
})

// Query outgoing
const following = await relationships.from('user/alice', { verb: 'follows' })

// Query incoming
const followers = await relationships.to('user/bob', { verb: 'follows' })

// List with filters
const allFollows = await relationships.list({
  verb: 'follows',
  limit: 100
})

// Delete
await relationships.delete(relationshipId)

// Delete by criteria
await relationships.deleteWhere({
  from: 'user/alice',
  verb: 'follows'
})
```

### Relationship Types

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique relationship ID |
| `verb` | string | Relationship type (follows, owns, manages) |
| `from` | string | Source entity URL |
| `to` | string | Target entity URL |
| `data` | JSON | Optional metadata |
| `createdAt` | Date | When relationship was created |

## ActionsStore

Log and track action execution with lifecycle management.

```typescript
const actions = new ActionsStore(ctx)

// Log new action
const action = await actions.log({
  verb: 'User.signup',
  target: 'user/abc123',
  actor: 'agent/priya',
  input: { email: 'alice@example.com' },
  durability: 'do',          // 'send' | 'try' | 'do'
  requestId: 'req-123',
  sessionId: 'sess-456',
  workflowId: 'wf-789'
})

// Complete action
await actions.complete(action.id, { userId: 'abc123' })

// Fail action
await actions.fail(action.id, new Error('Validation failed'))

// Retry action
await actions.retry(action.id)

// Query actions
const pending = await actions.pending()
const failed = await actions.failed()
const byTarget = await actions.list({ target: 'user/abc123' })
```

### Action States

| Status | Description |
|--------|-------------|
| `pending` | Created, not started |
| `running` | Currently executing |
| `completed` | Finished successfully |
| `failed` | Terminated with error |
| `retrying` | Failed, retrying |
| `undone` | Rolled back |

### Durability Levels

```typescript
// Fire-and-forget
await actions.log({ verb: 'User.viewed', durability: 'send' })

// Single attempt
await actions.log({ verb: 'Email.send', durability: 'try' })

// Durable with retries
await actions.log({ verb: 'Payment.process', durability: 'do' })
```

## EventsStore

Emit and stream events with sequence tracking.

```typescript
const events = new EventsStore(ctx)

// Emit event
const event = await events.emit({
  verb: 'Order.created',
  source: 'order/123',
  data: { total: 99.99, items: ['product-1', 'product-2'] },
  actionId: 'action-abc'
})

// Mark as streamed
await events.stream(event.id)

// Stream all pending
const count = await events.streamPending()

// Query events
const orderEvents = await events.list({
  source: 'order/123',
  verb: 'Order.created',
  afterSequence: 100
})

// Replay events
const history = await events.replay({
  fromSequence: 50,
  limit: 100
})
```

### Event Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique event ID |
| `verb` | string | Event type |
| `source` | string | Source entity |
| `data` | JSON | Event payload |
| `sequence` | number | Monotonic sequence number |
| `streamed` | boolean | Whether sent to pipeline |
| `streamedAt` | Date | When streamed |

## SearchStore

Full-text and semantic search indexing.

```typescript
const search = new SearchStore(ctx)

// Index content
await search.index({
  $id: 'doc-123',
  $type: 'Document',
  content: 'Full text content to index...'
})

// Batch index
await search.indexMany([
  { $id: 'doc-1', $type: 'Document', content: '...' },
  { $id: 'doc-2', $type: 'Document', content: '...' }
])

// Text search
const results = await search.query('search terms', {
  type: 'Document',
  limit: 10
})
// Returns: [{ $id, $type, content, score }]

// Semantic search (with embeddings)
const similar = await search.semantic('natural language query', {
  type: 'Document',
  limit: 10
})

// Remove from index
await search.remove('doc-123')
await search.removeMany(['doc-1', 'doc-2'])

// Reindex all of a type
await search.reindexType('Document')
```

## ObjectsStore

Registry for Durable Object references across namespaces.

```typescript
const objects = new ObjectsStore(ctx)

// Register a DO
await objects.register({
  ns: 'https://payments.do',
  id: 'CF_DO_ID_abc123',
  class: 'PaymentsDO',
  relation: 'child',
  region: 'wnam',
  primary: true
})

// Get by namespace
const obj = await objects.get('https://payments.do')

// List by criteria
const childDOs = await objects.list({
  relation: 'child',
  class: 'PaymentsDO',
  region: 'wnam'
})

// Get shards
const shards = await objects.shards('users')

// Get primary replica
const primary = await objects.primary('https://data.do')

// Resolve to live stub
const stub = await objects.resolve('https://payments.do')
await stub.fetch(new Request('/charge', { method: 'POST' }))

// Global lookup (R2 SQL fallback)
const global = await objects.getGlobal('https://external.do')

// Update cached data
await objects.update('https://payments.do', {
  cached: { lastActive: Date.now() }
})

// Delete registration
await objects.delete('https://payments.do')
```

### Relation Types

| Relation | Description |
|----------|-------------|
| `parent` | Parent DO in hierarchy |
| `child` | Child DO in hierarchy |
| `follower` | Read replica following a primary |
| `shard` | Shard of a distributed collection |
| `reference` | Reference to external DO |

## DLQStore

Dead Letter Queue for failed event processing.

```typescript
const dlq = new DLQStore(ctx, eventHandlers)

// Register handler for replay
dlq.registerHandler('Order.process', async (data) => {
  // Reprocess the event
  return processOrder(data)
})

// Add failed event
await dlq.add({
  eventId: 'evt-123',
  verb: 'Order.process',
  source: 'order/456',
  data: { total: 99.99 },
  error: 'Payment gateway timeout',
  errorStack: 'Error: timeout at...',
  maxRetries: 5
})

// List DLQ entries
const entries = await dlq.list({
  verb: 'Order.process',
  minRetries: 2,
  limit: 100
})

// Retry single entry
const result = await dlq.retry('dlq-entry-id')
if (result.success) {
  console.log('Replayed successfully:', result.result)
}

// Replay all of a type
const stats = await dlq.replayAll({ verb: 'Order.process' })
console.log(`Replayed: ${stats.replayed}, Failed: ${stats.failed}`)

// Purge exhausted entries (exceeded maxRetries)
const purged = await dlq.purgeExhausted()

// Get count
const count = await dlq.count()
```

## Pipeline Integration

Stores automatically stream to Cloudflare Pipelines when configured:

```typescript
// When PIPELINE binding exists, events are automatically streamed

const events = new EventsStore(ctx)
await events.emit({
  verb: 'User.signup',
  source: 'user/123',
  data: { plan: 'premium' }
})
// Automatically sends to Pipeline for analytics processing

const things = new ThingsStore(ctx)
await things.create({
  $type: 'User',
  name: 'Alice'
})
// Emits User.created event to Pipeline
```

## SQL Injection Prevention

Stores include built-in protection against SQL injection:

```typescript
// Safe JSON path validation
validateJsonPath('data.user.email')  // OK
validateJsonPath('data; DROP TABLE')  // Throws

// Whitelisted order columns
validateOrderColumn('id')    // OK
validateOrderColumn('name')  // OK
validateOrderColumn('DROP')  // Throws

// Type-safe ORDER BY construction
buildOrderClause('name', 'desc')  // Returns safe SQL fragment
```

## Related

- [Things & Versioning](/docs/database/things) - Version history and time-travel
- [Actions](/docs/concepts/actions) - Action lifecycle and durability
- [Relationships](/docs/concepts/relationships) - Entity connections
- [Search](/docs/compat/search) - Full-text and vector search
