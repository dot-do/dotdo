---
title: JSON Indexes
description: Expression indexes on JSON fields for fast querying of structured data
---

# JSON Indexes

dotdo supports expression indexes on JSON fields using SQLite's `json_extract()`. This enables fast queries on structured data stored in the `data` column of Things.

## Overview

Traditional indexes only work on top-level columns. JSON indexes let you index nested paths:

```sql
-- Create index on JSON path
CREATE INDEX idx_things_data_email
  ON things(json_extract(data, '$.email'))

-- Queries use the index
SELECT * FROM things
WHERE json_extract(data, '$.email') = 'alice@example.com'
```

## Quick Start

```typescript
import { createJsonIndex, listJsonIndexes, syncNounIndexes } from 'db/json-indexes'

// Create an index
await createJsonIndex(db, {
  table: 'things',
  path: 'email',
  typeId: 1  // Optional: partial index for specific type
})

// List existing indexes
const indexes = await listJsonIndexes(db, 'things')

// Sync indexes from schema
await syncNounIndexes(db, {
  nounName: 'User',
  typeId: 1,
  schema: {
    email: { type: 'string', index: true },
    role: '#string',  // # prefix = indexed
    name: 'string'    // Not indexed
  }
})
```

## Creating Indexes

### Basic Index

Index a path across all Things:

```typescript
await createJsonIndex(db, {
  table: 'things',
  path: 'status'
})

// Creates: idx_things_data_status
// SQL: CREATE INDEX idx_things_data_status
//        ON things(json_extract(data, '$.status'))
```

### Type-Filtered Index

Partial index for specific types (more efficient):

```typescript
await createJsonIndex(db, {
  table: 'things',
  path: 'email',
  typeId: 1  // Only index type=1 (e.g., User)
})

// Creates: idx_things_type1_data_email
// SQL: CREATE INDEX idx_things_type1_data_email
//        ON things(type, json_extract(data, '$.email'))
//        WHERE type = 1
```

### Nested Paths

Index deeply nested fields:

```typescript
await createJsonIndex(db, {
  table: 'things',
  path: 'address.city'
})

// Creates: idx_things_data_address_city
// SQL: json_extract(data, '$.address.city')

await createJsonIndex(db, {
  table: 'things',
  path: 'settings.notifications.email'
})

// Creates: idx_things_data_settings_notifications_email
```

### Relationship Indexes

Index JSON in relationships table:

```typescript
await createJsonIndex(db, {
  table: 'relationships',
  path: 'permissions.read',
  verbFilter: 'grants'  // Only for 'grants' relationships
})

// Creates: idx_relationships_verb_grants_data_permissions_read
// SQL: CREATE INDEX ... ON relationships(verb, json_extract(data, '$.permissions.read'))
//        WHERE verb = 'grants'
```

## Dropping Indexes

```typescript
import { dropJsonIndex } from 'db/json-indexes'

// Drop by path
await dropJsonIndex(db, {
  table: 'things',
  path: 'email',
  typeId: 1  // Must match if created with typeId
})
```

## Listing Indexes

```typescript
import { listJsonIndexes } from 'db/json-indexes'

const indexes = await listJsonIndexes(db, 'things')

for (const index of indexes) {
  console.log(`${index.name}: $.${index.path}`)
  if (index.typeId) {
    console.log(`  Type: ${index.typeId}`)
  }
}

// Example output:
// idx_things_data_status: $.status
// idx_things_type1_data_email: $.email
//   Type: 1
// idx_things_data_address_city: $.address.city
```

## Schema-Based Sync

Automatically manage indexes based on Noun schemas:

```typescript
import { syncNounIndexes } from 'db/json-indexes'

// Define schema with indexed fields
const userSchema = {
  // Full object syntax
  email: { type: 'string', index: true },
  phone: { type: 'string', index: true },
  name: { type: 'string' },  // Not indexed

  // Shorthand: # prefix = indexed
  role: '#string',
  status: '#string',
  department: 'string'  // Not indexed
}

// Sync indexes
await syncNounIndexes(db, {
  nounName: 'User',
  typeId: 1,
  schema: userSchema
})

// This will:
// 1. Create indexes for: email, phone, role, status
// 2. Drop indexes for fields no longer marked index: true
```

### Automatic Sync on Noun Update

```typescript
// When a Noun schema is updated, sync indexes
await nouns.update('User', {
  schema: newSchema
})

// Trigger index sync
await syncNounIndexes(db, {
  nounName: 'User',
  typeId: await nouns.getTypeId('User'),
  schema: newSchema
})
```

## Path Validation

Paths are validated to prevent SQL injection:

```typescript
import { validateIndexPath } from 'db/json-indexes'

// Valid paths
validateIndexPath('email')                  // OK
validateIndexPath('address.city')           // OK
validateIndexPath('user_preferences')       // OK
validateIndexPath('settings.notify_email')  // OK

// Invalid paths (throws Error)
validateIndexPath('')                       // Empty
validateIndexPath('1field')                 // Starts with number
validateIndexPath('field..nested')          // Consecutive dots
validateIndexPath('.field')                 // Leading dot
validateIndexPath('field.')                 // Trailing dot
validateIndexPath("field'; DROP TABLE")    // SQL injection attempt
```

### Path Rules

- Must start with letter or underscore
- Can contain alphanumeric characters and underscores
- Dots allowed for nesting (but not leading, trailing, or consecutive)
- No SQL metacharacters (quotes, semicolons, parentheses)

## Index Naming Convention

Indexes follow a consistent naming pattern:

| Pattern | Example | Description |
|---------|---------|-------------|
| `idx_{table}_data_{path}` | `idx_things_data_status` | Full index |
| `idx_{table}_type{id}_data_{path}` | `idx_things_type1_data_email` | Type-filtered |
| `idx_{table}_verb_{verb}_data_{path}` | `idx_relationships_verb_owns_data_role` | Verb-filtered |

Path dots are converted to underscores in the name:

```typescript
getIndexName('things', 'address.city')
// Returns: idx_things_data_address_city

getIndexName('things', 'settings.notify.email', 1)
// Returns: idx_things_type1_data_settings_notify_email
```

## Query Patterns

### Equality Lookup

```typescript
// With index on 'email'
const users = await things.list({
  type: 'User',
  where: { 'data.email': 'alice@example.com' }
})

// Uses: idx_things_type{id}_data_email
```

### Range Queries

```typescript
// With index on 'createdAt'
const recent = await things.list({
  type: 'Order',
  where: {
    'data.createdAt': { $gt: '2024-01-01' }
  }
})

// Uses index for range scan
```

### Composite Conditions

```typescript
// Multiple indexed fields
const filtered = await things.list({
  type: 'User',
  where: {
    'data.status': 'active',
    'data.role': 'admin'
  }
})

// Query planner chooses most selective index
```

## Performance Considerations

### When to Index

Index fields that are:
- Frequently used in WHERE clauses
- Used for sorting (ORDER BY)
- Have high cardinality (many distinct values)
- Used in joins or lookups

### When NOT to Index

Avoid indexing:
- Low-cardinality fields (status with 3 values)
- Rarely queried fields
- Large text fields (use full-text search instead)
- Frequently updated fields (index maintenance cost)

### Partial Indexes

Use `typeId` to create partial indexes when:
- Query always filters by type
- Different types have different indexed fields
- Want to reduce index size

```typescript
// Better: partial index for User type only
await createJsonIndex(db, {
  table: 'things',
  path: 'email',
  typeId: 1  // User type
})

// vs. full index across all types (larger, less efficient)
await createJsonIndex(db, {
  table: 'things',
  path: 'email'
})
```

## Database Compatibility

Works with both synchronous and async SQLite:

```typescript
// better-sqlite3 (sync)
const db = require('better-sqlite3')('database.db')
await createJsonIndex(db, { table: 'things', path: 'email' })

// D1 (async)
const db = env.DB
await createJsonIndex(db, { table: 'things', path: 'email' })

// Drizzle
const db = drizzle(client)
await createJsonIndex(db, { table: 'things', path: 'email' })
```

## Related

- [Things & Versioning](/docs/database/things) - Entity storage with JSON data
- [Store Accessors](/docs/database/stores) - Query with where clauses
- [Query Engine](/docs/database/query-engine) - Advanced query optimization
