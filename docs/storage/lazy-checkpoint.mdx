---
title: L2 - Lazy Checkpoint
description: Batched SQLite persistence with dirty tracking, reducing write operations by 95%
---

# L2: Lazy Checkpoint

The `LazyCheckpointer` implements batched persistence to SQLite, only writing dirty entries from L0. This lazy approach reduces SQLite write operations by approximately 95% compared to write-through strategies, while maintaining strong durability through the L1 Pipeline WAL.

## Overview

```
       +------------------+
       |  L0: InMemory    |
       |  (dirty entries) |
       +--------+---------+
                |
        (timer/threshold)
                v
       +------------------+
       | LazyCheckpointer |
       +--------+---------+
                |
                v
       +------------------+
       |  SQLite (L2)     |  <- Batched writes
       +------------------+     Only dirty entries
```

**Key characteristics:**

- **Lazy persistence** - Writes delayed until timer or threshold triggers
- **Dirty-only writes** - Only modified entries are persisted
- **Batch optimization** - Multiple entries written in single checkpoint
- **Version tracking** - Handles concurrent writes during checkpoint
- **Hibernation safety** - Flushes all dirty state before DO hibernation

## Basic Usage

### Creating a Checkpointer

```typescript
import { LazyCheckpointer, type DirtyTracker } from 'dotdo/storage'

// The checkpointer needs a DirtyTracker (typically InMemoryStateManager)
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker: memoryManager,  // Implements DirtyTracker interface
  intervalMs: 5000,             // Checkpoint every 5 seconds
  dirtyCountThreshold: 100,     // Or when 100 entries dirty
  memoryThresholdBytes: 10 * 1024 * 1024  // Or at 10MB memory
})

// Start the checkpoint timer
checkpointer.start()
```

### Manual Checkpoint

```typescript
// Force immediate checkpoint
const stats = await checkpointer.checkpoint()

console.log(stats)
// {
//   entriesWritten: 47,
//   bytesWritten: 15234,
//   durationMs: 12,
//   trigger: 'manual'
// }
```

### Hibernation

```typescript
// Before DO hibernation - flush all dirty state
await checkpointer.beforeHibernation()
// All dirty entries now in SQLite
```

## Checkpoint Triggers

### Timer-Based (Default)

Checkpoints occur at regular intervals:

```typescript
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker,
  intervalMs: 5000  // Every 5 seconds
})

checkpointer.start()

// Timeline:
// t=0s: entries modified
// t=5s: checkpoint (47 entries)
// t=10s: checkpoint (12 entries)
// t=15s: checkpoint (0 entries - skipped)
```

### Dirty Count Threshold

Checkpoint when dirty entry count exceeds threshold:

```typescript
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker,
  dirtyCountThreshold: 100  // Checkpoint at 100 dirty entries
})

// Notify after each write
function onWrite(id) {
  memoryManager.create(/* ... */)
  checkpointer.notifyDirty()  // Checks threshold
}

// If dirtyCount >= 100, immediate checkpoint
```

### Memory Threshold

Checkpoint when memory usage exceeds threshold:

```typescript
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker,
  memoryThresholdBytes: 10 * 1024 * 1024  // 10MB
})

// Notify after large writes
function onLargeWrite() {
  memoryManager.create({ data: largePayload })
  checkpointer.notifyDirty()  // Checks memory usage
}
```

### Hibernation (Forced)

Always checkpoint before DO hibernation:

```typescript
// DO lifecycle hook
async beforeHibernation() {
  // Force checkpoint regardless of timer/threshold
  await this.checkpointer.beforeHibernation()
}
```

## Dirty Tracking Integration

### DirtyTracker Interface

The checkpointer requires a `DirtyTracker` to know what to persist:

```typescript
interface DirtyTracker {
  getDirtyEntries(): Map<string, { type: string; data: unknown; size: number }>
  getDirtyCount(): number
  getMemoryUsage(): number
  clearDirty(keys: string[]): void
  clear(): void
}
```

### InMemoryStateManager as DirtyTracker

The `InMemoryStateManager` implements this interface natively:

```typescript
import { InMemoryStateManager } from 'dotdo/storage'

const memory = new InMemoryStateManager()

// Create adapter if needed
const dirtyTracker: DirtyTracker = {
  getDirtyEntries() {
    const entries = new Map()
    for (const key of memory.getDirtyKeys()) {
      const thing = memory.get(key)
      if (thing) {
        entries.set(key, {
          type: thing.$type,
          data: thing,
          size: JSON.stringify(thing).length
        })
      }
    }
    return entries
  },
  getDirtyCount: () => memory.getDirtyCount(),
  getMemoryUsage: () => memory.getStats().estimatedBytes,
  clearDirty: (keys) => memory.markClean(keys),
  clear: () => memory.clear()
}
```

## Write Optimization

### Only Dirty Entries

The checkpointer **only writes entries modified since last checkpoint**:

```typescript
// Scenario: 1000 entries in L0, only 15 modified
// Traditional: 1000 SQLite writes
// LazyCheckpointer: 15 SQLite writes (98.5% reduction)

const stats = await checkpointer.checkpoint()
console.log(stats.entriesWritten)  // 15 (not 1000)
```

### Batched Writes

Multiple entries are written in a single checkpoint:

```typescript
// Instead of:
// INSERT thing_1
// INSERT thing_2
// INSERT thing_3
// ... 47 separate operations

// Checkpointer does:
// Single checkpoint operation with 47 entries
// (Implementation uses SQLite transactions)
```

## Concurrent Write Handling

### Version Tracking

The checkpointer tracks write versions to handle concurrent modifications:

```typescript
// Problem: Entry modified during checkpoint
// 1. Checkpoint starts, reads dirty entries
// 2. User modifies entry X
// 3. Checkpoint completes, clears dirty flags
// 4. Entry X's new changes are lost!

// Solution: Version tracking
checkpointer.trackWrite('entry_x')  // Called on each write

// During checkpoint:
// - Snapshot version before reading dirty entries
// - Only clear dirty flags for entries not modified during checkpoint
// - Entry X remains dirty for next checkpoint
```

### Safe Clearing

```typescript
// Checkpoint implementation
async doCheckpoint() {
  const checkpointVersion = this.currentVersion
  const dirtyEntries = this.dirtyTracker.getDirtyEntries()

  const keysToClean = []

  for (const [key, entry] of dirtyEntries) {
    // Check if entry was modified during checkpoint
    const writeVersion = this.writeVersions.get(key) ?? 0
    if (writeVersion > checkpointVersion) {
      // Modified during checkpoint - skip clearing
      continue
    }

    // Safe to write and clear
    this.sql.exec('INSERT OR REPLACE ...', key, entry.data)
    keysToClean.push(key)
  }

  // Only clear entries not modified during checkpoint
  this.dirtyTracker.clearDirty(keysToClean)
}
```

## Checkpoint Statistics

### CheckpointStats

Every checkpoint returns statistics:

```typescript
interface CheckpointStats {
  entriesWritten: number  // Number of entries persisted
  bytesWritten: number    // Total bytes written
  durationMs: number      // Checkpoint duration
  trigger: 'timer' | 'threshold' | 'hibernation' | 'manual'
}
```

### Monitoring Callbacks

```typescript
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker,
  onCheckpoint: (stats) => {
    console.log(`Checkpoint: ${stats.entriesWritten} entries in ${stats.durationMs}ms`)

    // Send to analytics
    metrics.record('checkpoint', {
      entries: stats.entriesWritten,
      bytes: stats.bytesWritten,
      duration: stats.durationMs,
      trigger: stats.trigger
    })
  }
})
```

## Configuration

### LazyCheckpointerOptions

```typescript
interface LazyCheckpointerOptions {
  sql: SqlStorage              // Required: SQLite storage
  dirtyTracker: DirtyTracker   // Required: Dirty entry tracker
  intervalMs?: number          // Default: 5000 (5 seconds)
  dirtyCountThreshold?: number // Default: 100 entries
  memoryThresholdBytes?: number // Default: 10MB
  columnarThreshold?: number   // Default: 1000 (storage optimization)
  onCheckpoint?: (stats: CheckpointStats) => void
}
```

### Recommended Settings

| Workload | intervalMs | dirtyCountThreshold | Notes |
|----------|------------|---------------------|-------|
| Real-time | 1000 | 50 | Low latency recovery |
| Balanced | 5000 | 100 | Default settings |
| High throughput | 10000 | 500 | Batch efficiency |
| Low frequency | 30000 | 200 | Reduce SQLite writes |

## Lifecycle Management

### Start and Stop

```typescript
// Start checkpoint timer
checkpointer.start()

// Stop timer (does not flush)
checkpointer.stop()

// Resume timer
checkpointer.start()
```

### Destroy

```typescript
// Stop timer and cleanup
await checkpointer.destroy()

// After destroy, checkpointer is unusable
```

### Hibernation Pattern

```typescript
class MyDO extends DurableObject {
  private checkpointer: LazyCheckpointer

  async beforeHibernation() {
    // Checkpoint all dirty state
    const stats = await this.checkpointer.beforeHibernation()
    console.log(`Hibernation checkpoint: ${stats.entriesWritten} entries`)
  }
}
```

## SQLite Schema

The checkpointer writes to a `things` table:

```sql
CREATE TABLE IF NOT EXISTS things (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  data TEXT NOT NULL  -- JSON serialized
);

CREATE INDEX IF NOT EXISTS idx_things_type ON things(type);
```

### Write Pattern

```typescript
// Each dirty entry written as:
sql.exec(
  'INSERT OR REPLACE INTO things (id, type, data) VALUES (?, ?, ?)',
  key,
  entry.type,
  JSON.stringify(entry.data)
)
```

## Performance Characteristics

| Metric | Value | Notes |
|--------|-------|-------|
| Checkpoint latency | 5-50ms | Depends on dirty count |
| Write reduction | ~95% | Compared to write-through |
| Memory overhead | ~1KB | Per dirty entry tracked |
| SQLite write rate | ~10K/s | Batched inserts |

### Benchmarks

| Dirty Count | Duration | Throughput |
|-------------|----------|------------|
| 10 | ~2ms | 5K entries/s |
| 100 | ~10ms | 10K entries/s |
| 1000 | ~80ms | 12.5K entries/s |

## Error Handling

### SQLite Errors

```typescript
const checkpointer = new LazyCheckpointer({
  sql: ctx.storage.sql,
  dirtyTracker,
  onCheckpoint: (stats) => {
    if (stats.entriesWritten === 0 && dirtyTracker.getDirtyCount() > 0) {
      // Checkpoint failed - entries still dirty
      console.error('Checkpoint failed, will retry next interval')
    }
  }
})
```

### Partial Checkpoint

If checkpoint fails mid-way, unflushed entries remain dirty:

```typescript
// Entry 1: Written, cleared
// Entry 2: Written, cleared
// Entry 3: Failed
// Entry 4: Not attempted

// After failed checkpoint:
// Entry 3 and 4 remain dirty
// Next checkpoint will retry both
```

## Integration with DOStorage

The `DOStorage` class integrates LazyCheckpointer automatically:

```typescript
import { DOStorage } from 'dotdo/storage'

const storage = new DOStorage({
  namespace: 'tenant-123',
  env: {
    sql: ctx.storage.sql,
    // ...
  },
  checkpointInterval: 5000  // L2 checkpoint every 5s
})

// Writes automatically checkpoint to L2
await storage.create({ $type: 'Customer', name: 'Alice' })
// Entry marked dirty in L0
// Checkpointed to SQLite within 5 seconds
```

## Next Steps

- [L0: In-Memory Cache](/storage/in-memory) - Source of dirty entries
- [L1: Pipeline WAL](/storage/pipeline-wal) - Durability before L2
- [L3: Cold Tier](/storage/cold-tier) - Long-term archival after L2
- [Recovery](/storage/recovery) - Loading from L2 on cold start
