---
title: Storage Migrations
description: Schema migrations, data transformations, and rollback strategies for Durable Object storage
---

# Storage Migrations

Evolve your DO schemas safely with versioned migrations, automatic rollback, and data transformations.

## Overview

The migration system provides:

- **Schema versioning** - Track database versions per DO
- **Forward migrations** - Apply schema changes safely
- **Rollback support** - Undo migrations when needed
- **Transaction safety** - Each migration runs atomically
- **Data transforms** - Custom data migration logic
- **Checksum validation** - Detect migration tampering

## Migration Runner

Initialize the migration runner in your DO:

```typescript
import { DO } from 'dotdo'
import { MigrationRunner } from 'dotdo/persistence'

export class ProductDO extends DO {
  private migrations: MigrationRunner

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)

    this.migrations = new MigrationRunner(ctx.storage, {
      config: {
        autoMigrate: true,
        backupBeforeMigration: true,
      },
    })
  }

  async onStart() {
    // Register migrations
    this.registerMigrations()

    // Initialize (runs pending migrations if autoMigrate is true)
    await this.migrations.initialize()
  }

  private registerMigrations() {
    // Each migration has a unique version number
    this.migrations.register({
      version: 1,
      name: 'add-products-table',
      up: [
        {
          type: 'sql',
          sql: `
            CREATE TABLE IF NOT EXISTS products (
              id TEXT PRIMARY KEY,
              name TEXT NOT NULL,
              price INTEGER NOT NULL,
              created_at INTEGER NOT NULL
            )
          `,
        },
      ],
      down: [
        { type: 'sql', sql: 'DROP TABLE IF EXISTS products' },
      ],
      createdAt: Date.now(),
      checksum: '',
    })
  }
}
```

## Defining Migrations

### SQL Migrations

Most migrations are SQL statements:

```typescript
this.migrations.register({
  version: 2,
  name: 'add-product-category',
  up: [
    {
      type: 'sql',
      sql: 'ALTER TABLE products ADD COLUMN category TEXT',
    },
    {
      type: 'sql',
      sql: 'CREATE INDEX idx_products_category ON products(category)',
    },
  ],
  down: [
    { type: 'sql', sql: 'DROP INDEX IF EXISTS idx_products_category' },
    // Note: SQLite doesn't support DROP COLUMN, would need table recreation
  ],
  createdAt: Date.now(),
  checksum: '',
})
```

### Data Transform Migrations

For complex data transformations, use transform functions:

```typescript
// Register the transform function
this.migrations.registerTransform('normalize-prices', async (table, params) => {
  const { multiplier } = params as { multiplier: number }

  // Get all rows
  const rows = this.ctx.storage.sql
    .exec(`SELECT id, price FROM ${table}`)
    .toArray() as Array<{ id: string; price: number }>

  // Update each row
  for (const row of rows) {
    this.ctx.storage.sql.exec(
      `UPDATE ${table} SET price = ? WHERE id = ?`,
      Math.round(row.price * multiplier),
      row.id
    )
  }
})

// Use in migration
this.migrations.register({
  version: 3,
  name: 'convert-prices-to-cents',
  up: [
    {
      type: 'transform',
      transform: 'normalize-prices',
      table: 'products',
      params: { multiplier: 100 },
    },
  ],
  down: [
    {
      type: 'transform',
      transform: 'normalize-prices',
      table: 'products',
      params: { multiplier: 0.01 },
    },
  ],
  createdAt: Date.now(),
  checksum: '',
})
```

### Multi-Step Migrations

Combine multiple operations:

```typescript
this.migrations.register({
  version: 4,
  name: 'add-inventory-tracking',
  up: [
    // Create new table
    {
      type: 'sql',
      sql: `
        CREATE TABLE inventory (
          product_id TEXT PRIMARY KEY REFERENCES products(id),
          quantity INTEGER NOT NULL DEFAULT 0,
          reserved INTEGER NOT NULL DEFAULT 0,
          updated_at INTEGER NOT NULL
        )
      `,
    },
    // Initialize inventory from existing products
    {
      type: 'sql',
      sql: `
        INSERT INTO inventory (product_id, quantity, reserved, updated_at)
        SELECT id, 0, 0, created_at FROM products
      `,
    },
    // Add index
    {
      type: 'sql',
      sql: 'CREATE INDEX idx_inventory_low_stock ON inventory(quantity) WHERE quantity < 10',
    },
  ],
  down: [
    { type: 'sql', sql: 'DROP INDEX IF EXISTS idx_inventory_low_stock' },
    { type: 'sql', sql: 'DROP TABLE IF EXISTS inventory' },
  ],
  createdAt: Date.now(),
  checksum: '',
})
```

## Running Migrations

### Manual Migration Control

```typescript
export class ManagedDO extends DO {
  async runPendingMigrations() {
    const results = await this.migrations.runAll()

    return results.map(r => ({
      version: r.version,
      status: r.status,
      duration: r.durationMs,
      error: r.error,
    }))
  }

  async runSpecificMigration(version: number) {
    return await this.migrations.run(version)
  }

  async getMigrationStatus() {
    const [current, pending, applied] = await Promise.all([
      this.migrations.getCurrentVersion(),
      this.migrations.getPendingMigrations(),
      this.migrations.getAppliedMigrations(),
    ])

    return {
      currentVersion: current,
      pendingCount: pending.length,
      pendingVersions: pending.map(m => m.version),
      applied: applied.map(m => ({
        version: m.version,
        name: m.name,
        appliedAt: new Date(m.appliedAt).toISOString(),
      })),
    }
  }
}
```

### Dry Run Mode

Preview migrations before applying:

```typescript
export class SafeMigrationDO extends DO {
  async previewMigration(version: number) {
    // Enable dry run mode
    this.migrations.configure({ dryRun: true })

    // Get the SQL that would be executed
    const sql = await this.migrations.getDryRunSQL(version)

    // Reset dry run
    this.migrations.configure({ dryRun: false })

    return sql
  }
}
```

## Rollback Strategies

### Rolling Back Single Migration

```typescript
export class RollbackDO extends DO {
  async rollbackLastMigration() {
    const current = await this.migrations.getCurrentVersion()

    if (current === 0) {
      throw new Error('No migrations to rollback')
    }

    return await this.migrations.rollback(current)
  }
}
```

### Rolling Back to Specific Version

```typescript
export class VersionedDO extends DO {
  async rollbackToVersion(targetVersion: number) {
    const current = await this.migrations.getCurrentVersion()

    if (targetVersion >= current) {
      throw new Error('Target version must be lower than current')
    }

    const results = await this.migrations.rollbackTo(targetVersion)

    return {
      from: current,
      to: targetVersion,
      rolledBack: results.length,
      results,
    }
  }

  async rollbackAll() {
    return await this.migrations.rollbackAll()
  }
}
```

### Handling Irreversible Migrations

Some migrations cannot be rolled back:

```typescript
this.migrations.register({
  version: 5,
  name: 'drop-legacy-columns',
  up: [
    // SQLite doesn't support DROP COLUMN, so we recreate the table
    {
      type: 'sql',
      sql: `
        CREATE TABLE products_new (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          price INTEGER NOT NULL,
          category TEXT,
          created_at INTEGER NOT NULL
        )
      `,
    },
    {
      type: 'sql',
      sql: `
        INSERT INTO products_new (id, name, price, category, created_at)
        SELECT id, name, price, category, created_at FROM products
      `,
    },
    { type: 'sql', sql: 'DROP TABLE products' },
    { type: 'sql', sql: 'ALTER TABLE products_new RENAME TO products' },
  ],
  // Empty down array marks migration as irreversible
  down: [],
  createdAt: Date.now(),
  checksum: '',
})

// Check if rollback is possible
export class SafeRollbackDO extends DO {
  async canRollback(version: number): Promise<boolean> {
    const migration = this.migrations.getMigration(version)
    return migration ? migration.down.length > 0 : false
  }

  async safeRollback(version: number) {
    const canRollback = await this.canRollback(version)

    if (!canRollback) {
      throw new Error(`Migration ${version} is irreversible`)
    }

    return await this.migrations.rollback(version)
  }
}
```

## Backup and Recovery

### Automatic Backups

The migration runner creates backups by default:

```typescript
const runner = new MigrationRunner(storage, {
  config: {
    backupBeforeMigration: true, // Default: true
  },
})

// Register callbacks
runner.onBackupCreated(() => {
  console.log('Backup created before migration')
})

runner.onBackupRestored(() => {
  console.log('Backup restored after migration failure')
})
```

### Manual Backup/Restore

```typescript
export class BackupDO extends DO {
  async createSnapshot(): Promise<string> {
    const tables = await this.listTables()
    const snapshot: Record<string, unknown[]> = {}

    for (const table of tables) {
      const rows = this.ctx.storage.sql
        .exec(`SELECT * FROM ${table}`)
        .toArray()
      snapshot[table] = rows
    }

    const snapshotId = `snapshot:${Date.now()}`
    await this.ctx.storage.put(snapshotId, {
      id: snapshotId,
      tables: snapshot,
      createdAt: Date.now(),
      schemaVersion: await this.migrations.getCurrentVersion(),
    })

    return snapshotId
  }

  async restoreSnapshot(snapshotId: string) {
    const snapshot = await this.ctx.storage.get<Snapshot>(snapshotId)
    if (!snapshot) throw new Error('Snapshot not found')

    // Clear existing data
    for (const table of Object.keys(snapshot.tables)) {
      this.ctx.storage.sql.exec(`DELETE FROM ${table}`)
    }

    // Restore data
    for (const [table, rows] of Object.entries(snapshot.tables)) {
      for (const row of rows as Record<string, unknown>[]) {
        const columns = Object.keys(row)
        const values = Object.values(row)
        const placeholders = columns.map(() => '?').join(', ')

        this.ctx.storage.sql.exec(
          `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${placeholders})`,
          ...values
        )
      }
    }
  }

  private async listTables(): Promise<string[]> {
    const result = this.ctx.storage.sql.exec(
      `SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE '_%'`
    )
    return (result.toArray() as { name: string }[]).map(r => r.name)
  }
}

interface Snapshot {
  id: string
  tables: Record<string, unknown[]>
  createdAt: number
  schemaVersion: number
}
```

## Validation and Safety

### Checksum Validation

Detect if migrations have been modified after being applied:

```typescript
export class ValidatedDO extends DO {
  async validateMigrations() {
    const { valid, mismatches } = await this.migrations.validateChecksums()

    if (!valid) {
      console.error('Migration checksum mismatches:', mismatches)
      throw new Error(
        `Migrations ${mismatches.join(', ')} have been modified after application`
      )
    }

    return { valid: true }
  }

  async validateVersionSequence() {
    const { valid, gaps } = this.migrations.validateVersions()

    if (!valid) {
      console.warn('Migration version gaps:', gaps)
    }

    return { valid, gaps }
  }
}
```

### Migration Locking

Prevent concurrent migration execution:

```typescript
export class ConcurrentDO extends DO {
  async safeMigrate() {
    const isLocked = await this.migrations.isLocked()

    if (isLocked) {
      throw new Error('Migrations are already running')
    }

    return await this.migrations.runAll()
  }

  async checkLockStatus() {
    return {
      locked: await this.migrations.isLocked(),
    }
  }
}
```

## Migration Patterns

### Feature Flags for Schema Changes

Deploy schema changes before code that uses them:

```typescript
// Migration 10: Add new column
this.migrations.register({
  version: 10,
  name: 'add-product-sku',
  up: [{ type: 'sql', sql: 'ALTER TABLE products ADD COLUMN sku TEXT' }],
  down: [],
  createdAt: Date.now(),
  checksum: '',
})

// In application code, check schema version
export class FeatureFlagDO extends DO {
  async getProduct(id: string) {
    const schemaVersion = await this.migrations.getCurrentVersion()

    const product = await this.db.select().from(schema.products)
      .where(eq(schema.products.id, id))
      .get()

    // Only include SKU if schema supports it
    if (schemaVersion >= 10 && 'sku' in product) {
      return { ...product, sku: product.sku }
    }

    return product
  }
}
```

### Zero-Downtime Migrations

For large data migrations, use background processing:

```typescript
this.migrations.register({
  version: 11,
  name: 'populate-sku-field',
  up: [
    // Mark migration as started
    {
      type: 'sql',
      sql: `
        INSERT INTO _migration_state (migration_id, status, started_at)
        VALUES (11, 'in_progress', ${Date.now()})
      `,
    },
  ],
  down: [],
  createdAt: Date.now(),
  checksum: '',
})

// Background job completes the migration
export class BackgroundMigrationDO extends DO {
  async processPendingMigration() {
    const state = await this.getMigrationState(11)

    if (state?.status !== 'in_progress') return

    // Process in batches
    const batchSize = 100
    let processed = 0

    while (true) {
      const products = await this.db.select()
        .from(schema.products)
        .where(isNull(schema.products.sku))
        .limit(batchSize)

      if (products.length === 0) break

      for (const product of products) {
        await this.db.update(schema.products)
          .set({ sku: this.generateSku(product) })
          .where(eq(schema.products.id, product.id))
      }

      processed += products.length
    }

    // Mark complete
    await this.updateMigrationState(11, 'completed')

    return { processed }
  }
}
```

## Related Documentation

- [Durable Object Storage](/docs/storage/durable-objects) - SQLite in DOs
- [Storage Architecture](/docs/storage) - Tiered storage overview
- [Hot Tier](/docs/storage/hot-tier) - DO SQLite details
