---
title: Replication Patterns
description: Geo-distributed data replication with read-your-writes consistency
---

# Replication Patterns

dotdo provides multi-region replication for Durable Objects, enabling low-latency reads from the nearest replica while ensuring writes are durable. Support for 35+ global cities with jurisdiction enforcement for regulatory compliance.

## Architecture

```
                      ┌─────────────────┐
                      │    Primary      │
                      │  (fra or iad)   │
                      └────────┬────────┘
                               │ writes
       ┌───────────────────────┼───────────────────────┐
       │ async replication     │                       │
       ▼                       ▼                       ▼
 ┌───────────┐          ┌───────────┐          ┌───────────┐
 │  Replica  │          │  Replica  │          │  Replica  │
 │   (lhr)   │          │   (ams)   │          │   (dub)   │
 └───────────┘          └───────────┘          └───────────┘
       │                       │                       │
       └───────────────────────┼───────────────────────┘
                               │ nearest read
                               ▼
                        ┌───────────┐
                        │   Client  │
                        └───────────┘
```

## Quick Start

```typescript
import { ReplicaManager } from 'dotdo/db/core'

const manager = new ReplicaManager(env.DO, {
  jurisdiction: 'eu',           // GDPR compliance
  regions: ['eu-west-1', 'eu-central-1'],
  readFrom: 'nearest',
  writeThrough: true,
})

// Read from nearest replica
const readStub = await manager.getReadStub('my-db')

// Write through to all replicas
await manager.writeThroughAll('my-db', '/write', { body: data })
```

## Consistency Models

| Mode | Latency | Consistency | Use Case |
|------|---------|-------------|----------|
| **primary** | ~50ms | Strong | Financial transactions |
| **nearest** | ~5-20ms | Eventual | Content delivery, dashboards |
| **session (RYW)** | ~5-50ms | Read-your-own | User-facing applications |

### Read-Your-Writes (RYW)

Session tokens enable read-your-writes consistency without always reading from primary:

```typescript
import { ReplicatedPostgres } from 'dotdo/db/edge-postgres'

const db = new ReplicatedPostgres(ctx, env, {
  replication: {
    jurisdiction: 'eu',
    cities: ['fra', 'ams', 'dub', 'lhr'],
    readFrom: 'nearest',
    writeThrough: false,
  },
})

await db.initialize()

// Write returns session token
const write = await db.exec(
  'INSERT INTO users VALUES ($1, $2)',
  ['u1', 'Alice']
)

// Read with RYW consistency
const user = await db.query(
  'SELECT * FROM users WHERE id = $1',
  ['u1'],
  { sessionToken: write.sessionToken }
)
console.log(user.source) // 'fra' (read from caught-up replica or primary)
```

## Placement Hierarchy

dotdo supports three levels of placement precision:

### 1. Jurisdiction (Guaranteed)

Data sovereignty with hard guarantees from Cloudflare:

```typescript
const manager = new ReplicaManager(env.DO, {
  jurisdiction: 'eu',  // Only EU cities
})
```

| Jurisdiction | Allowed Regions |
|--------------|-----------------|
| `eu` | eu-west-1, eu-west-2, eu-west-3, eu-central-1, eu-north-1 |
| `us` | us-east-1, us-east-2, us-west-1, us-west-2, ca-central-1 |
| `fedramp` | us-gov-west-1, us-gov-east-1 |

### 2. Region (Location Hint)

AWS-style region names as location hints:

```typescript
const manager = new ReplicaManager(env.DO, {
  regions: ['us-east-1', 'eu-west-1', 'ap-northeast-1'],
  readFrom: 'nearest',
})
```

### 3. City (Precise via colo.do)

IATA airport codes for exact city placement:

```typescript
const manager = new ReplicaManager(env.DO, {
  cities: ['iad', 'fra', 'nrt'],  // Washington DC, Frankfurt, Tokyo
  readFrom: 'nearest',
})
```

## Supported Cities

### Americas

| Code | City |
|------|------|
| `iad` | Washington DC |
| `ord` | Chicago |
| `sfo` | San Francisco |
| `sea` | Seattle |
| `dfw` | Dallas |
| `mia` | Miami |
| `lax` | Los Angeles |
| `den` | Denver |
| `atl` | Atlanta |
| `bos` | Boston |
| `gru` | Sao Paulo |

### Europe

| Code | City |
|------|------|
| `lhr` | London |
| `fra` | Frankfurt |
| `ams` | Amsterdam |
| `cdg` | Paris |
| `dub` | Dublin |
| `mad` | Madrid |
| `mxp` | Milan |
| `arn` | Stockholm |
| `hel` | Helsinki |

### Asia Pacific

| Code | City |
|------|------|
| `nrt` | Tokyo |
| `sin` | Singapore |
| `syd` | Sydney |
| `hkg` | Hong Kong |
| `icn` | Seoul |
| `bom` | Mumbai |

## Write Modes

### Asynchronous (Default)

Writes go to primary immediately, replicas sync in batches (~50ms typical lag):

```typescript
const db = new ReplicatedPostgres(ctx, env, {
  replication: {
    cities: ['fra', 'ams', 'dub'],
    readFrom: 'nearest',
    writeThrough: false,  // Async
  },
})
```

**Benefits:**
- Lower write latency
- Higher throughput
- Sub-100ms typical replication lag

### Write-Through

Synchronous writes to all replicas for strong consistency:

```typescript
const db = new ReplicatedPostgres(ctx, env, {
  replication: {
    cities: ['fra', 'ams', 'dub'],
    readFrom: 'nearest',
    writeThrough: true,  // Sync to all
  },
})
```

**Benefits:**
- Strong consistency across all replicas
- No replication lag
- Guaranteed durability

**Tradeoffs:**
- Higher write latency (sum of replica RTTs)
- Lower write throughput

## Session Token Format

Session tokens are compact base62-encoded values (~15 characters):

```
Structure (84 bits):
├── LSN: 32 bits (supports up to 4B operations)
├── Timestamp delta: 42 bits (ms since 2024-01-01)
├── City index: 6 bits (supports 64 cities)
└── Version: 4 bits (supports 16 versions)
```

**Example:** `3k8Yw2xPqNrT5`

Tokens automatically expire after TTL (default: 1 hour) to prevent stale reads.

## Health-Aware Routing

Nearest replica selection considers multiple factors:

```typescript
effectiveLatency = networkLatency + (lag * 5ms) + statusPenalty
```

| Status | Penalty |
|--------|---------|
| `active` | 0ms |
| `stale` | 500ms |
| `initializing` | 200ms |
| `unavailable` | Excluded |

This ensures a healthy far replica may be preferred over a lagging near replica.

## Dynamic Replica Management

```typescript
// Add a new replica
await db.addReplica('sin')  // Singapore

// Remove a replica
await db.removeReplica('sin')

// Force sync a specific replica
await db.forceSyncReplica('ams')

// Get replica status
const replicas = await db.getReplicas()
for (const r of replicas) {
  console.log(`${r.city}: lag=${r.lag}, status=${r.status}`)
}

// Get replication statistics
const stats = await db.getReplicationStats()
console.log(`Batches: ${stats.replicationBatches}`)
console.log(`Items replicated: ${stats.totalItemsReplicated}`)
```

## Best Practices

### 1. Choose the Right Consistency Model

- Use `primary` for financial transactions
- Use `nearest` with `writeThrough: false` for high-read workloads
- Use `session` tokens when users need to see their own writes

### 2. Set Appropriate Session Token TTL

```typescript
const db = new ReplicatedPostgres(ctx, env, {
  replication: {
    sessionTokenTTLMs: 3600000,  // 1 hour
    rywFallbackToPrimary: true,  // Fallback on timeout
  },
})
```

### 3. Monitor Replication Lag

```typescript
const replicas = await db.getReplicas()
const maxLag = Math.max(...replicas.map(r => r.lag))

if (maxLag > 10) {
  // Alert: High replication lag
}
```

### 4. Use Jurisdiction for Compliance

```typescript
// GDPR-compliant EU deployment
const db = new ReplicatedPostgres(ctx, env, {
  replication: {
    jurisdiction: 'eu',  // Enforced by Cloudflare
    cities: ['fra', 'ams', 'dub'],
  },
})

// FedRAMP-compliant deployment
const fedRampDb = new ReplicatedPostgres(ctx, env, {
  replication: {
    jurisdiction: 'fedramp',
    readFrom: 'primary',
    writeThrough: true,
  },
})
```

## API Reference

### ReplicaManager

```typescript
class ReplicaManager {
  constructor(
    namespace: DurableObjectNamespace,
    config?: Partial<ReplicaConfig>,
    coloBindings?: ColoBindings
  )

  get config(): ReplicaConfig
  get replicaCount(): number

  isValidRegion(region: Region): boolean

  getPrimaryStub(name: string): Promise<DurableObjectStub>
  getStubInCity(name: string, city: City): Promise<DurableObjectStub>
  getStubInRegion(name: string, region: Region): Promise<DurableObjectStub>
  getReadStub(name: string): Promise<DurableObjectStub>
  getWriteStub(name: string): Promise<DurableObjectStub>
  getAllReplicaStubs(name: string): Promise<DurableObjectStub[]>

  writeThroughAll<T>(
    name: string,
    path: string,
    init?: RequestInit
  ): Promise<WriteResult<T>[]>
}
```

### ReplicaConfig

```typescript
interface ReplicaConfig {
  jurisdiction?: 'eu' | 'us' | 'fedramp'
  regions?: Region[]
  cities?: City[]
  readFrom: 'primary' | 'nearest' | 'secondary'
  writeThrough?: boolean
  sessionTokenTTLMs?: number
  rywFallbackToPrimary?: boolean
  maxLagForStale?: number
  nearestCacheTTLMs?: number
}
```

## Related

- [Sharding Strategies](/docs/storage/sharding) - Horizontal scaling across DOs
- [Tiered Storage](/docs/storage/tiered) - Hot/warm/cold data management
- [Storage Architecture](/docs/storage) - Overall storage overview
