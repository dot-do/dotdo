---
title: Workers KV
description: Global key-value storage for caching, sessions, and configuration with millisecond reads
---

# Workers KV

Cloudflare Workers KV provides globally distributed key-value storage. Use it for caching, session management, and configuration that needs to be read quickly from anywhere.

## Overview

KV is optimized for:

- **High read volume** - Eventually consistent reads at the edge
- **Global distribution** - Data replicated to 300+ locations
- **Caching** - API key lookups, session tokens, feature flags
- **Configuration** - Settings that change infrequently

| Characteristic | Value |
|---------------|-------|
| Read latency | ~10-50ms (at edge) |
| Write latency | ~500ms-1s |
| Consistency | Eventually consistent |
| Max value size | 25 MB |
| Max key size | 512 bytes |

## KVStore Integration

dotdo provides a typed KV wrapper with namespacing:

```typescript
import { createKVStore, KVStore } from 'dotdo/cloudflare'

export class SessionDO extends DO {
  private kv: KVStore

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)
    this.kv = createKVStore(env.SESSIONS, {
      namespace: 'sessions',
      defaultTtl: 86400, // 1 day default
    })
  }
}
```

## Basic Operations

### Get and Set

```typescript
export class ConfigDO extends DO {
  private kv: KVStore

  async getConfig<T>(key: string): Promise<T | null> {
    return await this.kv.get<T>(key)
  }

  async setConfig<T>(key: string, value: T) {
    await this.kv.set(key, value)
  }

  async setWithExpiration<T>(key: string, value: T, ttlSeconds: number) {
    await this.kv.set(key, value, { ttl: ttlSeconds })
  }

  async deleteConfig(key: string) {
    await this.kv.delete(key)
  }

  async exists(key: string): Promise<boolean> {
    return await this.kv.exists(key)
  }
}
```

### TTL Helpers

Use the built-in TTL helpers for readable code:

```typescript
export class CacheDO extends DO {
  private kv: KVStore

  async cacheResponse(key: string, data: unknown) {
    // Cache for 5 minutes
    await this.kv.set(key, data, {
      ttl: this.kv.ttl.minutes(5),
    })
  }

  async cacheForHour(key: string, data: unknown) {
    await this.kv.set(key, data, {
      ttl: this.kv.ttl.hours(1),
    })
  }

  async cacheForDay(key: string, data: unknown) {
    await this.kv.set(key, data, {
      ttl: this.kv.ttl.days(1),
    })
  }
}
```

## Session Management

KV is excellent for distributed session storage:

```typescript
export class AuthDO extends DO {
  private sessions: KVStore

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)
    this.sessions = createKVStore(env.KV, {
      namespace: 'session',
      defaultTtl: 86400, // 24 hours
    })
  }

  async createSession(userId: string, metadata: SessionMeta): Promise<string> {
    const sessionId = crypto.randomUUID()

    await this.sessions.setSession(sessionId, {
      userId,
      metadata,
      createdAt: Date.now(),
      lastAccessAt: Date.now(),
    }, this.kv.ttl.days(7))

    return sessionId
  }

  async getSession(sessionId: string): Promise<Session | null> {
    return await this.sessions.getSession<Session>(sessionId)
  }

  async refreshSession(sessionId: string): Promise<boolean> {
    // Refresh TTL without modifying data
    return await this.sessions.refreshSession<Session>(
      sessionId,
      this.kv.ttl.days(7)
    )
  }

  async destroySession(sessionId: string) {
    await this.sessions.deleteSession(sessionId)
  }
}

interface Session {
  userId: string
  metadata: SessionMeta
  createdAt: number
  lastAccessAt: number
}

interface SessionMeta {
  userAgent: string
  ip: string
  location?: string
}
```

## Caching Patterns

### Cache-Aside Pattern

```typescript
export class UserDO extends DO {
  private cache: KVStore

  async getUser(userId: string): Promise<User | null> {
    // Try cache first
    const cached = await this.cache.get<User>(`user:${userId}`)
    if (cached) {
      return cached
    }

    // Cache miss - fetch from database
    const user = await this.db.select()
      .from(schema.users)
      .where(eq(schema.users.id, userId))
      .get()

    if (user) {
      // Cache for 5 minutes
      await this.cache.set(`user:${userId}`, user, {
        ttl: this.cache.ttl.minutes(5),
      })
    }

    return user
  }

  async updateUser(userId: string, data: Partial<User>) {
    // Update database
    await this.db.update(schema.users)
      .set(data)
      .where(eq(schema.users.id, userId))

    // Invalidate cache
    await this.cache.invalidate(`user:${userId}`)
  }
}
```

### Cache Factory Pattern

Use the `cache()` method for automatic cache population:

```typescript
export class ProductDO extends DO {
  private cache: KVStore

  async getProduct(productId: string): Promise<Product> {
    return await this.cache.cache(
      `product:${productId}`,
      async () => {
        // This only runs on cache miss
        const product = await this.fetchProduct(productId)
        if (!product) throw new Error('Product not found')
        return product
      },
      { ttl: this.cache.ttl.minutes(15) }
    )
  }

  async getProductWithNullCaching(productId: string): Promise<Product | null> {
    return await this.cache.cache(
      `product:${productId}`,
      async () => this.fetchProduct(productId),
      {
        ttl: this.cache.ttl.minutes(15),
        cacheNull: true, // Cache null results too
      }
    )
  }
}
```

### Pattern Invalidation

Invalidate multiple keys at once:

```typescript
export class CatalogDO extends DO {
  private cache: KVStore

  async updateCategory(categoryId: string) {
    // Invalidate all products in this category
    await this.cache.invalidatePattern(`product:${categoryId}:*`)
  }

  async clearAllProductCache() {
    await this.cache.invalidatePattern('product:*')
  }
}
```

## API Key Caching

Cache API key validation results:

```typescript
export class ApiKeyDO extends DO {
  private cache: KVStore

  async validateApiKey(apiKey: string): Promise<ApiKeyInfo | null> {
    // Hash the key for cache lookup
    const keyHash = await this.hashKey(apiKey)

    // Check cache first
    const cached = await this.cache.getApiKey<ApiKeyInfo>(keyHash)
    if (cached !== null) {
      return cached
    }

    // Validate against database
    const keyInfo = await this.validateKeyInDatabase(apiKey)

    if (keyInfo) {
      // Cache valid keys for 5 minutes
      await this.cache.cacheApiKey(keyHash, keyInfo, this.cache.ttl.minutes(5))
    } else {
      // Cache invalid keys for 1 minute to prevent brute force
      await this.cache.cacheApiKey(keyHash, null, this.cache.ttl.minutes(1))
    }

    return keyInfo
  }

  async revokeApiKey(apiKey: string) {
    const keyHash = await this.hashKey(apiKey)
    await this.cache.invalidateApiKey(keyHash)
  }

  private async hashKey(key: string): Promise<string> {
    const data = new TextEncoder().encode(key)
    const hash = await crypto.subtle.digest('SHA-256', data)
    return btoa(String.fromCharCode(...new Uint8Array(hash)))
  }
}
```

## Rate Limiting

Implement distributed rate limiting:

```typescript
export class RateLimitDO extends DO {
  private kv: KVStore

  async checkRateLimit(
    identifier: string,
    limit: number,
    windowSeconds: number
  ): Promise<RateLimitResult> {
    const key = `ratelimit:${identifier}`

    const result = await this.kv.checkRateLimit(key, limit, windowSeconds)

    return {
      allowed: result.allowed,
      remaining: result.remaining,
      resetAt: Date.now() + windowSeconds * 1000,
    }
  }

  async resetRateLimit(identifier: string) {
    await this.kv.resetRateLimit(`ratelimit:${identifier}`)
  }
}

interface RateLimitResult {
  allowed: boolean
  remaining: number
  resetAt: number
}
```

### Sliding Window Rate Limiting

```typescript
export class SlidingWindowDO extends DO {
  async checkSlidingWindow(
    identifier: string,
    limit: number,
    windowMs: number
  ): Promise<{ allowed: boolean; count: number }> {
    const now = Date.now()
    const windowStart = now - windowMs
    const key = `sliding:${identifier}`

    // Get existing requests
    const requests = await this.kv.get<number[]>(key) ?? []

    // Filter to current window
    const currentWindow = requests.filter(ts => ts > windowStart)

    if (currentWindow.length >= limit) {
      return { allowed: false, count: currentWindow.length }
    }

    // Add current request
    currentWindow.push(now)

    // Store with TTL slightly longer than window
    await this.kv.set(key, currentWindow, {
      ttl: Math.ceil(windowMs / 1000) + 60,
    })

    return { allowed: true, count: currentWindow.length }
  }
}
```

## Batch Operations

### Multi-Get

```typescript
export class BatchDO extends DO {
  private kv: KVStore

  async getUsers(userIds: string[]): Promise<Record<string, User | null>> {
    const keys = userIds.map(id => `user:${id}`)
    return await this.kv.mget<User>(keys)
  }
}
```

### Multi-Set

```typescript
export class BulkDO extends DO {
  private kv: KVStore

  async cacheProducts(products: Product[]) {
    const data: Record<string, Product> = {}
    for (const product of products) {
      data[`product:${product.id}`] = product
    }

    await this.kv.mset(data, {
      ttl: this.kv.ttl.hours(1),
    })
  }
}
```

### Multi-Delete

```typescript
export class CleanupDO extends DO {
  private kv: KVStore

  async bulkInvalidate(keys: string[]) {
    await this.kv.mdelete(keys)
  }
}
```

## Listing Keys

### Prefix Listing

```typescript
export class FeatureFlagDO extends DO {
  private kv: KVStore

  async listAllFlags(): Promise<FeatureFlag[]> {
    const result = await this.kv.list('flag:', { limit: 1000 })

    const flags: FeatureFlag[] = []
    for (const key of result.keys) {
      const flag = await this.kv.get<FeatureFlag>(key.name)
      if (flag) flags.push(flag)
    }

    return flags
  }

  async listFlagsForEnvironment(env: string) {
    const result = await this.kv.list(`flag:${env}:`)
    return result.keys.map(k => k.name)
  }
}
```

### Paginated Listing

```typescript
export class PaginatedDO extends DO {
  private kv: KVStore

  async listKeys(
    prefix: string,
    cursor?: string,
    limit: number = 100
  ) {
    const result = await this.kv.list(prefix, { cursor, limit })

    return {
      keys: result.keys,
      hasMore: !result.list_complete,
      nextCursor: result.cursor,
    }
  }
}
```

## Best Practices

### When to Use KV

| Use Case | Recommended |
|----------|-------------|
| Session tokens | Yes |
| API key cache | Yes |
| Feature flags | Yes |
| User preferences | Yes |
| Frequently changing data | No |
| Strong consistency required | No |
| Large datasets | No |

### Caching Guidelines

1. **Set appropriate TTLs** - Balance freshness vs cache hits
2. **Handle cache misses** - Always have a fallback
3. **Use namespaces** - Avoid key collisions
4. **Batch operations** - Reduce API calls
5. **Monitor hit rates** - Adjust TTLs based on data

### Common Pitfalls

```typescript
// Bad: No TTL for frequently changing data
await kv.set('user:123', userData) // Never expires!

// Good: Appropriate TTL
await kv.set('user:123', userData, { ttl: kv.ttl.minutes(5) })

// Bad: Not handling eventual consistency
const updated = await kv.set('config', newConfig)
const current = await kv.get('config') // May still return old value!

// Good: Accept eventual consistency or use DO storage
// For strong consistency, use Durable Object storage instead
```

## Related Documentation

- [Durable Object Storage](/docs/storage/durable-objects) - For strong consistency
- [R2 Object Storage](/docs/storage/r2) - For large objects
- [Storage Architecture](/docs/storage) - Tiered storage overview
