---
title: Durable Objects Deep Dive
description: Understanding the DO lifecycle, state management, hibernation, and WebSocket handling
---

import { Callout } from 'fumadocs-ui/components/callout'

# Durable Objects Deep Dive

Durable Objects (DOs) are the core abstraction in dotdo. Each DO is an isolated execution environment with persistent state, acting like a virtual Chrome tab that never closes. This guide covers the internal mechanics.

## DO Lifecycle

### Creation

DOs are created on-demand when first accessed. The Cloudflare runtime handles instantiation:

```
Request → Worker → DO Namespace → ID Lookup → DO Instance
                                      ↓
                              [Create if needed]
```

```typescript
// Worker routes to DO by namespace
export default API({ ns: '/:tenant' })

// First request to 'acme' creates the DO
// GET https://api.dotdo.dev/acme/users
//     → DO('acme') created
//     → DO.fetch(request) called
```

### Initialization

dotdo provides lifecycle hooks for setup:

```typescript
import { DO } from 'dotdo'

class MyDO extends DO {
  // Called once when DO is first created (not on every request)
  async initialize(): Promise<void> {
    // Run migrations
    await this.db.run(sql`
      CREATE TABLE IF NOT EXISTS settings (
        key TEXT PRIMARY KEY,
        value TEXT
      )
    `)

    // Set up event handlers
    this.$.on.User.created(this.onUserCreated.bind(this))

    // Initialize stores
    await this.things.initialize()
  }

  // Called on every request
  async fetch(request: Request): Promise<Response> {
    // Handle HTTP request
    return this.app.fetch(request)
  }
}
```

### Request Processing

Each request follows this flow:

```
┌─────────────────────────────────────────────────────────────┐
│                     Incoming Request                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    DO.fetch(request)                         │
│                                                              │
│  1. Parse request                                           │
│  2. Route to handler                                        │
│  3. Execute within transaction                              │
│  4. Return response                                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Single-Threaded Execution                  │
│                                                              │
│  • No concurrent requests within same DO                    │
│  • Actor model eliminates race conditions                   │
│  • Requests queue if DO is busy                             │
└─────────────────────────────────────────────────────────────┘
```

### Eviction

DOs are evicted when idle to free resources:

```
Active Request → Idle Timer (30s default) → Eviction
                                              ↓
                               [State persisted to SQLite]
                               [In-memory state lost]
```

<Callout type="warning">
In-memory state (class properties not backed by SQLite) is lost on eviction. Always persist important state to `this.db` or `this.ctx.storage`.
</Callout>

```typescript
class MyDO extends DO {
  // BAD: Lost on eviction
  private cache = new Map<string, unknown>()

  // GOOD: Survives eviction
  async getFromDb(key: string) {
    return this.db.select().from(cache).where(eq(cache.key, key))
  }
}
```

## State Management

### SQLite Storage

Every DO has a co-located SQLite database with ACID guarantees:

```typescript
import { DO } from 'dotdo'
import { drizzle } from 'drizzle-orm'

class DataDO extends DO {
  async setup() {
    // Drizzle ORM is pre-configured
    this.db = drizzle(this.ctx.storage, { schema })
  }

  async createUser(email: string) {
    // ACID transaction
    return await this.db.transaction(async (tx) => {
      const [user] = await tx.insert(users).values({ email }).returning()
      await tx.insert(audit).values({ action: 'create', userId: user.id })
      return user
    })
  }
}
```

### Storage Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      DO Instance                             │
├─────────────────────────────────────────────────────────────┤
│  this.db (Drizzle)                                          │
│     │                                                        │
│     ▼                                                        │
│  this.ctx.storage (SQLite)                                  │
│     │                                                        │
│     ├── things table       (entities)                       │
│     ├── relationships table (edges)                         │
│     ├── actions table      (audit log)                      │
│     ├── events table       (domain events)                  │
│     ├── search table       (FTS + vectors)                  │
│     └── custom tables      (your schema)                    │
└─────────────────────────────────────────────────────────────┘
```

### Storage Limits

| Resource | Limit |
|----------|-------|
| SQLite database size | 10 GB |
| Rows per table | Unlimited |
| Row size | 2 MB |
| Concurrent reads | Unlimited |
| Concurrent writes | 1 (single-threaded) |

### Key-Value Storage

For simple key-value patterns, use the storage API directly:

```typescript
// Low-level storage API
await this.ctx.storage.put('config', { theme: 'dark' })
const config = await this.ctx.storage.get('config')

// Batch operations
await this.ctx.storage.put({
  'user:1': { name: 'Alice' },
  'user:2': { name: 'Bob' },
})

// Delete
await this.ctx.storage.delete('config')
await this.ctx.storage.deleteAll()  // Clear everything
```

### Transactional Guarantees

SQLite provides ACID transactions within each DO:

```typescript
// Atomic multi-table update
await this.db.transaction(async (tx) => {
  // Debit source account
  await tx.update(accounts)
    .set({ balance: sql`balance - ${amount}` })
    .where(eq(accounts.id, fromId))

  // Credit destination account
  await tx.update(accounts)
    .set({ balance: sql`balance + ${amount}` })
    .where(eq(accounts.id, toId))

  // Log the transfer
  await tx.insert(transfers).values({
    fromId,
    toId,
    amount,
    timestamp: new Date()
  })
})
```

<Callout type="info">
Transactions are automatic for single statements. Use explicit transactions for multi-statement atomicity.
</Callout>

## Hibernation

Hibernation allows DOs to maintain WebSocket connections while releasing compute resources.

### How Hibernation Works

```
┌──────────────────────────────────────────────────────────────┐
│                    Active DO                                  │
│                                                               │
│  • Holding WebSocket connections                             │
│  • Consuming CPU/memory                                      │
│  • Billing for compute time                                  │
└──────────────────────────────────────────────────────────────┘
                              │
                              │ (No activity for 10s)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                  Hibernated DO                                │
│                                                               │
│  • WebSocket connections maintained by platform              │
│  • CPU/memory released                                       │
│  • No compute billing                                        │
│  • State persisted to SQLite                                 │
└──────────────────────────────────────────────────────────────┘
                              │
                              │ (Message received)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                   Awakened DO                                 │
│                                                               │
│  • webSocketMessage() handler called                         │
│  • State restored from SQLite                                │
│  • Connection context available                              │
└──────────────────────────────────────────────────────────────┘
```

### Enabling Hibernation

```typescript
import { DO } from 'dotdo'

class RealtimeDO extends DO {
  async fetch(request: Request): Promise<Response> {
    if (request.headers.get('Upgrade') === 'websocket') {
      return this.handleWebSocketUpgrade(request)
    }
    return new Response('Expected WebSocket', { status: 400 })
  }

  async handleWebSocketUpgrade(request: Request): Promise<Response> {
    const pair = new WebSocketPair()
    const [client, server] = Object.values(pair)

    // Accept with hibernation enabled
    this.ctx.acceptWebSocket(server, {
      // Attach metadata that survives hibernation
      userId: request.headers.get('X-User-Id'),
      room: new URL(request.url).pathname,
    })

    return new Response(null, {
      status: 101,
      webSocket: client,
    })
  }

  // Called when message arrives (even after hibernation)
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    // Retrieve attached metadata
    const { userId, room } = this.ctx.getWebSocketState(ws) ?? {}

    // Broadcast to all connections in this room
    const connections = this.ctx.getWebSockets(room)
    for (const conn of connections) {
      conn.send(message)
    }
  }

  // Called when connection closes
  async webSocketClose(ws: WebSocket, code: number, reason: string) {
    const { userId } = this.ctx.getWebSocketState(ws) ?? {}
    await this.things.delete(`presence:${userId}`)
  }
}
```

### Hibernation Best Practices

```typescript
class OptimizedRealtimeDO extends DO {
  // Store connection metadata in SQLite, not memory
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    const data = JSON.parse(message as string)

    switch (data.type) {
      case 'subscribe':
        // Persist subscription to SQLite
        await this.db.insert(subscriptions).values({
          wsId: this.ctx.getWebSocketId(ws),
          channel: data.channel,
        })
        break

      case 'broadcast':
        // Query subscriptions from SQLite
        const subs = await this.db
          .select()
          .from(subscriptions)
          .where(eq(subscriptions.channel, data.channel))

        // Send to matching connections
        for (const sub of subs) {
          const conn = this.ctx.getWebSocketById(sub.wsId)
          conn?.send(JSON.stringify(data.payload))
        }
        break
    }
  }
}
```

<Callout type="info">
Hibernation is automatic when using `ctx.acceptWebSocket()`. The DO hibernates after 10 seconds of inactivity and awakens on any incoming message.
</Callout>

## WebSocket Handling

### Connection Lifecycle

```
Client                          DO
  │                              │
  │──── Upgrade Request ────────▶│
  │                              │ acceptWebSocket()
  │◀─── 101 Switching ──────────│
  │                              │
  │──── Message ────────────────▶│ webSocketMessage()
  │◀─── Message ─────────────────│ ws.send()
  │                              │
  │──── Close ──────────────────▶│ webSocketClose()
  │◀─── Close ───────────────────│
```

### Multi-Room Chat Example

```typescript
import { DO } from 'dotdo'

interface ChatMessage {
  type: 'join' | 'leave' | 'message'
  room: string
  user: string
  content?: string
}

class ChatDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)

    if (url.pathname === '/ws') {
      return this.upgradeWebSocket(request)
    }

    if (url.pathname === '/rooms') {
      return this.listRooms()
    }

    return new Response('Not found', { status: 404 })
  }

  async upgradeWebSocket(request: Request): Promise<Response> {
    const url = new URL(request.url)
    const room = url.searchParams.get('room') ?? 'general'
    const user = url.searchParams.get('user') ?? 'anonymous'

    const pair = new WebSocketPair()
    const [client, server] = Object.values(pair)

    // Tag connection with room for efficient broadcasting
    this.ctx.acceptWebSocket(server, { room, user })

    // Notify room of new user
    this.broadcast(room, {
      type: 'join',
      room,
      user,
    })

    return new Response(null, { status: 101, webSocket: client })
  }

  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    const state = this.ctx.getWebSocketState(ws)
    if (!state) return

    const data = JSON.parse(message as string) as ChatMessage

    // Broadcast message to room
    this.broadcast(state.room, {
      type: 'message',
      room: state.room,
      user: state.user,
      content: data.content,
    })

    // Persist message to history
    await this.events.emit({
      verb: 'message',
      source: `Chat/${state.room}`,
      data: { user: state.user, content: data.content },
    })
  }

  async webSocketClose(ws: WebSocket) {
    const state = this.ctx.getWebSocketState(ws)
    if (!state) return

    this.broadcast(state.room, {
      type: 'leave',
      room: state.room,
      user: state.user,
    })
  }

  private broadcast(room: string, message: ChatMessage) {
    const connections = this.ctx.getWebSockets(room)
    const payload = JSON.stringify(message)

    for (const ws of connections) {
      try {
        ws.send(payload)
      } catch {
        // Connection may have closed
      }
    }
  }

  private async listRooms(): Promise<Response> {
    const allConnections = this.ctx.getWebSockets()
    const rooms = new Map<string, number>()

    for (const ws of allConnections) {
      const state = this.ctx.getWebSocketState(ws)
      if (state?.room) {
        rooms.set(state.room, (rooms.get(state.room) ?? 0) + 1)
      }
    }

    return Response.json(
      Array.from(rooms.entries()).map(([room, count]) => ({ room, count }))
    )
  }
}
```

### WebSocket API Reference

| Method | Description |
|--------|-------------|
| `ctx.acceptWebSocket(ws, tags?)` | Accept connection with optional tags |
| `ctx.getWebSockets(tag?)` | Get all connections, optionally filtered by tag |
| `ctx.getWebSocketState(ws)` | Get tags attached to a connection |
| `ctx.getWebSocketId(ws)` | Get unique ID for a connection |
| `ctx.getWebSocketById(id)` | Get connection by ID |

## Alarm Scheduling

DOs support scheduled execution via alarms:

```typescript
import { DO } from 'dotdo'

class ScheduledDO extends DO {
  async scheduleReminder(userId: string, message: string, delay: number) {
    // Store reminder data
    await this.things.create({
      $type: 'Reminder',
      data: { userId, message },
    })

    // Schedule alarm
    await this.ctx.storage.setAlarm(Date.now() + delay)
  }

  // Called when alarm fires
  async alarm(): Promise<void> {
    // Process all pending reminders
    const reminders = await this.things.list({ type: 'Reminder' })

    for (const reminder of reminders) {
      await this.sendNotification(reminder.data.userId, reminder.data.message)
      await this.things.delete(reminder.$id)
    }
  }
}
```

### Alarm Guarantees

| Guarantee | Description |
|-----------|-------------|
| At-least-once | Alarm will fire at least once |
| Single active | Only one alarm per DO at a time |
| Persistence | Survives DO eviction |
| Accuracy | Within ~1 minute of scheduled time |

<Callout type="warning">
If you need multiple scheduled tasks, store them in SQLite and process them all in a single `alarm()` call.
</Callout>

## Performance Considerations

### Cold Starts

| Bundle | Cold Start | Warm Request |
|--------|------------|--------------|
| `dotdo/tiny` | ~5ms | \<1ms |
| `dotdo` | ~15ms | \<1ms |
| `dotdo/full` | ~25ms | \<1ms |

### Memory Limits

| Resource | Limit |
|----------|-------|
| Memory per DO | 128 MB |
| CPU time per request | 30s (paid) / 10ms (free) |
| Subrequest limit | 1,000 per request |

### Optimizing Performance

```typescript
class OptimizedDO extends DO {
  // Lazy initialization - don't load what you don't need
  private _heavyData?: HeavyData

  get heavyData(): HeavyData {
    if (!this._heavyData) {
      this._heavyData = new HeavyData(this.db)
    }
    return this._heavyData
  }

  // Batch operations
  async bulkInsert(items: Item[]) {
    // BAD: N queries
    for (const item of items) {
      await this.db.insert(things).values(item)
    }

    // GOOD: 1 query
    await this.db.insert(things).values(items)
  }

  // Use indexes
  async setup() {
    await this.db.run(sql`
      CREATE INDEX IF NOT EXISTS idx_things_type
      ON things(type)
    `)
  }
}
```

## Related

<Cards>
  <Card title="DO Class Hierarchy" href="/docs/architecture/do-hierarchy">
    Three-tier bundle system and mixin composition.
  </Card>
  <Card title="Edge Computing" href="/docs/architecture/edge-computing">
    Global distribution and latency optimization.
  </Card>
  <Card title="Scalability" href="/docs/architecture/scalability">
    Horizontal scaling and sharding strategies.
  </Card>
</Cards>
