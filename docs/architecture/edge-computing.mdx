---
title: Edge Computing Patterns
description: Global distribution, latency optimization, and data locality strategies for edge-first applications
---

import { Callout } from 'fumadocs-ui/components/callout'

# Edge Computing Patterns

dotdo runs on Cloudflare's global edge network, spanning 300+ cities worldwide. This guide covers patterns for optimizing latency, data locality, and global distribution.

## Global Distribution

### The Edge Network

Cloudflare's network provides global coverage with automatic request routing:

```
                    ┌─────────────────────────────────────────┐
                    │         Cloudflare Edge Network          │
                    │                                          │
   User ───────────▶│  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐    │
   (Tokyo)          │  │ NRT │  │ SIN │  │ HKG │  │ SYD │    │
                    │  └──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘    │
                    │     │        │        │        │        │
                    │     └────────┴────────┴────────┘        │
                    │                   │                      │
                    │                   ▼                      │
                    │            ┌───────────┐                │
                    │            │  Your DO  │                │
                    │            └───────────┘                │
                    └─────────────────────────────────────────┘
```

### Request Flow

```typescript
// Request from Tokyo user
// 1. Hits nearest edge (NRT - Narita)
// 2. Worker executes at edge
// 3. Routes to DO (may be in different location)
// 4. Response returns via edge

export default API({ ns: '/:tenant' })
```

### Latency Breakdown

| Stage | Typical Latency |
|-------|-----------------|
| User to edge | 1-20ms |
| Edge to DO (same region) | 5-15ms |
| Edge to DO (cross-region) | 50-150ms |
| DO processing | 1-100ms |
| Total (optimized) | 10-50ms |
| Total (unoptimized) | 100-300ms |

## Latency Optimization

### 1. Colocate DO with Users

Place DOs close to your users using location hints:

```typescript
import { DO } from 'dotdo'

class RegionalDO extends DO {
  static readonly locationHint = 'apac'  // Asia-Pacific
}

// Or dynamically during creation
const stub = env.DO.get(
  env.DO.idFromName('my-do'),
  { locationHint: 'weur' }  // Western Europe
)
```

### Location Hint Reference

| Hint | Region | Example Cities |
|------|--------|----------------|
| `wnam` | Western North America | Seattle, Los Angeles, San Francisco |
| `enam` | Eastern North America | New York, Chicago, Washington DC |
| `weur` | Western Europe | London, Paris, Frankfurt, Amsterdam |
| `eeur` | Eastern Europe | Warsaw, Prague, Vienna |
| `apac` | Asia-Pacific | Tokyo, Singapore, Hong Kong, Sydney |
| `oc` | Oceania | Sydney, Melbourne, Auckland |
| `sam` | South America | Sao Paulo, Buenos Aires |
| `afr` | Africa | Johannesburg, Cape Town |
| `me` | Middle East | Dubai, Tel Aviv |

### 2. Edge Caching

Cache responses at the edge to eliminate DO round-trips:

```typescript
import { DO } from 'dotdo'

class CachedDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)

    // Check edge cache first
    const cacheKey = new Request(url.toString(), request)
    const cache = caches.default
    let response = await cache.match(cacheKey)

    if (response) {
      return response
    }

    // Cache miss - generate response
    const data = await this.getData(url.pathname)
    response = Response.json(data, {
      headers: {
        'Cache-Control': 'public, max-age=60',
        'CDN-Cache-Control': 'max-age=300',
      },
    })

    // Store in edge cache
    this.ctx.waitUntil(cache.put(cacheKey, response.clone()))

    return response
  }
}
```

### Cache Header Strategies

```typescript
class SmartCacheDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const path = new URL(request.url).pathname

    // Static content - long cache
    if (path.startsWith('/static/')) {
      return this.serveStatic(path, {
        'Cache-Control': 'public, max-age=31536000, immutable',
      })
    }

    // User profile - short cache with revalidation
    if (path.startsWith('/profile/')) {
      return this.serveProfile(path, {
        'Cache-Control': 'public, max-age=60, stale-while-revalidate=300',
      })
    }

    // Real-time data - no cache
    if (path.startsWith('/live/')) {
      return this.serveLive(path, {
        'Cache-Control': 'no-store',
      })
    }

    return new Response('Not found', { status: 404 })
  }
}
```

### 3. Request Coalescing

Prevent thundering herd by coalescing identical requests:

```typescript
import { DO } from 'dotdo'

class CoalescingDO extends DO {
  private pendingRequests = new Map<string, Promise<Response>>()

  async fetch(request: Request): Promise<Response> {
    const cacheKey = this.getCacheKey(request)

    // Check if identical request is in flight
    const pending = this.pendingRequests.get(cacheKey)
    if (pending) {
      return pending.then(r => r.clone())
    }

    // Start new request
    const promise = this.handleRequest(request)
    this.pendingRequests.set(cacheKey, promise)

    try {
      const response = await promise
      return response.clone()
    } finally {
      this.pendingRequests.delete(cacheKey)
    }
  }

  private getCacheKey(request: Request): string {
    const url = new URL(request.url)
    return `${request.method}:${url.pathname}:${url.search}`
  }
}
```

### 4. Prefetching

Anticipate user needs and prefetch data:

```typescript
class PrefetchingDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)

    if (url.pathname === '/products') {
      const products = await this.getProducts()

      // Prefetch product details in background
      this.ctx.waitUntil(
        Promise.all(
          products.slice(0, 5).map(p =>
            this.prefetchProduct(p.id)
          )
        )
      )

      return Response.json(products)
    }

    return new Response('Not found', { status: 404 })
  }

  private async prefetchProduct(id: string): Promise<void> {
    const cache = caches.default
    const key = new Request(`https://internal/products/${id}`)

    if (await cache.match(key)) return

    const product = await this.getProductDetails(id)
    await cache.put(key, Response.json(product))
  }
}
```

## Data Locality

### Region-Aware Routing

Route users to region-specific DOs:

```typescript
// Worker entry point
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const region = request.cf?.continent ?? 'NA'

    // Route to regional DO
    const regionalNs = `${env.TENANT}-${region}`
    const id = env.DO.idFromName(regionalNs)
    const stub = env.DO.get(id, {
      locationHint: getLocationHint(region)
    })

    return stub.fetch(request)
  }
}

function getLocationHint(continent: string): string {
  const hints: Record<string, string> = {
    'EU': 'weur',
    'NA': 'enam',
    'AS': 'apac',
    'SA': 'sam',
    'OC': 'oc',
    'AF': 'afr',
  }
  return hints[continent] ?? 'enam'
}
```

### Data Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                      Global Architecture                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐      │
│   │   EU DO     │     │   US DO     │     │  APAC DO    │      │
│   │ (Frankfurt) │     │ (Virginia)  │     │  (Tokyo)    │      │
│   └──────┬──────┘     └──────┬──────┘     └──────┬──────┘      │
│          │                   │                   │              │
│          └───────────────────┼───────────────────┘              │
│                              │                                   │
│                              ▼                                   │
│                    ┌─────────────────┐                          │
│                    │   Global DO     │                          │
│                    │  (Aggregation)  │                          │
│                    └─────────────────┘                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Local-First with Global Sync

```typescript
import { DO } from 'dotdo'

class LocalFirstDO extends DO {
  async write(data: unknown): Promise<void> {
    // Write locally first (fast)
    await this.things.create({
      $type: 'Data',
      data,
    })

    // Sync to global DO in background
    this.ctx.waitUntil(this.syncToGlobal(data))
  }

  private async syncToGlobal(data: unknown): Promise<void> {
    const globalId = this.env.GLOBAL_DO.idFromName('global')
    const globalStub = this.env.GLOBAL_DO.get(globalId)

    await globalStub.fetch('/sync', {
      method: 'POST',
      body: JSON.stringify({
        region: this.region,
        data,
        timestamp: Date.now(),
      }),
    })
  }
}
```

### GDPR-Compliant Data Locality

```typescript
import { DO } from 'dotdo'

class GDPRCompliantDO extends DO {
  async storeUserData(userId: string, data: unknown): Promise<void> {
    const userRegion = await this.getUserRegion(userId)

    if (userRegion === 'EU') {
      // Store in EU-only DO with jurisdiction lock
      const euId = this.env.EU_DO.idFromName(userId)
      const euStub = this.env.EU_DO.get(euId, {
        locationHint: 'weur',
      })

      await euStub.fetch('/store', {
        method: 'POST',
        body: JSON.stringify(data),
      })
    } else {
      // Store locally
      await this.things.create({
        $type: 'UserData',
        data: { userId, ...data },
      })
    }
  }
}
```

## Edge Compute Patterns

### Compute at the Edge, Store at Origin

```
┌──────────────────────────────────────────────────────────────┐
│                    Edge Workers (300+ locations)              │
│                                                               │
│  • Request validation                                        │
│  • Authentication                                            │
│  • Rate limiting                                             │
│  • Response transformation                                   │
│  • Caching                                                   │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                    Durable Objects (Regional)                 │
│                                                               │
│  • Business logic                                            │
│  • State management                                          │
│  • Event processing                                          │
│  • Data persistence                                          │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                    Cold Storage (Global)                      │
│                                                               │
│  • R2 (object storage)                                       │
│  • Parquet archives                                          │
│  • Backup data                                               │
└──────────────────────────────────────────────────────────────┘
```

### Edge Authentication

```typescript
// Worker-level auth (runs at edge before hitting DO)
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Fast auth check at edge
    const token = request.headers.get('Authorization')?.split(' ')[1]

    if (!token) {
      return new Response('Unauthorized', { status: 401 })
    }

    // Verify JWT at edge (fast, no network)
    const payload = await verifyJWT(token, env.JWT_SECRET)
    if (!payload) {
      return new Response('Invalid token', { status: 401 })
    }

    // Add user context to request
    const modifiedRequest = new Request(request, {
      headers: new Headers([
        ...request.headers.entries(),
        ['X-User-Id', payload.sub],
        ['X-User-Role', payload.role],
      ]),
    })

    // Forward to DO
    const id = env.DO.idFromName(payload.tenant)
    return env.DO.get(id).fetch(modifiedRequest)
  }
}
```

### Edge Rate Limiting

```typescript
import { DO } from 'dotdo/tiny'

class RateLimiterDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const ip = request.headers.get('CF-Connecting-IP') ?? 'unknown'
    const key = `ratelimit:${ip}`

    const current = await this.ctx.storage.get<number>(key) ?? 0
    const limit = 100  // requests per minute

    if (current >= limit) {
      return new Response('Rate limit exceeded', {
        status: 429,
        headers: {
          'Retry-After': '60',
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': '0',
        },
      })
    }

    // Increment counter
    await this.ctx.storage.put(key, current + 1)

    // Schedule reset after 1 minute
    if (current === 0) {
      await this.ctx.storage.setAlarm(Date.now() + 60000)
    }

    // Forward to main DO
    return this.forwardRequest(request)
  }

  async alarm(): Promise<void> {
    // Reset all rate limits
    await this.ctx.storage.deleteAll()
  }
}
```

## Real-World Architecture Examples

### Global E-commerce Platform

```typescript
// Multi-region product catalog with edge caching
class ProductCatalogDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)
    const region = request.cf?.continent ?? 'NA'

    // Product list - edge cached, region-specific pricing
    if (url.pathname === '/products') {
      return this.getProducts(region, {
        'Cache-Control': 'public, max-age=300',
        'Vary': 'CF-IPCountry',
      })
    }

    // Cart operations - no cache, regional DO
    if (url.pathname.startsWith('/cart')) {
      return this.handleCart(request)
    }

    // Checkout - no cache, global inventory lock
    if (url.pathname === '/checkout') {
      return this.handleCheckout(request)
    }

    return new Response('Not found', { status: 404 })
  }

  private async handleCheckout(request: Request): Promise<Response> {
    const order = await request.json() as Order

    // Lock inventory globally
    const inventoryDO = this.env.INVENTORY.get(
      this.env.INVENTORY.idFromName('global')
    )

    const lockResult = await inventoryDO.fetch('/lock', {
      method: 'POST',
      body: JSON.stringify(order.items),
    })

    if (!lockResult.ok) {
      return new Response('Inventory unavailable', { status: 409 })
    }

    // Process payment
    const payment = await this.processPayment(order)

    // Confirm order
    await this.confirmOrder(order, payment)

    return Response.json({ orderId: order.id, status: 'confirmed' })
  }
}
```

### Real-time Gaming Backend

```typescript
class GameServerDO extends DO {
  // Players connected to this game session
  private players = new Set<WebSocket>()

  async fetch(request: Request): Promise<Response> {
    if (request.headers.get('Upgrade') === 'websocket') {
      return this.handlePlayerConnection(request)
    }

    const url = new URL(request.url)

    // Match state - cached at edge for spectators
    if (url.pathname === '/state') {
      const state = await this.getGameState()
      return Response.json(state, {
        headers: {
          'Cache-Control': 'public, max-age=1',
        },
      })
    }

    return new Response('Not found', { status: 404 })
  }

  async handlePlayerConnection(request: Request): Promise<Response> {
    const pair = new WebSocketPair()
    const [client, server] = Object.values(pair)

    const playerId = new URL(request.url).searchParams.get('player')
    this.ctx.acceptWebSocket(server, { playerId })

    // Notify other players
    this.broadcast({
      type: 'player_joined',
      playerId,
      timestamp: Date.now(),
    })

    return new Response(null, { status: 101, webSocket: client })
  }

  async webSocketMessage(ws: WebSocket, message: string) {
    const state = this.ctx.getWebSocketState(ws)
    const action = JSON.parse(message) as GameAction

    // Validate and apply action
    const result = await this.applyAction(state.playerId, action)

    // Broadcast to all players with minimal latency
    this.broadcast({
      type: 'game_update',
      action,
      result,
      timestamp: Date.now(),
    })
  }

  private broadcast(message: unknown): void {
    const payload = JSON.stringify(message)
    for (const ws of this.ctx.getWebSockets()) {
      ws.send(payload)
    }
  }
}
```

## Performance Monitoring

### Latency Tracking

```typescript
class MonitoredDO extends DO {
  async fetch(request: Request): Promise<Response> {
    const start = performance.now()
    const requestId = crypto.randomUUID()

    try {
      const response = await this.handleRequest(request)

      // Log latency metrics
      this.ctx.waitUntil(
        this.logMetrics({
          requestId,
          path: new URL(request.url).pathname,
          method: request.method,
          duration: performance.now() - start,
          status: response.status,
          colo: request.cf?.colo,
          country: request.cf?.country,
        })
      )

      return response
    } catch (error) {
      this.ctx.waitUntil(
        this.logError({
          requestId,
          error: error instanceof Error ? error.message : 'Unknown error',
          duration: performance.now() - start,
        })
      )
      throw error
    }
  }

  private async logMetrics(metrics: RequestMetrics): Promise<void> {
    // Send to analytics pipeline
    await this.env.ANALYTICS.writeDataPoint({
      blobs: [metrics.path, metrics.method, metrics.colo ?? 'unknown'],
      doubles: [metrics.duration, metrics.status],
      indexes: [metrics.country ?? 'unknown'],
    })
  }
}
```

## Related

<Cards>
  <Card title="Durable Objects Deep Dive" href="/docs/architecture/durable-objects">
    DO lifecycle, state management, and WebSocket handling.
  </Card>
  <Card title="Scalability Patterns" href="/docs/architecture/scalability">
    Horizontal scaling and sharding strategies.
  </Card>
  <Card title="Geo-Replication" href="/docs/deployment/geo-replication">
    Multi-region deployment with jurisdiction controls.
  </Card>
</Cards>
