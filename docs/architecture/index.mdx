---
title: Architecture Overview
description: Technical deep dive into dotdo's internal architecture
---

import { Callout } from 'fumadocs-ui/components/callout'

# Architecture Overview

dotdo is a Business-as-Code framework built on Cloudflare's V8 Isolates and Durable Objects. This section provides a technical deep dive into the internal architecture for advanced users building on the platform.

## System Architecture

The complete dotdo stack integrates V8 Isolates, Durable Objects, Cap'n Web RPC, and tiered storage:

```
                              DOTDO SYSTEM ARCHITECTURE
                              =========================

    CLIENT                         EDGE (300+ Cities)                    STORAGE
    ======                         =================                     =======

    ┌─────────────────┐
    │   Browser/App   │
    │                 │        ┌─────────────────────────────────────────────────────┐
    │ ┌─────────────┐ │        │                  Cloudflare Edge                    │
    │ │ RPC Client  │─┼───────▶│                                                     │
    │ │ (capnweb)   │ │  WS    │  ┌───────────────────────────────────────────────┐  │
    │ └─────────────┘ │  or    │  │               Worker (V8 Isolate)              │  │
    │                 │  HTTP  │  │                                                │  │
    │ ┌─────────────┐ │        │  │  ┌──────────────┐    ┌──────────────────────┐ │  │
    │ │DuckDB-WASM  │◀┼────────│──│──│   API()      │───▶│   DO Router          │ │  │
    │ │(Analytics)  │ │Parquet │  │  │   Router     │    │   (namespace lookup) │ │  │
    │ └─────────────┘ │        │  │  └──────────────┘    └──────────┬───────────┘ │  │
    └─────────────────┘        │  └──────────────────────────────────│─────────────┘  │
                               │                                     │                │
                               │         ┌───────────────────────────┴─────────┐     │
                               │         ▼                                     ▼     │
                               │  ┌─────────────────┐               ┌─────────────────┐
                               │  │ Durable Object  │               │ Durable Object  │
                               │  │ (tenant-a)      │               │ (tenant-b)      │
                               │  │                 │               │                 │
                               │  │ ┌─────────────┐ │               │ ┌─────────────┐ │
                               │  │ │   SQLite    │ │               │ │   SQLite    │ │
                               │  │ │  (10GB max) │ │               │ │  (10GB max) │ │
                               │  │ ├─────────────┤ │               │ ├─────────────┤ │
                               │  │ │ things      │ │               │ │ things      │ │
                               │  │ │ rels        │ │               │ │ rels        │ │
                               │  │ │ actions     │ │               │ │ actions     │ │
                               │  │ │ events      │ │               │ │ events      │ │
                               │  │ │ search      │ │  CF Pipelines │ │ search      │ │
                               │  │ └──────┬──────┘ │ (streaming)   │ └──────┬──────┘ │
                               │  └────────│────────┘       │       └────────│────────┘
                               │           │                ▼                │        │
                               │           │         ┌─────────────────────┐ │        │
                               │           └────────▶│   R2 + Iceberg      │◀┘        │
                               │                     │   (warm tier)       │          │
                               │                     │                     │          │
                               │                     │ ┌─────────────────┐ │          │
                               │                     │ │  Parquet files  │ │          │
                               │                     │ │  (partitioned)  │ │          │
                               │                     │ └────────┬────────┘ │          │
                               │                     └──────────│──────────┘          │
                               │                                ▼                     │
                               │                     ┌─────────────────────┐          │
                               │                     │  ClickHouse / R2    │          │
                               │                     │  (cold analytics)   │          │
                               │                     └─────────────────────┘          │
                               └──────────────────────────────────────────────────────┘
```

### Key Integration Points

| Layer | Technology | Role |
|-------|------------|------|
| **Transport** | Cap'n Web RPC | Promise pipelining, batch operations |
| **Compute** | V8 Isolates | ~0ms cold starts, 128MB memory |
| **State** | Durable Objects + SQLite | Actor model, ACID transactions |
| **Warm Storage** | R2 + Iceberg/Parquet | Cross-DO queries, event archive |
| **Cold Storage** | ClickHouse + R2 | Analytics, time-series aggregation |

## Core Philosophy

### V8 Isolates as Virtual Chrome Tabs

dotdo treats each Durable Object as a **virtual Chrome tab** with persistent state. Just as Chrome isolates tabs for security and performance, V8 Isolates provide:

| Property | Description |
|----------|-------------|
| **Memory isolation** | Each DO runs in its own V8 isolate |
| **State persistence** | SQLite storage survives across requests |
| **Concurrent execution** | Millions of DOs can run simultaneously |
| **Actor model** | Single-threaded execution eliminates race conditions |

```typescript
// Each DO is like a persistent browser tab
class MyStartup extends DO {
  // State lives in SQLite, survives restarts
  async fetch(request: Request) {
    const data = await this.db.select().from(things)
    return Response.json(data)
  }
}
```

### Edge-First Architecture

Cloudflare Workers + Durable Objects run on **300+ cities globally**:

- **~0ms cold starts** (when warm) - V8 Isolates spin up in microseconds
- **~50ms cold starts** - When loading new isolate with SQLite state
- **Single-digit latency** - Code runs close to users
- **Automatic failover** - Cloudflare handles regional redundancy

### SQLite as Universal Storage Layer

Every DO has a built-in SQLite database via Drizzle ORM:

```typescript
// Initialize Drizzle with DO storage
this.db = drizzle(ctx.storage, { schema })

// Type-safe queries
const startups = await this.db
  .select()
  .from(things)
  .where(eq(things.type, startupFK))
```

SQLite provides:
- **ACID transactions** - Consistent state within each DO
- **JSON columns** - Flexible schema with `json_extract()` queries
- **Full-text search** - FTS5 for text search
- **Vector storage** - 128-dim MRL embeddings for semantic search

## Package Structure

```
dotdo/
├── do/                    # Entry points (tiny, index, full)
│   ├── index.ts           # Default export (all capabilities)
│   ├── tiny.ts            # Minimal DO (~15KB)
│   ├── fs.ts              # DO + filesystem
│   ├── git.ts             # DO + filesystem + git
│   ├── bash.ts            # DO + filesystem + bash
│   └── full.ts            # DO + all capabilities (~120KB)
│
├── objects/               # DO classes
│   ├── DO.ts              # Base class (identity, storage, $)
│   ├── Worker.ts          # Execution context
│   ├── Entity.ts          # Data entity (Customer, Invoice)
│   ├── Agent.ts           # AI agent
│   ├── Human.ts           # Human actor
│   ├── Business.ts        # Business organization
│   ├── App.ts             # Application
│   ├── Site.ts            # Website/docs
│   ├── Collection.ts      # Entity collection
│   ├── Directory.ts       # Entity directory
│   └── lifecycle/         # Lifecycle modules
│       ├── Clone.ts       # DO cloning
│       ├── Branch.ts      # Git-style branching
│       ├── Compact.ts     # State compaction
│       ├── Promote.ts     # Entity -> DO promotion
│       └── Shard.ts       # Horizontal sharding
│
├── db/                    # Database layer
│   ├── stores.ts          # Store accessors
│   ├── things.ts          # Things table (entities)
│   ├── relationships.ts   # Relationships table (edges)
│   ├── actions.ts         # Actions table (audit log)
│   ├── events.ts          # Events table (domain events)
│   ├── search.ts          # Search index (FTS + vector)
│   └── compat/            # Database compatibility layers
│
├── workflows/             # $ context DSL
│   ├── proxy.ts           # Pipeline proxy
│   ├── on.ts              # Event subscription DSL
│   └── schedule-builder.ts # Cron scheduling
│
├── agents/                # Agent SDK
│   ├── Agent.ts           # Multi-provider agent
│   ├── Tool.ts            # Tool definitions
│   └── Providers/         # LLM providers
│
└── app/                   # Frontend
    └── components/        # TanStack Start + MDXUI
```

## Key Abstractions

### Three-Layer Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     WorkflowContext ($)                     │
│   $.send() │ $.try() │ $.do() │ $.on │ $.every │ $.ai      │
├─────────────────────────────────────────────────────────────┤
│                         Stores                              │
│   things │ rels │ actions │ events │ search │ objects │ dlq │
├─────────────────────────────────────────────────────────────┤
│                      SQLite (Drizzle)                       │
│                   Durable Object Storage                    │
└─────────────────────────────────────────────────────────────┘
```

1. **WorkflowContext ($)** - The primary API for workflow operations
2. **Stores** - Typed accessors for different data categories
3. **SQLite** - The persistence layer via Drizzle ORM

### Execution Flow

```
Request → Worker → Durable Object → WorkflowContext → Stores → SQLite
                                   ↓
                             Event Pipeline
                                   ↓
                              R2 Parquet
```

Every operation flows through the WorkflowContext, which handles durability, event emission, and cross-DO communication.

## Key Design Decisions

### Why SQLite?

1. **Zero network hops** - Data is co-located with compute
2. **ACID guarantees** - No distributed transaction complexity
3. **JSON support** - Flexible schema without migration overhead
4. **Built-in FTS** - Full-text search without external services
5. **Single file** - Easy backup, replication, and debugging

### Why Append-Only?

The Things store uses append-only inserts for updates:

```typescript
// Each update creates a new row with higher rowid
await this.db.insert(things).values({
  id,           // Same ID
  version: ++v, // Incrementing version
  data: newData,
})
```

Benefits:
- Full audit trail for free
- Time-travel queries via version
- No locking contention
- Branch/merge support

### Why Lazy Loading?

Stores are initialized on first access:

```typescript
get things(): ThingsStore {
  if (!this._things) {
    this._things = new ThingsStore(this.getStoreContext())
  }
  return this._things
}
```

This minimizes cold start impact - you only pay for what you use.

## Storage Hierarchy

Data flows through three tiers automatically based on access patterns:

```
                              STORAGE HIERARCHY
                              =================

    ┌─────────────────────────────────────────────────────────────────────┐
    │  HOT TIER: DO SQLite                                                 │
    │  ─────────────────                                                   │
    │  Latency: ~50ms │ Size: 10GB/shard │ Cost: Included with DO         │
    │                                                                      │
    │  Use for:                                                            │
    │  • Active working set (current entities, recent events)             │
    │  • Real-time state (sessions, carts, in-progress workflows)         │
    │  • High-frequency reads/writes                                       │
    │                                                                      │
    │  Stores: things, rels, actions, events, search                      │
    └──────────────────────────────────────┬──────────────────────────────┘
                                           │ Cloudflare Pipelines
                                           │ (streaming, automatic)
                                           ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  WARM TIER: R2 + Iceberg/Parquet                                     │
    │  ───────────────────────────────                                     │
    │  Latency: 100-150ms │ Size: Unlimited │ Cost: $0.015/GB-mo, $0 egress│
    │                                                                      │
    │  Use for:                                                            │
    │  • Cross-DO queries (find all customers with status X)              │
    │  • Historical data (last 90 days of events)                         │
    │  • Analytics that need recent data                                   │
    │                                                                      │
    │  Access via: $.query() or browser DuckDB-WASM with presigned URLs   │
    └──────────────────────────────────────┬──────────────────────────────┘
                                           │ R2 SQL / ClickHouse
                                           │ (batch, scheduled)
                                           ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  COLD TIER: ClickHouse + R2 Archive                                  │
    │  ──────────────────────────────                                      │
    │  Latency: Variable │ Size: Unlimited │ Cost: Pennies per TB          │
    │                                                                      │
    │  Use for:                                                            │
    │  • Long-term analytics (year-over-year trends)                      │
    │  • Aggregated time-series (hourly/daily rollups)                    │
    │  • Compliance archives                                               │
    │                                                                      │
    │  Access via: $.analytics() or scheduled batch jobs                  │
    └─────────────────────────────────────────────────────────────────────┘
```

### Data Flow Example

```typescript
// Hot tier: Real-time state in DO SQLite
const customer = await $.Customer('cust_abc').get()

// Warm tier: Cross-DO query via Iceberg
const recentOrders = await $.query(`
  SELECT * FROM orders
  WHERE customer_id = 'cust_abc'
  AND created_at > NOW() - INTERVAL '30 days'
`)

// Cold tier: Analytics aggregation
const yearlyMetrics = await $.analytics(`
  SELECT
    date_trunc('month', created_at) as month,
    count(*) as orders,
    sum(total) as revenue
  FROM orders
  WHERE created_at > NOW() - INTERVAL '1 year'
  GROUP BY 1
`)
```

### Automatic Archival

Events and old entity versions flow to warm/cold storage automatically via Cloudflare Pipelines:

```typescript
// Events are streamed to R2 Parquet automatically
await events.emit({
  verb: 'purchased',
  source: 'Customer/cust_abc',
  data: { amount: 99.99 }
})
// -> Immediately available in DO SQLite
// -> Streams to R2 Parquet within seconds
// -> Available for cross-DO queries via $.query()
```

## Cap'n Web RPC and Promise Pipelining

dotdo uses Cap'n Web RPC for efficient cross-DO communication. The key optimization is **promise pipelining**: passing unawaited promises as parameters to batch multiple calls into single network round trips.

### The Core Pattern

```typescript
// BAD: 3 network round trips
const spec = await priya`define the MVP`     // Round trip 1
const app = await ralph`build ${spec}`        // Round trip 2
const deployed = await tom`ship ${app}`       // Round trip 3

// GOOD: 1 network round trip
const spec = priya`define the MVP`            // RpcPromise (not awaited)
const app = ralph`build ${spec}`               // Passed as promise
const deployed = await tom`ship ${app}`        // All execute in one batch
```

### When to Await: Quick Reference

| Scenario | Await? | Example |
|----------|--------|---------|
| Pass to another RPC call | **No** | `ralph\`build ${spec}\`` |
| Branch on result | **Yes** | `if ((await x).status === 'ready')` |
| Loop over results | **Yes** | `for (const x of await items)` |
| Display/log value | **Yes** | `console.log(await result)` |
| Return to non-RPC caller | **Yes** | `return await finalResult` |
| Fire and forget | **No** | `mark\`send notification\`` |

### Decision Tree

```
Do I need the value locally?
├─ No → Don't await, pass RpcPromise
└─ Yes → Why?
    ├─ To branch (if/else) → Await
    ├─ To loop (for/while) → Await (or use Magic Map)
    ├─ To display/log → Await
    ├─ To return to non-pipeline caller → Await
    └─ To pass to another RPC call → Don't await!
```

<Callout type="info">
For detailed promise pipelining patterns, see [Await Patterns](/docs/rpc/await-patterns) and [Promise Pipelining](/docs/concepts/promise-pipelining).
</Callout>

## Further Reading

<Cards>
  <Card title="DO Class Hierarchy" href="/docs/architecture/do-hierarchy">
    Understand the three-tier bundle system and capability composition.
  </Card>
  <Card title="Bundle Optimization" href="/docs/architecture/bundle-optimization">
    Strategies for minimizing bundle size and cold start latency.
  </Card>
  <Card title="Data Model" href="/docs/architecture/data-model">
    Deep dive into Things, Actions, Events, and Relationships.
  </Card>
</Cards>

## Related

<Cards>
  <Card title="RPC Deep Dive" href="/docs/rpc/">
    Learn about Cap'n Web RPC, promise pipelining, and Magic Map for efficient cross-DO communication.
  </Card>
</Cards>
