---
title: Bundle Optimization
description: Strategies for minimizing bundle size and cold start latency
---

import { Callout } from 'fumadocs-ui/components/callout'

# Bundle Optimization

Cloudflare Workers have strict constraints that make bundle size critical. This guide covers dotdo's bundle optimization strategies and how to minimize cold start latency.

## Why Bundle Size Matters

### Cold Start Latency

Larger bundles take longer to parse and initialize. For high-volume workers handling thousands of requests per second, even 10ms of additional cold start time compounds significantly.

| Bundle | Parse Time | Total Cold Start |
|--------|------------|------------------|
| 15KB | ~2ms | ~5ms |
| 80KB | ~8ms | ~15ms |
| 120KB | ~15ms | ~25ms |
| 350KB | ~40ms | ~60ms |

### Memory Limits

Workers have a 128MB memory limit per isolate. Larger bundles consume more baseline memory, leaving less for your application's runtime data.

### Script Size Limits

Workers have a 10MB compressed script limit. While dotdo itself won't hit this, large bundles combined with your application code and dependencies can approach it.

## Optimization Strategies

### 1. Lazy Loading

Heavy operations are lazy-loaded to minimize cold start impact:

```typescript
// Stores are initialized on first access
get things(): ThingsStore {
  if (!this._things) {
    this._things = new ThingsStore(this.getStoreContext())
  }
  return this._things
}

// Schedule manager loaded when scheduling is used
protected get scheduleManager(): ScheduleManager {
  if (!this._scheduleManager) {
    this._scheduleManager = new ScheduleManager(this.ctx)
  }
  return this._scheduleManager
}
```

<Callout type="info">
Lazy loading means you only pay the initialization cost for capabilities you actually use during a request. A health check endpoint won't load the ThingsStore.
</Callout>

### 2. Mixin-Based Composition

Capabilities are added via mixins, not inheritance:

```typescript
// Each mixin adds specific capabilities
export const DO = withBash(withGit(withFs(BaseDO)))

// Users can compose exactly what they need
class MinimalDO extends BaseDO { }           // ~15KB
class FsDO extends withFs(BaseDO) { }        // ~40KB
class FullDO extends withBash(withGit(withFs(BaseDO))) { } // ~120KB
```

This ensures you don't pay for capabilities you don't use.

### 3. Tree-Shakeable Exports

Entry points are structured for tree-shaking:

```typescript
// do/tiny.ts - Minimal exports
export { DO } from '../objects/DO'
export const capabilities: string[] = []

// do/full.ts - All capabilities
export const DO = withBash(withGit(withFs(BaseDO)))
export const capabilities = ['fs', 'git', 'bash']
export { withFs, withGit, withBash }
```

When you import from `dotdo/tiny`, bundlers can tree-shake everything not in that entry point.

### 4. RPC Workers for Heavy Operations

Offload heavy operations to separate Workers:

```typescript
// Lifecycle operations can be RPC'd to dedicated workers
const shardResult = await this.env.LIFECYCLE_WORKER.shard(this.ns, options)

// AI inference goes through API gateway
const response = await this.env.AI_GATEWAY.complete(prompt)
```

This keeps your hot-path worker small while enabling full capabilities when needed.

## Best Practices

### Use Tiny for High-Volume Workers

If you're building rate limiters, counters, or coordination primitives that handle thousands of requests per second, the cold start savings compound:

```typescript
// Good: Minimal bundle for hot path
import { DO } from 'dotdo/tiny'

class RateLimiterDO extends DO {
  async check(key: string, limit: number, window: number) {
    // Simple SQLite-based rate limiting
    const now = Date.now()
    const windowStart = now - window

    // Count requests in window
    const result = await this.db.all(
      sql`SELECT COUNT(*) as count FROM requests
          WHERE key = ${key} AND timestamp > ${windowStart}`
    )

    return (result[0].count as number) < limit
  }
}
```

### Dynamic Imports for Rare Operations

For operations that run infrequently, use dynamic imports:

```typescript
import { DO } from 'dotdo'

class UserDO extends DO {
  async exportData() {
    // Only load sharding when needed
    const { ShardManager } = await import('dotdo/full')
    const manager = new ShardManager(this)
    await manager.export()
  }
}
```

<Callout type="warn">
Dynamic imports add latency to the operation itself. Only use for operations where cold start is more important than operation latency.
</Callout>

### Separate Workers by Bundle Size

Split high-volume and heavy operations into separate workers:

```typescript
// worker-hot.ts - High volume, tiny bundle
import { DO } from 'dotdo/tiny'
export class CounterDO extends DO { }
export class RateLimiterDO extends DO { }

// worker-heavy.ts - Low volume, full bundle
import { DO } from 'dotdo/full'
export class AnalyticsDO extends DO { }
export class ShardedUserDO extends DO { }
```

Configure separate wrangler configurations:

```toml
# wrangler-hot.toml
name = "dotdo-hot"
main = "src/worker-hot.ts"

# wrangler-heavy.toml
name = "dotdo-heavy"
main = "src/worker-heavy.ts"
```

### Tree-Shake Unused Stores

If you only need specific stores, import them directly:

```typescript
import { DO } from 'dotdo/tiny'
import { ThingsStore, EventsStore } from 'dotdo/stores'

class MinimalDO extends DO {
  private _things?: ThingsStore
  private _events?: EventsStore

  get things() {
    if (!this._things) {
      this._things = new ThingsStore(this.getStoreContext())
    }
    return this._things
  }

  get events() {
    if (!this._events) {
      this._events = new EventsStore(this.getStoreContext())
    }
    return this._events
  }

  // Only ~20KB instead of ~80KB
}
```

## Monitoring Bundle Size

### Wrangler Size Reporting

Use Wrangler's dry-run to check bundle size:

```bash
# Check bundle size
npx wrangler deploy --dry-run --outdir dist

# Output shows compressed size
Total Upload: 45.23 KiB / gzip: 12.45 KiB
```

### Bundle Analysis

Analyze what's included in your bundle:

```bash
# Install visualizer
npm install -D esbuild-visualizer

# Build with metafile
npx esbuild src/worker.ts --bundle --outfile=dist/worker.js --metafile=meta.json

# Generate visualization
npx esbuild-visualizer --metadata meta.json --open
```

### Track Size Over Time

Add bundle size checks to CI:

```yaml
# .github/workflows/bundle-check.yml
- name: Check bundle size
  run: |
    npx wrangler deploy --dry-run --outdir dist
    SIZE=$(stat -f%z dist/worker.js 2>/dev/null || stat -c%s dist/worker.js)
    if [ $SIZE -gt 150000 ]; then
      echo "Bundle too large: ${SIZE} bytes"
      exit 1
    fi
```

## Size Breakdown by Feature

Understanding what contributes to bundle size helps make informed decisions:

| Feature | Size | Notes |
|---------|------|-------|
| Base DO class | ~5KB | Identity, fetch handler |
| Drizzle ORM | ~8KB | SQLite queries |
| WorkflowContext | ~15KB | $ proxy, durability |
| Event handlers | ~8KB | $.on subscription DSL |
| Scheduling | ~6KB | $.every cron DSL |
| ThingsStore | ~10KB | CRUD operations |
| RelationshipsStore | ~5KB | Graph edges |
| ActionsStore | ~5KB | Audit log |
| EventsStore | ~5KB | Event streaming |
| SearchStore | ~8KB | FTS + vector |
| Filesystem (fsx) | ~5KB | File operations |
| Git (gitx) | ~8KB | Version control |
| Bash (bashx) | ~3KB | Shell execution |
| Lifecycle ops | ~20KB | Clone, branch, shard |

## Migration Guide

### From Monolithic to Tiered

If you're currently using the full bundle and want to optimize:

1. **Audit your usage**: Which methods do you actually call?

```bash
# Find DO method usage
grep -r "this\.\$\." src/ --include="*.ts"
grep -r "this\.things\." src/ --include="*.ts"
grep -r "this\.git\." src/ --include="*.ts"
```

2. **Start with tiny**: Can your DO work with just SQLite?

```typescript
// Before: 350KB
import { DO } from 'dotdo'

// After: 15KB + mixins
import { DO } from 'dotdo/tiny'
import { withStores } from 'dotdo/mixins'

class MyDO extends withStores(DO) {
  // Same functionality, smaller bundle
}
```

3. **Add mixins as needed**: Incrementally add capabilities

4. **Test cold starts**: Measure the improvement

```typescript
// Add timing to your worker
export default {
  async fetch(request, env) {
    const start = Date.now()
    // ... handle request
    const coldStart = Date.now() - start
    console.log(`Cold start: ${coldStart}ms`)
  }
}
```

## Summary

| Strategy | Impact | Effort |
|----------|--------|--------|
| Use `dotdo/tiny` | -65KB | Low |
| Lazy load stores | -10-20KB | Low |
| Dynamic imports | Variable | Medium |
| Separate workers | -50%+ | High |
| Tree-shake stores | -20-40KB | Medium |

Start with the smallest bundle that meets your requirements. Profile cold starts in production. Add capabilities only when you need them.
