---
title: DO Class Hierarchy
description: Understanding the three-tier bundle system and mixin-based composition
---

import { Callout } from 'fumadocs-ui/components/callout'

# DO Class Hierarchy

dotdo provides three entry points with different bundle sizes, optimized for different use cases. The architecture uses mixin-based composition to allow fine-grained capability selection.

## The Three Tiers

```
DOTiny (~15KB)
│   Identity (ns)
│   SQLite (Drizzle)
│   fetch() handler

DO (~80KB)
│   + WorkflowContext ($)
│   + Stores (things, rels, actions, events, search)
│   + Event handlers ($.on.Noun.verb)
│   + Scheduling ($.every)

DOFull (~120KB)
    + Filesystem ($.fs)
    + Git ($.git)
    + Bash ($.bash)
    + Lifecycle (clone, branch, compact, promote, shard)
```

## Entry Points

### DOTiny - Minimal (~15KB)

```typescript
import { DO } from 'dotdo/tiny'
```

The smallest possible Durable Object with just the essentials:

| Capability | Description |
|------------|-------------|
| `ns` | Namespace identifier (URL-based identity) |
| `db` | Drizzle ORM instance for SQLite access |
| `fetch()` | HTTP request handler |
| `initialize()` | Lifecycle hook for setup |
| `/health` | Built-in health check endpoint |

<Callout type="info">
Use `dotdo/tiny` for high-volume workers that need persistent state but not the full framework: rate limiters, counters, coordination primitives.
</Callout>

```typescript
import { DO } from 'dotdo/tiny'
import { eq, sql } from 'drizzle-orm'
import { counters } from './schema'

class CounterDO extends DO {
  async increment() {
    const [result] = await this.db
      .insert(counters)
      .values({ id: this.ns, count: 1 })
      .onConflictDoUpdate({
        target: counters.id,
        set: { count: sql`${counters.count} + 1` }
      })
      .returning()

    return result.count
  }
}
```

### DO - Standard (~80KB)

```typescript
import { DO } from 'dotdo'
```

The standard bundle with workflow orchestration and event-driven patterns:

| Capability | Description |
|------------|-------------|
| Everything in `tiny` | Identity, SQLite, fetch() |
| `$` | WorkflowContext proxy |
| `$.send/try/do` | Three durability levels |
| `$.on.Noun.verb` | Event subscription DSL |
| `$.every.*` | Human-readable scheduling |
| `things` | Entity store |
| `rels` | Relationship store |
| `actions` | Action audit log |
| `events` | Event stream |
| `search` | Full-text and vector search |
| `objects` | DO registry |
| `dlq` | Dead letter queue |

<Callout type="info">
Use `dotdo` for most applications: user profiles, business logic, event-driven workflows.
</Callout>

```typescript
import { DO } from 'dotdo'

class UserDO extends DO {
  async setup() {
    // React to events
    this.$.on.User.created(async (event) => {
      await this.$.try(() => this.sendWelcomeEmail(event.data))
      await this.things.put('profile', event.data)
    })

    // Schedule recurring tasks
    this.$.every.day.at9am(async () => {
      await this.sendDailyDigest()
    })
  }
}
```

### DOFull - Complete (~120KB)

```typescript
import { DO } from 'dotdo/full'
```

The complete bundle with advanced lifecycle management:

| Capability | Description |
|------------|-------------|
| Everything in standard | Stores, events, scheduling |
| `$.fs` | Filesystem operations (fsx) |
| `$.git` | Git operations (gitx) |
| `$.bash` | Shell execution (bashx) |
| `fork()` | Create independent copy |
| `clone()` | Create linked copy |
| `compact()` | Compress historical data |
| `branch()` | Git-style branching |
| `checkout()` | Switch branches |
| `merge()` | Merge branches |
| `shard()` | Horizontal sharding |
| `unshard()` | Merge shards back |
| `promote()` | Elevate to higher tier |
| `demote()` | Move to lower tier |

<Callout type="info">
Use `dotdo/full` for multi-tenant platforms, data-heavy applications, or systems requiring horizontal scaling and git-like version control.
</Callout>

```typescript
import { DO } from 'dotdo/full'

class ShardedDO extends DO {
  async scale() {
    const stats = await this.getStats()

    if (stats.rowCount > 1_000_000) {
      await this.shard({
        strategy: 'consistent-hash',
        count: 4,
        key: 'user_id'
      })
    }
  }

  async backup() {
    return await this.clone({
      name: `backup-${Date.now()}`,
      readonly: true
    })
  }

  async experimentalFeature() {
    await this.branch('experiment-v2')
    await this.applyExperimentalChanges()
    await this.checkout('main')
    await this.merge('experiment-v2')
  }
}
```

## Mixin-Based Composition

For fine-grained control, compose your own bundle using mixins:

```typescript
import { DO } from 'dotdo/tiny'
import { withFs, withGit, withSchedule } from 'dotdo/mixins'

// Custom: tiny + filesystem + git (~25KB)
class GitDO extends withGit(withFs(DO)) {
  async saveFile(path: string, content: string) {
    await this.fs.write(path, content)
    await this.git.add(path)
    await this.git.commit(`Update ${path}`)
  }
}

// Custom: tiny + scheduling (~20KB)
class ScheduledDO extends withSchedule(DO) {
  async setup() {
    this.$.every.hour(async () => {
      await this.cleanup()
    })
  }
}
```

### Available Mixins

| Mixin | Size | Provides |
|-------|------|----------|
| `withFs` | ~5KB | `this.fs` - filesystem operations |
| `withGit` | ~8KB | `this.git` - version control |
| `withBash` | ~3KB | `this.bash` - shell execution |
| `withSchedule` | ~6KB | `$.every.*` scheduling |
| `withStores` | ~15KB | All 7 stores |
| `withLifecycle` | ~20KB | fork, clone, compact, move |
| `withSharding` | ~15KB | shard, unshard, routing |
| `withBranching` | ~10KB | branch, checkout, merge |

### Mixin Order Matters

Some mixins depend on others. The `full` export composes them in the correct order:

```typescript
// This is what dotdo/full exports
export const DO = withBash(withGit(withFs(BaseDO)))
```

If composing manually, follow the dependency chain:
- `withGit` requires `withFs`
- `withBash` requires `withFs`
- `withSharding` requires `withStores`

## Bundle Selection Guide

Use this decision tree to select the appropriate bundle:

```
Do you need event handlers ($.on.Noun.verb)?
├─ No → Do you need stores beyond raw SQLite?
│       ├─ No → dotdo/tiny
│       └─ Yes → dotdo
└─ Yes → Do you need clone/shard/lifecycle ops?
         ├─ No → dotdo
         └─ Yes → dotdo/full
```

### Quick Reference

| Requirement | Bundle |
|-------------|--------|
| Just SQLite storage | `dotdo/tiny` |
| Rate limiting / counters | `dotdo/tiny` |
| Event handlers | `dotdo` |
| Scheduling ($.every) | `dotdo` |
| Entity stores | `dotdo` |
| Sharding / horizontal scale | `dotdo/full` |
| Cloning / forking | `dotdo/full` |
| Git-like branching | `dotdo/full` |

## Class Inheritance Diagram

```
DurableObject (Cloudflare)
       │
       ▼
    DOTiny
       │
       ├── Identity (ns, $type)
       ├── SQLite (this.db)
       └── fetch() handler
       │
       ▼
      DO
       │
       ├── WorkflowContext ($)
       ├── Stores (7 total)
       ├── Event handlers ($.on)
       └── Scheduling ($.every)
       │
       ▼
    DOFull
       │
       ├── Extended primitives (fs, git, bash)
       └── Lifecycle ops (clone, branch, shard)
```

## Runtime Capability Detection

Check for capabilities at runtime using type guards:

```typescript
import { hasFs, hasGit, hasBash, hasRateLimit } from '@dotdo/types'

if (hasFs($)) {
  // $ is typed as WithFs
  await $.fs.readFile('/data.json')
}

if (hasGit($)) {
  // $ is typed as WithGit
  await $.git.status()
}
```

This enables writing generic code that adapts to available capabilities.

## Summary

| Bundle | Size | Cold Start | Memory | Use When |
|--------|------|------------|--------|----------|
| `dotdo/tiny` | ~15KB | ~5ms | ~2MB | High volume, simple state |
| `dotdo` | ~80KB | ~15ms | ~8MB | Standard applications |
| `dotdo/full` | ~120KB | ~25ms | ~12MB | Complex lifecycle needs |

Choose the smallest bundle that meets your requirements. When in doubt, start with `tiny` and add mixins as needed - it is easier to add capabilities than to remove unused code.
