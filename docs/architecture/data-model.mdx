---
title: Data Model
description: Deep dive into Things, Actions, Events, and Relationships - the four core abstractions of dotdo
---

import { Callout, Tab, Tabs } from 'fumadocs-ui/components/callout'

# Data Model

dotdo uses four core abstractions to model business data: **Things**, **Actions**, **Events**, and **Relationships**. This document provides a complete technical reference for each abstraction, including design philosophy, best practices, and implementation details.

## Overview

```
┌─────────────────────────────────────────────────────────────┐
│                         Things                              │
│              URL-identified entities with state             │
│              (Nouns - the "what" of your domain)            │
├─────────────────────────────────────────────────────────────┤
│                      Relationships                          │
│              Typed edges between Things                     │
│              (Graph connections with verbs)                 │
├─────────────────────────────────────────────────────────────┤
│                        Actions                              │
│              Command log of all operations                  │
│              (Verbs - the "how" with full audit trail)      │
├─────────────────────────────────────────────────────────────┤
│                         Events                              │
│              Domain events for pub/sub                      │
│              (5W+H model for observability)                 │
└─────────────────────────────────────────────────────────────┘
```

## Design Philosophy

### Why URL-Based Identity?

dotdo uses fully-qualified URLs for all entity identifiers. This choice solves several fundamental problems:

| Problem | URL Solution |
|---------|--------------|
| **Namespace collisions** | URLs include the host, making IDs globally unique |
| **Federation** | Reference entities across organizations without coordination |
| **External integrations** | Stripe payments, GitHub repos, and domain entities share the same format |
| **Human readability** | `https://acme.co/Customer/cus_123` is self-documenting |
| **Routing** | The URL tells you exactly which DO owns the entity |

```typescript
// All of these are valid Thing $ids:
'https://acme.co/Customer/cus_123'        // Local entity
'https://stripe.com/Payment/pay_456'       // External reference
'https://github.com/drivly/dotdo'          // Third-party resource
'https://acme.co/Customer'                 // A Noun (type) is also a Thing
```

<Callout type="info">
**The namespace IS the Durable Object.** When you parse `https://acme.co/Customer/cus_123`, the namespace `https://acme.co` identifies the DO that owns this entity. Cross-DO references just work.
</Callout>

### Namespace Derivation Rules

The namespace (ns) is derived from the URL and determines DO routing:

```typescript
import { parseThingId } from 'dotdo/types'

// Standard case: protocol + host
parseThingId('https://acme.co/Customer/cus_123')
// → { ns: 'https://acme.co', path: 'Customer/cus_123' }

// Subdomains create separate namespaces
parseThingId('https://staging.acme.co/Customer/cus_123')
// → { ns: 'https://staging.acme.co', path: 'Customer/cus_123' }

// A Thing with no path IS the DO itself
parseThingId('https://acme.co')
// → { ns: 'https://acme.co', path: '' }  // isDO = true
```

**Key rules:**
1. `ns = protocol + host` (no port, no path)
2. Each unique namespace maps to one Durable Object
3. Things without a path (`path === ''`) are "promoted" DOs themselves
4. Subdomains create separate DOs (useful for staging/prod isolation)

## Things

Every entity in dotdo is a **Thing** with URL-based identity:

```typescript
interface Thing {
  $id: string        // URL: 'https://acme.co/customers/cus_123'
  $type: string      // URL: 'https://acme.co/Customer'
  name?: string      // Display name
  data?: Record<string, unknown>   // Custom data fields
  meta?: Record<string, unknown>   // Metadata
  branch?: string    // Git-style branch name
  version?: number   // Monotonic version number
  deleted?: boolean  // Soft-delete flag
  createdAt: Date
  updatedAt: Date
}
```

### URL-Based Identity

The `$id` is a fully qualified URL, making entities globally unique and unambiguous:

```typescript
// Local entity within a DO
'https://acme.co/customers/cus_123'

// Cross-organization reference
'https://stripe.com/payments/pay_456'

// The namespace (ns) is derived from the URL host
const ns = new URL(thing.$id).host // 'acme.co'
```

<Callout type="info">
URL identity enables federation. A Thing can reference entities from other organizations, other dotdo instances, or external systems.
</Callout>

### Type Identity

The `$type` points to a Noun definition that describes the entity's schema and behavior:

```typescript
// Type URL points to a Noun
thing.$type = 'https://acme.co/Customer'

// The Noun defines the schema
const CustomerNoun = {
  name: 'Customer',
  plural: 'Customers',
  schema: {
    email: 'string',
    plan: ['free', 'pro', 'enterprise'],
    subscribed: 'boolean'
  }
}
```

### Append-Only Versioning

Things use append-only inserts for updates, creating an immutable audit trail:

```typescript
// Version 1: Initial creation
{ $id: 'cus_123', version: 1, data: { email: 'alice@example.com' } }

// Version 2: Plan upgraded
{ $id: 'cus_123', version: 2, data: { email: 'alice@example.com', plan: 'pro' } }

// Version 3: Email changed
{ $id: 'cus_123', version: 3, data: { email: 'alice@newdomain.com', plan: 'pro' } }
```

Query any historical version:

```typescript
// Get current version
const current = await things.get('cus_123')

// Get specific version
const v1 = await things.get('cus_123', { version: 1 })

// Get all versions
const history = await things.versions('cus_123')
```

### Visibility Levels

Things have four visibility levels that control access:

```typescript
type Visibility = 'public' | 'unlisted' | 'org' | 'user'
```

| Level | Description | Use Case |
|-------|-------------|----------|
| `public` | Visible to everyone, including anonymous users | Public APIs, landing pages |
| `unlisted` | Not discoverable, but accessible with direct link | Shareable links, invite-only |
| `org` | Visible only to organization members | Internal tools, team resources |
| `user` | Visible only to the owner (default) | Personal data, drafts |

```typescript
// Authorization check
import { canView } from 'dotdo/types'

const thing = await things.get('cus_123')
const actor = { userId: 'user_456', orgId: 'org_acme' }

if (canView(thing, actor)) {
  // User can access this thing
}
```

<Callout type="warn">
**Default is `user` (most restrictive).** Always explicitly set visibility when creating public-facing entities.
</Callout>

### ThingsStore API

```typescript
// Create
const thing = await things.create({
  $type: 'Customer',
  name: 'Alice',
  data: { email: 'alice@example.com' },
  visibility: 'org'  // Explicitly set visibility
})

// Read
const thing = await things.get('cus_123')
const customers = await things.list({ type: 'Customer', limit: 100 })

// Read with visibility filter
const publicApis = await things.list({
  type: 'API',
  visibility: 'public'
})

// Update (creates new version)
await things.update('cus_123', { data: { plan: 'pro' } })

// Delete (soft by default)
await things.delete('cus_123')

// Hard delete (removes all versions)
await things.delete('cus_123', { hard: true })
```

### Schema Design Best Practices

<Callout type="info">
**Rule of thumb:** Use `data` for domain fields, `meta` for system fields.
</Callout>

```typescript
// Good: Clean separation
{
  $id: 'https://acme.co/Customer/cus_123',
  $type: 'https://acme.co/Customer',
  name: 'Alice',
  data: {
    email: 'alice@example.com',
    plan: 'pro',
    company: 'Acme Inc'
  },
  meta: {
    ownerId: 'user_456',
    orgId: 'org_acme',
    source: 'signup_form'
  }
}

// Bad: Mixing concerns
{
  name: 'Alice',
  data: {
    email: 'alice@example.com',
    ownerId: 'user_456'  // Should be in meta
  }
}
```

**When to embed vs. relate:**

| Use Embedded Data | Use Relationships |
|-------------------|-------------------|
| Data always needed together | Referenced from multiple places |
| Simple values (strings, numbers) | Full entities with their own lifecycle |
| Rarely changes | Frequently changes |
| No independent identity | Has its own $id |

```typescript
// Embed: Address is always needed with Customer
data: {
  address: {
    street: '123 Main St',
    city: 'San Francisco'
  }
}

// Relate: Orders are independent entities
await rels.create({
  verb: 'placed',
  from: 'Customer/cus_123',
  to: 'Order/ord_456'
})
```

## Relationships

Relationships connect Things with typed verbs:

```typescript
interface Relationship {
  id: string
  verb: string       // 'manages', 'employs', 'owns', 'subscribes'
  from: string       // Thing $id (source)
  to: string         // Thing $id (target)
  data?: Record<string, unknown>  // Edge metadata
  createdAt: Date
}
```

### Typed Edges

Each relationship has a verb that describes the connection:

```typescript
// Organization employs Person
{ verb: 'employs', from: 'org_acme', to: 'person_alice' }

// Person manages Project
{ verb: 'manages', from: 'person_alice', to: 'project_x' }

// Customer subscribes Plan
{ verb: 'subscribes', from: 'cus_123', to: 'plan_pro' }
```

### Verb Conventions

Relationship verbs follow consistent patterns for predictability:

**Standard Verbs (built-in):**

| Category | Verbs |
|----------|-------|
| Ownership | `owns`, `belongsTo`, `contains` |
| Hierarchy | `manages`, `reportsTo`, `parentOf`, `childOf` |
| Association | `relatedTo`, `linkedTo`, `references` |
| Membership | `memberOf`, `employs`, `enrolledIn` |
| Creation | `createdBy`, `authoredBy`, `madeBy` |

**Verb Naming Rules:**

1. **Use camelCase**: `managedBy`, not `managed_by`
2. **Use present tense**: `manages`, not `managed`
3. **Direction matters**: `from` is the subject, `to` is the object
4. **Inverse verbs**: Consider the reverse direction

```typescript
// Forward: Person manages Project
{ verb: 'manages', from: 'person_alice', to: 'project_x' }

// Inverse (implicit): Project managedBy Person
// Query with: rels.to('project_x', { verb: 'manages' })

// For bidirectional, store both explicitly:
{ verb: 'manages', from: 'person_alice', to: 'project_x' }
{ verb: 'managedBy', from: 'project_x', to: 'person_alice' }
```

<Callout type="info">
**Reserved prefix:** Verbs starting with `$` are reserved for system use (e.g., `$parent`, `$branch`).
</Callout>

### Relationship Operators

When defining Noun schemas, use operators to declare relationships:

| Operator | Direction | Match | Description |
|----------|-----------|-------|-------------|
| `->` | Forward | Exact | Direct reference to another Thing |
| `<-` | Backward | Exact | Inverse reference (from another Thing) |
| `~>` | Forward | Fuzzy | AI-assisted matching |
| `<~` | Backward | Fuzzy | AI-assisted inverse matching |

```typescript
// In Noun schema definition
const CustomerSchema = {
  name: 'Customer',
  schema: {
    primaryContact: '->Person',        // Exact forward reference
    orders: '[->Order]',               // Array of forward references
    assignedRep: '~>SalesRep',         // Fuzzy-matched forward
    recommendations: '[<~Product]'     // Array of inverse fuzzy matches
  }
}
```

### Edge Metadata

Relationships can carry their own data:

```typescript
await rels.create({
  verb: 'employs',
  from: 'org_acme',
  to: 'person_alice',
  data: {
    role: 'Engineering Manager',
    startDate: '2024-01-15',
    department: 'Platform'
  }
})
```

### RelationshipsStore API

```typescript
// Create
const rel = await rels.create({
  verb: 'manages',
  from: 'person_alice',
  to: 'project_x'
})

// Query outbound edges
const managed = await rels.from('person_alice')
// [{ verb: 'manages', to: 'project_x' }, ...]

// Query inbound edges
const managers = await rels.to('project_x')
// [{ verb: 'manages', from: 'person_alice' }, ...]

// Filter by verb
const employees = await rels.from('org_acme', { verb: 'employs' })

// Delete relationship
await rels.delete(rel.id)

// Delete by criteria
await rels.deleteWhere({ from: 'person_alice', verb: 'manages' })
```

### Graph Queries

Relationships form a graph that can be traversed:

```typescript
// Get all things managed by Alice
const aliceManages = await rels.from('person_alice', { verb: 'manages' })
const projects = await Promise.all(
  aliceManages.map(r => things.get(r.to))
)

// Get all managers of a project
const projectManagers = await rels.to('project_x', { verb: 'manages' })
const managers = await Promise.all(
  projectManagers.map(r => things.get(r.from))
)
```

## Actions

Every operation is logged in an append-only audit trail:

```typescript
interface Action {
  id: string
  verb: string            // 'create', 'update', 'approve', 'deploy'
  target: string          // Thing $id or namespace
  actor: string           // 'Human/nathan', 'Agent/claude'
  input?: Record<string, unknown>   // Operation input
  output?: unknown        // Operation result
  durability: 'send' | 'try' | 'do'
  status: ActionStatus
  error?: Record<string, unknown>   // Error details if failed
  requestId?: string      // HTTP request correlation
  sessionId?: string      // User session correlation
  workflowId?: string     // Workflow correlation
  createdAt: Date
  startedAt?: Date
  completedAt?: Date
  duration?: number       // Milliseconds
  retryCount?: number
}

type ActionStatus = 'pending' | 'running' | 'retrying' | 'completed' | 'failed' | 'undone'
```

### Three Durability Levels

Actions track their durability level, which determines retry behavior:

| Durability | Behavior | Use Case |
|------------|----------|----------|
| `send` | Fire-and-forget, no retries | Analytics, notifications |
| `try` | Single attempt, fail fast | Validations, cache lookups |
| `do` | Durable with retries | Payments, order processing |

```typescript
// $.send creates action with durability: 'send'
$.send('notify', { userId, message })

// $.try creates action with durability: 'try'
await $.try('validate', data)

// $.do creates action with durability: 'do'
await $.do('processPayment', order)
```

### Action Lifecycle

```
                  ┌──────────────────────────────────────┐
                  ▼                                      │
pending ──► running ──► completed                       │
              │                                          │
              ▼                                          │
           retrying ◄────────────────────────────────────┘
              │
              ▼
           failed
```

### ActionsStore API

```typescript
// Log a new action
const action = await actions.log({
  verb: 'approve',
  target: 'order_123',
  actor: 'Human/nathan',
  input: { approved: true }
})

// Mark as completed
await actions.complete(action.id, { approvedAt: new Date() })

// Mark as failed
await actions.fail(action.id, new Error('Insufficient funds'))

// Retry a failed action
await actions.retry(action.id)

// Query actions
const pending = await actions.pending()
const failed = await actions.failed()
const forOrder = await actions.list({ target: 'order_123' })
const byNathan = await actions.list({ actor: 'Human/nathan' })
```

### Correlation IDs

Actions support multiple correlation IDs for tracing:

```typescript
await actions.log({
  verb: 'submit',
  target: 'order_123',
  requestId: 'req_abc',    // HTTP request ID
  sessionId: 'sess_xyz',   // User session ID
  workflowId: 'wf_456'     // Workflow instance ID
})

// Query by correlation
const requestActions = await actions.list({ requestId: 'req_abc' })
```

## Events

Domain events flow through the event system for pub/sub patterns:

```typescript
interface Event {
  id: string
  verb: string           // 'signup', 'paid', 'shipped'
  source: string         // Thing $id that emitted the event
  data: Record<string, unknown>   // Event payload
  actionId?: string      // Related action ID
  sequence: number       // Monotonic sequence number
  streamed: boolean      // Has been sent to pipeline
  streamedAt?: Date
  createdAt: Date
}
```

### Event Emission

Events are emitted when things happen:

```typescript
// Emit an event
await events.emit({
  verb: 'signup',
  source: 'Customer/cus_123',
  data: { email: 'alice@example.com', plan: 'free' }
})

// Events linked to actions
const action = await actions.log({ verb: 'upgrade', target: 'cus_123' })
await events.emit({
  verb: 'upgraded',
  source: 'Customer/cus_123',
  data: { from: 'free', to: 'pro' },
  actionId: action.id
})
```

### Event Subscription

Subscribe to events using the `$.on` DSL:

```typescript
// Subscribe to specific Noun.verb
$.on.Customer.signup(async (event) => {
  await sendWelcomeEmail(event.data.email)
})

$.on.Invoice.paid(async (event) => {
  await recordRevenue(event.data.amount)
})

// Wildcards
$.on['*'].created(async (event) => {
  await logCreation(event.source, event.data)
})

$.on.Customer['*'](async (event) => {
  await trackCustomerActivity(event.verb, event.data)
})
```

### Event Pipeline

Events flow through a pipeline to external storage:

```
DO Internal → Events Table → Cloudflare Pipeline → R2 Parquet
                                    ↓
                               /api/search
```

```typescript
// Stream pending events to pipeline
const count = await events.streamPending()

// Replay events from a sequence
const history = await events.replay({ fromSequence: 100, limit: 50 })
```

### EventsStore API

```typescript
// Emit event
const event = await events.emit({
  verb: 'shipped',
  source: 'Order/ord_123',
  data: { trackingNumber: 'TRK456' }
})

// Get event by ID
const event = await events.get('evt_789')

// List events
const all = await events.list()
const shipped = await events.list({ verb: 'shipped' })
const orderEvents = await events.list({ source: 'Order/ord_123' })

// Replay from sequence
const fromSeq100 = await events.replay({ fromSequence: 100 })

// Stream to external pipeline
await events.stream(event.id)
const streamed = await events.streamPending()
```

## Store Relationships

The stores work together to provide a complete data model:

```
Things ◄──────────────────────────► Relationships
   │                                      │
   │  thing.relate(verb, to)             │
   │  thing.unrelate(verb, to)           │
   │                                      │
   ▼                                      ▼
Actions ◄──────────────────────────► Events
   │                                      │
   │  actions.complete() → events.emit() │
   │  actions.fail() → events.emit()     │
   │                                      │
   └──────────────────────────────────────┘
```

### Typical Flow

1. **Thing created** - Inserted into Things table
2. **Action logged** - Create action recorded
3. **Event emitted** - `Customer.created` event published
4. **Handlers invoked** - Subscribed handlers process event
5. **Relationships updated** - Edges created/updated as needed

```typescript
// This happens automatically when using the $ context
await $.do('createCustomer', { email: 'alice@example.com' })
// Creates Thing, logs Action, emits Event, triggers handlers
```

## Schema Summary

### Things Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | URL-based identity |
| type | INTEGER | Foreign key to nouns.rowid |
| name | TEXT | Display name |
| data | JSON | Custom fields |
| branch | TEXT | Git-style branch |
| deleted | BOOLEAN | Soft-delete flag |

### Relationships Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Relationship type |
| from | TEXT | Source Thing $id |
| to | TEXT | Target Thing $id |
| data | JSON | Edge metadata |
| createdAt | DATETIME | Creation time |

### Actions Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Operation type |
| target | TEXT | Thing $id or namespace |
| actor | TEXT | Who performed it |
| input | JSON | Operation input |
| output | JSON | Operation result |
| durability | TEXT | send/try/do |
| status | TEXT | pending/running/completed/failed |
| error | JSON | Error details |
| createdAt | DATETIME | When logged |
| completedAt | DATETIME | When finished |

### Events Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Event type |
| source | TEXT | Emitting Thing $id |
| data | JSON | Event payload |
| actionId | TEXT | Related action |
| sequence | INTEGER | Monotonic order |
| streamed | BOOLEAN | Sent to pipeline |
| createdAt | DATETIME | Emission time |
