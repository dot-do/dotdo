---
title: Data Model
description: Deep dive into Things, Actions, Events, and Relationships
---

import { Callout } from 'fumadocs-ui/components/callout'

# Data Model

dotdo uses four core abstractions to model business data: **Things**, **Actions**, **Events**, and **Relationships**. This document provides a technical deep dive into each.

## Overview

```
┌─────────────────────────────────────────────────────────────┐
│                         Things                              │
│              URL-identified entities with state             │
├─────────────────────────────────────────────────────────────┤
│                      Relationships                          │
│              Typed edges between Things                     │
├─────────────────────────────────────────────────────────────┤
│                        Actions                              │
│              Audit log of all operations                    │
├─────────────────────────────────────────────────────────────┤
│                         Events                              │
│              Domain events for subscriptions                │
└─────────────────────────────────────────────────────────────┘
```

## Things

Every entity in dotdo is a **Thing** with URL-based identity:

```typescript
interface Thing {
  $id: string        // URL: 'https://acme.co/customers/cus_123'
  $type: string      // URL: 'https://acme.co/Customer'
  name?: string      // Display name
  data?: Record<string, unknown>   // Custom data fields
  meta?: Record<string, unknown>   // Metadata
  branch?: string    // Git-style branch name
  version?: number   // Monotonic version number
  deleted?: boolean  // Soft-delete flag
  createdAt: Date
  updatedAt: Date
}
```

### URL-Based Identity

The `$id` is a fully qualified URL, making entities globally unique and unambiguous:

```typescript
// Local entity within a DO
'https://acme.co/customers/cus_123'

// Cross-organization reference
'https://stripe.com/payments/pay_456'

// The namespace (ns) is derived from the URL host
const ns = new URL(thing.$id).host // 'acme.co'
```

<Callout type="info">
URL identity enables federation. A Thing can reference entities from other organizations, other dotdo instances, or external systems.
</Callout>

### Type Identity

The `$type` points to a Noun definition that describes the entity's schema and behavior:

```typescript
// Type URL points to a Noun
thing.$type = 'https://acme.co/Customer'

// The Noun defines the schema
const CustomerNoun = {
  name: 'Customer',
  plural: 'Customers',
  schema: {
    email: 'string',
    plan: ['free', 'pro', 'enterprise'],
    subscribed: 'boolean'
  }
}
```

### Append-Only Versioning

Things use append-only inserts for updates, creating an immutable audit trail:

```typescript
// Version 1: Initial creation
{ $id: 'cus_123', version: 1, data: { email: 'alice@example.com.ai' } }

// Version 2: Plan upgraded
{ $id: 'cus_123', version: 2, data: { email: 'alice@example.com.ai', plan: 'pro' } }

// Version 3: Email changed
{ $id: 'cus_123', version: 3, data: { email: 'alice@newdomain.com', plan: 'pro' } }
```

Query any historical version:

```typescript
// Get current version
const current = await things.get('cus_123')

// Get specific version
const v1 = await things.get('cus_123', { version: 1 })

// Get all versions
const history = await things.versions('cus_123')
```

### ThingsStore API

```typescript
// Create
const thing = await things.create({
  $type: 'Customer',
  name: 'Alice',
  data: { email: 'alice@example.com.ai' }
})

// Read
const thing = await things.get('cus_123')
const customers = await things.list({ type: 'Customer', limit: 100 })

// Update (creates new version)
await things.update('cus_123', { data: { plan: 'pro' } })

// Delete (soft by default)
await things.delete('cus_123')

// Hard delete (removes all versions)
await things.delete('cus_123', { hard: true })
```

## Relationships

Relationships connect Things with typed verbs:

```typescript
interface Relationship {
  id: string
  verb: string       // 'manages', 'employs', 'owns', 'subscribes'
  from: string       // Thing $id (source)
  to: string         // Thing $id (target)
  data?: Record<string, unknown>  // Edge metadata
  createdAt: Date
}
```

### Typed Edges

Each relationship has a verb that describes the connection:

```typescript
// Organization employs Person
{ verb: 'employs', from: 'org_acme', to: 'person_alice' }

// Person manages Project
{ verb: 'manages', from: 'person_alice', to: 'project_x' }

// Customer subscribes Plan
{ verb: 'subscribes', from: 'cus_123', to: 'plan_pro' }
```

### Edge Metadata

Relationships can carry their own data:

```typescript
await rels.create({
  verb: 'employs',
  from: 'org_acme',
  to: 'person_alice',
  data: {
    role: 'Engineering Manager',
    startDate: '2024-01-15',
    department: 'Platform'
  }
})
```

### RelationshipsStore API

```typescript
// Create
const rel = await rels.create({
  verb: 'manages',
  from: 'person_alice',
  to: 'project_x'
})

// Query outbound edges
const managed = await rels.from('person_alice')
// [{ verb: 'manages', to: 'project_x' }, ...]

// Query inbound edges
const managers = await rels.to('project_x')
// [{ verb: 'manages', from: 'person_alice' }, ...]

// Filter by verb
const employees = await rels.from('org_acme', { verb: 'employs' })

// Delete relationship
await rels.delete(rel.id)

// Delete by criteria
await rels.deleteWhere({ from: 'person_alice', verb: 'manages' })
```

### Graph Queries

Relationships form a graph that can be traversed:

```typescript
// Get all things managed by Alice
const aliceManages = await rels.from('person_alice', { verb: 'manages' })
const projects = await Promise.all(
  aliceManages.map(r => things.get(r.to))
)

// Get all managers of a project
const projectManagers = await rels.to('project_x', { verb: 'manages' })
const managers = await Promise.all(
  projectManagers.map(r => things.get(r.from))
)
```

## Actions

Every operation is logged in an append-only audit trail:

```typescript
interface Action {
  id: string
  verb: string            // 'create', 'update', 'approve', 'deploy'
  target: string          // Thing $id or namespace
  actor: string           // 'Human/nathan', 'Agent/claude'
  input?: Record<string, unknown>   // Operation input
  output?: unknown        // Operation result
  durability: 'send' | 'try' | 'do'
  status: ActionStatus
  error?: Record<string, unknown>   // Error details if failed
  requestId?: string      // HTTP request correlation
  sessionId?: string      // User session correlation
  workflowId?: string     // Workflow correlation
  createdAt: Date
  startedAt?: Date
  completedAt?: Date
  duration?: number       // Milliseconds
  retryCount?: number
}

type ActionStatus = 'pending' | 'running' | 'retrying' | 'completed' | 'failed' | 'undone'
```

### Three Durability Levels

Actions track their durability level, which determines retry behavior:

| Durability | Behavior | Use Case |
|------------|----------|----------|
| `send` | Fire-and-forget, no retries | Analytics, notifications |
| `try` | Single attempt, fail fast | Validations, cache lookups |
| `do` | Durable with retries | Payments, order processing |

```typescript
// $.send creates action with durability: 'send'
$.send('notify', { userId, message })

// $.try creates action with durability: 'try'
await $.try('validate', data)

// $.do creates action with durability: 'do'
await $.do('processPayment', order)
```

### Action Lifecycle

```
                  ┌──────────────────────────────────────┐
                  ▼                                      │
pending ──► running ──► completed                       │
              │                                          │
              ▼                                          │
           retrying ◄────────────────────────────────────┘
              │
              ▼
           failed
```

### ActionsStore API

```typescript
// Log a new action
const action = await actions.log({
  verb: 'approve',
  target: 'order_123',
  actor: 'Human/nathan',
  input: { approved: true }
})

// Mark as completed
await actions.complete(action.id, { approvedAt: new Date() })

// Mark as failed
await actions.fail(action.id, new Error('Insufficient funds'))

// Retry a failed action
await actions.retry(action.id)

// Query actions
const pending = await actions.pending()
const failed = await actions.failed()
const forOrder = await actions.list({ target: 'order_123' })
const byNathan = await actions.list({ actor: 'Human/nathan' })
```

### Correlation IDs

Actions support multiple correlation IDs for tracing:

```typescript
await actions.log({
  verb: 'submit',
  target: 'order_123',
  requestId: 'req_abc',    // HTTP request ID
  sessionId: 'sess_xyz',   // User session ID
  workflowId: 'wf_456'     // Workflow instance ID
})

// Query by correlation
const requestActions = await actions.list({ requestId: 'req_abc' })
```

## Events

Domain events flow through the event system for pub/sub patterns:

```typescript
interface Event {
  id: string
  verb: string           // 'signup', 'paid', 'shipped'
  source: string         // Thing $id that emitted the event
  data: Record<string, unknown>   // Event payload
  actionId?: string      // Related action ID
  sequence: number       // Monotonic sequence number
  streamed: boolean      // Has been sent to pipeline
  streamedAt?: Date
  createdAt: Date
}
```

### Event Emission

Events are emitted when things happen:

```typescript
// Emit an event
await events.emit({
  verb: 'signup',
  source: 'Customer/cus_123',
  data: { email: 'alice@example.com.ai', plan: 'free' }
})

// Events linked to actions
const action = await actions.log({ verb: 'upgrade', target: 'cus_123' })
await events.emit({
  verb: 'upgraded',
  source: 'Customer/cus_123',
  data: { from: 'free', to: 'pro' },
  actionId: action.id
})
```

### Event Subscription

Subscribe to events using the `$.on` DSL:

```typescript
// Subscribe to specific Noun.verb
$.on.Customer.signup(async (event) => {
  await sendWelcomeEmail(event.data.email)
})

$.on.Invoice.paid(async (event) => {
  await recordRevenue(event.data.amount)
})

// Wildcards
$.on['*'].created(async (event) => {
  await logCreation(event.source, event.data)
})

$.on.Customer['*'](async (event) => {
  await trackCustomerActivity(event.verb, event.data)
})
```

### Event Pipeline

Events flow through a pipeline to external storage:

```
DO Internal → Events Table → Cloudflare Pipeline → R2 Parquet
                                    ↓
                               /api/search
```

```typescript
// Stream pending events to pipeline
const count = await events.streamPending()

// Replay events from a sequence
const history = await events.replay({ fromSequence: 100, limit: 50 })
```

### EventsStore API

```typescript
// Emit event
const event = await events.emit({
  verb: 'shipped',
  source: 'Order/ord_123',
  data: { trackingNumber: 'TRK456' }
})

// Get event by ID
const event = await events.get('evt_789')

// List events
const all = await events.list()
const shipped = await events.list({ verb: 'shipped' })
const orderEvents = await events.list({ source: 'Order/ord_123' })

// Replay from sequence
const fromSeq100 = await events.replay({ fromSequence: 100 })

// Stream to external pipeline
await events.stream(event.id)
const streamed = await events.streamPending()
```

## Store Relationships

The stores work together to provide a complete data model:

```
Things ◄──────────────────────────► Relationships
   │                                      │
   │  thing.relate(verb, to)             │
   │  thing.unrelate(verb, to)           │
   │                                      │
   ▼                                      ▼
Actions ◄──────────────────────────► Events
   │                                      │
   │  actions.complete() → events.emit() │
   │  actions.fail() → events.emit()     │
   │                                      │
   └──────────────────────────────────────┘
```

### Typical Flow

1. **Thing created** - Inserted into Things table
2. **Action logged** - Create action recorded
3. **Event emitted** - `Customer.created` event published
4. **Handlers invoked** - Subscribed handlers process event
5. **Relationships updated** - Edges created/updated as needed

```typescript
// This happens automatically when using the $ context
await $.do('createCustomer', { email: 'alice@example.com.ai' })
// Creates Thing, logs Action, emits Event, triggers handlers
```

## Schema Summary

### Things Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | URL-based identity |
| type | INTEGER | Foreign key to nouns.rowid |
| name | TEXT | Display name |
| data | JSON | Custom fields |
| branch | TEXT | Git-style branch |
| deleted | BOOLEAN | Soft-delete flag |

### Relationships Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Relationship type |
| from | TEXT | Source Thing $id |
| to | TEXT | Target Thing $id |
| data | JSON | Edge metadata |
| createdAt | DATETIME | Creation time |

### Actions Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Operation type |
| target | TEXT | Thing $id or namespace |
| actor | TEXT | Who performed it |
| input | JSON | Operation input |
| output | JSON | Operation result |
| durability | TEXT | send/try/do |
| status | TEXT | pending/running/completed/failed |
| error | JSON | Error details |
| createdAt | DATETIME | When logged |
| completedAt | DATETIME | When finished |

### Events Table

| Column | Type | Description |
|--------|------|-------------|
| id | TEXT | UUID |
| verb | TEXT | Event type |
| source | TEXT | Emitting Thing $id |
| data | JSON | Event payload |
| actionId | TEXT | Related action |
| sequence | INTEGER | Monotonic order |
| streamed | BOOLEAN | Sent to pipeline |
| createdAt | DATETIME | Emission time |
