---
title: Things
description: Collection interface for managing Things with complete CRUD, queries, and relationships
---

import { AutoTypeTable } from 'fumadocs-typescript/ui'

# Things

The `Things<T>` interface provides a collection interface for managing groups of Thing entities. It supports CRUD operations, querying, relationships, and iteration.

## Overview

Things collections are accessed via ThingDO namespaces and provide typed access to entities.

<AutoTypeTable type="Things" />

## Generic Type Parameter

The Things interface is generic over `T extends Thing`:

```typescript
interface Things<T extends Thing = Thing> {
  // Collection methods...
}
```

This allows for typed collections:

```typescript
const users: Things<User> = thingDO.collection('User')
const projects: Things<Project> = thingDO.collection('Project')
```

---

## CRUD Operations

### Create

Create new Things with automatic or custom IDs.

#### Auto-generated ID

```typescript
const user = await users.create({
  name: 'John Doe',
  data: { email: 'john@example.com', role: 'admin' }
})

console.log(user.$id) // Auto-generated UUID: 'f47ac10b-58cc-4372-a567-0e02b2c3d479'
console.log(user.$type) // 'User'
```

#### Custom ID

```typescript
const user = await users.create({
  $id: 'user-john-doe',
  name: 'John Doe',
  data: { email: 'john@example.com' }
})

console.log(user.$id) // 'user-john-doe'
```

#### With Cascade Generation

When creating entities with relationships, use cascade options to auto-generate related entities:

```typescript
const order = await orders.create({
  name: 'Order #1234',
  data: {
    customerId: 'customer-123',
    items: [{ sku: 'WIDGET-1', qty: 2 }]
  }
}, {
  cascade: true,          // Enable cascade generation
  maxDepth: 2,            // Limit recursion depth
  cascadeTypes: ['Customer', 'Product'], // Types to generate
  onProgress: (progress) => {
    console.log(`Generated ${progress.totalEntitiesCreated} entities`)
  }
})
```

### Read

#### Get Single by ID

```typescript
const user = await users.get('user-123')

if (user) {
  console.log(user.name, user.data)
}
```

#### Get with Options

```typescript
// Get a specific version (time travel)
const oldVersion = await users.get('user-123', { version: 3 })

// Get from a specific branch
const staging = await users.get('user-123', { branch: 'staging' })

// Include soft-deleted items
const deleted = await users.get('user-123', { includeDeleted: true })
```

#### Get Multiple (List)

```typescript
// List all users
const allUsers = await users.list()

// With pagination
const page1 = await users.find({ limit: 20, offset: 0 })
const page2 = await users.find({ limit: 20, offset: 20 })
```

#### First Match

```typescript
const admin = await users.first({
  where: { 'data.role': 'admin' }
})
```

#### Count

```typescript
const total = await users.count()
const activeCount = await users.count({
  where: { 'data.status': 'active' }
})
```

### Update

#### Partial Update (Default: Merge)

By default, updates merge with existing data:

```typescript
// Original: { email: 'john@example.com', role: 'user' }
await users.update('user-123', {
  data: { role: 'admin' }
})
// Result: { email: 'john@example.com', role: 'admin' }
```

#### Full Replace

To replace the entire data object, disable merge:

```typescript
await users.update('user-123', {
  data: { role: 'admin' }
}, { merge: false })
// Result: { role: 'admin' } (email is gone)
```

#### Update with Validation

Updates validate against the entity schema:

```typescript
try {
  await users.update('user-123', {
    data: { email: 'not-an-email' }
  })
} catch (error) {
  console.log(error.message) // 'Validation failed: email failed custom validation'
}
```

### Delete

#### Soft Delete (Default)

Soft delete creates a new version with `deleted: true`:

```typescript
await users.delete('user-123')

// Item is no longer returned by default
const user = await users.get('user-123') // null

// But can be retrieved with includeDeleted
const deleted = await users.get('user-123', { includeDeleted: true })
console.log(deleted?.deleted) // true
```

#### Hard Delete

Permanently remove all versions:

```typescript
await users.delete('user-123', { hard: true })

// Gone forever, even with includeDeleted
const user = await users.get('user-123', { includeDeleted: true }) // null
```

#### Delete with Confirmation

```typescript
const user = await users.get('user-123')
if (user) {
  const confirmed = await users.delete(user.$id)
  console.log(`Deleted ${confirmed.name}`)
}
```

### Upsert Pattern

Create or update based on existence:

```typescript
async function upsertUser(id: string, data: UserData) {
  const existing = await users.get(id)

  if (existing) {
    return users.update(id, { data })
  } else {
    return users.create({ $id: id, data })
  }
}
```

---

## Query Syntax

### Basic Queries

```typescript
const results = await users.find({
  where: { 'data.status': 'active' },
  orderBy: 'name',
  order: 'asc',
  limit: 20,
  offset: 0
})
```

### Where Clause

The `where` clause supports JSON path queries on the `data` field:

```typescript
// Simple equality
await users.find({ where: { 'data.status': 'active' } })

// Nested paths
await users.find({ where: { 'data.address.city': 'New York' } })

// Multiple conditions (AND)
await users.find({
  where: {
    'data.status': 'active',
    'data.role': 'admin'
  }
})
```

### Supported Operators

JSON path queries use SQLite's `json_extract()` for efficient filtering:

| Path Pattern | Example | Description |
|--------------|---------|-------------|
| `data.field` | `'data.status': 'active'` | Top-level field equality |
| `data.nested.field` | `'data.address.city': 'NYC'` | Nested field equality |

Note: Complex operators like `$gte`, `$lt`, `$in` require custom SQL. For advanced queries, use the underlying ThingsStore directly.

### OrderBy Syntax

Order by these allowed columns:

```typescript
// Order by id (default)
await users.find({ orderBy: 'id', order: 'asc' })

// Order by name
await users.find({ orderBy: 'name', order: 'desc' })

// Allowed columns: 'id', 'name', 'type', 'branch', 'deleted'
```

### Pagination Patterns

#### Offset-based Pagination

```typescript
const pageSize = 20
const pageNumber = 3

const results = await users.find({
  limit: pageSize,
  offset: (pageNumber - 1) * pageSize
})
```

#### Cursor-based Pagination

More efficient for large datasets:

```typescript
// First page
const page1 = await users.find({ limit: 20 })
const lastId = page1[page1.length - 1]?.$id

// Next page (using cursor)
const page2 = await users.find({
  limit: 20,
  after: lastId  // Cursor-based: get items after this ID
})
```

### Full-Text Search

Search across indexed content:

```typescript
// Basic text search
const results = await users.search('john admin', 10)

// Search returns scored results
for (const result of results) {
  console.log(result.$id, result.score)
}
```

#### Indexing for Search

Things must be indexed before they appear in search results:

```typescript
// Index a thing for search
await searchStore.index({
  $id: user.$id,
  $type: 'User',
  content: `${user.name} ${user.data.email} ${user.data.bio}`
})

// Now searchable
const found = await users.search('john')
```

---

## Relationships

### Modeling Relationships

Things use a separate relationships table with verb-based edges:

```typescript
interface Relationship {
  id: string
  verb: string    // e.g., 'manages', 'owns', 'belongsTo'
  from: string    // Source Thing $id
  to: string      // Target Thing $id
  data?: object   // Optional relationship metadata
  createdAt: Date
}
```

### Creating Relationships

```typescript
// Create a relationship using the Thing's relate method
await manager.relate('manages', employee.$id)

// Or using the RelationshipsStore directly
await relationships.create({
  verb: 'manages',
  from: manager.$id,
  to: employee.$id,
  data: { since: '2024-01-01' }
})
```

### Querying Relationships

#### Outbound (From a Thing)

```typescript
// Get all relationships FROM a thing
const managing = await relationships.from(manager.$id)

// Filter by verb
const directReports = await relationships.from(manager.$id, { verb: 'manages' })
```

#### Inbound (To a Thing)

```typescript
// Get all relationships TO a thing
const references = await relationships.to(employee.$id)

// Find who manages this employee
const managers = await relationships.to(employee.$id, { verb: 'manages' })
```

### Accessing Relationships on Things

Things automatically include relationship data:

```typescript
const user = await users.get('user-123')

// Outbound relationships by verb
console.log(user.relationships)
// { manages: [{ $id: '...', name: 'Employee 1' }, ...] }

// Inbound references by reverse verb
console.log(user.references)
// { managedBy: { $id: '...', name: 'Manager' } }
```

### Removing Relationships

```typescript
// Remove a specific relationship
await manager.unrelate('manages', employee.$id)

// Or delete by ID
await relationships.delete(relationshipId)

// Bulk delete by criteria
const deleted = await relationships.deleteWhere({
  from: manager.$id,
  verb: 'manages'
})
console.log(`Removed ${deleted} relationships`)
```

### Nested Writes (Transactions)

Create Things with relationships in a single operation:

```typescript
// Create a team with members
const team = await teams.create({
  name: 'Engineering',
  data: { department: 'Product' }
})

// Add members with relationships
for (const memberId of memberIds) {
  await team.relate('includes', memberId)
}
```

---

## Common Patterns

### Soft Delete with Recovery

```typescript
// Soft delete
await users.delete('user-123')

// List deleted items for recovery
const deleted = await users.find({
  includeDeleted: true,
  where: { 'deleted': true }
})

// Recover by updating
await users.update('user-123', { deleted: false })
```

### Versioning and Time Travel

Things automatically track versions. Every update creates a new version:

```typescript
// Get version history
const versions = await things.versions('user-123')

for (const version of versions) {
  console.log(`Version ${version.version}: ${version.updatedAt}`)
}

// Retrieve a specific version
const v2 = await users.get('user-123', { version: 2 })
```

#### Comparing Versions

```typescript
const current = await users.get('user-123')
const previous = await users.get('user-123', { version: current.version - 1 })

// Compare changes
const changes = diffObjects(previous.data, current.data)
```

### Audit Trails

Use the ActionsStore to track who did what:

```typescript
// Log an action
const action = await actions.log({
  verb: 'update',
  target: user.$id,
  actor: currentUser.$id,
  input: { changes: { role: 'admin' } },
  requestId: ctx.requestId
})

// Complete the action
await actions.complete(action.id, { success: true })

// Query audit history
const history = await actions.list({
  target: user.$id,
  verb: 'update'
})
```

### Branching (Staging Changes)

Work on changes in isolation before merging:

```typescript
// Create on a branch
const draft = await users.create({
  name: 'New User',
  data: { status: 'draft' }
}, { branch: 'staging' })

// Read from branch
const staging = await users.get(draft.$id, { branch: 'staging' })

// Main branch doesn't see it
const main = await users.get(draft.$id) // null

// Merge by updating main branch
await users.create({
  ...staging,
}, { branch: 'main' })
```

### Real-time Sync

Subscribe to mutations for real-time updates:

```typescript
// In your DO
things.onMutation = (type, thing, rowid) => {
  syncEngine.broadcast({
    channel: `things:${thing.$type}`,
    event: type,
    data: thing,
    version: rowid,
  })
}
```

### Batch Processing

Process large collections efficiently:

```typescript
const progress = await users.forEach(async (user) => {
  await sendWelcomeEmail(user)
}, {
  concurrency: 5,
  maxRetries: 3,
  onProgress: (p) => {
    console.log(`${p.completed}/${p.total} processed`)
  },
  onError: (err, user) => {
    console.error(`Failed for ${user.$id}:`, err)
    return 'skip' // or 'retry' or 'abort'
  }
})

console.log(`Completed: ${progress.completed}, Failed: ${progress.failed}`)
```

### Async Iteration

Iterate over collections with for-await-of:

```typescript
for await (const user of users) {
  console.log(user.name)
}

// Or stream results
const stream = await users.stream()
for await (const user of stream) {
  await processUser(user)
}
```

### Natural Language Queries

Use template literals for AI-powered queries:

```typescript
// Query with natural language
const results = await db.Startup`who closed deals this month?`

// Results are typed
for (const startup of results) {
  console.log(startup.name, startup.data.deals)
}
```

---

## Related Types

- [Thing](/docs/sdk/thing) - Base entity type
- [ThingDO](/docs/sdk/thing#thingdo-interface) - Namespace that contains collections
- [Concepts: Things](/docs/concepts/things) - What Things are and how they work
