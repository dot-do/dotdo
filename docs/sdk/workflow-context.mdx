---
title: WorkflowContext Reference
description: Complete reference for the $ proxy - unified interface for all DO operations
---

import { Callout } from 'fumadocs-ui/components/callout'
import { AutoTypeTable } from 'fumadocs-typescript/ui'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

# WorkflowContext ($) Reference

The `$` proxy is THE primary API in dotdo. One interface for durability, events, scheduling, AI, and cross-DO communication. This reference covers every aspect of the WorkflowContext API.

## Quick Reference Table

### Complete API Surface

| Category | API | Signature | Returns | Available In |
|----------|-----|-----------|---------|--------------|
| **Durability** | | | | |
| | `$.track()` | `(event: string, data: unknown) => void` | `void` | All DOs |
| | `$.send()` | `(event: string, data: T) => string` | `EventId` | All DOs |
| | `$.try()` | `<T>(action: string, data: unknown, opts?: TryOptions) => Promise<T>` | `Promise<T>` | All DOs |
| | `$.do()` | `<T>(action: string, data: unknown, opts?: DoOptions) => Promise<T>` | `Promise<T>` | All DOs |
| **Events** | | | | |
| | `$.on.Noun.verb()` | `(handler: EventHandler, opts?: HandlerOptions) => void` | `void` | All DOs |
| | `send.Noun.verb()` | `(payload: T) => PipelinePromise` | `PipelinePromise` | Import from workflows |
| **Scheduling** | | | | |
| | `$.every.Day.atTime()` | `(handler: () => void) => void` | `void` | All DOs |
| | `$.every(schedule, handler)` | `(schedule: string, handler: () => void) => void` | `void` | All DOs |
| **Cross-DO RPC** | | | | |
| | `$.Noun(id)` | `(id: string) => DomainProxy` | `DomainProxy` | All DOs |
| | `$.Noun(id).method()` | `(...args: unknown[]) => RpcPromise<T>` | `RpcPromise<T>` | All DOs |
| **AI Functions** | | | | |
| | `$.ai` | `` `template literal` => AIPipelinePromise<string>`` | `AIPipelinePromise<string>` | AI-enabled DOs |
| | `$.write` | `` `template literal` => AIPipelinePromise<WriteResult>`` | `AIPipelinePromise<WriteResult>` | AI-enabled DOs |
| | `$.summarize` | `` `template literal` => AIPipelinePromise<string>`` | `AIPipelinePromise<string>` | AI-enabled DOs |
| | `$.list` | `` `template literal` => AIPipelinePromise<string[]>`` | `AIPipelinePromise<string[]>` | AI-enabled DOs |
| | `$.extract` | `` `template literal` => AIPipelinePromise<ExtractResult>`` | `AIPipelinePromise<ExtractResult>` | AI-enabled DOs |
| | `$.is` | `` `template literal` => AIPipelinePromise<boolean>`` | `AIPipelinePromise<boolean>` | AI-enabled DOs |
| | `$.decide()` | `(options: string[]) => AITemplateLiteralFn<T>` | Template literal fn | AI-enabled DOs |
| **Control Flow** | | | | |
| | `when()` | `(cond, { then, else? }) => PipelinePromise` | `PipelinePromise` | Import from workflows |
| | `waitFor()` | `(event: string, opts?) => PipelinePromise` | `PipelinePromise` | Import from workflows |
| | `$.sleep()` | `(duration: string \| number) => Promise<void>` | `Promise<void>` | Workflow DOs |
| **Version Control** | | | | |
| | `$.branch()` | `(name: string) => Promise<void>` | `Promise<void>` | All DOs |
| | `$.checkout()` | `(ref: string) => Promise<void>` | `Promise<void>` | All DOs |
| | `$.merge()` | `(branch: string) => Promise<void>` | `Promise<void>` | All DOs |
| **State & Logging** | | | | |
| | `$.state` | `Record<string, unknown>` | Object | All DOs |
| | `$.log()` | `(message: string, data?: unknown) => void` | `void` | All DOs |
| | `$.user` | `UserContext \| null` | Object | All DOs |
| **Capabilities** | | | | |
| | `$.fs` | `FsCapability` | Object | WithFs DOs |
| | `$.git` | `GitCapability` | Object | WithGit DOs |
| | `$.bash` | `BashCapability` | Object | WithBash DOs |
| | `$.rateLimit` | `RateLimitCapability` | Object | WithRateLimit DOs |

### Durability Matrix

|  | Fire & Forget | Durable |
|---|---------------|---------|
| **Event** | `track()` -> void | `send()` -> EventId |
| **Action** | `try()` -> T | `do()` -> T |

### Import Reference

```typescript
// WorkflowContext is available as this.$ in DO methods
// No import needed for core $ functionality

// For standalone workflow utilities, import from workflows
import {
  on,           // Event subscription: on.Customer.signup(handler)
  every,        // Scheduling: every.Monday.at9am(handler)
  send,         // Event emission: send.Order.shipped(payload)
  when,         // Conditional: when(cond, { then, else })
  waitFor,      // Human-in-loop: await waitFor('approval')
  Domain,       // Domain factory: Domain('CRM', handlers)
  Workflow,     // Workflow definition: Workflow('name', fn)
} from 'dotdo/workflows'

// Type imports
import type {
  WorkflowContext,
  EventHandler,
  HandlerOptions,
  UserContext,
  RetryPolicy,
  DoOptions,
  TryOptions,
} from '@dotdo/types'

// Capability types
import type {
  WithFs,
  WithGit,
  WithBash,
  WithRateLimit,
  WithAllCapabilities,
} from '@dotdo/types'

// Type guards for capability checking
import { hasFs, hasGit, hasBash, hasRateLimit } from '@dotdo/types'
```

## Getting the $ Context

The `$` WorkflowContext is available as `this.$` inside any Durable Object method. You can use it directly or destructure it for convenience:

```typescript
import { DO } from 'dotdo'

export class MyStartup extends DO {
  async launch() {
    // Option 1: Use this.$ directly
    this.$.on.Customer.signup(async (event) => {
      await sendWelcomeEmail(event.data.email)
    })

    // Option 2: Destructure for cleaner code
    const $ = this.$

    $.every.Monday.at9am(async () => {
      await generateWeeklyReport()
    })

    await $.do('processPayment', { amount: 100 })
  }
}
```

<Callout type="info">
Throughout the docs, standalone `$` in code examples assumes you've set `const $ = this.$` or are inside a DO method where `this.$` is available.
</Callout>

## Overview

```typescript
// $ is the WorkflowContext, available as this.$ in DO methods
const $ = this.$

// Four execution modes (two fire-and-forget, two durable)
$.track('event', data)  // Fire-and-forget telemetry
$.send('event', data)   // Durable event with EventId
await $.try(action)     // Single attempt, fallible
await $.do(action)      // Durable with retries

// Infinite event combinations
$.on.Customer.signup(handler)
$.on.Payment.failed(handler)
$.on['*'].created(handler)  // Wildcards

// Human-readable scheduling
$.every.Monday.at9am(handler)
$.every('daily at 6am', handler)

// Cross-DO RPC with promise pipelining
await $.Customer(id).notify()
const city = await $.Order(id).shipping.address.city

// Control flow
when(condition, { then: () => A, else: () => B })
await waitFor('approval', { timeout: '24h' })

// AI as primitives
await $.write`blog post about ${topic}`
const isSpam = await $.is`Is this spam? ${message}`

// Authenticated user context
if ($.user) {
  console.log(`Request from: ${$.user.email}`)
}
```

<AutoTypeTable type="WorkflowContext" />

## Durability Levels

Four execution modes organized by durability and blocking behavior:

|  | Fire & Forget | Durable |
|---|---------------|---------|
| **Event** | `track()` -> void | `send()` -> EventId |
| **Action** | `try()` -> T | `do()` -> T |

Choose based on what happens if it fails and whether you need confirmation.

### $.track() - Fire-and-Forget Telemetry

Best-effort telemetry. Non-blocking, no confirmation, errors swallowed. Use for analytics, logging, and metrics where loss is acceptable.

```typescript
// Analytics events - no waiting, no retries
$.track('pageview', { path: '/dashboard', userId })
$.track('user.activity', { action: 'login' })
$.track('metrics.counter', { name: 'logins', value: 1 })

// Telemetry in hot paths
$.track('api.latency', { endpoint: '/users', ms: 45 })
$.track('cache.hit', { key: 'user:123' })
```

| Property | Value |
|----------|-------|
| Blocking | No |
| Durable | No |
| Retries | No |
| Returns | `void` |
| Use case | Analytics, telemetry, non-critical logging |

<Callout type="info">
Uses `queueMicrotask` for async execution. Errors are swallowed silently - that's the point. Perfect for high-throughput telemetry where you don't want to slow down the critical path.
</Callout>

### $.send() - Durable Event Emission

Guaranteed delivery with retries. Returns a trackable EventId. Use for important domain events that must not be lost.

```typescript
// Emit notification - guaranteed delivery
const eventId = $.send('notification', { userId: 'abc', message: 'Welcome!' })

// Domain events - must not be lost
$.send('order.placed', { orderId: 'ord-123', total: 99.99 })
$.send('payment.captured', { orderId: 'ord-123', amount: 99.99 })

// Track the event if needed
console.log(`Event emitted with ID: ${eventId}`)
```

| Property | Value |
|----------|-------|
| Blocking | No (returns immediately) |
| Durable | Yes |
| Retries | Yes (internal) |
| Returns | `string` (EventId) |
| Use case | Domain events, notifications, webhooks |

<Callout type="info">
Unlike `track()`, `send()` guarantees eventual delivery. Events are persisted and retried until acknowledged. Use this for domain events that drive business logic.
</Callout>

### $.try() - Single Attempt

Blocking but not durable. Use for operations that should fail fast without retries.

```typescript
// Try to fetch - fail immediately if it doesn't work
const data = await $.try<ApiResponse>('fetch', {
  url: 'https://api.example.com/data'
})

// Quick validation check
const valid = await $.try<boolean>('validate', { schema, input })

// With timeout
const result = await $.try<Result>('externalApi', data, {
  timeout: 5000
})
```

| Property | Value |
|----------|-------|
| Blocking | Yes |
| Durable | No |
| Retries | No |
| Returns | `Promise<T>` |
| Use case | Validations, cache lookups, non-critical fetches |

#### TryOptions

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | `number` | 30000 | Timeout in milliseconds |

### $.do() - Durable Execution

Blocking with retries and persistence. Use for anything that must succeed.

```typescript
// Process payment - must succeed
const result = await $.do<PaymentResult>('processPayment', {
  amount: 100,
  currency: 'USD',
  customerId: 'cus_123'
})

// Create user - retry on failure
const user = await $.do<User>('createUser', {
  email: 'alice@example.com',
  name: 'Alice'
})

// With custom retry policy
const order = await $.do<Order>('fulfillOrder', orderData, {
  retry: {
    maxAttempts: 5,
    initialDelayMs: 500,
    backoffMultiplier: 3
  },
  timeout: 60000,
  stepId: 'order-fulfillment'
})
```

| Property | Value |
|----------|-------|
| Blocking | Yes |
| Durable | Yes |
| Retries | Exponential backoff |
| Returns | `Promise<T>` |
| Use case | Payments, order processing, user creation |

#### DoOptions

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `retry` | `Partial<RetryPolicy>` | see below | Retry configuration |
| `timeout` | `number` | - | Timeout per attempt (ms) |
| `stepId` | `string` | auto | Explicit ID for replay |

#### RetryPolicy

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `maxAttempts` | `number` | 3 | Maximum retry attempts |
| `initialDelayMs` | `number` | 100 | Initial delay before first retry |
| `maxDelayMs` | `number` | 30000 | Maximum delay between retries |
| `backoffMultiplier` | `number` | 2 | Exponential backoff multiplier |
| `jitter` | `boolean` | true | Add random jitter to delays |

<Callout type="warn">
When `$.do()` fails all retries, it emits a failure event. Connect a dead-letter handler to catch unrecoverable failures.
</Callout>

## Event Handlers

Subscribe to domain events using `$.on`. No class definitions needed - any Noun.verb combination works.

```typescript
// Customer events
$.on.Customer.signup(async (event) => {
  await sendWelcomeEmail(event.data.email)
})

$.on.Customer.upgraded(async (event) => {
  await enablePremiumFeatures(event.data.customerId)
})

// Order events
$.on.Order.placed(async (event) => {
  await notifyWarehouse(event.data)
})

$.on.Order.shipped(async (event) => {
  await sendTrackingEmail(event.data.email, event.data.trackingNumber)
})

// Invoice events
$.on.Invoice.paid(async (event) => {
  await recordRevenue(event.data.amount)
})

$.on.Invoice.overdue(async (event) => {
  await sendReminderEmail(event.data)
})
```

<Callout type="info">
Infinite combinations. `Customer.signup`, `Payment.failed`, `Inventory.low`, `Report.generated` - any noun, any verb.
</Callout>

### Emitting Events with send Proxy

Use the `send` proxy DSL to emit events with `Noun.verb` syntax:

```typescript
import { send } from 'dotdo/workflows'

// Emit order shipped event
send.Order.shipped({
  orderId: '12345',
  carrier: 'UPS',
  trackingNumber: '1Z999AA10123456784'
})

// Emit customer created event
send.Customer.created({
  id: 'cust_123',
  email: 'user@example.com',
  name: 'John Doe'
})

// In workflow context
async function processOrder(order: Order) {
  await validateOrder(order)

  // Fire-and-forget notification
  send.Order.validated({ orderId: order.id })

  await chargePayment(order)
  send.Payment.captured({ orderId: order.id, amount: order.total })

  return order
}
```

The `send` proxy creates pipeline expressions for deferred execution, integrating with Cap'n Web RPC promise pipelining.

### Wildcards

Match patterns across nouns or verbs:

```typescript
// All 'created' events across all nouns
$.on['*'].created(async (event) => {
  await logCreation(event.source, event.data)
})

// All events for Customer noun
$.on.Customer['*'](async (event) => {
  await trackCustomerActivity(event.verb, event.data)
})

// Global handler - ALL events
$.on['*']['*'](async (event) => {
  await auditLog(event)
})
```

### Handler Options

Enhanced control over event handling:

```typescript
$.on.Order.placed(
  async (event) => {
    await processHighValueOrder(event.data)
  },
  {
    priority: 10,                    // Higher = runs first
    filter: (e) => e.data.total > 1000,  // Conditional handling
    name: 'high-value-orders',       // For debugging
    maxRetries: 5                    // DLQ retries
  }
)
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `priority` | `number` | 0 | Execution order (higher first) |
| `filter` | `(event) => boolean` | - | Skip if returns false |
| `name` | `string` | auto | Handler identifier |
| `maxRetries` | `number` | 3 | Max DLQ retry attempts |

### Handler Cleanup and Unsubscribe

Event handlers return an unsubscribe function and support context-based cleanup:

```typescript
import { on, clearHandlersByContext, unregisterHandler } from 'dotdo/workflows'

// Subscribe with context for grouped cleanup
const unsubscribe = on.Order.created((order) => {
  processOrder(order)
}, { context: 'order-processor' })

// Manual unsubscribe
unsubscribe()

// Clean up all handlers for a context (e.g., when a DO is destroyed)
const removedCount = clearHandlersByContext('order-processor')
console.log(`Removed ${removedCount} handlers`)
```

This is essential for proper resource management in long-running Durable Objects.

### Event Payload

Every event includes full context:

```typescript
interface DomainEvent<TData> {
  id: string          // Unique event ID
  verb: string        // Action taken ('signup', 'paid')
  source: string      // Source DO namespace
  data: TData         // Event payload
  actionId?: string   // Related action ID
  timestamp: Date     // When it happened
}
```

### Typed Events

Extend `EventPayloadMap` for compile-time type safety:

```typescript
// In your domain types:
declare module '@dotdo/types' {
  interface EventPayloadMap {
    'Customer.created': { id: string; email: string; name: string }
    'Order.paid': { orderId: string; amount: number; currency: string }
    'Invoice.sent': { invoiceId: string; recipientEmail: string }
  }
}

// Now handlers are typed:
$.on.Customer.created(async (event) => {
  // event.data is { id: string; email: string; name: string }
  console.log(event.data.email)
})
```

## Scheduling

Human-readable schedules that compile to CRON. No cryptic syntax.

### Fluent API

```typescript
// Weekly - specific day and time
$.every.Monday.at9am(async () => {
  await generateWeeklyReport()
})

$.every.Friday.at5pm(async () => {
  await sendWeeklySummary()
})

// Daily
$.every.day.at6am(async () => {
  await runDailyBackup()
})

$.every.day.atnoon(async () => {
  await sendDailyDigest()
})

$.every.day.atmidnight(async () => {
  await rotateKeys()
})

// Weekday/Weekend
$.every.weekday.at9am(async () => {
  await checkInTeam()
})

$.every.weekend.at10am(async () => {
  await generateWeekendMetrics()
})

// Fixed intervals
$.every.hour(async () => {
  await collectMetrics()
})

$.every.minute(async () => {
  await checkHealth()
})
```

### Dynamic Time with .at()

For custom times not covered by preset properties:

```typescript
// Dynamic time string using .at() method
$.every.day.at('9:30am')(async () => {
  await handleMeeting()
})

$.every.weekday.at('17:00')(async () => {
  await endOfDayReport()
})

// Supports multiple time formats
$.every.Monday.at('14:30')(handler)  // 24-hour format
$.every.day.at('9am')(handler)       // 12-hour format
$.every.Friday.at('noon')(handler)   // Special names
$.every.day.at('midnight')(handler)
```

### Days Available

| Property | Maps to | CRON Day |
|----------|---------|----------|
| `Monday` | 1 | `* * * * 1` |
| `Tuesday` | 2 | `* * * * 2` |
| `Wednesday` | 3 | `* * * * 3` |
| `Thursday` | 4 | `* * * * 4` |
| `Friday` | 5 | `* * * * 5` |
| `Saturday` | 6 | `* * * * 6` |
| `Sunday` | 0 | `* * * * 0` |
| `day` | Every day | `* * * * *` |
| `weekday` | Mon-Fri | `* * * * 1-5` |
| `weekend` | Sat-Sun | `* * * * 0,6` |

### Times Available

| Property | CRON |
|----------|------|
| `at12am` | 0 0 * * * |
| `at1am` | 0 1 * * * |
| `at2am` | 0 2 * * * |
| `at3am` | 0 3 * * * |
| `at4am` | 0 4 * * * |
| `at5am` | 0 5 * * * |
| `at6am` | 0 6 * * * |
| `at7am` | 0 7 * * * |
| `at8am` | 0 8 * * * |
| `at9am` | 0 9 * * * |
| `at10am` | 0 10 * * * |
| `at11am` | 0 11 * * * |
| `at12pm` | 0 12 * * * |
| `at1pm` | 0 13 * * * |
| `at2pm` | 0 14 * * * |
| `at3pm` | 0 15 * * * |
| `at4pm` | 0 16 * * * |
| `at5pm` | 0 17 * * * |
| `at6pm` | 0 18 * * * |
| `at7pm` | 0 19 * * * |
| `at8pm` | 0 20 * * * |
| `at9pm` | 0 21 * * * |
| `at10pm` | 0 22 * * * |
| `at11pm` | 0 23 * * * |
| `atnoon` | 0 12 * * * |
| `atmidnight` | 0 0 * * * |

### Natural Language

For schedules that don't fit the fluent API:

```typescript
// String-based scheduling
$.every('daily at 6am', async () => {
  await runBackup()
})

$.every('first of month at 9am', async () => {
  await generateMonthlyReport()
})

$.every('15th of month', async () => {
  await generateBiweeklyReport()
})

$.every('every 5 minutes', async () => {
  await syncData()
})

$.every('every 2 hours', async () => {
  await cleanupCache()
})

$.every('weekdays at 8:30am', async () => {
  await sendDailyBriefing()
})

$.every('weekends at 10am', async () => {
  await weekendDigest()
})
```

### Common Pattern Reference

These natural language patterns are pre-cached for fast parsing:

| Pattern | CRON |
|---------|------|
| `every minute` | `* * * * *` |
| `every hour` / `hourly` | `0 * * * *` |
| `every 5 minutes` | `*/5 * * * *` |
| `every 10 minutes` | `*/10 * * * *` |
| `every 15 minutes` | `*/15 * * * *` |
| `every 30 minutes` | `*/30 * * * *` |
| `every 2 hours` | `0 */2 * * *` |
| `every 6 hours` | `0 */6 * * *` |
| `every 12 hours` | `0 */12 * * *` |
| `daily at 6am` | `0 6 * * *` |
| `daily at 9am` | `0 9 * * *` |
| `daily at noon` | `0 12 * * *` |
| `daily at midnight` | `0 0 * * *` |
| `first of month` | `0 0 1 * *` |
| `15th of month` | `0 0 15 * *` |
| `weekdays at 9am` | `0 9 * * 1-5` |
| `weekends at 10am` | `0 10 * * 0,6` |

### AI-Powered Parsing

When AI environment bindings are available, complex schedules are parsed using Claude:

```typescript
// These work with regex fallback
$.every('every 5 minutes', handler)
$.every('daily at 9am', handler)

// These require AI for accurate parsing
$.every('every second Tuesday at 3pm', handler)
$.every('last Friday of month', handler)  // Not supported - standard cron limitation
```

<Callout type="info">
Natural language schedules are parsed at registration time. Invalid schedules throw immediately. Standard cron does not support "last day of month" - use day 28 or implement custom logic.
</Callout>

### Timezone Handling

Schedules use UTC by default. The Durable Object alarm API handles timezone-aware execution:

```typescript
// All times are in UTC
$.every.Monday.at9am(handler)  // 9am UTC

// For local time, calculate offset in your handler
$.every.day.at('14:00')(async () => {
  // 14:00 UTC = 9:00 EST / 6:00 PST
  await sendLocalTimeReminder()
})
```

<Callout type="warn">
Cloudflare Workers and Durable Objects operate in UTC. Account for timezone offsets in your business logic or use explicit UTC times.
</Callout>

## Cross-DO RPC

Call methods on other Durable Objects using `$.Noun(id)`. Returns a proxy for any method.

```typescript
// Call methods on Customer DO
const customer = $.Customer('cus_123')
await customer.notify({ message: 'Welcome!' })
await customer.updateProfile({ name: 'Alice' })

// Call methods on Order DO
await $.Order('ord_456').fulfill()
await $.Order('ord_456').addItem({ sku: 'WIDGET', qty: 2 })

// Call methods on Invoice DO
await $.Invoice('inv_789').send()
await $.Invoice('inv_789').markPaid({ amount: 100 })

// Chain calls (single round-trip with Cap'n Web RPC)
const summary = await $.Startup('acme')
  .getSales()
  .thisMonth()
  .summarize()
```

### Stub Caching

Domain proxies are cached with LRU eviction. Same ID returns same stub:

```typescript
// These return the same cached stub
const c1 = $.Customer('123')
const c2 = $.Customer('123')

// Methods can be called on the proxy
await c1.notify()  // First call
await c2.update()  // Same stub, different method
```

### RPC Returns

All RPC calls return `RpcPromise<T>` - a promise that supports proxy chaining:

```typescript
// Property access on unresolved values
const email = await $.Customer(id).profile.email

// Method chaining without awaiting
const posts = await $.Blog(id).posts.recent(10)

// Deep property access
const city = await $.Order(id).shipping.address.city
```

## AI Functions

AI operations as template literals. No configuration - just describe what you want.

### $.ai - General Completion

```typescript
// Simple completion
const answer = await $.ai`What is the capital of France?`

// With context
const explanation = await $.ai`Explain ${concept} in simple terms`

// Complex prompts
const analysis = await $.ai`
  Analyze this customer feedback:
  ${feedback}

  Focus on sentiment and actionable items.
`
```

### $.write - Structured Writing

Returns an object with `title`, `body`, `summary`, and more:

```typescript
// Generate blog post
const { title, body } = await $.write`Write a blog post about ${topic}`

// Generate email
const { subject, body } = await $.write`
  Write a follow-up email for ${customerName}
  regarding their ${orderType} order
`

// Generate documentation
const { title, summary, content } = await $.write`
  Document the ${featureName} feature for developers
`
```

### $.summarize - Condensation

```typescript
// Summarize long content
const summary = await $.summarize`${longArticle}`

// Summarize with focus
const tldr = await $.summarize`
  Summarize the key points from:
  ${meetingNotes}

  Focus on action items and decisions.
`
```

### $.list - Array Generation

```typescript
// Generate lists
const languages = await $.list`List 5 programming languages for beginners`
// ['Python', 'JavaScript', 'Ruby', 'Go', 'Scratch']

const features = await $.list`
  List the key features we should build for ${product}
`
```

### $.extract - Entity Extraction

```typescript
// Extract structured data
const { entities } = await $.extract`
  Extract company names and their industries from:
  ${newsArticle}
`
// { entities: [{ name: 'Acme Corp', industry: 'Technology' }, ...] }

// Extract with schema (type inference)
const { entities } = await $.extract<{
  name: string
  email: string
  company?: string
}>`Extract contacts from: ${emailThread}`
```

### $.is - Binary Classification

```typescript
// Yes/no questions
const isSpam = await $.is`Is this message spam? ${message}`
// true or false

const needsReview = await $.is`
  Does this code change need security review?
  ${diff}
`

const isUrgent = await $.is`Is this support ticket urgent? ${ticket}`
```

### $.decide - Multi-Option Classification

Factory function that creates a classifier:

```typescript
// Create a sentiment classifier
const sentiment = $.decide(['positive', 'negative', 'neutral'])
const result = await sentiment`What is the sentiment of: ${review}`
// 'positive' | 'negative' | 'neutral'

// Create a priority classifier
const priority = $.decide(['critical', 'high', 'medium', 'low'])
const level = await priority`Classify the priority of: ${issue}`

// Create a category classifier
const category = $.decide(['bug', 'feature', 'question', 'docs'])
const type = await category`What type of issue is this? ${title}`
```

### Pipeline Chaining

AI functions return `AIPipelinePromise` with chainable methods:

```typescript
// Map results
const titles = await $.list`Generate 5 article titles for ${topic}`
  .map(title => title.toUpperCase())

// Access properties
const firstParagraph = await $.write`Write about ${topic}`
  .get('body')
  .map(body => body.split('\n')[0])

// Error handling
const result = await $.summarize`${content}`
  .catch(err => 'Summary unavailable')
```

## Branching and Version Control

Built-in version control for DO state.

### branch()

Create a new branch at current HEAD:

```typescript
// Create experiment branch
await $.branch('experiment-a')

// Create feature branch
await $.branch('feature-dark-mode')
```

### checkout()

Switch to a branch or specific version:

```typescript
// Switch to branch
await $.checkout('experiment-a')

// Switch to specific version
await $.checkout('@v1234')

// Switch back to main
await $.checkout('main')
```

### merge()

Merge a branch into current:

```typescript
// Merge experiment into main
await $.checkout('main')
await $.merge('experiment-a')
```

## Utilities

### log()

Structured logging with automatic history tracking:

```typescript
$.log('Processing order', { orderId: 'ord-123', items: 5 })
$.log('Payment received', { amount: 99.99, method: 'card' })
$.log('Order shipped', { trackingNumber: 'TRK-456' })
```

### state

Access and modify workflow state:

```typescript
// Read state
console.log($.state.currentStep)
console.log($.state.progress)

// Update state
$.state.progress = 0.5
$.state.lastCheckpoint = new Date()
$.state.metadata = { attempts: 3 }
```

## Capabilities

WorkflowContext can be extended with capabilities:

### Filesystem (fs)

```typescript
const $: WithFs = context

await $.fs.readFile('/data/config.json')
await $.fs.writeFile('/output/report.txt', content)
await $.fs.readDir('/uploads')
await $.fs.exists('/cache/key')
await $.fs.mkdir('/exports', { recursive: true })
await $.fs.rm('/temp', { recursive: true })
```

### Git (git)

```typescript
const $: WithGit = context

await $.git.status()
await $.git.add(['src/index.ts', 'package.json'])
await $.git.commit('feat: add new feature')
await $.git.push()
await $.git.log({ limit: 10 })
await $.git.diff('HEAD~1')
```

### Bash (bash)

```typescript
const $: WithBash = context

const { stdout, stderr, exitCode } = await $.bash.exec('ls -la', {
  cwd: '/app',
  timeout: 5000
})
```

### Rate Limiting (rateLimit)

```typescript
const $: WithRateLimit = context

// Check without consuming
const { success, remaining } = await $.rateLimit.check('user:123', {
  limit: 100,
  windowMs: 60000
})

// Consume quota
await $.rateLimit.consume('user:123', 1)

// Get status
const status = await $.rateLimit.status('user:123')

// Reset
await $.rateLimit.reset('user:123')
```

### Type Guards

Check for capabilities at runtime:

```typescript
import { hasFs, hasGit, hasBash, hasRateLimit } from '@dotdo/types'

if (hasFs($)) {
  // $ is typed as WithFs
  await $.fs.readFile('/data.json')
}

if (hasGit($)) {
  // $ is typed as WithGit
  await $.git.status()
}
```

## Control Flow

Declarative conditionals and human-in-the-loop workflows.

### when() - Declarative Conditional

Create pipeline expressions for conditional branching:

```typescript
import { when } from 'dotdo/workflows'

// Basic conditional
const result = when(order.total > 100, {
  then: () => applyDiscount(order, 0.1),
  else: () => order
})

// With pipeline promise condition
const status = $.Inventory(product).check()

const result = when(status.available, {
  then: () => $.Order(order).fulfill(),
  else: () => $.Order(order).backorder()
})

// Without else branch (only run if true)
when(user.isVIP, {
  then: () => send.Notification.vipWelcome({ userId: user.id })
})
```

The `when()` function creates pipeline expressions that are evaluated during workflow execution. Both the condition and branches can be pipeline promises for deferred execution.

### waitFor() - Human-in-the-Loop

Suspend workflow execution until an external event is received:

```typescript
import { waitFor } from 'dotdo/workflows'

// Wait for human approval
const approval = await waitFor('manager.approval', {
  timeout: '24 hours',
  type: 'approval'
})

if (approval.approved) {
  processRefund(order)
}

// Wait for external webhook
const paymentResult = await waitFor('payment.completed', {
  timeout: '30 minutes'
})

if (paymentResult.success) {
  send.Order.paid({ orderId: order.id })
}
```

Use `waitFor()` for:
- Human approval workflows
- External system callbacks
- Long-running asynchronous operations
- Multi-step onboarding flows

```typescript
// Complete approval workflow example
async function processLargeRefund(refund: Refund) {
  // Escalate to manager
  send.Approval.requested({
    type: 'refund',
    amount: refund.amount,
    customerId: refund.customerId
  })

  // Workflow hibernates until approval event
  const decision = await waitFor('refund.decision')

  return decision.approved
    ? executeRefund(refund)
    : rejectRefund(refund, decision.reason)
}
```

<Callout type="info">
The workflow hibernates during `waitFor()` - the DO can be evicted and restored when the event arrives. State is preserved across hibernation.
</Callout>

### $.sleep() - Durable Delays

Pause workflow execution for a specified duration. The workflow hibernates during the sleep, preserving state across DO eviction.

```typescript
import { Workflow } from 'dotdo/workflows'

// Multi-day onboarding workflow
const onboardingWorkflow = Workflow('customer-onboarding', async ($, customer) => {
  // Day 0: Welcome
  await $.do('Email.sendWelcome', customer)
  await $.do('Account.createTrial', customer)

  // Day 1: Check engagement
  await $.sleep('1 day')
  const engaged = await $.do('Analytics.checkEngagement', customer.id)

  if (!engaged) {
    await $.do('Email.sendTip1', customer)
  }

  // Day 3: Feature highlight
  await $.sleep('2 days')
  await $.do('Email.sendFeatureHighlight', customer)

  // Day 7: Trial ending soon
  await $.sleep('4 days')
  await $.do('Email.sendTrialEndingWarning', customer)
})
```

#### Duration Formats

`$.sleep()` accepts human-readable duration strings:

| Format | Example | Description |
|--------|---------|-------------|
| Milliseconds | `$.sleep(5000)` | Numeric value in ms |
| Seconds | `$.sleep('30 seconds')` | Seconds duration |
| Minutes | `$.sleep('5 minutes')` | Minutes duration |
| Hours | `$.sleep('2 hours')` | Hours duration |
| Days | `$.sleep('1 day')` | Days duration |
| Weeks | `$.sleep('1 week')` | Weeks duration |

| Property | Value |
|----------|-------|
| Blocking | Yes (suspends workflow) |
| Durable | Yes (survives DO eviction) |
| State | Preserved across sleep |
| Use case | Long-running workflows, drip campaigns, retry delays |

<Callout type="info">
During `$.sleep()`, the Durable Object can be evicted from memory. When the sleep completes, the workflow resumes exactly where it left off with full state preservation.
</Callout>

<Callout type="warn">
For short delays in non-durable contexts (like retry backoff), use `await new Promise(r => setTimeout(r, ms))` instead. `$.sleep()` has persistence overhead designed for long-running workflows.
</Callout>

## Domain Factory

Create callable domain objects that encapsulate business logic:

```typescript
import { Domain } from 'dotdo/workflows'

// Define a domain with handlers
const CRM = Domain('CRM', {
  createAccount: (customer) => ({
    id: generateId(),
    ...customer,
    createdAt: new Date()
  }),
  sendWelcome: (account) => {
    return sendEmail({
      to: account.email,
      template: 'welcome'
    })
  }
})

// Use in workflows - returns PipelinePromise
const account = CRM(customer).createAccount()
const emailResult = CRM(account).sendWelcome()

// Can be awaited when needed
const result = await account
```

### Composing Domains

```typescript
const Inventory = Domain('Inventory', {
  check: (product) => getStock(product.id),
  reserve: (product, quantity) => reserveStock(product.id, quantity),
  release: (reservation) => releaseStock(reservation.id)
})

const Shipping = Domain('Shipping', {
  calculate: (order) => calculateRates(order),
  create: (order, rate) => createShipment(order, rate)
})

// Compose in workflows
async function fulfillOrder(order: Order) {
  const stock = await Inventory(order.product).check()
  if (stock.available >= order.quantity) {
    const reservation = await Inventory(order.product).reserve(order.quantity)
    const rates = await Shipping(order).calculate()
    return Shipping(order).create(rates[0])
  }
}
```

### Handler Function Signature

Domain handlers receive context, args, and the $ workflow API:

```typescript
type HandlerFunction<TContext, TArgs, TResult> = (
  context: TContext,
  args: TArgs,
  $: WorkflowContext
) => TResult | Promise<TResult>

// Example with typed parameters
const Payment = Domain('Payment', {
  charge: async (card: Card, { amount }: { amount: number }, $) => {
    const result = await stripeClient.charges.create({
      amount,
      currency: 'usd',
      source: card.token
    })
    $.track('payment.charged', { amount, chargeId: result.id })
    return { chargeId: result.id, status: 'succeeded' }
  }
})
```

## User Context

Access the authenticated user from incoming requests:

```typescript
// $.user contains the authenticated user (or null if unauthenticated)
if ($.user) {
  console.log(`User ID: ${$.user.id}`)
  console.log(`Email: ${$.user.email}`)
  console.log(`Role: ${$.user.role}`)
}

// Use in event handlers
$.on.Customer.created(async (event) => {
  if ($.user) {
    console.log(`Customer created by: ${$.user.id}`)
    await audit.log({
      action: 'customer.created',
      actor: $.user.id,
      target: event.data.id
    })
  }
})

// Authorization based on role
$.on.Refund.requested(async (event) => {
  if ($.user?.role !== 'manager' && event.data.amount > 1000) {
    throw new Error('Large refunds require manager approval')
  }
  await processRefund(event.data)
})
```

### UserContext Interface

```typescript
interface UserContext {
  /** Unique user identifier */
  id: string
  /** User's email address (optional) */
  email?: string
  /** User's role for authorization (optional) */
  role?: string
}
```

<Callout type="info">
User context is extracted from `X-User-*` headers by the RPC auth middleware before forwarding requests to Durable Objects. The context is request-scoped and updated on each incoming request.
</Callout>

## Noun Registration

Register custom domain nouns with typed payloads for full type safety:

```typescript
// In your domain types file:
declare module '@dotdo/types' {
  interface NounRegistry {
    Customer: { id: string; email: string; name: string }
    Invoice: { id: string; amount: number; status: string }
    Order: { id: string; items: string[]; total: number }
    Product: { id: string; sku: string; price: number }
  }
}

// Now $.Customer, $.Invoice, $.Order are properly typed
const customer = $.Customer('cust-123')  // Returns DomainProxy
await customer.notify({ message: 'Hello!' })
await customer.updateProfile({ name: 'Alice' })

// Type-safe noun access
import { getNoun, isValidNoun } from '@dotdo/types'

const maybeNoun: string = 'Customer'
if (isValidNoun(maybeNoun)) {
  $[maybeNoun](id)  // Type-safe access
}
```

## Advanced Context APIs

WorkflowContext can be extended with specialized context APIs for common business operations.

### Feature Flags ($.flag)

```typescript
import { createFlagContext } from 'dotdo/workflows'

// Extend context with feature flags
const ctx = createFlagContext(baseContext)

// Check if flag is enabled for user
const enabled = await ctx.flag('dark-mode').isEnabled(userId)

// Get full evaluation with variant
const result = await ctx.flag('checkout-flow').get(userId)
if (result.enabled) {
  console.log(`Variant: ${result.variant}`)
  console.log(`Payload: ${result.payload}`)
}

// Manage flags
await ctx.flag('new-feature').setTraffic(50)  // 50% rollout
await ctx.flag('new-feature').enable()         // Enable for all
await ctx.flag('broken-feature').disable()     // Disable

// Fetch all flags for local evaluation
const allFlags = await ctx.flags.fetch()
const evaluation = ctx.flags.evaluate('my-flag', userId, allFlags)
```

### Analytics ($.analytics)

```typescript
import { createAnalyticsContext } from 'dotdo/workflows'

const ctx = createAnalyticsContext(baseContext)

// Web analytics
await ctx.analytics.web.pageview({ path: '/pricing', sessionId })
await ctx.analytics.web.session({ sessionId, userId })
const webMetrics = await ctx.analytics.web.summary('daily')

// Product analytics
await ctx.analytics.product.track('feature_used', { feature: 'export' })
await ctx.analytics.product.identify(userId, { plan: 'pro' })
const dau = await ctx.analytics.product.summary('daily')

// Financial analytics
await ctx.analytics.financial.revenue({ amount: 99, currency: 'USD' })
const mrr = await ctx.analytics.financial.summary('monthly')
```

### Data API ($.data)

```typescript
import { createDataContext } from 'dotdo/workflows'

const ctx = createDataContext(baseContext)

// Basic CRUD
await ctx.data.set('users', 'user-1', { name: 'Alice' })
const user = await ctx.data.get('users', 'user-1')
await ctx.data.delete('users', 'user-1')

// Query with filters
const results = await ctx.data.query('orders')
  .where('status', '==', 'pending')
  .where('total', '>', 100)
  .orderBy('createdAt', 'desc')
  .limit(10)
  .execute()

// Real-time subscriptions
const unsubscribe = ctx.data.watch('orders', (event) => {
  console.log(`Order ${event.type}: ${event.key}`)
})
```

### Specialized Data Namespaces

```typescript
// Event tracking
await ctx.track('purchase', { amount: 99, product: 'widget' })
const funnel = await ctx.track.funnel(['signup', 'checkout', 'purchase'])

// Metrics and KPIs
await ctx.measure('api_latency', 45, { endpoint: '/users' })
const p99 = await ctx.measure.percentile('api_latency', 99)

// A/B experiments
const variant = await ctx.experiment('checkout-v2').assign(userId)
await ctx.experiment('checkout-v2').track(userId, 'conversion', 1)

// Goals and OKRs
await ctx.goal('q4-revenue').record(50000)
const progress = await ctx.goal('q4-revenue').progress()

// Real-time streams
const stream = ctx.stream('events')
await stream.push({ type: 'click', target: 'button' })

// Entity event sourcing
await ctx.Entity('order-123').append({ type: 'item_added', sku: 'WIDGET' })
const state = await ctx.Entity('order-123').state()
```

## Error Handling Patterns

### Durable Execution Errors

When `$.do()` exhausts retries:

```typescript
import { WorkflowStepError } from 'dotdo/workflows'

try {
  await $.do('Payment.charge', { amount: 100 })
} catch (error) {
  if (error instanceof WorkflowStepError) {
    console.error(`Step ${error.stepId} failed after ${error.attempts} attempts`)
    console.error(`Cause: ${error.cause?.message}`)

    // Send to dead-letter queue or alert
    await $.send('dlq.payment', {
      stepId: error.stepId,
      attempts: error.attempts,
      error: error.message
    })
  }
}
```

### Handler Not Found

```typescript
import { HandlerNotFoundError } from 'dotdo/workflows'

try {
  await $.do('Unknown.method', data)
} catch (error) {
  if (error instanceof HandlerNotFoundError) {
    console.error(`Handler not found: ${error.path.join('.')}`)
  }
}
```

### Event Handler Errors

Failed event handlers are automatically sent to the dead-letter queue:

```typescript
$.on.Order.placed(
  async (event) => {
    // If this throws, it goes to DLQ
    await processOrder(event.data)
  },
  {
    maxRetries: 3,  // Retry from DLQ up to 3 times
    name: 'order-processor'
  }
)

// Handle DLQ events
$.on['dlq'].Order.placed(async (dlqEvent) => {
  console.error(`Order processing failed: ${dlqEvent.data.error}`)
  await alertOps(dlqEvent)
})
```

## Type Definitions

### Core Types

```typescript
// WorkflowContext type (full interface)
interface WorkflowContext extends NounAccessors {
  // Durability
  track(event: string, data: unknown): void
  send<T>(event: string, data: T): string
  try<T>(action: string, data: unknown, opts?: TryOptions): Promise<T>
  do<T>(action: string, data: unknown, opts?: DoOptions): Promise<T>

  // Events and Scheduling
  on: OnProxy
  every: ScheduleBuilder

  // AI Functions
  ai: AITemplateLiteralFn<string>
  write: AITemplateLiteralFn<WriteResult>
  summarize: AITemplateLiteralFn<string>
  list: AITemplateLiteralFn<string[]>
  extract: <T>(strings: TemplateStringsArray, ...values: unknown[]) => AIPipelinePromise<ExtractResult<T>>
  is: AITemplateLiteralFn<boolean>
  decide: DecideFn

  // Version Control
  branch(name: string): Promise<void>
  checkout(ref: string): Promise<void>
  merge(branch: string): Promise<void>

  // Utilities
  log(message: string, data?: unknown): void
  state: Record<string, unknown>
  user: UserContext | null
}

// Retry policy for $.do()
interface RetryPolicy {
  maxAttempts: number       // Default: 3
  initialDelayMs: number    // Default: 100
  maxDelayMs: number        // Default: 30000
  backoffMultiplier: number // Default: 2
  jitter: boolean           // Default: true
}

// Options for $.do()
interface DoOptions {
  retry?: Partial<RetryPolicy>
  timeout?: number
  stepId?: string
}

// Options for $.try()
interface TryOptions {
  timeout?: number
}

// User context from authentication
interface UserContext {
  id: string
  email?: string
  role?: string
}

// Domain event structure
interface DomainEvent<TData = unknown> {
  id: string
  verb: string
  source: string
  data: TData
  actionId?: string
  timestamp: Date
}

// Handler options for event subscriptions
interface HandlerOptions<TPayload = unknown> {
  priority?: number
  filter?: (event: DomainEvent<TPayload>) => boolean | Promise<boolean>
  name?: string
  maxRetries?: number
}
```

### Capability Types

```typescript
// Filesystem capability
interface FsCapability {
  read(path: string, opts?: FsReadOptions): Promise<string>
  write(path: string, content: string, opts?: FsWriteOptions): Promise<void>
  list(path: string, opts?: FsListOptions): Promise<FsEntry[]>
  exists(path: string): Promise<boolean>
  delete(path: string): Promise<void>
  mkdir(path: string, opts?: MkdirOptions): Promise<void>
  stat(path: string): Promise<FileStats>
  copy(src: string, dest: string): Promise<void>
  move(src: string, dest: string): Promise<void>
}

// Git capability
interface GitCapability {
  status(): Promise<GitStatus>
  add(files: string | string[]): Promise<void>
  commit(message: string): Promise<string | { hash: string }>
  push(remote?: string, branch?: string): Promise<void>
  pull(remote?: string, branch?: string): Promise<void>
  log(opts?: GitLogOptions): Promise<GitCommit[]>
  diff(ref?: string): Promise<string>
  clone?(url: string, dest: string, opts?: GitCloneOptions): Promise<void>
  checkout?(ref: string, opts?: { create?: boolean }): Promise<void>
  branch?(name: string, startPoint?: string): Promise<void>
  merge?(branch: string, opts?: { noFf?: boolean; squash?: boolean }): Promise<void>
  fetch?(remote?: string, branch?: string): Promise<void>
}

// Bash capability
interface BashCapability {
  exec(command: string, opts?: ExecOptions): Promise<ExecResult>
  spawn(command: string, args?: string[], opts?: SpawnOptions): SpawnedProcess
  run?(command: string, opts?: ExecOptions): Promise<string>
  which?(command: string): Promise<boolean>
}

// Rate limit capability
interface RateLimitCapability {
  check(key: string, opts?: RateLimitCheckOptions): Promise<RateLimitResult>
  consume(key: string, cost?: number): Promise<RateLimitResult>
  status(key: string): Promise<RateLimitResult>
  reset(key: string): Promise<void>
}
```

## Related

- [Thing](/docs/sdk/thing) - Base entity type
- [Events](/docs/concepts/events) - 5W+H event model
- [Functions](/docs/sdk/functions) - DOFunction type
- [Capabilities](/docs/lib/do-capabilities) - Capability modules
- [Proxy Chaining](/docs/rpc/proxy-chaining) - RPC proxy patterns
- [Workflow Runtime](/docs/sdk/workflow-runtime) - Durable execution engine
- [Rate Limiting](/docs/sdk/rate-limit) - Rate limit configuration
- [Promise Pipelining](/docs/concepts/promise-pipelining) - RPC optimization
