---
title: Promise Pipelining
description: Chain RPC calls without intermediate round-trips for efficient network usage
---

# Promise Pipelining

Promise pipelining allows you to chain multiple RPC calls into a single network request, eliminating the latency of intermediate round-trips. This is especially valuable when working with remote Durable Objects across Cloudflare's global network.

## The Problem: Sequential Round-trips

Without pipelining, each RPC call requires a full network round-trip:

```typescript
// WITHOUT pipelining: 3 network round-trips
const orders = await customer.getOrders()           // Round-trip 1
const filtered = orders.filter(o => o.total > 100)  // Local
const ids = filtered.map(o => o.id)                 // Local
await customer.notify(`Processed ${ids.length}`)    // Round-trip 2
```

If each round-trip takes 50ms, this sequence takes at least 100ms of network time.

## The Solution: Promise Pipelining

With pipelining, chain operations execute in a **single request**:

```typescript
import { pipeline } from 'dotdo/rpc'

// WITH pipelining: 1 network round-trip
const result = await pipeline(customer)
  .then('getOrders')
  .then('filter', (o) => o.total > 100)
  .then('map', (o) => o.id)
  .execute()
```

The entire chain is sent as a single request, with all operations executed server-side.

## Creating Pipelines

Use the `pipeline()` function to create a pipeline builder:

```typescript
import { pipeline, createRPCClient } from 'dotdo/rpc'

const customer = createRPCClient<CustomerDO>({
  target: 'https://customer.api.dotdo.dev/cust-123',
})

const builder = pipeline(customer)
```

### Chaining Methods

Use `.then()` to chain method calls:

```typescript
const builder = pipeline(customer)
  .then('getOrders')              // Call getOrders()
  .then('notify', 'Order ready')  // Then call notify('Order ready')
```

Each `.then()` takes a method name and optional arguments.

### Executing the Pipeline

Use `.execute()` to run the pipeline and get the final result:

```typescript
const result = await pipeline(customer)
  .then('getOrders')
  .then('filter', (o) => o.total > 100)
  .execute()

console.log(result)  // Filtered orders array
```

## Pipeline Operations

### Method Calls

Call any method on the target:

```typescript
await pipeline(customer)
  .then('charge', 99.99)
  .execute()
```

### Array Operations

Apply transformations to array results:

```typescript
const orderIds = await pipeline(customer)
  .then('getOrders')
  .then('filter', (order) => order.status === 'pending')
  .then('map', (order) => order.id)
  .execute()
```

Supported array operations:
- `filter` - Filter elements by predicate
- `map` - Transform elements

### Conditional Branching

Use `branch` for conditional logic within pipelines:

```typescript
const result = await pipeline(customer)
  .then('getOrders')
  .then('branch', {
    condition: (orders) => orders.length > 0,
    ifTrue: (orders) => orders[0],      // Return first order
    ifFalse: () => null,                 // Return null if empty
  })
  .execute()
```

## Inspecting Pipelines

### The Execution Plan

Use `.plan()` to inspect what will be executed:

```typescript
const builder = pipeline(customer)
  .then('getOrders')
  .then('filter', (o) => o.total > 100)
  .then('notify', 'Processed!')

const plan = builder.plan()
console.log(plan)
// [
//   { method: 'getOrders', args: [], index: 0 },
//   { method: 'filter', args: [Function], index: 1 },
//   { method: 'notify', args: ['Processed!'], index: 2 }
// ]
```

This is useful for:
- Debugging pipeline construction
- Logging and monitoring
- Testing pipeline structure

### PipelineStep Structure

Each step in the plan has:

| Property | Type | Description |
|----------|------|-------------|
| `method` | `string` | Method name to call |
| `args` | `unknown[]` | Arguments for the method |
| `index` | `number` | Position in the pipeline (0-based) |

## Error Handling

### Pipeline Errors

Errors include context about where the failure occurred:

```typescript
try {
  await pipeline(customer)
    .then('getOrders')
    .then('invalidMethod')  // This will fail
    .execute()
} catch (error) {
  console.error(error.message)
  // "Method 'invalidMethod' failed at pipeline step 1"
}
```

### Partial Results

On failure, you can access results from completed steps:

```typescript
try {
  await pipeline(customer)
    .then('getOrders')      // Step 0: succeeds
    .then('failingMethod')  // Step 1: fails
    .execute()
} catch (error) {
  if (error.partialResults) {
    console.log('Completed steps:', error.partialResults.length)
    console.log('Orders from step 0:', error.partialResults[0])
  }
}
```

The `partialResults` array contains results from all steps that completed before the failure.

### RPCError Properties

Pipeline errors include full RPC context:

| Property | Type | Description |
|----------|------|-------------|
| `message` | `string` | Error description |
| `code` | `string` | Error code (`'RPC_ERROR'`) |
| `method` | `string` | Method that failed |
| `target` | `string` | Target URL or stub identifier |
| `partialResults` | `unknown[]` | Results from completed steps |

## Nested Pipelines

Pipelines can be nested for complex operations:

```typescript
const result = await pipeline(customer)
  .then('getOrders')
  .then('map', (order) =>
    pipeline(order)
      .then('items')
      .execute()
  )
  .execute()
```

<Callout type="info">
Nested pipelines are resolved recursively. Each nested pipeline may result in additional network calls depending on the data locality.
</Callout>

## Performance Characteristics

### Network Efficiency

| Operation | Round-trips | Notes |
|-----------|-------------|-------|
| Sequential calls | N | One per call |
| Pipelined calls | 1 | All in single request |
| Nested pipelines | 1-N | Depends on nesting depth |

### When to Use Pipelining

**Use pipelining when:**
- Making multiple related calls to the same target
- Performing filter/map operations on remote data
- Building conditional workflows on remote state

**Consider alternatives when:**
- Making a single call
- Calls are to different targets
- You need intermediate results for local logic

## Advanced Patterns

### Pipeline with Capabilities

Combine pipelining with capability-based access:

```typescript
const readCap = createCapability(customer, ['getOrders'])

const result = await pipeline(readCap)
  .then('getOrders')
  .then('filter', (o) => o.total > 100)
  .execute()
```

### Conditional Notification Pattern

```typescript
const summary = await pipeline(customer)
  .then('getOrders')
  .then('filter', (o) => o.status === 'shipped')
  .then('branch', {
    condition: (orders) => orders.length > 5,
    ifTrue: () => 'Many orders shipped!',
    ifFalse: (orders) => `${orders.length} orders shipped`,
  })
  .execute()

// Use the summary for notification
await customer.notify(summary)
```

### Aggregation Pipeline

```typescript
const stats = await pipeline(customer)
  .then('getOrders')
  .then('map', (order) => ({
    total: order.total,
    items: order.items.length,
  }))
  .then('branch', {
    condition: (mapped) => mapped.length > 0,
    ifTrue: (mapped) => ({
      totalRevenue: mapped.reduce((sum, o) => sum + o.total, 0),
      totalItems: mapped.reduce((sum, o) => sum + o.items, 0),
      count: mapped.length,
    }),
    ifFalse: () => ({ totalRevenue: 0, totalItems: 0, count: 0 }),
  })
  .execute()
```

## API Reference

### `pipeline<T>(target)`

Create a pipeline builder for a target.

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `target` | `T` | Yes | RPC client or object to pipeline |

**Returns:** `PipelineBuilder<T>`

### `PipelineBuilder<T>.then(method, ...args)`

Add a step to the pipeline.

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `method` | `keyof T` | Yes | Method name to call |
| `args` | `unknown[]` | No | Arguments for the method |

**Returns:** `PipelineBuilder<T>`

### `PipelineBuilder<T>.execute()`

Execute the pipeline and return the final result.

**Returns:** `Promise<T>`

**Throws:** `RPCError` with `partialResults` on failure

### `PipelineBuilder<T>.plan()`

Get the execution plan without executing.

**Returns:** `PipelineStep[]`

### `PipelineStep`

```typescript
interface PipelineStep {
  method: string
  args: unknown[]
  index: number
}
```

## Next Steps

- [Serialization](/rpc/serialization) - How data is encoded for transfer
- [Capabilities](/rpc/capabilities) - Secure pipeline execution
