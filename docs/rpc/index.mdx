---
title: Cap'n Web RPC
description: Object-capability RPC with promise pipelining - the foundation of dotdo's performance
---

import { Callout } from 'fumadocs-ui/components/callout'

# Cap'n Web RPC

<Callout type="info">
**New to RPC?** If you're just getting started, you can safely skip this section. Promise pipelining happens automatically—you don't need to understand it to use dotdo effectively. Just write natural code and the system optimizes it for you.
</Callout>

This is how dotdo achieves impossible performance. Cap'n Web is an object-capability RPC protocol with **promise pipelining**—the ability to pass unawaited promises as parameters, batching entire call graphs into single network round trips.

```typescript
const spec = priya`define the MVP`           // RpcPromise (not awaited)
const app = ralph`build ${spec}`              // spec passed as promise
const deployed = tom`ship ${app}`             // app passed as promise
// ONE network round trip when we finally await
```

Three agent calls. One round trip. The entire pipeline executes on the server.

## Why This Matters

Traditional RPC forces a round trip per call:

```typescript title="Traditional RPC - 3 Round Trips"
const spec = await priya`define the MVP`     // Round trip 1
const app = await ralph`build ${spec}`        // Round trip 2
const deployed = await tom`ship ${app}`       // Round trip 3
```

Each `await` waits for the response before sending the next request. Three operations equals three round trips, with latency compounding at each step.

Cap'n Web eliminates this:

```typescript title="Cap'n Web - 1 Round Trip"
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = await tom`ship ${app}`
```

When you pass `spec` to Ralph without awaiting, the system doesn't need to send it back to the client. Instead, it builds a **pipeline graph** and sends it all at once.

<Callout type="info" title="The Core Insight">
A promise is just a reference to a future value. If the server knows what to do with that value, why send it back to the client first?
</Callout>

### Real-World Latency Impact

With typical 100ms network round-trip latency:

| Approach | Round Trips | Total Latency |
|----------|-------------|---------------|
| **Traditional REST** | 3 sequential requests | ~300ms |
| **Promise pipelining** | 1 batched request | ~100ms |

That's a **3x improvement** for a simple 3-step operation. For complex pipelines with 5-10 agent calls, the difference becomes even more dramatic—1000ms vs 100ms.

## RpcPromise vs Promise

Agent calls don't return regular JavaScript Promises. They return `RpcPromise`—a special type that acts as both a promise and a proxy.

```typescript
const spec = priya`define the MVP`  // Type: RpcPromise<Spec>

// You can await it like a promise
const result = await spec

// Or you can pass it to another call without awaiting
const app = ralph`build ${spec}`

// Or you can call methods on it (proxy behavior)
const summary = spec.summarize()

// Or access properties
const title = spec.title

// All without resolving the promise!
```

This dual nature is what makes pipelining possible. An RpcPromise is a **stub**—a local representative of a remote value that doesn't exist yet.

## How Pipelines Execute

When you write pipelined code, the client builds a graph:

```typescript
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = tom`ship ${app}`
await deployed
```

The client constructs:

```
Graph:
  0: priya("define the MVP")
  1: ralph("build", $0)      // Reference to result 0
  2: tom("ship", $1)         // Reference to result 1

Return: $2
```

This entire graph is sent in **one request**. The server:

1. Executes node 0 (Priya), stores result
2. Executes node 1 (Ralph) with the stored result
3. Executes node 2 (Tom) with that result
4. Returns only the final result to the client

No intermediate values cross the network.

## Start Here

<Cards>
  <Card title="Understanding Promise Pipelining" href="/docs/rpc/understanding-promise-pipelining">
    **The essential guide.** Mental model, visual diagrams, and why unawaited promises eliminate network round trips.
  </Card>
</Cards>

## Learning Path

Choose your level based on your goals:

### Level 1: Just Use It (Automatic)

You don't need to understand pipelining to benefit from it. Write natural code:

```typescript
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
await app
```

The system automatically pipelines your calls. Move on to building your product.

### Level 2: Understanding Pipelining Basics

Learn when pipelining helps and when you need to await:

1. Read [Understanding Promise Pipelining](/docs/rpc/understanding-promise-pipelining) for the mental model
2. Review [Await Patterns](/docs/rpc/await-patterns) for practical rules
3. Practice identifying where pipelines break

### Level 3: Advanced Optimization

Master the full toolkit for maximum performance:

1. [Proxy Chaining](/docs/rpc/proxy-chaining) for method calls on unresolved values
2. [Magic Map](/docs/rpc/magic-map) for server-side collection transforms
3. [Pipeline Inspection](/docs/rpc/pipelines#pipeline-inspection) for debugging complex graphs

## Key Concepts

<Cards>
  <Card title="Client SDK" href="/docs/rpc/client">
    Connect from any client—browsers, Node.js, Workers—with the same promise pipelining.
  </Card>
  <Card title="Promise Pipelining" href="/docs/rpc/pipelines">
    Deep dive into how pipelines batch multiple calls into single round trips.
  </Card>
  <Card title="Magic Map" href="/docs/rpc/magic-map">
    The .map() that runs on the server—transform collections without awaiting.
  </Card>
  <Card title="Await Patterns" href="/docs/rpc/await-patterns">
    When to await and when to pipeline—the complete rules.
  </Card>
  <Card title="Proxy Chaining" href="/docs/rpc/proxy-chaining">
    Method chaining on RpcPromises—call methods on values that don't exist yet.
  </Card>
</Cards>

## The Signature Pattern

This is the canonical dotdo startup launch:

```typescript title="One Round Trip Startup"
import { Startup } from 'dotdo'
import { priya, ralph, tom, mark, sally } from 'agents.do'

export class MyStartup extends Startup {
  async launch() {
    // Build the pipeline - no awaits!
    const spec = priya`define the MVP for ${this.hypothesis}`
    const app = ralph`build ${spec}`
    const deployed = tom`ship ${app}`
    const announced = mark`announce ${deployed}`
    const selling = sally`start selling ${announced}`

    // ONE round trip executes the entire chain
    return await selling
  }
}
```

Five agent calls. One network round trip. The entire pipeline executes on the server in sequence.

<Callout type="warn" title="Don't Await Until You Need To">
Every `await` is a potential pipeline flush. If you don't need the value for local computation (branching, loops, display), don't await it.
</Callout>

## When Pipelining Breaks

Pipelining works when the server knows what to do with results. It breaks when you need local decisions:

```typescript title="Await Required for Branching"
const analysis = await priya`analyze the market`

// We need the actual value to branch
if (analysis.opportunity === 'high') {
  const spec = priya`define aggressive MVP`
  return await ralph`build ${spec}`
} else {
  const spec = priya`define lean experiment`
  return await ralph`build ${spec}`
}
```

Here the `await` is necessary—the client needs to inspect `analysis.opportunity` to decide which branch to take. The server can't know this in advance.

See [Await Patterns](/docs/rpc/await-patterns) for the complete rules.

## Common Anti-Patterns

Avoid these mistakes that break pipelining:

### Awaiting Every Call

```typescript title="Anti-Pattern: Sequential Awaits"
const spec = await priya`define the MVP`      // Round trip 1
const app = await ralph`build ${spec}`         // Round trip 2
const deployed = await tom`ship ${app}`        // Round trip 3
// 3 round trips = ~300ms
```

```typescript title="Fix: Pipeline Until Final Result"
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = await tom`ship ${app}`        // 1 round trip = ~100ms
```

### Await-Then-Pass

```typescript title="Anti-Pattern: Unnecessary Await"
const spec = await priya`define the MVP`  // Why await here?
const app = ralph`build ${spec}`           // spec is now resolved value
```

If you're just passing `spec` to another call, don't await it.

### Async Map Callbacks

```typescript title="Anti-Pattern: Await in Map"
const tasks = await priya`list tasks`
const results = await Promise.all(
  tasks.map(async task => await ralph`implement ${task}`)  // N round trips!
)
```

```typescript title="Fix: Use Magic Map"
const tasks = priya`list tasks`
const results = await tasks.map(task => ralph`implement ${task}`)  // 1 round trip
```

### How to Identify Issues

Watch for these warning signs:

1. **Multiple `await` keywords in sequence** without local branching between them
2. **Async functions that immediately await** then pass to another call
3. **`Promise.all` with async callbacks** that await inside the callback
4. **Round-trip counts** higher than expected in performance profiling

Use `.describe()` on any RpcPromise to visualize the pipeline graph before execution.

## Object Capabilities

Cap'n Web is built on the **object-capability model**. Every RpcPromise is a capability—a reference that grants specific permissions to act on a remote object.

```typescript
// Get a capability to a Customer DO
const customer = $.Customer('cus_123')

// The capability lets you call methods
await customer.notify({ message: 'Welcome!' })
await customer.updateProfile({ name: 'Alice' })

// But not methods you don't have access to
// await customer.deleteAccount()  // Would fail if not authorized
```

Capabilities are:
- **Unforgeable** - You can't create a reference you weren't given
- **Attenuated** - You can delegate with reduced permissions
- **Revocable** - Capabilities can be invalidated

This provides fine-grained security without authentication headers or tokens.

## Performance Characteristics

| Pattern | Round Trips | Latency (200ms RTT) |
|---------|-------------|---------------------|
| 5 awaited calls | 5 | 1000ms |
| 5 pipelined calls | 1 | 200ms |
| 5 parallel + pipeline | 1 | 200ms |
| Mixed (3 await, 2 pipeline) | 3 | 600ms |

Pipeline aggressively. Your users will thank you.

## Next Steps

Start with [Promise Pipelining](/docs/rpc/pipelines) for the deep dive, or jump to [Await Patterns](/docs/rpc/await-patterns) if you want the practical rules immediately.
