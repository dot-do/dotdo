---
title: DB Proxy Patterns
description: Cap'n Proto-style promise pipelining for database operations with fluent query building
---

import { Callout } from 'fumadocs-ui/components/callout'

# DB Proxy Patterns

The `db/proxy` module implements Cap'n Proto-style promise pipelining for database operations. This enables chaining multiple database operations without awaiting intermediate results, reducing network round trips and improving performance.

## The Problem

Traditional database access requires awaiting each operation before using its result:

```typescript title="Traditional Database Access - Multiple Round Trips"
// 3 network round trips
const lead = await db.getLead('lead-123')           // Round trip 1
const company = await db.getCompany(lead.companyId) // Round trip 2
const contacts = await db.getContacts(company.id)   // Round trip 3
```

Each `await` forces a network round trip. The client sends a request, waits for the response, then sends the next request. For distributed systems with network latency, this adds up quickly.

## The Solution: Promise Pipelining

With promise pipelining, operations chain without intermediate awaits:

```typescript title="Promise Pipelined - Single Round Trip"
// 1 network round trip
const contacts = await db.Lead
  .get('lead-123')
  .expand('company')
  .expand('contacts')
```

The entire pipeline is sent to the server as a single operation. The server executes it in sequence, and only the final result crosses the network.

<Callout type="info" title="Key Insight">
Each method returns a new `DBPromise` - a thenable that accumulates operations. No database calls happen until you `await`. This is the core of promise pipelining: build the computation graph first, execute it once.
</Callout>

## Architecture

The proxy system has three main components:

```
+------------------------------------------------------------------+
|  db.Lead                    (DBProxy)                             |
|  - Property access creates EntityAccessor                         |
+----------------------------+-------------------------------------+
                             |
                             v
+----------------------------+-------------------------------------+
|  EntityAccessor                                                   |
|  - get(id), list(), find(), search()                              |
|  - create(), update(), delete()                                   |
|  - Template literal: db.Lead`who closed deals?`                   |
+----------------------------+-------------------------------------+
                             |
                             v
+----------------------------+-------------------------------------+
|  DBPromise                                                        |
|  - Accumulates operations (filter, sort, limit, expand)           |
|  - Executes lazily when awaited                                   |
|  - Results cached (memoized)                                      |
+------------------------------------------------------------------+
```

### DBProxy

The entry point that intercepts property access. When you write `db.Lead`, the proxy creates and caches an `EntityAccessor` for that type.

```typescript
const db = createDBProxy({ store: this.things })

// Property access returns EntityAccessor
const leads = db.Lead   // EntityAccessor<Lead>
const orders = db.Order // EntityAccessor<Order>

// Accessors are cached
db.Lead === db.Lead // true
```

### EntityAccessor

Provides CRUD operations for a specific entity type. Supports both traditional methods and natural language queries via template literals.

```typescript
// Traditional CRUD
const lead = await db.Lead.get('lead-123')
const leads = await db.Lead.list()
const newLead = await db.Lead.create({ name: 'Acme Corp' })

// Natural language query
const deals = await db.Lead`who closed deals this month?`
```

### DBPromise

The fluent query builder. Each method returns a **new** DBPromise with the operation added to an internal queue. No execution happens until you await.

```typescript
// Building a pipeline - no execution yet
const pipeline = db.Lead
  .filter(lead => lead.status === 'active')  // Returns new DBPromise
  .orderBy('score', 'desc')                   // Returns new DBPromise
  .limit(10)                                  // Returns new DBPromise

// Execution happens HERE when awaited
const results = await pipeline
```

## Performance Benefits

### Reduced Network Round Trips

The most significant benefit is reducing network round trips. With typical 100ms latency:

| Pattern | Operations | Round Trips | Total Latency |
|---------|------------|-------------|---------------|
| Sequential awaits | 3 | 3 | ~300ms |
| Promise pipelined | 3 | 1 | ~100ms |
| Complex pipeline | 5 | 1 | ~100ms |

### Lazy Execution

Operations are accumulated and optimized before execution:

```typescript
// These operations are NOT executed yet
const query = db.Lead
  .filter(l => l.score > 50)
  .filter(l => l.status === 'active')  // Combines with previous filter
  .limit(100)
  .limit(10)  // Overrides previous limit

// Only executed when awaited - with optimizations applied
const results = await query
```

### Result Memoization

Once executed, results are cached. Subsequent awaits return the cached result:

```typescript
const query = db.Lead.limit(10)

const first = await query   // Executes query, caches result
const second = await query  // Returns cached result (no re-execution)
```

### Immutability

Each operation creates a new DBPromise, preserving immutability:

```typescript
const base = db.Lead.filter(l => l.active)
const topTen = base.limit(10)      // New DBPromise
const sorted = base.orderBy('score')  // New DBPromise from same base

// base is unchanged - both topTen and sorted derive from it
```

## Quick Start

```typescript
import { createDBProxy } from 'dotdo/db/proxy'

class MyDO extends DOBase {
  get db() {
    return createDBProxy({
      store: this.things,
      searchStore: this.search,
    })
  }

  async process() {
    // Fluent query building
    const results = await this.db.Lead
      .filter(lead => lead.status === 'active')
      .orderBy('score', 'desc')
      .limit(10)

    // Natural language query
    const deals = await this.db.Lead`who closed deals this month?`

    // Batch processing with concurrency
    await this.db.Lead
      .filter(l => l.needsEmail)
      .forEach(async lead => {
        await sendEmail(lead)
      }, {
        concurrency: 5,
        persist: true,
        onProgress: p => console.log(`${p.completed}/${p.total}`)
      })
  }
}
```

## DBPromise API Reference

### Filtering

```typescript
// Predicate function
const active = await db.User
  .filter(user => user.status === 'active' && user.age >= 18)

// Field equality (convenience)
const admins = await db.User
  .where('role', 'admin')

// Operators for complex conditions
const highValue = await db.Customer
  .whereOp('revenue', 'gte', 100000)
  .whereOp('status', 'in', ['active', 'premium'])
```

#### Available Operators

| Operator | Description | Example |
|----------|-------------|---------|
| `eq` | Equal | `whereOp('status', 'eq', 'active')` |
| `neq` | Not equal | `whereOp('deleted', 'neq', true)` |
| `gt` | Greater than | `whereOp('score', 'gt', 80)` |
| `gte` | Greater than or equal | `whereOp('age', 'gte', 18)` |
| `lt` | Less than | `whereOp('count', 'lt', 10)` |
| `lte` | Less than or equal | `whereOp('price', 'lte', 100)` |
| `in` | In set | `whereOp('category', 'in', ['A', 'B'])` |
| `nin` | Not in set | `whereOp('status', 'nin', ['deleted'])` |
| `contains` | String contains | `whereOp('name', 'contains', 'Smith')` |
| `startsWith` | String prefix | `whereOp('email', 'startsWith', 'admin')` |
| `endsWith` | String suffix | `whereOp('domain', 'endsWith', '.com')` |

### Transformation

```typescript
// Map results
const names = await db.User
  .map(user => ({ $id: user.$id, displayName: `${user.firstName} ${user.lastName}` }))

// Select specific fields
const summary = await db.Order
  .select('$id', 'total', 'status')

// Expand relationships (eager loading)
const leadWithCompany = await db.Lead
  .expand('company')
  .expand('contacts')

// Nested expansion
const full = await db.Lead
  .expand('company.employees')  // Dot notation for nested relations
```

### Ordering

```typescript
// Custom comparator
const sorted = await db.Product
  .sort((a, b) => b.price - a.price)

// Field-based ordering
const recent = await db.Order
  .orderBy('createdAt', 'desc')
```

### Pagination

```typescript
// Limit results
const top10 = await db.Lead.limit(10)

// Offset-based pagination
const page2 = await db.Lead
  .offset(20)
  .limit(10)

// Cursor-based pagination
const afterId = await db.Lead
  .after('last-cursor-id')
  .limit(10)

// Paginate helper with cursor
const page = await db.Lead.paginate({
  limit: 10,
  cursor: previousCursor
})
const results = await page
const nextCursor = await page.nextCursor
```

### Aggregation

```typescript
// Count results
const total = await db.User
  .filter(u => u.active)
  .count()

// Get first result
const first = await db.Order
  .orderBy('createdAt', 'desc')
  .first()

// Check existence
const hasAdmins = await db.User
  .where('role', 'admin')
  .exists()
```

## Natural Language Queries

Query using template literals with AI-powered understanding:

```typescript
// Simple query
const deals = await db.Lead`who closed deals this month?`

// With interpolation
const region = 'West Coast'
const topLeads = await db.Lead`top 10 leads by revenue in ${region}`

// Complex query
const year = 2024
const status = 'active'
const report = await db.Order`
  summarize orders where status is ${status}
  from ${year} grouped by quarter
`
```

<Callout type="info" title="AI-Powered Understanding">
Natural language queries use Cloudflare AI to parse intent. The system extracts filters, ordering, and limits from natural language and translates them to database operations.
</Callout>

## Batch Processing

Process items with concurrency control, retries, and crash recovery:

```typescript
const result = await db.Lead
  .filter(lead => lead.status === 'new')
  .forEach(async (lead, index) => {
    await sendEmail(lead.email, 'Welcome!')
  }, {
    // Concurrency control
    concurrency: 5,

    // Retry configuration
    maxRetries: 3,
    retryDelay: 1000,  // Exponential backoff

    // Crash recovery
    persist: true,
    resume: 'previous-run-id',  // Resume from failed run

    // Progress callback
    onProgress: (progress) => {
      console.log(`${progress.completed}/${progress.total}`)
      console.log(`Rate: ${progress.rate.toFixed(1)} items/sec`)
      console.log(`ETA: ${Math.round(progress.eta / 1000)}s`)
    },

    // Error handling
    onError: (error, item, attempt) => {
      if (error.message.includes('rate limit')) {
        return 'retry'  // Retry with backoff
      }
      if (error.message.includes('invalid email')) {
        return 'skip'   // Skip this item
      }
      return 'abort'    // Stop processing
    }
  })

console.log(`Completed: ${result.completed}`)
console.log(`Failed: ${result.failed}`)
console.log(`Skipped: ${result.skipped}`)
console.log(`Run ID: ${result.runId}`)  // For resumption
```

## Relationship Expansion

The `expand()` operation fetches related entities and attaches them to query results.

### Single Relationship

```typescript
const leadsWithCompany = await db.Lead
  .filter(lead => lead.status === 'active')
  .expand('company')

// Each lead now has lead.data.company populated
```

### Multiple Relationships

```typescript
const orders = await db.Order
  .expand('customer', 'lineItems')

// Both customer and lineItems are attached
```

### Nested Expansion

```typescript
const leads = await db.Lead
  .expand('company.employees')

// lead.data.company.data.employees is populated
```

### Circular Reference Handling

The expand operation automatically detects circular references to prevent infinite loops. When a cycle is detected, the circular reference is set to `null`:

```typescript
// If Employee -> Manager -> Employee creates a cycle
const employees = await db.Employee
  .expand('manager')  // Circular refs resolved safely
```

## When to Await

The golden rule: **await when you need the value locally**.

| Scenario | Await? | Reason |
|----------|--------|--------|
| Chain to another operation | No | Keep pipeline intact |
| Branch on the value | Yes | Client needs to decide |
| Loop over the value | Yes | Client needs to iterate |
| Display/log the value | Yes | Client needs the bytes |
| Return to caller | Maybe | Depends if caller continues |

```typescript
// DON'T await when chaining
const pipeline = db.Lead
  .filter(l => l.active)    // Don't await
  .orderBy('score', 'desc') // Don't await
  .limit(10)                // Don't await

// DO await for control flow
const analysis = await db.Lead.first()
if (analysis?.status === 'hot') {
  // Different path based on analysis
}

// DO await for iteration
const tasks = await db.Task.list()
for (const task of tasks) {
  // Need actual array to loop
}
```

<Callout type="warn" title="Every Await is a Batch Boundary">
When you `await`, you flush the current pipeline. Unnecessary awaits fragment your pipelines and increase round trips.
</Callout>

## Custom Data Sources

Implement `DBPromiseDataSource` for custom backends:

```typescript
import { DBPromise, DBPromiseDataSource } from 'dotdo/db/proxy'

class CustomDataSource implements DBPromiseDataSource {
  async fetchAll(): Promise<ThingEntity[]> {
    return this.api.fetchEntities()
  }

  async fetchPage(options: {
    limit: number
    offset?: number
    after?: string
  }): Promise<ThingEntity[]> {
    return this.api.fetchPage(options)
  }

  async count(): Promise<number> {
    return this.api.count()
  }

  getEntityType(): string {
    return 'CustomEntity'
  }

  // Optional: for crash recovery
  async persistProgress(tracker: ForEachProgress): Promise<void> {
    await this.storage.save(tracker.runId, tracker)
  }

  async loadProgress(runId: string): Promise<{ completedIds: string[] } | null> {
    return this.storage.load(runId)
  }

  // Optional: for relationship expansion
  async resolveRelationship(
    item: ThingEntity,
    relationName: string
  ): Promise<ThingEntity | ThingEntity[] | null> {
    const rel = this.relationships.get(relationName)
    if (!rel) return null
    return this.api.fetchRelated(item.$id, rel)
  }
}

// Use custom data source
const dataSource = new CustomDataSource(api)
const query = new DBPromise(dataSource)
  .filter(item => item.active)
  .limit(10)
```

## Performance Comparison

| Pattern | Code | Round Trips |
|---------|------|-------------|
| **Anti-pattern** | `await a; await b; await c` | 3 |
| **Better** | `a; b; await c` | 1 |
| **Pipeline** | `a.then(b).then(c)` | 1 |
| **DBPromise** | `db.X.filter().sort().limit()` | 1 |

The DBPromise pattern is optimal for database operations because:

1. **Single execution point** - All operations batch at the final `await`
2. **Server-side optimization** - The database can optimize the combined query
3. **Minimal data transfer** - Only the final result crosses the network
4. **Type safety** - Full TypeScript support through the chain

## Summary

| Do | Don't |
|----|-------|
| Chain operations without awaiting | Await every operation |
| Use `.filter().sort().limit()` chains | Split into separate queries |
| Await once at the end | Await intermediate results |
| Use `expand()` for relationships | Fetch related data manually |
| Use `forEach()` for batch processing | Loop with individual awaits |

Promise pipelining in the DB proxy reduces network overhead, improves performance, and provides a clean, fluent API for database operations.

## Related

- [Promise Pipelining](/docs/rpc/pipelines) - Core pipelining concepts
- [Understanding Promise Pipelining](/docs/rpc/understanding-promise-pipelining) - Mental model and diagrams
- [Await Patterns](/docs/rpc/await-patterns) - When to await and when to pipeline
- [Magic Map](/docs/rpc/magic-map) - Server-side array transforms
