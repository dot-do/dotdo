---
title: Await Patterns
description: Pattern-focused examples for common await scenarios in promise pipelining
---

import { Callout } from 'fumadocs-ui/components/callout'

# Await Patterns

This page provides pattern-focused examples for common await scenarios. For the definitive decision tree and quick reference, see [When to Await](/docs/rpc/when-to-await).

Every `await` is a decision point. Await too early and you break pipelining. Await too late and you lose control. This guide covers exactly when to use each pattern.

## The Core Rule

**Don't await until you need the value locally.**

If the next step is another RPC call that will use the value, don't await—pass the RpcPromise directly. Only await when:

1. You need to inspect the value (branching, conditionals)
2. You need to iterate over the value (loops)
3. You need to display or log the value
4. You're at a function boundary returning to non-pipeline code

## Pattern: Sequential Pipeline (No Awaits)

The ideal case—chain operations without any intermediate awaits:

```typescript title="Best - Single Round Trip"
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = tom`ship ${app}`
const announced = mark`announce ${deployed}`
const result = await announced  // Only await at the end
```

**When to use:** When each step's output feeds directly into the next step with no local logic needed.

**Round trips:** 1

## Pattern: Branching (Must Await)

When you need the value to decide what to do next:

```typescript title="Await for Conditional Logic"
const analysis = await priya`analyze ${market}`

if (analysis.opportunity === 'high') {
  const spec = priya`define aggressive MVP`
  return await ralph`build ${spec}`
} else if (analysis.opportunity === 'medium') {
  const spec = priya`define lean MVP`
  return await ralph`build ${spec}`
} else {
  return null  // Not worth pursuing
}
```

**When to use:** When you need to inspect a property to determine the next action.

**Round trips:** 2 (one for analysis, one for build)

<Callout type="info" title="Minimize Branching Awaits">
Sometimes you can restructure to avoid branching:

```typescript
// Instead of branching on opportunity level
const spec = priya`define MVP appropriate for ${market} opportunity level`
const app = ralph`build ${spec}`  // Priya handles the branching
```

Let the agent make the decision instead of awaiting to branch locally.
</Callout>

## Pattern: Loops (Must Await)

When you need to iterate:

```typescript title="Await for Iteration"
const tasks = await priya`break down ${spec} into tasks`

// Must iterate over the resolved array
for (const task of tasks) {
  const impl = ralph`implement ${task}`
  const reviewed = tom`review ${impl}`
  await reviewed  // Await each iteration
}
```

**When to use:** When you need to loop over results with `for`, `forEach`, etc.

**Round trips:** 1 + N (one for tasks, one per iteration)

<Callout type="warn" title="Use Magic Map When Possible">
Often you can replace loops with Magic Map when using the workflow proxy:

```typescript
// Instead of a for loop - use workflow proxy for Magic Map
const tasks = $.Agent('priya')`break down ${spec} into tasks`
const impls = tasks.map(task => $.Agent('ralph')`implement ${task}`)
const reviewed = impls.map(impl => $.Agent('tom')`review ${impl}`)
await reviewed  // ONE round trip
```

Magic Map keeps everything in a single pipeline when using `$`.
</Callout>

## Pattern: Parallel Independent Operations

When operations don't depend on each other:

```typescript title="Parallel with Promise.all"
const spec = priya`define the MVP`
const marketing = mark`draft marketing plan`
const prospects = sally`identify prospects`

// All three run in parallel, one round trip
const [specResult, marketingResult, prospectsResult] = await Promise.all([
  spec,
  marketing,
  prospects
])
```

**When to use:** When you need multiple results that don't depend on each other.

**Round trips:** 1

You can also mix parallel with sequential:

```typescript title="Parallel into Sequential"
const spec = priya`define the MVP`
const marketing = mark`draft marketing plan`

// These two are parallel
// But ralph depends on spec (sequential)
const app = ralph`build ${spec}`

// tom depends on both app and marketing
const launch = await tom`coordinate ${app} with ${marketing}`
```

Still one round trip—the server figures out the execution order.

## Pattern: Fire and Forget

When you don't need the result at all:

```typescript title="No Await - Background Work"
// These run in the background
mark`send newsletter`
sally`update CRM with ${event}`

// Continue without waiting
return { status: 'event_processed' }
```

**When to use:** For notifications, analytics, logging—anything where you don't need confirmation.

**Round trips:** 0 for the main flow (background operations happen asynchronously)

<Callout type="warn" title="Fire and Forget Has No Error Handling">
If you don't await, you won't catch errors. Use this only for operations where failures are acceptable.
</Callout>

## Pattern: Checkpoint Awaits

When you need to ensure completion before a critical section:

```typescript title="Strategic Checkpoints"
// Phase 1: Build
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const tested = quinn`test ${app}`

// Checkpoint: Ensure everything passed before shipping
const testResults = await tested
if (!testResults.allPassed) {
  throw new Error('Tests failed')
}

// Phase 2: Ship (only if tests passed)
const deployed = tom`ship ${app}`
const announced = mark`announce ${deployed}`
return await announced
```

**When to use:** When you need to gate progression on success.

**Round trips:** 2 (one for build/test, one for ship/announce)

## Pattern: Function Boundaries

When returning from functions that will be called by non-pipeline code:

```typescript title="Await at Return"
async function buildProduct(hypothesis: string) {
  const spec = priya`define MVP for ${hypothesis}`
  const app = ralph`build ${spec}`
  const tested = quinn`test ${app}`

  // Await at the return boundary
  return await tested
}

// Caller gets resolved value
const product = await buildProduct('AI todo app')
console.log(product.testResults)
```

**When to use:** When your function's caller expects a resolved value.

But if the caller will continue the pipeline:

```typescript title="Return RpcPromise for Composition"
function buildProduct(hypothesis: string) {
  const spec = priya`define MVP for ${hypothesis}`
  const app = ralph`build ${spec}`
  return quinn`test ${app}`  // Return RpcPromise, not awaited
}

// Caller continues the pipeline
const tested = buildProduct('AI todo app')
const shipped = tom`ship ${tested}`  // tested is RpcPromise
await shipped  // One round trip for everything
```

## Anti-Pattern: Await Every Call

The worst pattern—treating RPC like synchronous function calls:

```typescript title="Anti-Pattern - Don't Do This"
const spec = await priya`define the MVP`      // Round trip 1
const app = await ralph`build ${spec}`         // Round trip 2
const tested = await quinn`test ${app}`        // Round trip 3
const shipped = await tom`ship ${tested}`      // Round trip 4
const announced = await mark`announce ${shipped}`  // Round trip 5
```

**Why it's bad:** 5 round trips instead of 1. With 200ms latency, that's 1 second vs 200ms.

**Fix:** Remove intermediate awaits:

```typescript title="Fixed - Single Round Trip"
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const tested = quinn`test ${app}`
const shipped = tom`ship ${tested}`
const announced = await mark`announce ${shipped}`  // Only await final
```

## Anti-Pattern: Await Then Pass

Awaiting then immediately passing to another call:

```typescript title="Anti-Pattern - Unnecessary Await"
const spec = await priya`define the MVP`  // Unnecessary await!
const app = ralph`build ${spec}`           // spec is now a value, not RpcPromise
await app
```

The await on line 1 is pointless—you're not using `spec` for anything local. Just pass the RpcPromise.

```typescript title="Fixed"
const spec = priya`define the MVP`  // RpcPromise
const app = ralph`build ${spec}`     // Pass RpcPromise directly
await app
```

## Anti-Pattern: Await in Map Callback

Awaiting inside a map breaks the pipeline for each element:

```typescript title="Anti-Pattern - Await in Map"
const tasks = await $.Agent('priya')`list tasks`
const results = await Promise.all(
  tasks.map(async task => {
    const impl = await $.Agent('ralph')`implement ${task}`  // N awaits!
    return impl
  })
)
```

**Fix:** Use Magic Map with the workflow proxy:

```typescript title="Fixed with Magic Map"
const tasks = $.Agent('priya')`list tasks`
const results = await tasks.map(task => $.Agent('ralph')`implement ${task}`)
```

Note: Magic Map requires using agents through the workflow proxy (`$`). Direct agent imports use simple promise chaining.

## Decision Tree

```
Do I need the value locally?
├─ No → Don't await, pass RpcPromise
└─ Yes → Why?
    ├─ To branch (if/else) → Await
    ├─ To loop (for/while) → Await (or use Magic Map)
    ├─ To display/log → Await
    ├─ To return to non-pipeline caller → Await
    └─ To pass to another RPC call → Don't await!
```

## Quick Reference

| Scenario | Await? | Example |
|----------|--------|---------|
| Chain RPC calls | No | `ralph\`build ${spec}\`` |
| Branch on result | Yes | `if (await x.status) ...` |
| Loop over results | Yes | `for (const x of await items)` |
| Display/log value | Yes | `console.log(await x)` |
| Return to caller | Depends | Return RpcPromise if caller continues pipeline |
| Fire and forget | No | `mark\`notify\`` |
| Final result | Yes | `return await finalStep` |

## Summary

1. **Default to not awaiting** - Let pipelines form naturally
2. **Await for local decisions** - Branching, looping, displaying
3. **Consider Magic Map** - Often eliminates the need to await for loops
4. **Return RpcPromises** - Let callers decide when to await
5. **One await at the end** - Build the whole pipeline, then flush it

The goal is simple: minimize round trips. Every unnecessary await is latency you didn't need to pay.
