---
title: Proxy Chaining
description: Call methods on values that don't exist yet - RpcPromise as a stub
---

import { Callout } from 'fumadocs-ui/components/callout'

# Proxy Chaining

An RpcPromise isn't just a promise—it's a **proxy**. You can access properties and call methods on it before it resolves. Every access creates another RpcPromise, building a chain that executes on the server in a single round trip.

```typescript
// user doesn't exist yet - it's an RpcPromise
const user = $.Customer('cus_123')

// .profile doesn't exist yet either
const email = user.profile.email

// Even this method call returns an RpcPromise
const formatted = user.formatAddress()

// ONE round trip when we await
const result = await formatted
```

This is the dual nature of RpcPromise: it's both a promise (can be awaited) and a proxy (can be chained).

## How Proxy Chaining Works

When you access a property or call a method on an RpcPromise, JavaScript's Proxy intercepts the access and returns a new RpcPromise that represents the result of that operation.

```typescript
const user = $.Customer('cus_123')
// Type: RpcPromise<Customer>

const profile = user.profile
// Type: RpcPromise<Profile>
// Internally: { parent: user, access: 'property', key: 'profile' }

const email = profile.email
// Type: RpcPromise<string>
// Internally: { parent: profile, access: 'property', key: 'email' }
```

Nothing executes until you `await`. The chain is just a description of operations to perform.

### Method Calls

Methods work the same way:

```typescript
const user = $.Customer('cus_123')

const greeting = user.greet('Hello')
// Type: RpcPromise<string>
// Internally: { parent: user, access: 'method', key: 'greet', args: ['Hello'] }

const result = await greeting
// Server executes: getCustomer('cus_123').greet('Hello')
```

## Deep Property Access

Chain as deep as you need:

```typescript
// Access nested properties
const city = $.Order('ord_456')
  .shipping
  .address
  .city

// Call methods on nested objects
const distance = $.Order('ord_456')
  .shipping
  .address
  .distanceFrom(warehouseLocation)

// Mix property access and method calls
const trackingUrl = $.Order('ord_456')
  .shipment
  .getTracking()
  .url

// All in one round trip
const result = await trackingUrl
```

The server receives the full chain and executes it in sequence.

## Index Access

Array indices and bracket notation work too:

```typescript
// Array index
const firstItem = $.Cart('cart_123').items[0]

// Bracket notation (for dynamic keys)
const field = $.User('user_456')['customField']

// Combine with method calls
const price = $.Cart('cart_123')
  .items[0]
  .getPrice('USD')
```

## Combining with Template Literals

Agent template literals return RpcPromises, so they chain the same way:

```typescript
const spec = priya`define the MVP`
// Type: RpcPromise<Spec>

const title = spec.title
// Type: RpcPromise<string>

const features = spec.features
// Type: RpcPromise<Feature[]>

const firstFeature = spec.features[0].name
// Type: RpcPromise<string>

// ONE round trip
const result = await firstFeature
```

## Proxy Methods vs Magic Map

Both let you call methods on unresolved values, but they serve different purposes:

**Proxy Chaining** - For calling methods on objects:
```typescript
const customer = $.Customer(id)
const email = customer.getEmail()           // Method on Customer
const verified = customer.verifyEmail()     // Another method
```

**Magic Map** - For transforming arrays:
```typescript
const customers = sally`find all customers`
const emails = customers.map(c => c.email)  // Transform each element
```

They compose naturally:

```typescript
const customers = sally`find enterprise customers`
const emails = customers
  .filter(c => c.verified)           // Magic Map
  .map(c => c.primaryContact)        // Magic Map
  .map(contact => contact.email)     // Magic Map

// Or with a method call at the end
const campaign = mark`create campaign for ${emails}`
  .schedule('monday 9am')            // Proxy chain on the result
```

## Type Safety

TypeScript tracks types through proxy chains:

```typescript
interface Customer {
  id: string
  profile: Profile
  getOrders(): Order[]
}

interface Profile {
  email: string
  address: Address
}

const customer: RpcPromise<Customer> = $.Customer('cus_123')

// TypeScript knows the types at each step
const email: RpcPromise<string> = customer.profile.email
const orders: RpcPromise<Order[]> = customer.getOrders()

// Errors caught at compile time
const wrong = customer.nonexistent  // Type error!
```

## Null Safety

The server handles null/undefined gracefully in chains:

```typescript
const city = $.Order('ord_456')
  .shipping        // What if shipping is null?
  .address         // What if address is null?
  .city

// If any step is null/undefined, the chain short-circuits
const result = await city  // Returns undefined, doesn't throw
```

For explicit null handling, await and check:

```typescript
const order = await $.Order('ord_456')
if (order.shipping?.address) {
  const city = order.shipping.address.city
}
```

## Common Patterns

### Get Multiple Properties

```typescript
// Inefficient - two round trips
const email = await $.Customer(id).email
const name = await $.Customer(id).name

// Better - one round trip with destructuring (after await)
const customer = await $.Customer(id)
const { email, name } = customer

// Or use Promise.all (still one round trip due to batching)
const [email, name] = await Promise.all([
  $.Customer(id).email,
  $.Customer(id).name
])
```

### Method Chaining on Results

```typescript
// Build a query-like interface
const results = $.Database('main')
  .collection('users')
  .where('active', '==', true)
  .orderBy('createdAt', 'desc')
  .limit(10)

const users = await results
```

### Fluent Configuration

```typescript
// Configure and execute
const deployment = $.Deployment('dep_789')
  .setEnvironment('production')
  .setReplicas(3)
  .enableHealthChecks()
  .deploy()

const status = await deployment
```

### Chaining Agent Results

```typescript
// Agent returns structured data
const analysis = priya`analyze ${market}`

// Chain to extract parts
const opportunities = analysis.opportunities
const topOpportunity = opportunities[0]
const score = topOpportunity.score

// All still one round trip
const result = await score
```

## Proxy Internals

For the curious, here's how the proxy is implemented:

```typescript
class RpcPromise<T> extends Promise<T> {
  private _chain: ChainStep[] = []

  constructor(executor: PromiseExecutor<T>) {
    super(executor)
    return new Proxy(this, {
      get(target, prop) {
        // Handle Promise methods
        if (prop === 'then' || prop === 'catch' || prop === 'finally') {
          return target[prop].bind(target)
        }

        // Handle internal properties
        if (prop === '_chain' || prop === '_pipeline') {
          return target[prop]
        }

        // Create new RpcPromise for property access
        return target._createChild({
          type: 'property',
          key: prop
        })
      },

      apply(target, thisArg, args) {
        // Create new RpcPromise for method call
        return target._createChild({
          type: 'method',
          args
        })
      }
    })
  }
}
```

Every property access or method call creates a new RpcPromise with a reference to its parent and the access operation.

## Performance Considerations

Proxy chaining adds no network overhead—the entire chain is sent as a single operation:

| Pattern | Network Operations |
|---------|-------------------|
| `await obj.a.b.c` | 1 |
| `await obj.a; await obj.b; await obj.c` | 1 (batched) |
| `await obj.method().property.method()` | 1 |

The serialized chain looks like:
```json
{
  "target": "Customer:cus_123",
  "chain": [
    { "type": "property", "key": "profile" },
    { "type": "property", "key": "address" },
    { "type": "method", "key": "format", "args": ["short"] }
  ]
}
```

## Summary

| Feature | Description |
|---------|-------------|
| Property access | `user.profile.email` |
| Method calls | `user.verifyEmail()` |
| Index access | `cart.items[0]` |
| Deep chaining | `order.shipping.address.city` |
| Type safety | TypeScript tracks through chains |
| Null safety | Chains short-circuit on null |
| Performance | Entire chain = one network op |

Chain freely. Await once. Let the server do the work.
