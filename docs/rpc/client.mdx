---
title: Client SDK
description: Connect to any dotdo from anywhere with promise pipelining
---

import { Callout } from 'fumadocs-ui/components/callout'

# Client SDK

Connect to your Durable Object from any client—browsers, Node.js, mobile apps, other Workers. Same promise pipelining. One round trip.

```typescript
import { $Context } from 'dotdo'

const $ = $Context('https://my-startup.example.com.ai')
await $.Customer('alice').orders.create({ item: 'widget', qty: 5 })
```

Your DO methods become your API. No routes to define. No schemas to generate.

## Two Ways to Connect

### $Context(namespace) - Explicit

Use when connecting to a specific DO namespace:

```typescript
import { $Context } from 'dotdo'

const startup = $Context('https://my-startup.example.com.ai')
const platform = $Context('https://platform.do')

// Each client connects to a different namespace
await startup.Customer('alice').notify()
await platform.Analytics.track({ event: 'pageview' })
```

<Callout type="info">
The namespace URL is your DO endpoint. Cap'n Web RPC uses the root endpoint (`/`) with WebSocket-first and HTTP batch fallback.
</Callout>

### $ - Pre-configured

Auto-connects using:

1. `do.config.ts` (if present)
2. `DOTDO_NAMESPACE` environment variable
3. `http://localhost:8787` (development fallback)

```typescript
import { $ } from 'dotdo'

// Connects to configured namespace automatically
await $.Customer('alice')
await $.Order('ord-123').fulfill()
```

```typescript title="do.config.ts"
export default {
  namespace: 'https://my-startup.example.com.ai',
}
```

## Promise Pipelining

The client uses the [capnweb](https://github.com/cloudflare/capnweb) library for true promise pipelining—building operation graphs that execute in a single network round trip:

```typescript
// Build the pipeline - no await yet
const customer = $.Customer('alice')
const orders = customer.orders
const recent = orders.recent(5)
const titles = recent.map(o => o.title)

// ONE request when awaited
const result = await titles
```

Capnweb batches all pending operations at the microtask boundary, so multiple independent calls also batch together:

```typescript
// These all batch into ONE request
const [alice, bob, charlie] = await Promise.all([
  $.Customer('alice'),
  $.Customer('bob'),
  $.Customer('charlie'),
])
```

One round trip. No matter how deep the chain or how many parallel calls.

<Callout type="warn" title="Await Flushes the Pipeline">
Every `await` sends the chain immediately. Build your entire pipeline before awaiting for maximum efficiency.
</Callout>

## RpcPromise

Every chain operation returns an `RpcPromise`—a thenable that's also a proxy.

```typescript
const customer = $.Customer('alice')  // RpcPromise (not awaited)

// Access properties without awaiting
const email = customer.email          // Still RpcPromise

// Call methods without awaiting
const orders = customer.getOrders()   // Still RpcPromise

// All combined into one request on await
const result = await orders
```

### Promise Methods

RpcPromise implements the full Promise interface:

```typescript
// .then()
$.Customer('alice')
  .then(c => console.log(c.name))

// .catch()
$.Customer('nonexistent')
  .catch(err => console.log('Not found'))

// .finally()
$.Customer('alice')
  .finally(() => console.log('Done'))

// Promise.all()
const [alice, bob] = await Promise.all([
  $.Customer('alice'),
  $.Customer('bob'),
])
```

## Works Everywhere

### Browser

```typescript
import { $Context } from 'dotdo'

const $ = $Context('https://api.my-startup.com')

// React component
async function updateProfile(name: string) {
  await $.Customer('me').updateProfile({ name })
}
```

### Node.js / CLI

```typescript
import { $ } from 'dotdo'

// CLI tool
const customers = await $.Customer.list({ status: 'active' })
console.table(customers)
```

### From Another Worker

```typescript
import { $Context } from 'dotdo'

export default {
  async fetch(request) {
    const $ = $Context('https://other-service.example.com.ai')
    await $.Integration.sync({ source: 'crm' })
    return new Response('OK')
  }
}
```

## Configuration

Runtime configuration for the pre-configured `$` client:

```typescript
import { configure } from 'dotdo'

configure({
  namespace: 'https://my-startup.example.com.ai',
  isDev: process.env.NODE_ENV === 'development',
  localUrl: 'http://localhost:8787',
})
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `namespace` | `string` | - | Default namespace URL |
| `isDev` | `boolean` | `false` | Use local dev server |
| `localUrl` | `string` | `http://localhost:8787` | Local dev URL |

Environment variables:

- `DOTDO_NAMESPACE` - Default namespace URL
- `DOTDO_LOCAL_URL` - Override local dev URL
- `DOTDO_DEV=true` - Force development mode

## Error Handling

RPC errors are thrown with structured error objects:

```typescript
try {
  await $.Customer('nonexistent')
} catch (error) {
  console.log(error.code)    // 'NOT_FOUND'
  console.log(error.message) // 'Customer not found'
}
```

### Error Codes

| Code | Description |
|------|-------------|
| `NOT_FOUND` | Resource doesn't exist |
| `NOT_CALLABLE` | Tried to call a non-function |
| `METHOD_NOT_FOUND` | Method doesn't exist on target |
| `INVALID_TARGET` | Cannot access property of null/undefined |
| `EXECUTION_ERROR` | Server-side execution failed |
| `RPC_BROKEN` | Connection was lost |

## Security

The client respects DO method visibility:

- **Public methods** - Accessible via RPC
- **Private methods** (prefixed with `_`) - Blocked
- **Internal methods** (fetch, alarm, etc.) - Blocked
- **Blocked list** - Configurable on server

```typescript
// These work
await $.getUser('alice')
await $.createOrder({ item: 'widget' })

// These throw BLOCKED_ACCESS
await $._privateMethod()
await $.fetch(request)
```

## TypeScript Support

The client proxy is typed as `RpcClient`:

```typescript
import type { RpcClient, RpcPromise } from 'dotdo'

const $: RpcClient = $Context('https://example.com.ai')

// All operations return RpcPromise<unknown>
const result: RpcPromise<unknown> = $.Customer('alice')
```

For full type inference, use typed stubs (coming soon).

## Performance

| Pattern | Round Trips | Latency (200ms RTT) |
|---------|-------------|---------------------|
| 5 awaited calls | 5 | 1000ms |
| 5 chained calls (1 await) | 1 | 200ms |
| Mixed (2 await, 3 chained) | 2 | 400ms |

<Callout type="info" title="One Await Rule">
Build your entire operation chain, then await once. Every `await` is a potential network round trip.
</Callout>

## Comparison

| Feature | Client SDK | REST API | GraphQL |
|---------|-----------|----------|---------|
| Round trips | 1 (pipelined) | 1 per call | 1 (batched) |
| Schema required | No | Yes (OpenAPI) | Yes |
| Type generation | No | Yes | Yes |
| Arbitrary depth | Yes | Limited | Query-based |
| Code = Contract | Yes | No | No |

The client SDK is your DO's API. No generation step. No version drift. Your methods are your contract.

## Related

- [Cap'n Web RPC](/docs/rpc) - The protocol powering this
- [Promise Pipelining](/docs/rpc/pipelines) - Why one round trip works
- [WorkflowContext](/docs/sdk/workflow-context) - The internal `$` interface
- [Await Patterns](/docs/rpc/await-patterns) - When to await
