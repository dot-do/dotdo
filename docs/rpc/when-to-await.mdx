---
title: When to Await
description: The definitive guide to await decisions in promise pipelining - decision tree, rules, and quick reference
---

import { Callout, Steps } from 'fumadocs-ui/components/callout'

# When to Await: The Definitive Guide

This is the consolidated reference for all await decisions in dotdo. Every `await` is a decision point that affects performance. This guide gives you the rules, patterns, and decision tree to make the right call every time.

<Callout type="info" title="The Golden Rule">
**Don't await until you need the value locally.** If the next operation is another RPC call, pass the RpcPromise directly.
</Callout>

## Decision Tree

Use this flowchart for every await decision:

```
Do you need the value locally?
|
+-- NO --> Don't await, pass the RpcPromise
|
+-- YES --> Why do you need it?
     |
     +-- To branch (if/else/switch) --> AWAIT
     |
     +-- To loop (for/while/forEach) --> AWAIT (or use Magic Map)
     |
     +-- To display/log/serialize --> AWAIT
     |
     +-- To return to non-pipeline caller --> AWAIT
     |
     +-- To use with external APIs --> AWAIT
     |
     +-- To pass to another RPC call --> DON'T AWAIT!
```

## Quick Reference Table

| Scenario | Await? | Reason |
|----------|--------|--------|
| Pass to another RPC call | No | Forms pipeline edge |
| Branch on result value | Yes | Client needs to decide path |
| Loop over array elements | Yes | Client needs to iterate (or use Magic Map) |
| Display, log, or serialize | Yes | Client needs actual bytes |
| Return to non-pipeline caller | Yes | Caller expects resolved value |
| Return to pipeline-aware caller | No | Caller continues the pipeline |
| Transform with Magic Map | No | Recorded, not executed |
| Access property on result | No | Proxy chaining handles it |
| Call method on result | No | Proxy chaining handles it |
| Fire-and-forget operation | No | Don't need confirmation |
| Checkpoint before critical section | Yes | Ensure completion |
| Error boundary | Yes | Need to catch and handle |
| External API integration | Yes | External code needs resolved values |

## The Five Laws of Await

<Steps>
### Law 1: Pipeline by Default

Start with no awaits. Let pipelines form naturally. Only add awaits when you have a specific reason.

```typescript
// Default - no awaits until the end
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = tom`ship ${app}`
const result = await deployed  // Only await here
```

### Law 2: Await for Local Decisions

If you need to inspect a value to decide what to do next, you must await.

```typescript
// Must await to branch
const analysis = await priya`analyze ${market}`
if (analysis.opportunity === 'high') {
  return await buildAggressiveMVP()
} else {
  return await buildLeanExperiment()
}
```

### Law 3: Await for Iteration

JavaScript's iteration constructs need resolved arrays. Exception: Magic Map.

```typescript
// Must await for standard iteration
const tasks = await priya`list tasks`
for (const task of tasks) {
  await ralph`implement ${task}`
}

// Alternative: Magic Map (no await needed)
const tasks = priya`list tasks`
const impls = tasks.map(task => ralph`implement ${task}`)
await impls  // Single round trip
```

### Law 4: Return RpcPromises When Possible

Functions that return RpcPromises let callers compose pipelines.

```typescript
// Good - returns RpcPromise
function buildProduct(hypothesis: string) {
  const spec = priya`define MVP for ${hypothesis}`
  const app = ralph`build ${spec}`
  return quinn`test ${app}`  // Return RpcPromise
}

// Caller can continue the pipeline
const tested = buildProduct('AI todo app')
const shipped = tom`ship ${tested}`
await shipped  // ONE round trip for everything
```

### Law 5: Await Once at the End

Build your entire pipeline, then flush it with a single await.

```typescript
// Build the full graph
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const tested = quinn`test ${app}`
const reviewed = tom`review ${app}`
const shipped = tom`ship ${reviewed} after ${tested}`
const announced = mark`announce ${shipped}`
const selling = sally`start selling ${announced}`

// Single await flushes everything
return await selling
```
</Steps>

## Patterns by Scenario

### Scenario: Sequential Operations

When each step feeds the next with no local logic:

```typescript
// GOOD - Pipeline all the way
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = tom`ship ${app}`
const announced = await mark`announce ${deployed}`

// BAD - Breaks pipeline unnecessarily
const spec = await priya`define the MVP`  // Why await here?
const app = await ralph`build ${spec}`     // And here?
const deployed = await tom`ship ${app}`    // And here?
const announced = await mark`announce ${deployed}`
```

**Round trips:** Good = 1, Bad = 4

### Scenario: Parallel Independent Operations

When operations don't depend on each other:

```typescript
// All three start independent
const spec = priya`define the MVP`
const marketing = mark`draft marketing plan`
const prospects = sally`identify prospects`

// Ralph depends on spec, but runs parallel to mark/sally
const app = ralph`build ${spec}`

// Tom needs everything
const launch = await tom`coordinate ${app} with ${marketing} and ${prospects}`

// Still ONE round trip - server parallelizes automatically
```

### Scenario: Conditional Branching

When you need the value to decide the path:

```typescript
// Must await for the branch
const analysis = await priya`analyze market ${segment}`

if (analysis.marketSize > 1_000_000) {
  // Large market - build full product
  const spec = priya`define comprehensive MVP`
  const app = ralph`build ${spec}`
  return await tom`ship ${app}`
} else if (analysis.marketSize > 100_000) {
  // Medium market - lean approach
  const spec = priya`define lean experiment`
  return await ralph`build ${spec}`
} else {
  // Small market - skip
  return null
}
```

**Round trips:** 2 (one for analysis, one for build)

<Callout type="info" title="Reduce Branching Awaits">
Sometimes you can push the decision to the agent:

```typescript
// Instead of local branching
const spec = priya`define MVP appropriate for ${market} size and opportunity`
const app = ralph`build ${spec}`  // Priya made the decision

// ONE round trip - Priya decides internally
```
</Callout>

### Scenario: Loop Over Results

When you need to iterate:

```typescript
// Standard approach - must await for iteration
const tasks = await priya`break down ${spec} into tasks`
for (const task of tasks) {
  const impl = ralph`implement ${task}`
  const reviewed = await tom`review ${impl}`
}
// Round trips: 1 + N

// Magic Map approach - no await needed
const tasks = priya`break down ${spec} into tasks`
const impls = tasks.map(task => ralph`implement ${task}`)
const reviewed = impls.map(impl => tom`review ${impl}`)
await reviewed
// Round trips: 1
```

### Scenario: Error Boundaries

When you need to catch and handle errors:

```typescript
// Checkpoint for error handling
const spec = priya`define the MVP`
const app = ralph`build ${spec}`

try {
  const tested = await quinn`test ${app}`  // Checkpoint
  if (!tested.allPassed) {
    throw new Error('Tests failed')
  }
} catch (error) {
  // Handle build/test failures
  await mark`notify team of failure: ${error}`
  return
}

// Continue only if tests passed
const shipped = await tom`ship ${app}`
```

### Scenario: Function Return Values

When crossing function boundaries:

```typescript
// If caller expects resolved value - await
async function getProductForDisplay(id: string) {
  const product = $.Product(id)
  const enriched = product.enrich()
  return await enriched  // Caller will render this
}

// If caller continues pipeline - don't await
function buildProduct(hypothesis: string) {
  const spec = priya`define MVP for ${hypothesis}`
  return ralph`build ${spec}`  // Return RpcPromise
}

// Caller decides when to await
const product = buildProduct('AI assistant')
const shipped = await tom`ship ${product}`
```

### Scenario: Fire and Forget

When you don't need confirmation:

```typescript
// Background work - no await needed
mark`send newsletter to ${subscribers}`
sally`update CRM with ${event}`

// Continue immediately
return { status: 'event_processed' }
```

<Callout type="warn" title="No Error Handling">
Fire-and-forget means you won't catch errors. Use only for operations where failures are acceptable (analytics, notifications, logging).
</Callout>

### Scenario: External API Integration

When passing to non-RPC code:

```typescript
// External code needs resolved values
const user = await $.Customer(id)

// Third-party API
await sendgrid.send({
  to: user.email,         // Needs actual string
  name: user.name,        // Needs actual string
  template: 'welcome'
})

// Database ORM
await db.insert(users).values({
  id: user.id,
  email: user.email,
  createdAt: new Date()
})
```

## Anti-Patterns to Avoid

### Anti-Pattern 1: Await Every Call

```typescript
// BAD - 5 round trips
const spec = await priya`define`      // RT 1
const app = await ralph`build ${spec}` // RT 2
const tested = await quinn`test ${app}` // RT 3
const shipped = await tom`ship ${app}`  // RT 4
const announced = await mark`announce`  // RT 5

// GOOD - 1 round trip
const spec = priya`define`
const app = ralph`build ${spec}`
const tested = quinn`test ${app}`
const shipped = tom`ship ${tested}`
const announced = await mark`announce ${shipped}`
```

### Anti-Pattern 2: Await Then Pass

```typescript
// BAD - Pointless await
const spec = await priya`define`  // Why await?
const app = ralph`build ${spec}`   // Just to pass it here?

// GOOD - Pass the RpcPromise
const spec = priya`define`
const app = ralph`build ${spec}`
```

### Anti-Pattern 3: Await in Map Callback

```typescript
// BAD - N round trips
const tasks = await priya`list tasks`
const results = await Promise.all(
  tasks.map(async task => {
    return await ralph`implement ${task}`  // RT per task!
  })
)

// GOOD - 1 round trip with Magic Map
const tasks = priya`list tasks`
const results = await tasks.map(task => ralph`implement ${task}`)
```

### Anti-Pattern 4: Await Just to Log

```typescript
// BAD - Breaks pipeline for logging
const spec = await priya`define`
console.log('Spec:', spec)  // Is this worth a round trip?
const app = await ralph`build ${spec}`

// GOOD - Log at the end if needed
const spec = priya`define`
const app = ralph`build ${spec}`
const result = await app
console.log('Built:', result)
```

### Anti-Pattern 5: Multiple Awaits on Same Object

```typescript
// BAD - Looks like 2 round trips (actually batched, but confusing)
const email = await $.Customer(id).email
const name = await $.Customer(id).name

// BETTER - Single explicit await
const customer = await $.Customer(id)
const { email, name } = customer

// ALSO GOOD - Promise.all (batched automatically)
const [email, name] = await Promise.all([
  $.Customer(id).email,
  $.Customer(id).name
])
```

## Magic Map vs Await-Then-Loop

When you have a collection to process, you have two options:

### Option 1: Await Then Loop (Traditional)

```typescript
const tasks = await priya`list tasks`  // Round trip 1
for (const task of tasks) {
  await ralph`implement ${task}`        // Round trip per task
}
// Total: 1 + N round trips
```

### Option 2: Magic Map (Pipelined)

```typescript
const tasks = priya`list tasks`
const impls = tasks.map(task => ralph`implement ${task}`)
await impls
// Total: 1 round trip
```

**Always prefer Magic Map** unless you need:
- Local logic in the loop body
- Early exit conditions
- Sequential (not parallel) execution
- Access to loop index for complex operations

## Cross-DO Call Rules

When calling across Durable Objects:

```typescript
// Rule: Treat cross-DO calls like any RPC
const customer = $.Customer(customerId)
const orders = $.Order(customer.id).list()  // customer.id is RpcPromise
const total = $.Analytics(orders).summarize()
await total  // Single batch

// Await boundaries matter
const customer = await $.Customer(customerId)  // Round trip 1
const orders = await $.Order(customer.id).list()  // Round trip 2 (customer.id now resolved)
const total = await $.Analytics(orders).summarize()  // Round trip 3
```

The same rules apply: don't await unless you need the value locally.

## Performance Impact Summary

| Pattern | Round Trips | Example |
|---------|-------------|---------|
| Full pipeline | 1 | `await tom\`ship ${ralph\`build ${spec}\`}\`` |
| Await every call | N | `await x; await y; await z;` |
| Await for branch | 2+ | `if (await x) { await y }` |
| Await for loop | 1+N | `for (x of await items) { await process(x) }` |
| Magic Map | 1 | `await items.map(x => process(x))` |
| Promise.all (batched) | 1 | `await Promise.all([x, y, z])` |

## Checklist Before Adding Await

Before writing `await`, ask yourself:

1. Do I need this value for local computation?
2. Can I pass the RpcPromise to the next call instead?
3. Can I use Magic Map instead of await-then-loop?
4. Can I push the decision to an agent instead of branching locally?
5. Am I at the end of the pipeline?
6. Is this a checkpoint where I need to verify success?

If you answered "no" to all of the first four and "no" to both of the last two, you probably don't need the await.

## Summary

1. **Default: Don't await** - Let pipelines form naturally
2. **Await for local decisions** - Branching, looping, displaying
3. **Prefer Magic Map** - Over await-then-loop patterns
4. **Return RpcPromises** - Let callers decide when to resolve
5. **One await at the end** - Build the pipeline, then flush it
6. **Every await = potential round trip** - Minimize them

The goal: minimize network round trips. Every unnecessary await is latency you didn't need to pay.

## Related

- [Understanding Promise Pipelining](/docs/rpc/understanding-promise-pipelining) - The conceptual foundation
- [Promise Pipelining](/docs/rpc/pipelines) - Building and composing pipelines
- [Magic Map](/docs/rpc/magic-map) - Server-side collection transforms
- [Proxy Chaining](/docs/rpc/proxy-chaining) - Method calls on unresolved values
- [Await Patterns](/docs/rpc/await-patterns) - Pattern-focused examples
