---
title: RPC Server
description: Set up RPC handlers on Durable Objects with context injection and error handling
---

import { Callout } from 'fumadocs-ui/components/callout'

# RPC Server

The RPC server runs inside your Durable Object, handling method calls from clients. No routes to define, no schemas to generate. Your methods are your API.

```typescript
import { DO } from 'dotdo'

export class CustomerDO extends DO {
  async getProfile() {
    return this.$.state.profile
  }

  async updateProfile(data: { name: string; email: string }) {
    this.$.state.profile = { ...this.$.state.profile, ...data }
    return this.$.state.profile
  }

  async getOrders(limit = 10) {
    return this.$.state.orders.slice(0, limit)
  }
}
```

Every public method becomes an RPC endpoint. Clients call them like local functions.

## Handler Setup

### Basic Handler

The simplest server setup wraps a target object with `InMemoryExecutor`:

```typescript
import { InMemoryExecutor, createRpcProxy } from '@dotdo/rpc'

// Your business logic
const userService = {
  async getUser(id: string) {
    const user = await db.users.findById(id)
    if (!user) throw new Error('User not found')
    return user
  },

  async createUser(data: { name: string; email: string }) {
    return db.users.create(data)
  },

  // Nested namespaces work automatically
  orders: {
    async list(userId: string) {
      return db.orders.findByUser(userId)
    },

    async create(userId: string, items: Item[]) {
      return db.orders.create({ userId, items })
    }
  }
}

// Create executor and proxy
const executor = new InMemoryExecutor(userService)
const proxy = createRpcProxy(executor)

// Clients can now call:
// proxy.getUser('123')
// proxy.orders.list('user-456')
```

### HTTP Handler

For HTTP transport, use `HTTPExecutor` on the client and handle requests on the server:

```typescript
import { Hono } from 'hono'
import { InMemoryExecutor } from '@dotdo/rpc'
import type { MethodCall, CallResult } from '@dotdo/rpc'

const app = new Hono()

// Your service implementation
const service = {
  async getUser(id: string) { /* ... */ },
  async updateUser(id: string, data: unknown) { /* ... */ },
}

const executor = new InMemoryExecutor(service)

// Single call endpoint
app.post('/rpc', async (c) => {
  const call: MethodCall = await c.req.json()
  const result = await executor.execute(call)
  return c.json(result)
})

// Batch endpoint
app.post('/rpc/batch', async (c) => {
  const calls: MethodCall[] = await c.req.json()
  const results = await executor.executeBatch(calls)
  return c.json(results)
})

export default app
```

### Durable Object Handler

In a Durable Object, the RPC handler integrates with the DO lifecycle:

```typescript
import { DO } from 'dotdo'
import { InMemoryExecutor } from '@dotdo/rpc'

export class MyDO extends DO {
  private executor: InMemoryExecutor

  constructor(state: DurableObjectState, env: Env) {
    super(state, env)
    // Executor wraps `this` - all public methods become RPC endpoints
    this.executor = new InMemoryExecutor(this)
  }

  // RPC-accessible methods
  async getData() {
    return this.$.state.data
  }

  async setData(value: unknown) {
    this.$.state.data = value
  }

  // Private methods (prefixed with _) are blocked
  private _internalMethod() {
    // Not accessible via RPC
  }

  // The fetch handler routes RPC calls
  async fetch(request: Request): Promise<Response> {
    if (request.method === 'POST') {
      const call = await request.json()
      const result = await this.executor.execute(call)
      return Response.json(result)
    }
    return new Response('Method not allowed', { status: 405 })
  }
}
```

## Context Injection

Access request context, authentication, and environment in your handlers:

```typescript
import { DO } from 'dotdo'

export class SecureDO extends DO {
  // Context is available via this.$
  async getPrivateData() {
    // Access the current user from context
    const user = this.$.ctx.user
    if (!user) {
      throw new Error('Authentication required')
    }

    // Access environment variables
    const apiKey = this.$.env.API_KEY

    // Access request metadata
    const requestId = this.$.ctx.requestId

    return {
      data: this.$.state.data,
      accessedBy: user.id,
      requestId,
    }
  }

  async updateData(value: unknown) {
    // Check permissions
    if (!this.$.ctx.user?.permissions.includes('write')) {
      throw new Error('Write permission required')
    }

    this.$.state.data = value
    this.$.state.updatedBy = this.$.ctx.user.id
    this.$.state.updatedAt = Date.now()
  }
}
```

### Custom Context Providers

Create custom context providers for your application:

```typescript
import type { Executor, MethodCall, CallResult } from '@dotdo/rpc'

interface RequestContext {
  user: { id: string; permissions: string[] } | null
  requestId: string
  timestamp: number
}

class ContextAwareExecutor implements Executor {
  private target: unknown
  private contextProvider: () => RequestContext

  constructor(target: unknown, contextProvider: () => RequestContext) {
    this.target = target
    this.contextProvider = contextProvider
  }

  async execute(call: MethodCall): Promise<CallResult> {
    // Inject context into the call metadata
    const context = this.contextProvider()
    const enrichedCall = {
      ...call,
      meta: { ...call.meta, context },
    }

    // Pass context to handlers
    try {
      const method = this.resolveMethod(call.path)
      const result = await method(...(call.args || []), context)
      return { result }
    } catch (error) {
      return {
        error: {
          code: 'EXECUTION_ERROR',
          message: error instanceof Error ? error.message : String(error),
        },
      }
    }
  }

  private resolveMethod(path: string[]): Function {
    let current: unknown = this.target
    for (const segment of path.slice(0, -1)) {
      current = (current as Record<string, unknown>)[segment]
    }
    return (current as Record<string, Function>)[path[path.length - 1]]
  }

  async executeBatch(calls: MethodCall[]): Promise<CallResult[]> {
    return Promise.all(calls.map((call) => this.execute(call)))
  }
}
```

## Error Handling

Structure errors with codes and metadata for proper client handling:

```typescript
import { RpcProxyError } from '@dotdo/rpc'

export class OrderDO extends DO {
  async createOrder(items: Item[]) {
    // Validation errors
    if (items.length === 0) {
      throw new RpcProxyError(
        'VALIDATION_ERROR',
        'Order must contain at least one item',
        { field: 'items' }
      )
    }

    // Business logic errors
    const inventory = await this.checkInventory(items)
    if (!inventory.available) {
      throw new RpcProxyError(
        'INSUFFICIENT_INVENTORY',
        'Some items are out of stock',
        { unavailable: inventory.unavailable }
      )
    }

    // Authorization errors
    if (!this.$.ctx.user?.verified) {
      throw new RpcProxyError(
        'UNVERIFIED_USER',
        'Account verification required for orders',
        { verificationUrl: '/verify' }
      )
    }

    return this.processOrder(items)
  }

  async getOrder(orderId: string) {
    const order = this.$.state.orders[orderId]

    if (!order) {
      throw new RpcProxyError(
        'NOT_FOUND',
        `Order ${orderId} not found`
      )
    }

    // Access control
    if (order.userId !== this.$.ctx.user?.id) {
      throw new RpcProxyError(
        'FORBIDDEN',
        'Access denied to this order'
      )
    }

    return order
  }
}
```

### Error Codes

| Code | Description | HTTP Equivalent |
|------|-------------|-----------------|
| `NOT_FOUND` | Resource doesn't exist | 404 |
| `FORBIDDEN` | Access denied | 403 |
| `VALIDATION_ERROR` | Invalid input | 400 |
| `EXECUTION_ERROR` | Server-side failure | 500 |
| `METHOD_NOT_FOUND` | Method doesn't exist | 404 |
| `INVALID_CALL` | Malformed RPC call | 400 |
| `TIMEOUT` | Operation timed out | 504 |
| `RATE_LIMITED` | Too many requests | 429 |

### Error Middleware

Add global error handling middleware:

```typescript
import type { Executor, MethodCall, CallResult } from '@dotdo/rpc'

class ErrorHandlingExecutor implements Executor {
  private inner: Executor
  private onError: (error: unknown, call: MethodCall) => void

  constructor(
    inner: Executor,
    onError: (error: unknown, call: MethodCall) => void
  ) {
    this.inner = inner
    this.onError = onError
  }

  async execute(call: MethodCall): Promise<CallResult> {
    try {
      const result = await this.inner.execute(call)

      // Log errors that came from the inner executor
      if (result.error) {
        this.onError(result.error, call)
      }

      return result
    } catch (error) {
      this.onError(error, call)

      return {
        error: {
          code: 'EXECUTION_ERROR',
          message: error instanceof Error ? error.message : 'Unknown error',
        },
      }
    }
  }

  async executeBatch(calls: MethodCall[]): Promise<CallResult[]> {
    return Promise.all(calls.map((call) => this.execute(call)))
  }
}

// Usage
const executor = new ErrorHandlingExecutor(
  new InMemoryExecutor(service),
  (error, call) => {
    console.error(`RPC Error in ${call.path.join('.')}:`, error)
    analytics.track('rpc_error', {
      method: call.path.join('.'),
      error: String(error),
    })
  }
)
```

## Method Visibility

Control which methods are accessible via RPC:

```typescript
export class SecureDO extends DO {
  // Public - accessible via RPC
  async getPublicData() {
    return this.$.state.publicData
  }

  // Private prefix - blocked from RPC
  private _computeInternal() {
    return this.$.state.secret
  }

  // Blocked by naming convention
  async _adminOnly() {
    // Clients cannot call this
  }

  // Lifecycle methods are always blocked
  async fetch(request: Request) { /* blocked */ }
  async alarm() { /* blocked */ }
}
```

### Custom Blocking

Implement custom access control:

```typescript
const BLOCKED_METHODS = new Set([
  'fetch',
  'alarm',
  'webSocketMessage',
  'webSocketClose',
  'webSocketError',
])

class SecureExecutor implements Executor {
  private inner: Executor

  constructor(inner: Executor) {
    this.inner = inner
  }

  async execute(call: MethodCall): Promise<CallResult> {
    const methodName = call.path[call.path.length - 1]

    // Block lifecycle methods
    if (BLOCKED_METHODS.has(methodName)) {
      return {
        error: {
          code: 'BLOCKED_ACCESS',
          message: `Method '${methodName}' is not accessible via RPC`,
        },
      }
    }

    // Block private methods
    if (methodName.startsWith('_')) {
      return {
        error: {
          code: 'BLOCKED_ACCESS',
          message: 'Private methods are not accessible via RPC',
        },
      }
    }

    return this.inner.execute(call)
  }

  async executeBatch(calls: MethodCall[]): Promise<CallResult[]> {
    return Promise.all(calls.map((call) => this.execute(call)))
  }
}
```

## Related

- [Client SDK](/docs/rpc/client) - Connect from any client
- [Request Batching](/docs/rpc/batching) - Optimize multiple calls
- [RPC Streaming](/docs/rpc/streaming) - Server-sent events and bidirectional streaming
- [Promise Pipelining](/docs/rpc/pipelines) - Single round trip execution
