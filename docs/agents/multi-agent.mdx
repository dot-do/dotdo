---
title: Multi-Agent Patterns
description: Orchestrate agents with delegation, handoffs, and coordination patterns
---

import { Callout } from 'fumadocs-ui/components/callout'

# Multi-Agent Patterns

One agent is useful. Many agents working together is powerful. Multi-agent coordination lets you build complex workflows where agents collaborate, specialize, and hand off work.

```typescript
import { priya, ralph, tom, mark, sally, quinn } from 'agents.do'

// Named agents working together
async function ship(hypothesis: string) {
  const spec = await priya`define the MVP for ${hypothesis}`
  const code = await ralph`build ${spec}`
  const feedback = await tom`review ${code}`
  const improved = await ralph`improve ${code} per ${feedback}`

  await quinn`test ${improved}`
  await tom`ship ${improved}`

  mark`announce ${hypothesis}`
  sally`start selling ${hypothesis}`
}
```

---

## Core Patterns

### Sequential Pipeline

Agents work one after another, each building on the previous result.

```typescript
// Priya specs, Ralph builds, Tom reviews
const spec = await priya`define the feature`
const code = await ralph`build ${spec}`
const reviewed = await tom`review ${code}`
```

This is the simplest pattern. Each agent completes before the next starts.

### Parallel Fan-Out

One agent delegates to multiple agents simultaneously.

```typescript
// Orchestrator delegates to specialists in parallel
const results = await Promise.all([
  ralph`build the API`,
  ralph`build the frontend`,
  ralph`build the tests`,
])
```

Use fan-out when tasks are independent and can run concurrently.

### Supervisor/Worker

A supervisor agent coordinates worker agents and aggregates results.

```typescript
import { createHandoffProtocol } from 'dotdo/agents'

const protocol = createHandoffProtocol({
  provider,
  agents: [orchestrator, analyzer, executor, verifier],
})

// Supervisor delegates tasks
const tasks = ['analyze', 'execute', 'verify']
const results = await Promise.all(
  tasks.map(task =>
    protocol.handoff({
      sourceAgentId: 'orchestrator',
      targetAgentId: task,
      reason: 'delegation',
      context: { messages, summary: `Task: ${task}` },
    })
  )
)
```

### Pipeline with Promise Pipelining

Use Magic Map for single round-trip execution:

```typescript
const sprint = await priya`plan the sprint`
  .map(issue => ralph`build ${issue}`)
  .map(code => tom`review ${code}`)
  .map(pr => quinn`test ${pr}`)
  .map(pr => tom`merge ${pr}`)
```

The `.map()` isn't JavaScript's array method. It records your callback, sends it to the server, and replays it for each result. All in one network round trip.

---

## Agent Handoffs

Handoffs transfer control from one agent to another with full context preservation.

### Basic Handoff

```typescript
import { createHandoffProtocol, createHandoffRequest } from 'dotdo/agents'

const protocol = createHandoffProtocol({
  provider,
  agents: [routerAgent, supportAgent, billingAgent, technicalAgent],
})

const result = await protocol.handoff({
  sourceAgentId: 'router',
  targetAgentId: 'support',
  reason: 'routing',
  context: {
    messages: conversationHistory,
    summary: 'Customer asking about billing',
  },
})
```

### Handoff Reasons

| Reason | When to Use |
|--------|-------------|
| `specialization` | Target agent has better capabilities |
| `escalation` | Issue requires higher authority |
| `delegation` | Parallel task delegation |
| `completion` | Current agent completed its part |
| `routing` | Initial routing decision |
| `error` | Current agent cannot proceed |

### Handoff Protocol

The handoff protocol ensures reliable context transfer:

```
Source Agent                    Target Agent
     |                               |
     |------ HandoffMessage -------->|  (initiate)
     |<----- HandoffAck -------------|  (acknowledge receipt)
     |                               |  (target processes)
     |<----- HandoffComplete --------|  (completion notification)
```

```typescript
import {
  createInitiateMessage,
  createAckMessage,
  createCompleteMessage
} from 'dotdo/agents'

// Source initiates
const initiate = createInitiateMessage(
  handoffId,
  'router',
  'support',
  'routing',
  { messages, summary: 'Customer needs help' }
)

// Target acknowledges
const ack = createAckMessage(initiate, true, {
  estimatedProcessingMs: 5000,
  message: 'Ready to help',
})

// Target completes
const complete = createCompleteMessage(initiate, result, durationMs, {
  summary: 'Customer issue resolved',
})
```

---

## Agent Communication

Agents communicate through a message bus that supports direct messaging, broadcasts, and request-response patterns.

### Direct Messaging

```typescript
import { createMessageBus } from 'dotdo/agents'

const bus = createMessageBus()

// Subscribe to messages
const subscription = bus.subscribe('support', async (message) => {
  console.log(`Received from ${message.sender}: ${message.payload}`)
})

// Send a message
await bus.send({
  id: 'msg-001',
  sender: 'router',
  recipient: 'support',
  type: 'request',
  payload: { question: 'Can you help this customer?' },
  timestamp: new Date(),
})
```

### Message Types

| Type | Description |
|------|-------------|
| `request` | Ask for something |
| `response` | Answer a request |
| `notification` | One-way information |
| `handoff` | Transfer control |
| `error` | Report a problem |

### Request-Response Pattern

```typescript
// Send request and wait for response
const response = await bus.request({
  sender: 'orchestrator',
  recipient: 'analyzer',
  payload: { task: 'analyze sentiment' },
}, { timeoutMs: 5000 })

console.log('Analysis:', response.payload)
```

### Broadcast to Multiple Agents

```typescript
// Send to all worker agents at once
await bus.broadcast({
  sender: 'orchestrator',
  recipients: ['analyzer', 'executor', 'verifier'],
  type: 'request',
  payload: { task: 'process customer request' },
})
```

---

## Named Agent Collaboration

The named agents are designed to work together:

| Agent | Role | Works With |
|-------|------|------------|
| Priya | Product | Defines what to build for Ralph |
| Ralph | Engineering | Builds what Priya specs, improves per Tom |
| Tom | Tech Lead | Reviews Ralph's code, ships approved work |
| Mark | Marketing | Announces what Tom ships |
| Sally | Sales | Sells what Mark announces |
| Quinn | QA | Tests what Ralph builds |

### Typical Workflow

```typescript
async function ship(feature: string) {
  // 1. Priya defines it
  const spec = await priya`define ${feature}`

  // 2. Ralph builds it
  let code = await ralph`build ${spec}`

  // 3. Tom reviews, Ralph improves
  let feedback = await tom`review ${code}`
  while (!await tom.approve(code)) {
    code = await ralph`improve ${code} per ${feedback}`
    feedback = await tom`review ${code}`
  }

  // 4. Quinn tests it
  const testResults = await quinn`test ${code}`

  // 5. Tom ships it
  await tom`ship ${code}`

  // 6. Mark and Sally work in parallel (fire-and-forget)
  mark`announce ${feature}`
  sally`start selling ${feature}`
}
```

### Approval Gates

Use `await agent.approve()` to pause workflows until an agent approves:

```typescript
// Tom must approve before merging
if (await tom.approve(pullRequest)) {
  await tom`merge ${pullRequest}`
} else {
  const feedback = await tom`explain rejection for ${pullRequest}`
  await ralph`address ${feedback}`
}
```

---

## Orchestration with Handoff Tools

Create tools that enable agents to hand off to each other:

### Handoff Tool

```typescript
import { createHandoffTool } from 'dotdo/agents'

const agents = [
  { id: 'technical', name: 'Terry', description: 'Technical support' },
  { id: 'billing', name: 'Bill', description: 'Billing questions' },
  { id: 'sales', name: 'Sally', description: 'Sales inquiries' },
]

const handoffTool = createHandoffTool(agents, async (agentId, reason) => {
  await router.handoff(agentId, reason)
})

// Agent can now hand off:
// "transfer to billing for payment question"
```

### Delegation Tool

```typescript
import { createDelegationTool } from 'dotdo/agents'

const delegateTool = createDelegationTool(async (task, agentId) => {
  const subagent = await spawnSubagent({ task, agentId })
  return subagent.result
})

// Agent can delegate parallel work:
// "delegate this research to a specialist"
```

---

## State Preservation

Handoffs preserve state across agent transitions:

```typescript
import { createPreservedState, createCompleteHandoffContext } from 'dotdo/agents'

// Create preserved state
const state = createPreservedState({
  agentState: { currentStep: 'analysis' },
  sessionId: 'session-123',
  userContext: {
    userId: 'user-456',
    preferences: { language: 'en' },
  },
  workflowState: {
    workflowId: 'workflow-789',
    currentStep: 'review',
    variables: { approved: false },
  },
})

// Include in handoff context
const context = createCompleteHandoffContext(result, {
  summary: 'Initial analysis complete',
  preservedState: state,
})

// Hand off with state
await protocol.handoff({
  sourceAgentId: 'analyzer',
  targetAgentId: 'executor',
  reason: 'completion',
  context,
})
```

---

## Error Handling

### Handoff Errors

```typescript
const result = await protocol.handoff({
  sourceAgentId: 'router',
  targetAgentId: 'support',
  reason: 'routing',
  context,
})

if (result.state === 'failed') {
  console.error('Handoff failed:', result.error?.message)

  // Try fallback agent
  const fallback = await protocol.handoff({
    sourceAgentId: 'router',
    targetAgentId: 'general-support',
    reason: 'error',
    reasonDescription: `Primary support unavailable: ${result.error?.message}`,
    context,
  })
}

if (result.state === 'rejected') {
  // Target agent rejected the handoff
  console.log('Rejected:', result.rejection?.rejectionReason)

  // Try suggested alternative
  if (result.rejection?.suggestAlternative) {
    await protocol.handoff({
      sourceAgentId: 'router',
      targetAgentId: result.rejection.suggestAlternative,
      reason: 'routing',
      context,
    })
  }
}
```

### Circular Handoff Prevention

The protocol automatically prevents circular handoffs:

```typescript
const protocol = createHandoffProtocol({
  provider,
  agents,
  maxChainDepth: 10, // Maximum handoff depth
})

// If agent A hands to B, then B tries to hand back to A,
// the protocol returns state: 'failed' with a circular handoff error
```

### Timeout Handling

```typescript
const result = await protocol.handoff({
  sourceAgentId: 'router',
  targetAgentId: 'support',
  reason: 'routing',
  context,
  timeoutMs: 30000, // 30 second timeout
})

if (result.state === 'failed' && result.error?.message.includes('timed out')) {
  // Handle timeout
}
```

---

## Hooks and Customization

### Handoff Hooks

```typescript
const protocol = createHandoffProtocol({
  provider,
  agents,
  hooks: {
    // Validate before handoff
    validateHandoff: async (request) => {
      // Check if target agent is available
      return isAgentAvailable(request.targetAgentId)
    },

    // Modify request before sending
    onBeforeHandoff: async (request) => {
      // Add tracking metadata
      return {
        ...request,
        context: {
          ...request.context,
          metadata: { ...request.context.metadata, trackingId: generateId() },
        },
      }
    },

    // Transform context during transfer
    onContextTransfer: async (context) => {
      // Redact sensitive information
      return {
        ...context,
        messages: redactPII(context.messages),
      }
    },

    // Log when handoff starts
    onHandoffStart: async (request) => {
      await audit.log('handoff_start', {
        source: request.sourceAgentId,
        target: request.targetAgentId,
        reason: request.reason,
      })
    },

    // Track completion
    onHandoffComplete: async (result) => {
      await audit.log('handoff_complete', {
        source: result.request.sourceAgentId,
        target: result.request.targetAgentId,
        durationMs: result.durationMs,
        state: result.state,
      })
    },

    // Handle errors
    onHandoffError: async (request, error) => {
      await alerts.send(`Handoff failed: ${error.message}`)
    },
  },
})
```

---

## Graph-Based Communication

For complex multi-agent systems, use graph-integrated communication:

```typescript
import { createGraphMessageBus } from 'dotdo/agents'
import { GraphEngine } from 'dotdo/db'

const graph = new GraphEngine()
const bus = createGraphMessageBus({ graph })

// Messages are persisted as graph relationships
await bus.send({
  id: 'msg-001',
  sender: 'orchestrator',
  recipient: 'analyzer',
  type: 'request',
  payload: { task: 'analyze' },
  timestamp: new Date(),
})

// Query message history
const history = await bus.getConversation('orchestrator', 'analyzer')

// Get handoff chain
const chain = await bus.getHandoffChain('conversation-123')

// Communication analytics
const stats = await bus.getStats()
// { totalMessages: 150, messagesByType: { request: 50, response: 50, handoff: 50 }, uniqueAgents: 5 }

// Find most active agents
const active = await bus.getMostActiveAgents(5)
// [{ agentId: 'orchestrator', messageCount: 100 }, ...]
```

---

## Best Practices

### Choose the Right Pattern

| Pattern | Use When |
|---------|----------|
| Sequential Pipeline | Tasks depend on previous results |
| Parallel Fan-Out | Tasks are independent |
| Supervisor/Worker | Complex coordination needed |
| Handoff | Control transfers completely |

### Keep Context Minimal

```typescript
// Good: Pass only what's needed
const context = {
  messages: recentMessages.slice(-5),
  summary: 'Customer asking about billing',
  variables: { accountId, issue: 'billing' },
}

// Avoid: Passing everything
const context = {
  messages: entireConversationHistory, // Could be huge
  metadata: allMetadataEver,
}
```

### Use Fire-and-Forget Wisely

```typescript
// Fire-and-forget for non-blocking work
mark`announce the launch`
sally`start selling`

// Always await when you need the result
const spec = await priya`what should we build?`
const code = await ralph`build ${spec}` // Needs spec first
```

### Monitor Handoff Chains

```typescript
// Track handoff depth
const chain = protocol.getChain(conversationId)
if (chain.length > 5) {
  console.warn('Deep handoff chain:', chain.map(e => e.agentId).join(' -> '))
}

// Clear stale chains
protocol.clearChain(conversationId)
```

---

## Related

<Cards>
  <Card title="Agent System" href="/docs/agents">
    Overview of AI workers with real identity.
  </Card>
  <Card title="Named Agents" href="/docs/agents/named-agents">
    Meet Priya, Ralph, Tom, Mark, Sally, and Quinn.
  </Card>
  <Card title="Agent Tools" href="/docs/agents/tools">
    Give agents capabilities with the unified tool system.
  </Card>
  <Card title="Custom Agents" href="/docs/agents/custom-agents">
    Build domain-specific agents for your industry.
  </Card>
</Cards>

- [Agent Providers](/docs/agents/providers) - Claude, OpenAI, Vercel AI providers
- [Concepts: Functions](/docs/concepts/functions) - Function types including agentic functions
- [Human Escalation](/docs/humans) - When AI needs human judgment
