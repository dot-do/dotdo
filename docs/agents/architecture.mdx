---
title: Agent Architecture
description: How agents run inside Durable Objects with persistent state and global distribution
---

import { Callout } from 'fumadocs-ui/components/callout'

# Agent Architecture

Agents in dotdo are not standalone services. They run **inside Durable Objects** (DOs), inheriting persistent state, global distribution, and single-threaded execution guarantees. This document explains where agents run, how they persist state, and the boundaries between agent memory and DO storage.

## The DO-Agent Relationship

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Durable Object Instance                              │
│  (Single-threaded, persistent, globally distributed)                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          Agent Class                                 │   │
│  │                                                                      │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │   │
│  │  │    Tools     │  │   Memory     │  │    Goals     │              │   │
│  │  │              │  │              │  │              │              │   │
│  │  │ • Search KB  │  │ • Short-term │  │ • Observe    │              │   │
│  │  │ • Create     │  │ • Long-term  │  │ • Think      │              │   │
│  │  │   Ticket     │  │ • Episodic   │  │ • Act        │              │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │   │
│  │                                                                      │   │
│  └──────────────────────────────────────────────┬───────────────────────┘   │
│                                                 │                            │
│                                                 │ Inherits                   │
│                                                 ▼                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          Worker Class                                │   │
│  │  • Task execution    • Approval workflows    • Notifications        │   │
│  └──────────────────────────────────────────────┬───────────────────────┘   │
│                                                 │                            │
│                                                 │ Inherits                   │
│                                                 ▼                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                            DO Class                                  │   │
│  │  • SQLite database   • Event handling   • Cross-DO RPC              │   │
│  │  • ctx.storage       • $ context        • Lifecycle methods         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Class Hierarchy

| Class | Extends | Provides |
|-------|---------|----------|
| `DO` | - | SQLite, `ctx.storage`, `$` WorkflowContext, events, scheduling |
| `Worker` | `DO` | Task execution, approval workflows, decision making, notifications |
| `Agent` | `Worker` | Tools, memory, goal-seeking loop (observe-think-act) |

```typescript
// Agent inherits everything from Worker and DO
class SupportAgent extends Agent {
  // Has access to:
  // - this.db (Drizzle ORM on SQLite)
  // - this.ctx.storage (key-value)
  // - this.$ (WorkflowContext)
  // - this.things (graph store)
  // - this.tools (registered tools)
  // - this.remember() (memory)
}
```

## Where Agents Run

Agents execute **inside V8 isolates** on Cloudflare's edge network (300+ cities). Each agent instance is a Durable Object with a unique ID.

### Execution Model

```
Client Request
      │
      ▼
┌─────────────────┐
│  Edge Worker    │  (Routes to correct DO)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  DO Namespace   │  (e.g., "Agents")
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Agent DO ID    │  (e.g., "agent:support:acme")
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│          Agent Instance                  │
│                                          │
│  • Single-threaded execution            │
│  • No race conditions                   │
│  • Requests queue automatically         │
│  • Runs closest to first requester      │
└─────────────────────────────────────────┘
```

<Callout type="info">
**Single-threaded guarantee**: When an agent is processing a request, all other requests to that agent queue until the first completes. This eliminates race conditions without explicit locks.
</Callout>

### Global Distribution

When you call an agent, it runs in the region closest to the first request:

```typescript
// First request from Tokyo → Agent runs in Tokyo
await agent.run({ prompt: 'Analyze this data' })

// Subsequent requests route to Tokyo (where state lives)
// Until the agent is evicted
```

After eviction (30s of inactivity), state persists in SQLite and the agent can be rehydrated in any region.

## How Agent State Persists

Agents have two persistence mechanisms: **DO storage** (inherited from DO) and **agent memory** (specific to agents).

### Storage Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Agent Instance                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  In-Memory (Lost on eviction)                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │  • this.tools Map                                                   │    │
│  │  • this.mode                                                        │    │
│  │  • Local variables                                                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  Persistent (Survives eviction)                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │                                                                     │    │
│  │  ctx.storage (SQLite)                                               │    │
│  │  ┌───────────────────────────────────────────────────────────┐     │    │
│  │  │  things table      → Entities, agent memories             │     │    │
│  │  │  relationships     → Connections between entities         │     │    │
│  │  │  actions table     → Audit log of agent actions           │     │    │
│  │  │  events table      → Domain events                        │     │    │
│  │  │  memory:* keys     → Legacy agent memories (ctx.storage)  │     │    │
│  │  │  custom tables     → Your application data                │     │    │
│  │  └───────────────────────────────────────────────────────────┘     │    │
│  │                                                                     │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Memory Types

| Memory Type | Storage | Survives Eviction | Use Case |
|-------------|---------|-------------------|----------|
| **Short-term** | ctx.storage or unified memory | Yes | Recent conversation context |
| **Long-term** | ctx.storage or unified memory | Yes | Customer preferences, learned facts |
| **Episodic** | ctx.storage or unified memory | Yes | Past interaction sequences |
| **In-memory cache** | Class properties | No | Temporary computation results |

<Callout type="warning">
**In-memory state is lost on eviction.** Class properties not backed by SQLite disappear after ~30s of inactivity. Always persist important state using `remember()` or `ctx.storage`.
</Callout>

### Memory Persistence Example

```typescript
class CustomerAgent extends Agent {
  // BAD: Lost on eviction
  private recentQueries: string[] = []

  async handleQuery(query: string) {
    // BAD: This array disappears after eviction
    this.recentQueries.push(query)

    // GOOD: Persisted to SQLite via unified memory
    await this.remember(`User asked: ${query}`, 'short-term')

    // GOOD: Search persisted memories
    const context = await this.searchMemories(query)

    // Process query with context...
  }
}
```

## Agent Lifecycle

### 1. Creation

Agents are created when first accessed via their DO ID:

```typescript
// Worker routes to Agent DO
const agent = env.AGENTS.get(env.AGENTS.idFromName('support:acme'))
const response = await agent.fetch(request)
```

### 2. Initialization

```typescript
class SupportAgent extends Agent {
  async onStart() {
    // Register tools the agent can use
    this.registerTool({
      name: 'searchKB',
      description: 'Search the knowledge base',
      parameters: { query: { type: 'string' } },
      handler: async ({ query }) => this.searchKnowledgeBase(query),
    })

    // Set up event handlers (inherited from DO)
    this.$.on.Ticket.created(this.handleNewTicket.bind(this))

    // Optionally set unified memory
    // this.setMemory(createGraphMemory({ store: this.graphStore, agentId: this.ctx.id.toString() }))
  }
}
```

### 3. Execution (Observe-Think-Act Loop)

When an agent runs a goal:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Agent.run(goal)                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │         1. OBSERVE            │
                    │                               │
                    │  • Load recent memories       │
                    │  • Get available tools        │
                    │  • Gather current state       │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │          2. THINK             │
                    │                               │
                    │  • Reason about goal          │
                    │  • Decide next action         │
                    │  • Check constraints          │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │           3. ACT              │
                    │                               │
                    │  • Execute tool               │
                    │  • Update state               │
                    │  • Emit events                │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                          ┌─────────────────┐
                          │ Goal achieved?  │
                          └────────┬────────┘
                                   │
                      ┌────────────┴────────────┐
                      │                         │
                      ▼                         ▼
                 ┌────────┐               ┌──────────┐
                 │   No   │──────────────▶│  Repeat  │
                 └────────┘               └──────────┘
                      │
                      ▼
                 ┌────────┐
                 │  Yes   │──────────────▶ Return result
                 └────────┘
```

### 4. Eviction and Rehydration

```
Active Agent                     Idle (30s)                    Evicted
     │                               │                            │
     │  Processing requests          │  No activity               │
     │  Memory in RAM                │  Timer counting            │  State in SQLite
     │  Tools registered             │                            │  RAM released
     │                               │                            │
     ▼                               ▼                            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           New Request Arrives                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │        REHYDRATION            │
                    │                               │
                    │  • Load state from SQLite     │
                    │  • Run onStart() again        │
                    │  • Re-register tools          │
                    │  • Resume processing          │
                    └───────────────────────────────┘
```

<Callout type="info">
**onStart() runs on every rehydration**, not just first creation. Register tools and event handlers there so they're available after eviction.
</Callout>

## Memory Boundaries

### What's Shared vs. Isolated

| Scope | Boundary | Example |
|-------|----------|---------|
| **Per-Agent** | Single DO instance | Agent's memories, tools, registered handlers |
| **Per-Tenant** | DO namespace | All agents for one customer |
| **Cross-Agent** | RPC via `$` | Agent A calling Agent B |
| **Global** | R2, KV, external APIs | Shared knowledge bases |

### Cross-Agent Communication

Agents can communicate via the `$` WorkflowContext:

```typescript
class OrchestratorAgent extends Agent {
  async coordinateTask(task: string) {
    // Call another agent (cross-DO RPC)
    const analysis = await this.$.Agent('analyst').analyze(task)

    // Fire-and-forget to another agent
    this.$.send({ type: 'task.started', to: 'Agent/monitor', data: { task } })

    return analysis
  }
}
```

### Memory Isolation

Each agent has its own memory namespace:

```typescript
// Agent A (support:acme)
await this.remember('Customer prefers email', 'long-term')

// Agent B (support:globex) - Cannot see Agent A's memories
const memories = await this.searchMemories('Customer preferences')
// Returns only Agent B's memories
```

## Two Agent Systems

dotdo has two agent implementations:

### 1. DO-Based Agent (`objects/Agent.ts`)

The persistent agent that runs inside a Durable Object:

```typescript
import { Agent } from 'dotdo'

class MyAgent extends Agent {
  // Runs inside a DO
  // Has access to: this.db, this.ctx.storage, this.$
  // State persists across requests
  // Survives eviction via SQLite
}
```

**Use when:**
- Agent needs persistent state
- Agent handles ongoing conversations
- Agent needs to schedule tasks
- Agent needs to receive events

### 2. SDK Agent (`agents/Agent.ts`)

The stateless agent SDK for provider abstraction:

```typescript
import { createClaudeProvider } from 'agents/providers'

const provider = createClaudeProvider({ apiKey: process.env.ANTHROPIC_API_KEY })
const agent = provider.createAgent({
  id: 'reviewer',
  instructions: 'Review code...',
})

const result = await agent.run({ prompt: 'Review this PR' })
```

**Use when:**
- Running one-shot agent tasks
- Need provider abstraction (Claude, OpenAI, etc.)
- Building stateless workflows
- Testing agent behaviors

### Combining Both

The DO-based agent can use the SDK agent internally:

```typescript
import { Agent } from 'dotdo'
import { createClaudeProvider } from 'agents/providers'

class SmartAgent extends Agent {
  private llm = createClaudeProvider({ apiKey: this.env.ANTHROPIC_API_KEY })

  async handleQuestion(question: string) {
    // Get context from persistent memory
    const memories = await this.searchMemories(question)

    // Use SDK agent for LLM call
    const sdkAgent = this.llm.createAgent({
      id: 'answerer',
      instructions: `Answer using this context: ${memories.map(m => m.content).join('\n')}`,
    })

    const result = await sdkAgent.run({ prompt: question })

    // Persist the interaction
    await this.remember(`Q: ${question}\nA: ${result.text}`, 'episodic')

    return result.text
  }
}
```

## Named Agents (Priya, Ralph, Tom, etc.)

The named agents from `agents.do` are stateless SDK agents with predefined personas:

```typescript
import { priya, ralph, tom } from 'agents.do'

// These are NOT Durable Objects
// They're stateless SDK agents with persona configurations

const spec = await priya`define the MVP for ${hypothesis}`
const app = await ralph`build ${spec}`
const approved = await tom.approve(app)
```

To make named agents persistent, instantiate them inside a DO:

```typescript
import { Agent } from 'dotdo'
import { createNamedAgent } from 'agents/named'

class ProductTeam extends Agent {
  async onStart() {
    // Create persistent versions of named agents
    this.priya = createNamedAgent('priya', { memory: this.getMemory() })
    this.ralph = createNamedAgent('ralph', { memory: this.getMemory() })
  }
}
```

## Related

<Cards>
  <Card title="Durable Objects Deep Dive" href="/docs/architecture/durable-objects">
    DO lifecycle, state management, and hibernation.
  </Card>
  <Card title="Agent Tools" href="/docs/agents/tools">
    Register and execute tools within agents.
  </Card>
  <Card title="Named Agents" href="/docs/agents/named-agents">
    Meet Priya, Ralph, Tom, Mark, Sally, and Quinn.
  </Card>
  <Card title="Custom Agents" href="/docs/agents/custom-agents">
    Build domain-specific agents with persistent state.
  </Card>
</Cards>
