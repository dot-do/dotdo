---
title: Integration Testing
description: Testing with the Cloudflare Workers runtime and real bindings
---

import { Callout } from 'fumadocs-ui/components/callout'

<Callout type="info" title="Part of Testing Guide">
This page is part of the [Testing](/docs/guides/testing) guide, which is part of [Guides](/docs/guides).
</Callout>

# Integration Testing

Integration tests run in the actual Workers runtime using `@cloudflare/vitest-pool-workers`. This provides access to real KV, Durable Objects, R2, and other bindings through Miniflare.

## Setting Up Workers Tests

Configure the Workers pool in your vitest config:

```typescript title="tests/config/vitest.workers.config.ts"
import { defineWorkersConfig } from '@cloudflare/vitest-pool-workers/config'

export default defineWorkersConfig({
  test: {
    globals: true,
    pool: '@cloudflare/vitest-pool-workers',
    poolOptions: {
      workers: {
        // Use wrangler.jsonc for bindings
        wrangler: { configPath: './wrangler.jsonc' },

        // Isolate storage between tests
        isolatedStorage: true,

        // Single worker for CI stability
        singleWorker: true,

        miniflare: {
          verbose: process.env.DEBUG === 'true',
          compatibilityDate: '2026-01-08',
          compatibilityFlags: ['nodejs_compat', 'nodejs_compat_v2'],
          // Enable outbound network for CDN fetches
          outboundService: 'internet',
        },
      },
    },
    testTimeout: 15_000,
    hookTimeout: 15_000,
    retry: process.env.CI ? 1 : 0,
  },
})
```

## Using cloudflare:test Imports

The Workers pool provides special imports:

```typescript title="api/tests/infrastructure/vitest.test.ts"
import { describe, it, expect, beforeEach } from 'vitest'
import { env, SELF, fetchMock } from 'cloudflare:test'

describe('Vitest Infrastructure', () => {
  it('provides env with bindings', () => {
    expect(env).toBeDefined()
    expect(typeof env).toBe('object')
  })

  it('provides SELF fetcher for worker requests', () => {
    expect(SELF).toBeDefined()
    expect(typeof SELF.fetch).toBe('function')
  })

  it('provides fetchMock for outbound requests', () => {
    expect(fetchMock).toBeDefined()
    expect(typeof fetchMock.activate).toBe('function')
    expect(typeof fetchMock.deactivate).toBe('function')
  })
})
```

## Testing Durable Objects

Access DO bindings through `env`:

```typescript title="api/tests/routes/startup.test.ts"
import { describe, it, expect } from 'vitest'
import { env } from 'cloudflare:test'

describe('Startup DO Integration', () => {
  it('creates and configures a startup', async () => {
    const id = env.MY_STARTUP.idFromName('test-startup')
    const stub = env.MY_STARTUP.get(id)

    // Configure via HTTP endpoint
    const configResponse = await stub.fetch('http://test/config', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Integration Test Startup',
        slug: 'int-test',
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    expect(configResponse.status).toBe(200)

    // Verify configuration persisted
    const getResponse = await stub.fetch('http://test/config')
    const data = await getResponse.json()

    expect(data.name).toBe('Integration Test Startup')
  })

  it('binds agents and retrieves them', async () => {
    const id = env.MY_STARTUP.idFromName('agent-test')
    const stub = env.MY_STARTUP.get(id)

    // Bind an agent
    await stub.fetch('http://test/agents', {
      method: 'POST',
      body: JSON.stringify({
        agentId: 'support-agent',
        name: 'Support Agent',
        role: 'primary',
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    // List agents
    const response = await stub.fetch('http://test/agents')
    const agents = await response.json()

    expect(agents).toHaveLength(1)
    expect(agents[0].role).toBe('primary')
  })
})
```

## Test Isolation

Storage is automatically reset between tests:

```typescript title="api/tests/isolation.test.ts"
import { describe, it, expect } from 'vitest'
import { env } from 'cloudflare:test'

describe('Storage Isolation', () => {
  const STORAGE_KEY = 'isolation-test'
  const TEST_VALUE = 'value-' + Math.random()

  it('test 1: writes to KV', async () => {
    // Storage starts empty
    const existing = await env.TEST_KV.get(STORAGE_KEY)
    expect(existing).toBeNull()

    // Write a value
    await env.TEST_KV.put(STORAGE_KEY, TEST_VALUE)

    const stored = await env.TEST_KV.get(STORAGE_KEY)
    expect(stored).toBe(TEST_VALUE)
  })

  it('test 2: storage is reset', async () => {
    // Value from test 1 should NOT exist
    const existing = await env.TEST_KV.get(STORAGE_KEY)

    // This proves isolation works
    expect(existing).toBeNull()
  })
})
```

## Testing with SELF

Use `SELF` to test your worker's HTTP interface:

```typescript title="api/tests/routes/health.test.ts"
import { describe, it, expect } from 'vitest'
import { SELF } from 'cloudflare:test'

describe('Health Endpoint', () => {
  it('GET /health returns 200', async () => {
    const response = await SELF.fetch('http://localhost/health')

    expect(response.status).toBe(200)
    expect(response.headers.get('content-type')).toContain('application/json')

    const data = await response.json()
    expect(data.status).toBe('healthy')
  })

  it('handles errors gracefully', async () => {
    const response = await SELF.fetch('http://localhost/not-found')

    expect(response.status).toBe(404)
  })
})
```

## Mocking Outbound Requests

Use `fetchMock` to mock external API calls:

```typescript title="api/tests/external-api.test.ts"
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { SELF, fetchMock } from 'cloudflare:test'

describe('External API Integration', () => {
  beforeEach(() => {
    fetchMock.activate()
    fetchMock.disableNetConnect()
  })

  afterEach(() => {
    fetchMock.deactivate()
  })

  it('calls external weather API', async () => {
    // Mock the external API
    fetchMock
      .get('https://api.weather.example/forecast')
      .reply(200, {
        temperature: 22,
        condition: 'sunny',
      })

    // Call your endpoint that uses the external API
    const response = await SELF.fetch('http://localhost/api/weather')
    const data = await response.json()

    expect(data.temperature).toBe(22)
    expect(data.condition).toBe('sunny')
  })

  it('handles external API errors', async () => {
    fetchMock
      .get('https://api.weather.example/forecast')
      .reply(500, { error: 'Service unavailable' })

    const response = await SELF.fetch('http://localhost/api/weather')

    expect(response.status).toBe(502) // Gateway error
  })
})
```

## Testing Cross-DO Communication

Test Durable Objects calling each other:

```typescript title="api/tests/cross-do.test.ts"
import { describe, it, expect } from 'vitest'
import { env } from 'cloudflare:test'

describe('Cross-DO Communication', () => {
  it('Startup dispatches work to Agent', async () => {
    // Create startup
    const startupId = env.MY_STARTUP.idFromName('dispatch-test')
    const startup = env.MY_STARTUP.get(startupId)

    // Bind an agent first
    await startup.fetch('http://test/agents', {
      method: 'POST',
      body: JSON.stringify({
        agentId: 'worker-agent',
        name: 'Worker Agent',
        role: 'primary',
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    // Dispatch work
    const response = await startup.fetch('http://test/dispatch', {
      method: 'POST',
      body: JSON.stringify({
        type: 'customer-inquiry',
        input: { question: 'What is my balance?' },
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    const result = await response.json()

    expect(result).toHaveProperty('workId')
    expect(result).toHaveProperty('assignedTo')
  })
})
```

## Testing Event Handlers

Test the event system in the Workers runtime:

```typescript title="api/tests/events.test.ts"
import { describe, it, expect } from 'vitest'
import { env } from 'cloudflare:test'

describe('Event System', () => {
  it('emits and handles phase change event', async () => {
    const id = env.MY_STARTUP.idFromName('event-test')
    const stub = env.MY_STARTUP.get(id)

    // Register a handler that stores events
    await stub.fetch('http://test/handlers/register', {
      method: 'POST',
      body: JSON.stringify({
        event: 'phase.changed',
        action: 'log',
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    // Trigger phase change
    await stub.fetch('http://test/phase', {
      method: 'POST',
      body: JSON.stringify({ phase: 'mvp' }),
      headers: { 'Content-Type': 'application/json' },
    })

    // Check event was handled
    const logsResponse = await stub.fetch('http://test/logs')
    const logs = await logsResponse.json()

    expect(logs).toContainEqual(
      expect.objectContaining({
        event: 'phase.changed',
        data: expect.objectContaining({ phase: 'mvp' }),
      })
    )
  })
})
```

## Testing Scheduled Events

Test cron-triggered workflows:

```typescript title="api/tests/scheduled.test.ts"
import { describe, it, expect } from 'vitest'
import { env } from 'cloudflare:test'

describe('Scheduled Workflows', () => {
  it('handles daily metrics collection', async () => {
    const id = env.MY_STARTUP.idFromName('scheduled-test')
    const stub = env.MY_STARTUP.get(id)

    // Simulate scheduled event
    const response = await stub.fetch('http://test/scheduled/daily-metrics', {
      method: 'POST',
      body: JSON.stringify({
        cron: '0 0 * * *',
        scheduledTime: new Date().toISOString(),
      }),
      headers: { 'Content-Type': 'application/json' },
    })

    expect(response.status).toBe(200)

    // Verify metrics were collected
    const metricsResponse = await stub.fetch('http://test/metrics')
    const metrics = await metricsResponse.json()

    expect(metrics).toHaveProperty('collectedAt')
  })
})
```

## Debugging Integration Tests

Enable verbose logging:

```bash
# Run with debug output
DEBUG=true npx vitest --project=workers

# Run single test with full output
npx vitest run api/tests/specific.test.ts --reporter=verbose
```

Add logging in tests:

```typescript
it('debugs complex flow', async () => {
  const id = env.MY_STARTUP.idFromName('debug-test')
  const stub = env.MY_STARTUP.get(id)

  const response = await stub.fetch('http://test/complex')

  if (!response.ok) {
    const text = await response.text()
    console.error('Response body:', text)
    console.error('Status:', response.status)
  }

  expect(response.ok).toBe(true)
})
```

## Best Practices

1. **Use descriptive DO names** - `idFromName('payment-processing-test')` not `idFromName('test')`
2. **Test complete flows** - Integration tests should cover end-to-end scenarios
3. **Mock external services** - Use `fetchMock` for third-party APIs
4. **Check error states** - Test 4xx and 5xx responses
5. **Run sequentially in CI** - Set `singleWorker: true` for stability

```typescript
// Good: Complete flow test
it('complete customer signup flow', async () => {
  // 1. Create customer
  // 2. Verify welcome email triggered
  // 3. Check customer in database
  // 4. Verify analytics event sent
})

// Avoid: Testing implementation details
it('calls internal helper function', async () => {
  // Too coupled to implementation
})
```

## Next Steps

- [Agent Testing](/guides/testing/agent-tests) - Mock providers for agent tests
- [Unit Testing](/guides/testing/unit-tests) - Fast tests with mocked infrastructure
