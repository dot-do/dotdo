---
title: Advanced Guides
description: Advanced topics and techniques for dotdo
---

# Advanced Guides

Deep dive into advanced dotdo features and patterns.

## Custom Middleware

Add custom middleware to your dotdo API for cross-cutting concerns like logging, rate limiting, and request validation.

```typescript
import { API } from 'dotdo'
import { Hono } from 'hono'

const app = new Hono()

// Logging middleware
app.use('*', async (c, next) => {
  const start = Date.now()
  await next()
  const duration = Date.now() - start
  console.log(`${c.req.method} ${c.req.path} - ${duration}ms`)
})

// Rate limiting middleware
app.use('/api/*', async (c, next) => {
  const ip = c.req.header('cf-connecting-ip')
  const key = `ratelimit:${ip}`

  const count = await c.env.KV.get(key)
  if (count && parseInt(count) > 100) {
    return c.json({ error: 'Rate limited' }, 429)
  }

  await c.env.KV.put(key, String((parseInt(count || '0')) + 1), {
    expirationTtl: 60,
  })

  await next()
})

export default API({ app })
```

## Performance Optimization

### Promise Pipelining

Batch multiple operations into single network round trips.

```typescript
// Bad: 3 sequential awaits = 3 round trips
const spec = await priya`define the MVP`
const code = await ralph`build ${spec}`
const review = await tom`review ${code}`

// Good: Pipeline = 1 round trip
const spec = priya`define the MVP`
const code = ralph`build ${spec}`
const review = tom`review ${code}`
const result = await review // All resolve together
```

### Sharding for Scale

Distribute load across multiple Durable Objects.

```typescript
import { ShardRouter } from 'dotdo'

const router = new ShardRouter(env.DO, {
  key: 'tenant_id',
  count: 64,              // 64 shards
  algorithm: 'consistent', // Minimal redistribution
})

// Queries route to the correct shard
const result = await router.query(`/users?tenant_id=${tenantId}`)
```

### Storage Tiering

Optimize for access patterns with automatic tiering.

```typescript
import { TieredStorage } from 'dotdo'

const storage = new TieredStorage({
  hot: {
    backend: 'sqlite',    // DO SQLite for hot data
    maxSize: '100MB',
    ttl: '7d',
  },
  warm: {
    backend: 'r2',        // R2 for warm data
    compression: 'zstd',
  },
  cold: {
    backend: 'parquet',   // Parquet for analytics
    partitionBy: ['year', 'month'],
  },
})

// Recent data: <10ms from SQLite
const recent = await storage.query('SELECT * FROM orders WHERE created_at > now() - interval \'7d\'')

// Historical data: DuckDB on Parquet
const historical = await storage.analytics('SELECT sum(amount) FROM orders WHERE year = 2024')
```

## Multi-Region Setup

Deploy to multiple regions with geo-aware routing.

```typescript
import { API, GeoRouter } from 'dotdo'

const geo = new GeoRouter({
  regions: ['us-east', 'eu-west', 'ap-south'],
  routing: 'latency',  // Route to nearest region
  fallback: 'us-east', // Fallback if region unavailable
})

// Jurisdiction-aware data routing
const router = new GeoRouter({
  regions: ['eu-west', 'us-east'],
  routing: 'jurisdiction',
  rules: {
    'EU': 'eu-west',    // EU data stays in EU
    '*': 'us-east',     // Everything else to US
  },
})

export default API({
  router: geo,
  replication: {
    strategy: 'async',
    lag: '50ms',
  },
})
```

## Topics

- [Deployment](/docs/deployment) - Production deployment strategies
- [Sharding](/docs/deployment/sharding) - Horizontal scaling patterns
- [Geo-Replication](/docs/deployment/geo-replication) - Multi-region deployments
