---
title: Deployment
description: Scale from prototype to production with sharding, geo-replication, and dynamic promotion
---

# Deployment

dotdo runs on Cloudflare's edge network: 300+ cities, 0ms cold starts, V8 isolates with persistent state. This section covers deploying to production and the scaling primitives that let you grow from a single Durable Object to a globally distributed system.

## Getting Started

### Prerequisites

Before deploying, ensure you have:

- Cloudflare account configured
- Wrangler CLI installed
- Production secrets set

### Basic Deployment

```bash
npm run deploy
```

Or using wrangler directly:

```bash
wrangler deploy
```

### Environment Variables

Set production environment variables:

```bash
wrangler secret put DATABASE_URL
wrangler secret put API_SECRET
```

### Rollback

If something goes wrong:

```bash
wrangler rollback
```

## The 10GB Problem

Every Durable Object has a 10GB SQLite limit. That sounds like a lot until you're running 100,000 concurrent AI agents, each accumulating state.

dotdo provides three strategies for scaling beyond this limit:

<Cards>
  <Card title="Sharding" href="/docs/deployment/sharding">
    Split a single DO across multiple instances. Consistent hashing minimizes redistribution.
  </Card>
  <Card title="Geo-Replication" href="/docs/deployment/geo-replication">
    Distribute replicas across regions. Read from nearest, write to primary.
  </Card>
  <Card title="Promote/Demote" href="/docs/deployment/promote-demote">
    Elevate Things to their own DOs. Demote them back when they cool down.
  </Card>
</Cards>

## Quick Overview

```typescript
// Shard when you hit the storage limit
startup.shard({
  key: 'customerId',
  count: 16,
  strategy: 'hash'
})

// Replicate when you need global presence
startup.replicate({
  primary: 'us-east',
  secondaries: ['eu-west', 'asia-pacific'],
  readPreference: 'nearest',
})

// Promote when a Thing needs its own DO
const newDO = await customer.promote({
  colo: 'Frankfurt'  // GDPR compliance
})

// Demote when it's done
await customer.demote({ preserveHistory: true })
```

## When to Use What

| Strategy | Use Case | Tradeoff |
|----------|----------|----------|
| **Sharding** | Single region, high write volume | Cross-shard queries require fan-out |
| **Geo-Replication** | Global reads, regional writes | Eventual consistency for replicas |
| **Promote/Demote** | Hot entities need isolation | Promotion has latency cost |

## Limits

| Resource | Limit |
|----------|-------|
| SQLite per DO | 10GB |
| Shards per DO | 1,000 |
| Concurrent DOs | Unlimited |
| Regions | 9 geographic regions |
| Cities (IATA codes) | 35+ supported |

## Next Steps

- [Cloudflare Workers](/docs/deployment/cloudflare) - Wrangler configuration and secrets management
- [Preview Deployments](/docs/deployment/preview) - Branch and PR preview environments
- [Rollbacks](/docs/deployment/rollback) - Version management and canary deployments
- [Monitoring](/docs/deployment/monitoring) - Health checks and alerting
- [Sharding](/docs/deployment/sharding) - Horizontal scaling with consistent hashing
- [Geo-Replication](/docs/deployment/geo-replication) - Multi-region deployment
- [Promote/Demote](/docs/deployment/promote-demote) - Dynamic scaling of entities
- [Observability](/docs/observability) - Logging, metrics, and tracing for production
