---
title: Sharding
description: Horizontal scaling with consistent hashing, range partitioning, and round-robin distribution
---

# Sharding

A single Durable Object has a 10GB SQLite limit. Sharding distributes data across multiple DOs, giving you 10GB per shard times up to 1,000 shards = 10TB per logical database.

## Basic Usage

```typescript
startup.shard({
  key: 'customerId',      // Field to partition on
  count: 16,              // Number of shards
  strategy: 'hash'        // Distribution algorithm
})
```

## Sharding Strategies

### Consistent Hashing (Default)

```typescript
startup.shard({
  key: 'tenantId',
  count: 16,
  strategy: 'consistent'
})
```

Consistent hashing uses virtual nodes (150 per shard by default) to minimize key redistribution when adding or removing shards. If you scale from 16 to 32 shards, only ~50% of keys move.

**Best for:** Multi-tenant applications, user data, anything that grows unpredictably.

### Range Partitioning

```typescript
startup.shard({
  key: 'timestamp',
  count: 12,              // One per month
  strategy: 'range'
})
```

Range sharding places sequential values in the same shard. Numeric keys are divided evenly across the range. String keys use alphabetical partitioning.

**Best for:** Time-series data, logs, ordered data that you query by range.

### Round Robin

```typescript
startup.shard({
  key: 'id',
  count: 8,
  strategy: 'roundRobin'
})
```

Round-robin distributes items sequentially across shards. Guarantees even distribution but provides no locality.

**Best for:** Event streams, queue processing, when you don't care which shard gets what.

### Custom Strategy

```typescript
startup.shard({
  key: 'region',
  count: 4,
  strategy: 'custom',
  keyExtractor: (thing) => {
    // Route by geographic region
    const region = thing.data.region
    return { 'us': 0, 'eu': 1, 'apac': 2 }[region] ?? 3
  }
})
```

Custom strategies let you implement domain-specific partitioning logic.

## How It Works

### Shard Routing

```typescript
const router = new ShardRouter(env.DO, {
  key: 'tenant_id',
  count: 16,
  algorithm: 'consistent',
})

// Route a specific key
const stub = await router.getShardStub('tenant-123')
await stub.fetch('/query', { method: 'POST', body: sql })

// Fan out to all shards
const results = await router.queryAll('/aggregate', { body: aggregateSql })
```

### SQL Key Extraction

The router automatically extracts shard keys from SQL statements:

```typescript
// Automatically routes to correct shard
await router.getShardStubForSql(
  "SELECT * FROM orders WHERE tenant_id = 'acme'",
  []
)

// Parameterized queries work too
await router.getShardStubForSql(
  "SELECT * FROM orders WHERE tenant_id = ?",
  ['acme']
)

// Named parameters
await router.getShardStubForSql(
  "SELECT * FROM orders WHERE tenant_id = :tenant_id",
  { tenant_id: 'acme' }
)
```

### Cross-Shard Queries

When a query doesn't specify a shard key, or uses `IN (...)`, the router fans out to all shards:

```typescript
// No shard key - queries all shards
const allOrders = await router.queryAll('/query', {
  body: JSON.stringify({ sql: 'SELECT COUNT(*) FROM orders' })
})

// Aggregate results
const totalCount = allOrders.reduce((sum, r) => sum + r.data.count, 0)
```

## Sharding Operations

### Creating Shards

```typescript
const result = await startup.shard({
  key: 'customerId',
  count: 16,
  strategy: 'hash'
})

console.log(result)
// {
//   shardKey: 'customerId',
//   shards: [
//     { ns: 'startup-shard-0', doId: '...', shardIndex: 0, thingCount: 1250 },
//     { ns: 'startup-shard-1', doId: '...', shardIndex: 1, thingCount: 1248 },
//     ...
//   ],
//   stats: {
//     totalThings: 20000,
//     minPerShard: 1180,
//     maxPerShard: 1320,
//     avgPerShard: 1250,
//     stdDev: 42.3,
//     skewRatio: 1.12
//   }
// }
```

### Rebalancing

```typescript
// Scale up
await startup.rebalanceShards({
  targetCount: 32,        // Double the shards
  strategy: 'incremental' // Move minimal data
})

// Scale down
await startup.rebalanceShards({
  targetCount: 8,         // Halve the shards
  maxSkew: 1.2           // Keep distribution even
})
```

### Unsharding

```typescript
// Merge all shards back into one DO
await startup.unshard()
```

This collects all data from all shards and consolidates it into the original DO. Use when you've cleaned up data and no longer need the capacity.

### Shard Discovery

```typescript
const { registry, health } = await startup.discoverShards()

for (const shard of health) {
  console.log(`Shard ${shard.shardIndex}: ${shard.healthy ? 'OK' : 'FAIL'}`)
  console.log(`  Response time: ${shard.responseTime}ms`)
}
```

## Best Practices

### Choose the Right Shard Key

The shard key determines data locality. Good shard keys:

- Have high cardinality (many unique values)
- Are immutable (don't change after creation)
- Are used in most queries (avoid cross-shard joins)

```typescript
// Good: tenant_id for multi-tenant apps
startup.shard({ key: 'tenantId', count: 16, strategy: 'hash' })

// Bad: status (low cardinality, most data in 'active')
startup.shard({ key: 'status', count: 16, strategy: 'hash' })
```

### Start Conservative

```typescript
// Start with fewer shards
startup.shard({ key: 'customerId', count: 8, strategy: 'consistent' })

// Scale up later with minimal redistribution
await startup.rebalanceShards({ targetCount: 16 })
```

### Monitor Distribution

```typescript
const stats = await startup.discoverShards()

// Alert on skew
if (stats.registry.stats.skewRatio > 2.0) {
  console.warn('High shard skew detected - consider rebalancing')
}
```

## Limits

| Limit | Value |
|-------|-------|
| Max shards per DO | 1,000 |
| SQLite per shard | 10GB |
| Max total capacity | 10TB |
| Shard key types | string, number |

## Related

- [Geo-Replication](/docs/deployment/geo-replication) - Multi-region distribution
- [Promote/Demote](/docs/deployment/promote-demote) - Dynamic entity scaling
