---
title: SaaS Starter
description: Build a complete SaaS with auth, subscriptions, and dashboard in 30 minutes
---

import { Callout } from 'fumadocs-ui/components/callout'

# Build a SaaS in 30 Minutes

User signup. Stripe subscriptions. Dashboard with metrics. Email notifications. All powered by your AI team.

By the end, you'll have a deployed SaaS at `your-app.workers.dev` with Sally handling customer onboarding and Mark sending launch announcements.

---

<Steps>

<Step>

## Create the Project

```bash
npx dotdo init my-saas --template saas
cd my-saas
npm install
```

This gives you:
- Auth configured with [org.ai](https://id.org.ai)
- Stripe integration ready
- Dashboard scaffolding
- Agent configurations

</Step>

<Step>

## Configure Environment

Create `.env` with your keys:

```bash title=".env"
# org.ai Authentication
ORGAI_CLIENT_ID=your_client_id
ORGAI_CLIENT_SECRET=your_secret

# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Email (optional - agents use this)
RESEND_API_KEY=re_...
```

<Callout type="info">
Get your org.ai keys at [id.org.ai/dashboard](https://id.org.ai/dashboard). Stripe test keys work fine for development.
</Callout>

</Step>

<Step>

## Define Your Startup

Open `src/startup.ts` - this is your business logic:

```typescript title="src/startup.ts"
import { Startup } from 'dotdo'
import { priya, ralph, tom, mark, sally, quinn } from 'agents.do'

export class MySaaS extends Startup {
  hypothesis = 'Teams need a simpler way to track OKRs'

  async launch() {
    // Priya defines the MVP
    const spec = priya`define the MVP for ${this.hypothesis}`

    // Ralph builds it
    let app = ralph`build ${spec}`

    // Review loop - Tom reviews, Ralph improves
    do {
      app = ralph`improve ${app} per ${tom}`
    } while (!await tom.approve(app))

    // Quinn validates
    await quinn`test ${app}`

    // Ship it
    await tom`deploy ${app}`

    // Fire-and-forget: marketing and sales
    mark`announce the launch of ${app}`
    sally`start onboarding customers`
  }
}
```

Notice: `mark` and `sally` have no `await`. They run in the background while the function returns.

</Step>

<Step>

## Build the Auth Flow

Create `src/auth.ts` for user signup and login:

```typescript title="src/auth.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'

export class Auth extends DO {
  async init() {
    // When a user signs up
    $.on.User.signup(async (event) => {
      const { user } = event.data

      // Store user
      await $.do('createUser', {
        id: user.id,
        email: user.email,
        name: user.name,
        plan: 'free'
      })

      // Fire-and-forget: welcome sequence
      sally`send welcome email to ${user.email}`
      sally`schedule onboarding call for ${user.name}`
    })

    // When a user logs in
    $.on.User.login(async (event) => {
      // Track for analytics - fire and forget
      $.send('analytics', {
        event: 'login',
        userId: event.data.user.id
      })
    })
  }

  // API endpoint: signup
  async signup(email: string, password: string, name: string) {
    // org.ai handles the actual auth
    const result = await $.try('auth.signup', { email, password, name })

    if (result.success) {
      // Emit event - triggers handler above
      $.send('User.signup', { user: result.user })
    }

    return result
  }

  // API endpoint: login
  async login(email: string, password: string) {
    const result = await $.try('auth.login', { email, password })

    if (result.success) {
      $.send('User.login', { user: result.user })
    }

    return result
  }
}
```

</Step>

<Step>

## Build Subscription Management

Create `src/billing.ts` for Stripe integration:

```typescript title="src/billing.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'
import { ceo } from 'humans.do'

export class Billing extends DO {
  async init() {
    // Successful payment
    $.on.Payment.succeeded(async (event) => {
      const { customerId, amount, plan } = event.data

      // Update user plan
      await $.Customer(customerId).updatePlan(plan)

      // Fire-and-forget notifications
      sally`send receipt to ${customerId} for $${amount}`
    })

    // Payment failed
    $.on.Payment.failed(async (event) => {
      const { customerId, reason } = event.data

      // Sally handles recovery
      sally`follow up on failed payment for ${customerId}: ${reason}`
    })

    // Large refund - escalate to human
    $.on.Refund.requested(async (event) => {
      const { customerId, amount, reason } = event.data

      if (amount > 500) {
        // Human approval required
        const approved = await ceo`approve $${amount} refund for ${reason}`

        if (approved) {
          await $.do('processRefund', { customerId, amount })
          sally`confirm refund to ${customerId}`
        }
      } else {
        // Auto-approve small refunds
        await $.do('processRefund', { customerId, amount })
        sally`confirm refund to ${customerId}`
      }
    })
  }

  // Stripe webhook handler
  async handleWebhook(event: StripeEvent) {
    switch (event.type) {
      case 'checkout.session.completed':
        $.send('Payment.succeeded', {
          customerId: event.data.object.customer,
          amount: event.data.object.amount_total / 100,
          plan: event.data.object.metadata.plan
        })
        break

      case 'invoice.payment_failed':
        $.send('Payment.failed', {
          customerId: event.data.object.customer,
          reason: event.data.object.last_payment_error?.message
        })
        break
    }
  }

  // Create checkout session
  async createCheckout(customerId: string, plan: 'pro' | 'team') {
    const prices = {
      pro: 'price_pro_monthly',
      team: 'price_team_monthly'
    }

    return await $.do('stripe.createCheckoutSession', {
      customer: customerId,
      price: prices[plan],
      successUrl: '/dashboard?upgraded=true',
      cancelUrl: '/pricing'
    })
  }
}
```

<Callout type="warn">
Refunds over $500 escalate to a human via `ceo`. The workflow pauses until they respond via Slack, email, or SMS.
</Callout>

</Step>

<Step>

## Build the Dashboard

Create `src/dashboard.ts` with metrics and activity:

```typescript title="src/dashboard.ts"
import { DO } from 'dotdo'
import { priya } from 'agents.do'

export class Dashboard extends DO {
  async init() {
    // Update metrics daily
    $.every.day.at6am(async () => {
      await this.refreshMetrics()
    })

    // Weekly insights from Priya
    $.every.monday.at9am(async () => {
      const metrics = await this.getMetrics()
      const insights = await priya`analyze ${metrics} and suggest improvements`

      await this.saveInsights(insights)
    })
  }

  async getMetrics() {
    // Aggregate from all customers
    const customers = await $.query('customers', { status: 'active' })

    const mrr = customers.reduce((sum, c) => sum + c.plan.price, 0)
    const churn = await this.calculateChurn()
    const growth = await this.calculateGrowth()

    return {
      mrr,
      customers: customers.length,
      churn,
      growth,
      updatedAt: new Date()
    }
  }

  async refreshMetrics() {
    const metrics = await this.getMetrics()
    $.state.metrics = metrics
    $.log('Metrics refreshed', metrics)
  }

  async calculateChurn() {
    const lastMonth = await $.query('customers', {
      cancelledAt: { $gte: thirtyDaysAgo() }
    })
    const total = await $.query('customers', {
      createdAt: { $lte: thirtyDaysAgo() }
    })

    return total.length > 0 ? lastMonth.length / total.length : 0
  }

  async calculateGrowth() {
    const thisMonth = await $.query('customers', {
      createdAt: { $gte: thirtyDaysAgo() }
    })
    const lastMonth = await $.query('customers', {
      createdAt: {
        $gte: sixtyDaysAgo(),
        $lt: thirtyDaysAgo()
      }
    })

    return lastMonth.length > 0
      ? (thisMonth.length - lastMonth.length) / lastMonth.length
      : 0
  }

  private async saveInsights(insights: string) {
    $.state.insights = {
      content: insights,
      generatedAt: new Date()
    }
  }
}

// Helpers
const thirtyDaysAgo = () => new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
const sixtyDaysAgo = () => new Date(Date.now() - 60 * 24 * 60 * 60 * 1000)
```

</Step>

<Step>

## Build Email Notifications

Create `src/notifications.ts`:

```typescript title="src/notifications.ts"
import { DO } from 'dotdo'
import { mark } from 'agents.do'

export class Notifications extends DO {
  async init() {
    // Welcome sequence
    $.on.User.signup(async (event) => {
      const { user } = event.data

      // Day 0: Welcome
      this.sendEmail(user.email, 'welcome')

      // Day 1: Getting started (scheduled)
      $.after('1 day', async () => {
        this.sendEmail(user.email, 'getting-started')
      })

      // Day 3: Tips
      $.after('3 days', async () => {
        this.sendEmail(user.email, 'tips')
      })

      // Day 7: Check in
      $.after('7 days', async () => {
        const usage = await $.Customer(user.id).getUsage()

        if (usage.actions < 5) {
          // Low engagement - personalized outreach
          const email = await mark`write a check-in email for ${user.name} who hasn't used the product much`
          await this.sendCustomEmail(user.email, email)
        }
      })
    })

    // Upgrade nudge
    $.on.Customer.hitLimit(async (event) => {
      const { customerId, limit } = event.data
      const customer = await $.Customer(customerId).get()

      const email = await mark`
        write an upgrade email for ${customer.name}
        who hit their ${limit} limit on the free plan
      `

      await this.sendCustomEmail(customer.email, email)
    })
  }

  async sendEmail(to: string, template: string) {
    await $.do('email.send', {
      to,
      template,
      from: 'hello@yourapp.com'
    })
  }

  async sendCustomEmail(to: string, content: { subject: string; body: string }) {
    await $.do('email.send', {
      to,
      subject: content.subject,
      html: content.body,
      from: 'hello@yourapp.com'
    })
  }
}
```

</Step>

<Step>

## Wire Up the API

Create `src/api.ts`:

```typescript title="src/api.ts"
import { Hono } from 'hono'
import { Auth } from './auth'
import { Billing } from './billing'
import { Dashboard } from './dashboard'

const app = new Hono()

// Auth routes
app.post('/auth/signup', async (c) => {
  const { email, password, name } = await c.req.json()
  const auth = await Auth.get('default')
  return c.json(await auth.signup(email, password, name))
})

app.post('/auth/login', async (c) => {
  const { email, password } = await c.req.json()
  const auth = await Auth.get('default')
  return c.json(await auth.login(email, password))
})

// Billing routes
app.post('/billing/checkout', async (c) => {
  const { customerId, plan } = await c.req.json()
  const billing = await Billing.get('default')
  return c.json(await billing.createCheckout(customerId, plan))
})

app.post('/billing/webhook', async (c) => {
  const event = await c.req.json()
  const billing = await Billing.get('default')
  await billing.handleWebhook(event)
  return c.json({ received: true })
})

// Dashboard routes
app.get('/dashboard/metrics', async (c) => {
  const dashboard = await Dashboard.get('default')
  return c.json(await dashboard.getMetrics())
})

export default app
```

</Step>

<Step>

## Test Locally

```bash
npm run dev
```

Open [http://localhost:8787](http://localhost:8787).

Test the flow:

```bash
# Sign up
curl -X POST http://localhost:8787/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123","name":"Test User"}'

# Check dashboard
curl http://localhost:8787/dashboard/metrics
```

Watch the terminal - you'll see Sally sending welcome emails and scheduling onboarding.

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Your SaaS is now live at `my-saas.workers.dev`.

Set production secrets:

```bash
npx wrangler secret put ORGAI_CLIENT_SECRET
npx wrangler secret put STRIPE_SECRET_KEY
npx wrangler secret put STRIPE_WEBHOOK_SECRET
npx wrangler secret put RESEND_API_KEY
```

Update your Stripe webhook URL to `https://my-saas.workers.dev/billing/webhook`.

</Step>

</Steps>

---

## What You Built

In 30 minutes, you've deployed a SaaS with:

| Feature | Implementation |
|---------|----------------|
| User auth | org.ai + signup/login flows |
| Subscriptions | Stripe checkout + webhooks |
| Dashboard | Real-time metrics + weekly insights |
| Notifications | Welcome sequence + smart follow-ups |
| Human escalation | Large refunds go to CEO |

And it runs itself:
- Sally handles customer onboarding
- Mark writes personalized emails
- Priya generates weekly insights
- Refunds over $500 wait for human approval

---

## Key Patterns Used

### Fire-and-Forget for Background Work

```typescript
// These don't block
sally`send welcome email to ${user.email}`
mark`announce the launch`
```

### $.do() for Critical Operations

```typescript
// These must succeed - retries built in
await $.do('processRefund', { customerId, amount })
await $.do('stripe.createCheckoutSession', { ... })
```

### Human Escalation for Decisions

```typescript
if (amount > 500) {
  const approved = await ceo`approve $${amount} refund`
  // Waits for human response
}
```

### Scheduled Jobs

```typescript
$.every.day.at6am(async () => await this.refreshMetrics())
$.every.monday.at9am(async () => priya`analyze metrics`)
```

---

## Next Steps

Your SaaS is live. Here's what to explore:

- [Customize agents](/docs/agents/custom-agents) - Train Sally's voice
- [Add more humans](/docs/humans) - Route to different team members
- [Deployment config](/docs/deployment) - Custom domains, regions
- [E-commerce tutorial](/docs/tutorials/ecommerce) - Build a store next

---

**You built a SaaS. Sally's onboarding customers. Mark's writing emails. Go get some coffee.**
