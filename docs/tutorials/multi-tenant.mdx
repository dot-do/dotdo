---
title: Multi-tenant SaaS
description: Build a multi-tenant SaaS application with tenant isolation, per-tenant databases, and billing integration in 30 minutes
---

import { Callout } from 'fumadocs-ui/components/callout'

# Build a Multi-tenant SaaS in 30 Minutes

Tenant isolation. Database per tenant. Per-tenant billing. All powered by Durable Objects for true data isolation and the dotdo routing layer for seamless multi-tenancy.

By the end, you'll have a deployed SaaS where each tenant has their own isolated data, custom subdomain, and subscription management.

---

## Prerequisites

Before starting this tutorial, you'll need:

- Node.js 18+
- A Cloudflare account (free tier works)
- A Stripe account for billing
- Basic familiarity with TypeScript

---

<Steps>

<Step>

## Create the Project

```bash
npx dotdo init my-saas --template multi-tenant
cd my-saas
npm install
```

You get:
- Tenant isolation infrastructure
- Per-tenant Durable Objects
- Subdomain routing
- Stripe billing integration

</Step>

<Step>

## Configure Environment

```bash title=".env"
# Auth
JWT_SECRET=your-super-secret-key
ORGAI_CLIENT_ID=your_client_id
ORGAI_CLIENT_SECRET=your_client_secret

# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRICE_STARTER=price_starter_monthly
STRIPE_PRICE_PRO=price_pro_monthly
STRIPE_PRICE_ENTERPRISE=price_enterprise_monthly

# Database (optional - uses DO storage by default)
DATABASE_URL=postgres://...
```

<Callout type="info">
Each tenant gets their own Durable Object, providing complete data isolation without needing separate databases. For larger tenants, you can migrate to dedicated databases.
</Callout>

</Step>

<Step>

## Build the Tenant Manager

Create `src/tenant.ts` - the core tenant infrastructure:

```typescript title="src/tenant.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'

interface TenantConfig {
  id: string
  name: string
  slug: string
  plan: 'starter' | 'pro' | 'enterprise'
  customDomain?: string
  settings: {
    branding: {
      logo?: string
      primaryColor: string
      companyName: string
    }
    features: string[]
    limits: {
      users: number
      storage: number // GB
      apiCalls: number // per month
    }
  }
  billing: {
    customerId: string
    subscriptionId?: string
    status: 'active' | 'past_due' | 'cancelled' | 'trialing'
    trialEndsAt?: Date
    currentPeriodEnd?: Date
  }
  createdAt: Date
  updatedAt: Date
}

interface TenantStats {
  users: number
  storage: number
  apiCalls: number
  lastActiveAt: Date
}

export class TenantManager extends DO {
  config: TenantConfig | null = null
  stats: TenantStats = {
    users: 0,
    storage: 0,
    apiCalls: 0,
    lastActiveAt: new Date()
  }

  async init() {
    // Check subscription status daily
    $.every.day.at6am(async () => {
      if (this.config) {
        await this.checkSubscription()
      }
    })

    // Reset monthly API call counts
    $.every('first day of month', async () => {
      this.stats.apiCalls = 0
      $.log('API call count reset', { tenantId: this.id })
    })

    // Check for approaching limits
    $.every.hour(async () => {
      if (this.config) {
        await this.checkLimits()
      }
    })
  }

  /**
   * Create a new tenant
   */
  async create(data: {
    name: string
    slug: string
    adminEmail: string
    plan?: TenantConfig['plan']
  }): Promise<TenantConfig> {
    if (this.config) {
      throw new Error('Tenant already exists')
    }

    // Create Stripe customer
    const customerId = await $.do('stripe.createCustomer', {
      email: data.adminEmail,
      name: data.name,
      metadata: { tenantId: this.id, slug: data.slug }
    })

    const plan = data.plan ?? 'starter'
    const limits = this.getPlanLimits(plan)

    this.config = {
      id: this.id,
      name: data.name,
      slug: data.slug,
      plan,
      settings: {
        branding: {
          primaryColor: '#3b82f6',
          companyName: data.name
        },
        features: this.getPlanFeatures(plan),
        limits
      },
      billing: {
        customerId,
        status: 'trialing',
        trialEndsAt: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000) // 14 days
      },
      createdAt: new Date(),
      updatedAt: new Date()
    }

    // Fire-and-forget: welcome sequence
    sally`send welcome email to ${data.adminEmail} for tenant ${data.name}`

    $.log('Tenant created', { tenantId: this.id, slug: data.slug })

    return this.config
  }

  /**
   * Get tenant configuration
   */
  async getConfig(): Promise<TenantConfig | null> {
    return this.config
  }

  /**
   * Update tenant settings
   */
  async updateSettings(settings: Partial<TenantConfig['settings']>) {
    if (!this.config) {
      throw new Error('Tenant not found')
    }

    this.config.settings = {
      ...this.config.settings,
      ...settings,
      branding: {
        ...this.config.settings.branding,
        ...settings.branding
      }
    }
    this.config.updatedAt = new Date()

    return this.config
  }

  /**
   * Update tenant plan
   */
  async updatePlan(plan: TenantConfig['plan']) {
    if (!this.config) {
      throw new Error('Tenant not found')
    }

    const oldPlan = this.config.plan
    this.config.plan = plan
    this.config.settings.features = this.getPlanFeatures(plan)
    this.config.settings.limits = this.getPlanLimits(plan)
    this.config.updatedAt = new Date()

    $.log('Tenant plan updated', {
      tenantId: this.id,
      oldPlan,
      newPlan: plan
    })

    // Notify about the change
    sally`send plan change confirmation for tenant ${this.config.name}: ${oldPlan} -> ${plan}`

    return this.config
  }

  /**
   * Check if a feature is enabled
   */
  async hasFeature(feature: string): Promise<boolean> {
    if (!this.config) return false
    return this.config.settings.features.includes(feature)
  }

  /**
   * Check if within limits
   */
  async checkLimit(resource: 'users' | 'storage' | 'apiCalls', amount: number = 1): Promise<{
    allowed: boolean
    current: number
    limit: number
    remaining: number
  }> {
    if (!this.config) {
      return { allowed: false, current: 0, limit: 0, remaining: 0 }
    }

    const limit = this.config.settings.limits[resource]
    const current = this.stats[resource]
    const remaining = limit - current

    return {
      allowed: current + amount <= limit,
      current,
      limit,
      remaining: Math.max(0, remaining)
    }
  }

  /**
   * Increment resource usage
   */
  async incrementUsage(resource: 'users' | 'storage' | 'apiCalls', amount: number = 1) {
    this.stats[resource] += amount
    this.stats.lastActiveAt = new Date()
  }

  /**
   * Get tenant statistics
   */
  async getStats(): Promise<TenantStats & { limits: TenantConfig['settings']['limits'] }> {
    return {
      ...this.stats,
      limits: this.config?.settings.limits ?? { users: 0, storage: 0, apiCalls: 0 }
    }
  }

  private getPlanLimits(plan: TenantConfig['plan']) {
    const limits = {
      starter: { users: 5, storage: 5, apiCalls: 10000 },
      pro: { users: 25, storage: 50, apiCalls: 100000 },
      enterprise: { users: -1, storage: 500, apiCalls: 1000000 } // -1 = unlimited
    }
    return limits[plan]
  }

  private getPlanFeatures(plan: TenantConfig['plan']) {
    const features = {
      starter: ['basic_analytics', 'email_support'],
      pro: ['basic_analytics', 'advanced_analytics', 'api_access', 'priority_support', 'custom_branding'],
      enterprise: ['basic_analytics', 'advanced_analytics', 'api_access', 'priority_support', 'custom_branding', 'sso', 'audit_logs', 'dedicated_support', 'sla']
    }
    return features[plan]
  }

  private async checkSubscription() {
    if (!this.config?.billing.subscriptionId) return

    // Check with Stripe
    const subscription = await $.try('stripe.getSubscription', {
      subscriptionId: this.config.billing.subscriptionId
    })

    if (subscription.success) {
      const status = subscription.data.status
      if (status !== this.config.billing.status) {
        this.config.billing.status = status

        if (status === 'past_due') {
          sally`send payment reminder to tenant ${this.config.name}`
        } else if (status === 'cancelled') {
          sally`send cancellation confirmation to tenant ${this.config.name}`
        }
      }
    }
  }

  private async checkLimits() {
    if (!this.config) return

    const { limits } = this.config.settings

    // Check API calls
    if (this.stats.apiCalls > limits.apiCalls * 0.8) {
      $.send('tenant.limit.approaching', {
        tenantId: this.id,
        resource: 'apiCalls',
        usage: this.stats.apiCalls,
        limit: limits.apiCalls
      })
    }

    // Check storage
    if (this.stats.storage > limits.storage * 0.8) {
      $.send('tenant.limit.approaching', {
        tenantId: this.id,
        resource: 'storage',
        usage: this.stats.storage,
        limit: limits.storage
      })
    }

    // Check users
    if (limits.users > 0 && this.stats.users > limits.users * 0.8) {
      $.send('tenant.limit.approaching', {
        tenantId: this.id,
        resource: 'users',
        usage: this.stats.users,
        limit: limits.users
      })
    }
  }
}
```

</Step>

<Step>

## Build Tenant-Scoped Data

Create `src/tenant-data.ts` - isolated data per tenant:

```typescript title="src/tenant-data.ts"
import { DO } from 'dotdo'

interface TenantItem {
  id: string
  tenantId: string
  type: string
  data: Record<string, unknown>
  createdAt: Date
  updatedAt: Date
  createdBy: string
}

export class TenantData extends DO {
  private items: Map<string, TenantItem> = new Map()

  /**
   * Create an item in tenant scope
   */
  async create(
    type: string,
    data: Record<string, unknown>,
    createdBy: string
  ): Promise<TenantItem> {
    // Check limit
    const tenant = await $.TenantManager(this.id)
    const limitCheck = await tenant.checkLimit('storage', 1)

    if (!limitCheck.allowed) {
      throw new Error(`Storage limit exceeded. Limit: ${limitCheck.limit}, Current: ${limitCheck.current}`)
    }

    const id = $.id()
    const item: TenantItem = {
      id,
      tenantId: this.id,
      type,
      data,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy
    }

    this.items.set(id, item)
    await tenant.incrementUsage('storage', 1)

    $.log('Item created', { tenantId: this.id, type, id })

    return item
  }

  /**
   * Get an item by ID
   */
  async get(id: string): Promise<TenantItem | null> {
    return this.items.get(id) ?? null
  }

  /**
   * List items by type
   */
  async list(
    type: string,
    options?: {
      limit?: number
      offset?: number
      orderBy?: 'createdAt' | 'updatedAt'
      desc?: boolean
    }
  ): Promise<TenantItem[]> {
    let items = Array.from(this.items.values())
      .filter(item => item.type === type)

    // Sort
    const orderBy = options?.orderBy ?? 'createdAt'
    items.sort((a, b) => {
      const aVal = a[orderBy].getTime()
      const bVal = b[orderBy].getTime()
      return options?.desc ? bVal - aVal : aVal - bVal
    })

    // Paginate
    const offset = options?.offset ?? 0
    const limit = options?.limit ?? 100

    return items.slice(offset, offset + limit)
  }

  /**
   * Update an item
   */
  async update(id: string, data: Record<string, unknown>): Promise<TenantItem | null> {
    const item = this.items.get(id)
    if (!item) return null

    item.data = { ...item.data, ...data }
    item.updatedAt = new Date()

    return item
  }

  /**
   * Delete an item
   */
  async delete(id: string): Promise<boolean> {
    const deleted = this.items.delete(id)

    if (deleted) {
      const tenant = await $.TenantManager(this.id)
      await tenant.incrementUsage('storage', -1)
    }

    return deleted
  }

  /**
   * Query items with filter
   */
  async query(
    type: string,
    filter: Record<string, unknown>
  ): Promise<TenantItem[]> {
    return Array.from(this.items.values())
      .filter(item => {
        if (item.type !== type) return false

        for (const [key, value] of Object.entries(filter)) {
          if (item.data[key] !== value) return false
        }

        return true
      })
  }

  /**
   * Count items by type
   */
  async count(type: string): Promise<number> {
    return Array.from(this.items.values())
      .filter(item => item.type === type)
      .length
  }

  /**
   * Bulk operations
   */
  async bulkCreate(
    type: string,
    items: Array<{ data: Record<string, unknown>; createdBy: string }>
  ): Promise<TenantItem[]> {
    const tenant = await $.TenantManager(this.id)
    const limitCheck = await tenant.checkLimit('storage', items.length)

    if (!limitCheck.allowed) {
      throw new Error(`Storage limit would be exceeded. Available: ${limitCheck.remaining}`)
    }

    const created: TenantItem[] = []

    for (const item of items) {
      const id = $.id()
      const tenantItem: TenantItem = {
        id,
        tenantId: this.id,
        type,
        data: item.data,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: item.createdBy
      }

      this.items.set(id, tenantItem)
      created.push(tenantItem)
    }

    await tenant.incrementUsage('storage', items.length)

    return created
  }
}
```

</Step>

<Step>

## Build Tenant User Management

Create `src/tenant-users.ts` for per-tenant user management:

```typescript title="src/tenant-users.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'

interface TenantUser {
  id: string
  tenantId: string
  email: string
  name: string
  role: 'owner' | 'admin' | 'member' | 'viewer'
  permissions: string[]
  invitedBy?: string
  joinedAt: Date
  lastActiveAt?: Date
  status: 'active' | 'invited' | 'suspended'
}

interface Invitation {
  id: string
  email: string
  role: TenantUser['role']
  invitedBy: string
  createdAt: Date
  expiresAt: Date
  token: string
}

export class TenantUsers extends DO {
  private users: Map<string, TenantUser> = new Map()
  private invitations: Map<string, Invitation> = new Map()

  async init() {
    // Clean up expired invitations daily
    $.every.day.at3am(async () => {
      await this.cleanupInvitations()
    })
  }

  /**
   * Add the first user (owner)
   */
  async addOwner(email: string, name: string, userId: string): Promise<TenantUser> {
    const user: TenantUser = {
      id: userId,
      tenantId: this.id,
      email,
      name,
      role: 'owner',
      permissions: ['*'], // Full access
      joinedAt: new Date(),
      status: 'active'
    }

    this.users.set(userId, user)

    const tenant = await $.TenantManager(this.id)
    await tenant.incrementUsage('users', 1)

    return user
  }

  /**
   * Invite a user
   */
  async invite(
    email: string,
    role: TenantUser['role'],
    invitedBy: string
  ): Promise<Invitation> {
    // Check user limit
    const tenant = await $.TenantManager(this.id)
    const limitCheck = await tenant.checkLimit('users', 1)

    if (!limitCheck.allowed) {
      throw new Error(`User limit exceeded. Limit: ${limitCheck.limit}`)
    }

    // Check if already a member
    for (const user of this.users.values()) {
      if (user.email === email) {
        throw new Error('User is already a member')
      }
    }

    // Generate invitation token
    const tokenBytes = new Uint8Array(32)
    crypto.getRandomValues(tokenBytes)
    const token = Array.from(tokenBytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')

    const invitation: Invitation = {
      id: $.id(),
      email,
      role,
      invitedBy,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      token
    }

    this.invitations.set(token, invitation)

    // Send invitation email
    const config = await tenant.getConfig()
    sally`
      send invitation email to ${email}
      from ${config?.name ?? 'the team'}
      role: ${role}
      invitation link with token: ${token}
    `

    return invitation
  }

  /**
   * Accept an invitation
   */
  async acceptInvitation(token: string, userId: string, name: string): Promise<TenantUser> {
    const invitation = this.invitations.get(token)

    if (!invitation) {
      throw new Error('Invalid invitation')
    }

    if (invitation.expiresAt < new Date()) {
      this.invitations.delete(token)
      throw new Error('Invitation expired')
    }

    const user: TenantUser = {
      id: userId,
      tenantId: this.id,
      email: invitation.email,
      name,
      role: invitation.role,
      permissions: this.getRolePermissions(invitation.role),
      invitedBy: invitation.invitedBy,
      joinedAt: new Date(),
      status: 'active'
    }

    this.users.set(userId, user)
    this.invitations.delete(token)

    const tenant = await $.TenantManager(this.id)
    await tenant.incrementUsage('users', 1)

    $.log('User joined tenant', { tenantId: this.id, userId, role: invitation.role })

    return user
  }

  /**
   * Get a user
   */
  async getUser(userId: string): Promise<TenantUser | null> {
    return this.users.get(userId) ?? null
  }

  /**
   * Get user by email
   */
  async getUserByEmail(email: string): Promise<TenantUser | null> {
    for (const user of this.users.values()) {
      if (user.email === email) {
        return user
      }
    }
    return null
  }

  /**
   * List all users
   */
  async listUsers(): Promise<TenantUser[]> {
    return Array.from(this.users.values())
  }

  /**
   * Update user role
   */
  async updateRole(userId: string, role: TenantUser['role'], updatedBy: string): Promise<TenantUser> {
    const user = this.users.get(userId)
    if (!user) {
      throw new Error('User not found')
    }

    // Prevent demoting the only owner
    if (user.role === 'owner' && role !== 'owner') {
      const owners = Array.from(this.users.values()).filter(u => u.role === 'owner')
      if (owners.length === 1) {
        throw new Error('Cannot demote the only owner')
      }
    }

    user.role = role
    user.permissions = this.getRolePermissions(role)

    $.log('User role updated', { tenantId: this.id, userId, role, updatedBy })

    return user
  }

  /**
   * Remove a user
   */
  async removeUser(userId: string, removedBy: string): Promise<boolean> {
    const user = this.users.get(userId)
    if (!user) return false

    // Prevent removing the only owner
    if (user.role === 'owner') {
      const owners = Array.from(this.users.values()).filter(u => u.role === 'owner')
      if (owners.length === 1) {
        throw new Error('Cannot remove the only owner')
      }
    }

    this.users.delete(userId)

    const tenant = await $.TenantManager(this.id)
    await tenant.incrementUsage('users', -1)

    $.log('User removed from tenant', { tenantId: this.id, userId, removedBy })

    return true
  }

  /**
   * Check if user has permission
   */
  async hasPermission(userId: string, permission: string): Promise<boolean> {
    const user = this.users.get(userId)
    if (!user) return false

    // Wildcard = all permissions
    if (user.permissions.includes('*')) return true

    // Check specific permission
    return user.permissions.includes(permission)
  }

  /**
   * Update last active timestamp
   */
  async updateActivity(userId: string) {
    const user = this.users.get(userId)
    if (user) {
      user.lastActiveAt = new Date()
    }
  }

  private getRolePermissions(role: TenantUser['role']): string[] {
    const permissions = {
      owner: ['*'],
      admin: ['read', 'write', 'delete', 'invite', 'manage_users', 'settings'],
      member: ['read', 'write', 'delete'],
      viewer: ['read']
    }
    return permissions[role]
  }

  private async cleanupInvitations() {
    const now = new Date()
    let removed = 0

    for (const [token, invitation] of this.invitations) {
      if (invitation.expiresAt < now) {
        this.invitations.delete(token)
        removed++
      }
    }

    if (removed > 0) {
      $.log('Expired invitations cleaned', { tenantId: this.id, removed })
    }
  }
}
```

</Step>

<Step>

## Build Billing Integration

Create `src/billing.ts` for Stripe integration:

```typescript title="src/billing.ts"
import { DO } from 'dotdo'
import { sally } from 'agents.do'
import { ceo } from 'humans.do'

export class TenantBilling extends DO {
  async init() {
    // Handle subscription events
    $.on.Subscription.created(async (event) => {
      if (event.data.tenantId === this.id) {
        await this.handleSubscriptionCreated(event.data)
      }
    })

    $.on.Subscription.updated(async (event) => {
      if (event.data.tenantId === this.id) {
        await this.handleSubscriptionUpdated(event.data)
      }
    })

    $.on.Payment.failed(async (event) => {
      if (event.data.tenantId === this.id) {
        await this.handlePaymentFailed(event.data)
      }
    })
  }

  /**
   * Start a subscription
   */
  async subscribe(plan: 'starter' | 'pro' | 'enterprise'): Promise<{ url: string }> {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config) {
      throw new Error('Tenant not found')
    }

    const prices = {
      starter: process.env.STRIPE_PRICE_STARTER!,
      pro: process.env.STRIPE_PRICE_PRO!,
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE!
    }

    // Create checkout session
    const session = await $.do('stripe.createCheckoutSession', {
      customer: config.billing.customerId,
      price: prices[plan],
      mode: 'subscription',
      successUrl: `https://${config.slug}.app.com/billing?success=true`,
      cancelUrl: `https://${config.slug}.app.com/billing?cancelled=true`,
      metadata: {
        tenantId: this.id,
        plan
      },
      subscription_data: {
        metadata: {
          tenantId: this.id,
          plan
        }
      }
    })

    return { url: session.url }
  }

  /**
   * Change plan
   */
  async changePlan(newPlan: 'starter' | 'pro' | 'enterprise'): Promise<void> {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config?.billing.subscriptionId) {
      throw new Error('No active subscription')
    }

    const prices = {
      starter: process.env.STRIPE_PRICE_STARTER!,
      pro: process.env.STRIPE_PRICE_PRO!,
      enterprise: process.env.STRIPE_PRICE_ENTERPRISE!
    }

    // Update subscription in Stripe
    await $.do('stripe.updateSubscription', {
      subscriptionId: config.billing.subscriptionId,
      items: [{ price: prices[newPlan] }],
      proration_behavior: 'create_prorations'
    })

    // Update tenant plan
    await tenant.updatePlan(newPlan)
  }

  /**
   * Cancel subscription
   */
  async cancel(reason?: string): Promise<void> {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config?.billing.subscriptionId) {
      throw new Error('No active subscription')
    }

    // Cancel at period end
    await $.do('stripe.updateSubscription', {
      subscriptionId: config.billing.subscriptionId,
      cancel_at_period_end: true
    })

    // Log cancellation
    $.log('Subscription cancelled', { tenantId: this.id, reason })

    // Notify
    sally`
      send cancellation confirmation to tenant ${config.name}
      subscription will end at ${config.billing.currentPeriodEnd}
    `
  }

  /**
   * Get billing portal URL
   */
  async getPortalUrl(): Promise<{ url: string }> {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config) {
      throw new Error('Tenant not found')
    }

    const session = await $.do('stripe.createBillingPortalSession', {
      customer: config.billing.customerId,
      return_url: `https://${config.slug}.app.com/billing`
    })

    return { url: session.url }
  }

  /**
   * Get invoices
   */
  async getInvoices(limit: number = 10): Promise<unknown[]> {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config) {
      throw new Error('Tenant not found')
    }

    const invoices = await $.do('stripe.listInvoices', {
      customer: config.billing.customerId,
      limit
    })

    return invoices.data
  }

  private async handleSubscriptionCreated(data: {
    subscriptionId: string
    plan: string
    currentPeriodEnd: Date
  }) {
    const tenant = await $.TenantManager(this.id)

    // Update billing info
    const config = await tenant.getConfig()
    if (config) {
      config.billing.subscriptionId = data.subscriptionId
      config.billing.status = 'active'
      config.billing.currentPeriodEnd = data.currentPeriodEnd

      // Update plan
      await tenant.updatePlan(data.plan as any)
    }

    $.log('Subscription created', { tenantId: this.id, plan: data.plan })
  }

  private async handleSubscriptionUpdated(data: {
    status: string
    currentPeriodEnd: Date
  }) {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (config) {
      config.billing.status = data.status as any
      config.billing.currentPeriodEnd = data.currentPeriodEnd
    }
  }

  private async handlePaymentFailed(data: {
    amount: number
    reason: string
  }) {
    const tenant = await $.TenantManager(this.id)
    const config = await tenant.getConfig()

    if (!config) return

    // First failure: Sally handles
    sally`
      send payment failed email to tenant ${config.name}
      amount: $${data.amount / 100}
      reason: ${data.reason}
    `

    // Update status
    config.billing.status = 'past_due'

    // If large account, escalate
    if (config.plan === 'enterprise') {
      ceo`
        Enterprise tenant ${config.name} payment failed
        Amount: $${data.amount / 100}
        Please review and contact customer
      `
    }
  }
}
```

</Step>

<Step>

## Build the Routing Layer

Create `src/router.ts` for tenant routing:

```typescript title="src/router.ts"
import { DO } from 'dotdo'

interface TenantRoute {
  slug: string
  tenantId: string
  customDomain?: string
  createdAt: Date
}

export class TenantRouter extends DO {
  private routes: Map<string, TenantRoute> = new Map()
  private domainToSlug: Map<string, string> = new Map()

  /**
   * Register a tenant route
   */
  async register(slug: string, tenantId: string, customDomain?: string): Promise<TenantRoute> {
    // Check if slug is available
    if (this.routes.has(slug)) {
      throw new Error(`Slug "${slug}" is already taken`)
    }

    const route: TenantRoute = {
      slug,
      tenantId,
      customDomain,
      createdAt: new Date()
    }

    this.routes.set(slug, route)

    if (customDomain) {
      this.domainToSlug.set(customDomain, slug)
    }

    $.log('Tenant route registered', { slug, tenantId })

    return route
  }

  /**
   * Resolve a request to a tenant
   */
  async resolve(host: string): Promise<{ tenantId: string; slug: string } | null> {
    // Check custom domains first
    if (this.domainToSlug.has(host)) {
      const slug = this.domainToSlug.get(host)!
      const route = this.routes.get(slug)
      if (route) {
        return { tenantId: route.tenantId, slug: route.slug }
      }
    }

    // Check subdomain pattern (e.g., acme.app.com)
    const subdomainMatch = host.match(/^([^.]+)\.app\.com$/)
    if (subdomainMatch) {
      const slug = subdomainMatch[1]
      const route = this.routes.get(slug)
      if (route) {
        return { tenantId: route.tenantId, slug: route.slug }
      }
    }

    return null
  }

  /**
   * Update custom domain
   */
  async setCustomDomain(slug: string, domain: string | null): Promise<void> {
    const route = this.routes.get(slug)
    if (!route) {
      throw new Error('Route not found')
    }

    // Remove old domain mapping
    if (route.customDomain) {
      this.domainToSlug.delete(route.customDomain)
    }

    // Set new domain
    if (domain) {
      route.customDomain = domain
      this.domainToSlug.set(domain, slug)
    } else {
      route.customDomain = undefined
    }
  }

  /**
   * Check if slug is available
   */
  async isSlugAvailable(slug: string): Promise<boolean> {
    return !this.routes.has(slug)
  }

  /**
   * Delete a route
   */
  async unregister(slug: string): Promise<boolean> {
    const route = this.routes.get(slug)
    if (!route) return false

    if (route.customDomain) {
      this.domainToSlug.delete(route.customDomain)
    }

    this.routes.delete(slug)
    return true
  }
}
```

</Step>

<Step>

## Build the API

Create `src/api.ts`:

```typescript title="src/api.ts"
import { Hono } from 'hono'
import { TenantManager } from './tenant'
import { TenantData } from './tenant-data'
import { TenantUsers } from './tenant-users'
import { TenantBilling } from './billing'
import { TenantRouter } from './router'

const app = new Hono()

// Tenant resolution middleware
app.use('/api/*', async (c, next) => {
  const host = c.req.header('host') ?? ''
  const router = await TenantRouter.get('global')

  const resolved = await router.resolve(host)
  if (!resolved) {
    return c.json({ error: 'Tenant not found' }, 404)
  }

  // Set tenant context
  c.set('tenantId', resolved.tenantId)
  c.set('tenantSlug', resolved.slug)

  // Track API call
  const tenant = await TenantManager.get(resolved.tenantId)
  await tenant.incrementUsage('apiCalls', 1)

  await next()
})

// Create tenant (public)
app.post('/tenants', async (c) => {
  const { name, slug, adminEmail, adminName, adminId } = await c.req.json()

  // Check slug availability
  const router = await TenantRouter.get('global')
  if (!await router.isSlugAvailable(slug)) {
    return c.json({ error: 'Slug is not available' }, 400)
  }

  // Create tenant
  const tenantId = `tenant_${$.id()}`
  const tenant = await TenantManager.get(tenantId)
  const config = await tenant.create({ name, slug, adminEmail })

  // Register route
  await router.register(slug, tenantId)

  // Add owner
  const users = await TenantUsers.get(tenantId)
  await users.addOwner(adminEmail, adminName, adminId)

  return c.json(config)
})

// Get tenant info
app.get('/api/tenant', async (c) => {
  const tenantId = c.get('tenantId')
  const tenant = await TenantManager.get(tenantId)
  const config = await tenant.getConfig()
  return c.json(config)
})

// Update settings
app.patch('/api/tenant/settings', async (c) => {
  const tenantId = c.get('tenantId')
  const settings = await c.req.json()

  const tenant = await TenantManager.get(tenantId)
  const updated = await tenant.updateSettings(settings)

  return c.json(updated)
})

// Get stats
app.get('/api/tenant/stats', async (c) => {
  const tenantId = c.get('tenantId')
  const tenant = await TenantManager.get(tenantId)
  return c.json(await tenant.getStats())
})

// Users
app.get('/api/users', async (c) => {
  const tenantId = c.get('tenantId')
  const users = await TenantUsers.get(tenantId)
  return c.json(await users.listUsers())
})

app.post('/api/users/invite', async (c) => {
  const tenantId = c.get('tenantId')
  const { email, role, invitedBy } = await c.req.json()

  const users = await TenantUsers.get(tenantId)
  const invitation = await users.invite(email, role, invitedBy)

  return c.json({ invitationId: invitation.id })
})

app.post('/api/users/accept', async (c) => {
  const tenantId = c.get('tenantId')
  const { token, userId, name } = await c.req.json()

  const users = await TenantUsers.get(tenantId)
  const user = await users.acceptInvitation(token, userId, name)

  return c.json(user)
})

// Data operations
app.post('/api/data/:type', async (c) => {
  const tenantId = c.get('tenantId')
  const type = c.req.param('type')
  const { data, createdBy } = await c.req.json()

  const tenantData = await TenantData.get(tenantId)
  const item = await tenantData.create(type, data, createdBy)

  return c.json(item)
})

app.get('/api/data/:type', async (c) => {
  const tenantId = c.get('tenantId')
  const type = c.req.param('type')

  const tenantData = await TenantData.get(tenantId)
  const items = await tenantData.list(type)

  return c.json(items)
})

app.get('/api/data/:type/:id', async (c) => {
  const tenantId = c.get('tenantId')
  const id = c.req.param('id')

  const tenantData = await TenantData.get(tenantId)
  const item = await tenantData.get(id)

  return item ? c.json(item) : c.json({ error: 'Not found' }, 404)
})

app.patch('/api/data/:type/:id', async (c) => {
  const tenantId = c.get('tenantId')
  const id = c.req.param('id')
  const data = await c.req.json()

  const tenantData = await TenantData.get(tenantId)
  const item = await tenantData.update(id, data)

  return item ? c.json(item) : c.json({ error: 'Not found' }, 404)
})

app.delete('/api/data/:type/:id', async (c) => {
  const tenantId = c.get('tenantId')
  const id = c.req.param('id')

  const tenantData = await TenantData.get(tenantId)
  const deleted = await tenantData.delete(id)

  return c.json({ deleted })
})

// Billing
app.get('/api/billing', async (c) => {
  const tenantId = c.get('tenantId')
  const billing = await TenantBilling.get(tenantId)
  return c.json(await billing.getInvoices())
})

app.post('/api/billing/subscribe', async (c) => {
  const tenantId = c.get('tenantId')
  const { plan } = await c.req.json()

  const billing = await TenantBilling.get(tenantId)
  return c.json(await billing.subscribe(plan))
})

app.post('/api/billing/change-plan', async (c) => {
  const tenantId = c.get('tenantId')
  const { plan } = await c.req.json()

  const billing = await TenantBilling.get(tenantId)
  await billing.changePlan(plan)

  return c.json({ success: true })
})

app.post('/api/billing/cancel', async (c) => {
  const tenantId = c.get('tenantId')
  const { reason } = await c.req.json()

  const billing = await TenantBilling.get(tenantId)
  await billing.cancel(reason)

  return c.json({ success: true })
})

app.get('/api/billing/portal', async (c) => {
  const tenantId = c.get('tenantId')
  const billing = await TenantBilling.get(tenantId)
  return c.json(await billing.getPortalUrl())
})

// Stripe webhook
app.post('/webhooks/stripe', async (c) => {
  const event = await c.req.json()

  const tenantId = event.data.object.metadata?.tenantId

  if (tenantId) {
    switch (event.type) {
      case 'customer.subscription.created':
        $.send('Subscription.created', {
          tenantId,
          subscriptionId: event.data.object.id,
          plan: event.data.object.metadata.plan,
          currentPeriodEnd: new Date(event.data.object.current_period_end * 1000)
        })
        break

      case 'customer.subscription.updated':
        $.send('Subscription.updated', {
          tenantId,
          status: event.data.object.status,
          currentPeriodEnd: new Date(event.data.object.current_period_end * 1000)
        })
        break

      case 'invoice.payment_failed':
        $.send('Payment.failed', {
          tenantId,
          amount: event.data.object.amount_due,
          reason: event.data.object.last_payment_error?.message ?? 'Unknown'
        })
        break
    }
  }

  return c.json({ received: true })
})

export default app
```

</Step>

<Step>

## Test Locally

```bash
npm run dev
```

Test multi-tenant functionality:

```bash
# Create a tenant
curl -X POST http://localhost:8787/tenants \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Acme Corp",
    "slug": "acme",
    "adminEmail": "admin@acme.com",
    "adminName": "Admin User",
    "adminId": "user_123"
  }'

# Access tenant API (simulate subdomain with Host header)
curl http://localhost:8787/api/tenant \
  -H "Host: acme.app.com"

# Create data in tenant scope
curl -X POST http://localhost:8787/api/data/projects \
  -H "Host: acme.app.com" \
  -H "Content-Type: application/json" \
  -d '{
    "data": { "name": "Project Alpha", "status": "active" },
    "createdBy": "user_123"
  }'

# List tenant users
curl http://localhost:8787/api/users \
  -H "Host: acme.app.com"

# Invite a team member
curl -X POST http://localhost:8787/api/users/invite \
  -H "Host: acme.app.com" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "dev@acme.com",
    "role": "member",
    "invitedBy": "user_123"
  }'

# Get tenant stats
curl http://localhost:8787/api/tenant/stats \
  -H "Host: acme.app.com"
```

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Set production secrets:

```bash
npx wrangler secret put JWT_SECRET
npx wrangler secret put STRIPE_SECRET_KEY
npx wrangler secret put STRIPE_WEBHOOK_SECRET
npx wrangler secret put STRIPE_PRICE_STARTER
npx wrangler secret put STRIPE_PRICE_PRO
npx wrangler secret put STRIPE_PRICE_ENTERPRISE
```

Configure your domain for wildcard subdomains (*.app.com).

Your multi-tenant SaaS is now live.

</Step>

</Steps>

---

## What You Built

In 30 minutes, you've deployed a multi-tenant SaaS with:

| Feature | Implementation |
|---------|----------------|
| Tenant isolation | Durable Object per tenant |
| Per-tenant data | Isolated storage with limits |
| User management | Invitations, roles, permissions |
| Subdomain routing | acme.app.com -> tenant DO |
| Custom domains | Map any domain to a tenant |
| Billing integration | Stripe subscriptions per tenant |
| Plan limits | Users, storage, API calls |

---

## Key Patterns Used

### True Tenant Isolation

```typescript
// Each tenant gets their own Durable Object instances
const tenant = await TenantManager.get(tenantId)
const data = await TenantData.get(tenantId)
const users = await TenantUsers.get(tenantId)

// Data cannot leak between tenants
```

### Subdomain Routing

```typescript
// Resolve tenant from hostname
const resolved = await router.resolve('acme.app.com')
// { tenantId: 'tenant_abc', slug: 'acme' }
```

### Resource Limits

```typescript
// Check before consuming resources
const check = await tenant.checkLimit('users', 1)
if (!check.allowed) {
  throw new Error(`Limit exceeded: ${check.limit}`)
}
```

---

## Extending Your Multi-tenant SaaS

### Add SSO for Enterprise

```typescript
async configureSAML(tenantId: string, config: {
  entryPoint: string
  issuer: string
  cert: string
}) {
  const tenant = await TenantManager.get(tenantId)
  const tenantConfig = await tenant.getConfig()

  if (!tenantConfig?.settings.features.includes('sso')) {
    throw new Error('SSO requires Enterprise plan')
  }

  // Store SAML config
  await tenant.updateSettings({
    sso: {
      provider: 'saml',
      config
    }
  })
}
```

### Add Audit Logs

```typescript
class TenantAuditLog extends DO {
  private logs: Array<{
    action: string
    userId: string
    resource: string
    timestamp: Date
    metadata: Record<string, unknown>
  }> = []

  async log(action: string, userId: string, resource: string, metadata?: Record<string, unknown>) {
    this.logs.push({
      action,
      userId,
      resource,
      timestamp: new Date(),
      metadata: metadata ?? {}
    })

    // Trim to keep last 10000 entries
    if (this.logs.length > 10000) {
      this.logs = this.logs.slice(-5000)
    }
  }
}
```

### Add Tenant Analytics

```typescript
$.on.Tenant.activity(async (event) => {
  const { tenantId, action, userId } = event.data

  // Track in analytics
  await $.do('analytics.track', {
    event: 'tenant_activity',
    properties: {
      tenantId,
      action,
      userId,
      timestamp: new Date()
    }
  })
})
```

---

## Next Steps

Your multi-tenant SaaS is live. Explore:

- [API Gateway tutorial](/docs/tutorials/api-gateway) - Protect your APIs
- [Real-time dashboard](/docs/tutorials/realtime-dashboard) - Monitor tenants
- [Deployment](/docs/deployment) - Custom domains and regions
- [SDK reference](/docs/sdk) - Full API documentation

---

**You built a multi-tenant SaaS. Each tenant is isolated. Billing is automatic. Go onboard your first customer.**
