---
title: E-commerce Store
description: Build a complete e-commerce backend with products, carts, orders, and payments
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

# E-commerce Store Tutorial

Build a production-ready e-commerce backend with dotdo. You'll create products, shopping carts, orders, and payment processing - all running on Durable Objects with automatic persistence.

## What You'll Build

- Product catalog with inventory tracking
- Shopping carts that persist across sessions
- Order processing with payment integration
- Scheduled tasks for abandoned cart reminders
- Event-driven notifications

## Prerequisites

- Basic TypeScript knowledge
- dotdo installed (`npm install dotdo`)
- A Cloudflare account (free tier works)

## Understanding the $ Context

<Callout type="info" title="The $ WorkflowContext">
Throughout this tutorial, you'll see `$` used extensively. This is the **WorkflowContext** - the primary API for all DO operations in dotdo.

```typescript
// $ is available as this.$ in any DO class
const $ = this.$
```

**$ provides:**
- **Scheduling** - `$.every.Monday.at9am()` for cron-like tasks
- **Queries** - `$.query()` for data retrieval
- **Durability** - `$.do()` (with retries), `$.try()` (single attempt), `$.send()` (fire events)
- **Cross-DO RPC** - `$.Customer('id')`, `$.Cart('id')` to call methods on other DOs
- **Events** - `$.on.Order.placed()` to subscribe to domain events
- **AI** - `$.ai`, `$.write`, `$.is` for AI-powered operations

The `$` is automatically available in every DO method. You can use `this.$` directly or destructure it with `const $ = this.$` for cleaner code.

See the [WorkflowContext Reference](/docs/sdk/workflow-context) for complete documentation.
</Callout>

## Step 1: Define Your Store

Create a new file `store.ts`:

```typescript
import { DO } from 'dotdo'

export class EcommerceStore extends DO {
  async setup() {
    // $ is the WorkflowContext, available as this.$
    const $ = this.$

    // Schedule abandoned cart reminders
    $.every.day.at10am(async () => {
      await this.sendAbandonedCartReminders()
    })

    // Handle order events
    $.on.Order.placed(async (event) => {
      await this.updateInventory(event.data.items)
      await this.sendOrderConfirmation(event.data)
    })

    $.on.Payment.captured(async (event) => {
      await this.fulfillOrder(event.data.orderId)
    })
  }
}
```

## Step 2: Products and Inventory

Add product management with automatic inventory tracking:

```typescript
export class EcommerceStore extends DO {
  // Create a product
  async createProduct(data: {
    name: string
    price: number
    inventory: number
    sku: string
  }) {
    const $ = this.$

    const product = await this.things.create({
      $type: 'Product',
      ...data,
      createdAt: new Date()
    })

    // Track the creation event
    $.send('Product.created', { productId: product.$id, sku: data.sku })

    return product
  }

  // Get product by SKU
  async getProductBySku(sku: string) {
    const products = await this.things.find({
      $type: 'Product',
      sku
    })
    return products[0] || null
  }

  // Update inventory with durable execution
  async updateInventory(items: Array<{ sku: string; quantity: number }>) {
    const $ = this.$

    // $.do() ensures this runs with retries if it fails
    await $.do('updateInventory', async () => {
      for (const item of items) {
        const product = await this.getProductBySku(item.sku)
        if (product) {
          await this.things.update(product.$id, {
            inventory: product.inventory - item.quantity
          })
        }
      }
    })
  }

  // Check if product is in stock
  async checkStock(sku: string, quantity: number): Promise<boolean> {
    const product = await this.getProductBySku(sku)
    return product ? product.inventory >= quantity : false
  }
}
```

## Step 3: Shopping Carts

Implement persistent shopping carts:

```typescript
export class EcommerceStore extends DO {
  // Get or create a cart for a customer
  async getCart(customerId: string) {
    const $ = this.$

    // Use cross-DO RPC to get customer's cart
    // $.Cart() returns a proxy to the Cart DO instance
    const cartId = `cart:${customerId}`

    let cart = await this.things.get(cartId)
    if (!cart) {
      cart = await this.things.create({
        $id: cartId,
        $type: 'Cart',
        customerId,
        items: [],
        createdAt: new Date(),
        updatedAt: new Date()
      })
    }

    return cart
  }

  // Add item to cart
  async addToCart(customerId: string, item: { sku: string; quantity: number }) {
    const $ = this.$

    const cart = await this.getCart(customerId)
    const product = await this.getProductBySku(item.sku)

    if (!product) {
      throw new Error(`Product not found: ${item.sku}`)
    }

    // Check stock availability
    const inStock = await this.checkStock(item.sku, item.quantity)
    if (!inStock) {
      throw new Error(`Insufficient stock for: ${item.sku}`)
    }

    // Update cart items
    const existingItem = cart.items.find((i: any) => i.sku === item.sku)
    if (existingItem) {
      existingItem.quantity += item.quantity
    } else {
      cart.items.push({
        sku: item.sku,
        name: product.name,
        price: product.price,
        quantity: item.quantity
      })
    }

    await this.things.update(cart.$id, {
      items: cart.items,
      updatedAt: new Date()
    })

    // Track for analytics
    $.track('Cart.itemAdded', {
      customerId,
      sku: item.sku,
      quantity: item.quantity
    })

    return cart
  }

  // Calculate cart total
  async getCartTotal(customerId: string): Promise<number> {
    const cart = await this.getCart(customerId)
    return cart.items.reduce(
      (total: number, item: any) => total + item.price * item.quantity,
      0
    )
  }
}
```

## Step 4: Order Processing

Create orders with payment integration:

```typescript
export class EcommerceStore extends DO {
  // Create an order from cart
  async createOrder(customerId: string, paymentMethod: string) {
    const $ = this.$

    const cart = await this.getCart(customerId)
    if (cart.items.length === 0) {
      throw new Error('Cart is empty')
    }

    const total = await this.getCartTotal(customerId)

    // Create the order with durable execution
    const order = await $.do('createOrder', async () => {
      const newOrder = await this.things.create({
        $type: 'Order',
        customerId,
        items: cart.items,
        total,
        status: 'pending',
        paymentMethod,
        createdAt: new Date()
      })

      // Clear the cart
      await this.things.update(cart.$id, {
        items: [],
        updatedAt: new Date()
      })

      return newOrder
    })

    // Emit order placed event
    $.send('Order.placed', {
      orderId: order.$id,
      customerId,
      items: cart.items,
      total
    })

    // Process payment
    await this.processPayment(order.$id, total, paymentMethod)

    return order
  }

  // Process payment with retry logic
  async processPayment(orderId: string, amount: number, method: string) {
    const $ = this.$

    // $.do() automatically retries on failure
    const result = await $.do('processPayment', async () => {
      // In production, integrate with Stripe, etc.
      // This is a placeholder for the actual payment processing
      const success = await this.chargePaymentMethod(method, amount)

      if (!success) {
        throw new Error('Payment failed')
      }

      return { success: true, transactionId: `txn_${Date.now()}` }
    }, {
      retry: {
        maxAttempts: 3,
        initialDelayMs: 1000,
        backoffMultiplier: 2
      }
    })

    if (result.success) {
      await this.things.update(orderId, {
        status: 'paid',
        transactionId: result.transactionId
      })

      $.send('Payment.captured', {
        orderId,
        amount,
        transactionId: result.transactionId
      })
    }

    return result
  }

  // Placeholder for actual payment integration
  private async chargePaymentMethod(method: string, amount: number) {
    // Integrate with Stripe, PayPal, etc.
    return true
  }
}
```

## Step 5: Event Handlers and Notifications

Set up event-driven workflows:

```typescript
export class EcommerceStore extends DO {
  async setup() {
    const $ = this.$

    // When an order is placed
    $.on.Order.placed(async (event) => {
      const { orderId, customerId, items, total } = event.data

      // Update inventory
      await this.updateInventory(items)

      // Send confirmation email
      await this.sendOrderConfirmation({
        orderId,
        customerId,
        items,
        total
      })
    })

    // When payment is captured
    $.on.Payment.captured(async (event) => {
      const { orderId } = event.data

      // Start fulfillment
      await this.fulfillOrder(orderId)
    })

    // When payment fails
    $.on.Payment.failed(async (event) => {
      const { orderId, error } = event.data

      await this.things.update(orderId, {
        status: 'payment_failed',
        error
      })

      // Notify customer
      await this.sendPaymentFailedNotification(orderId)
    })

    // Low inventory alerts
    $.on.Product.lowStock(async (event) => {
      const { sku, currentStock } = event.data
      await this.notifyAdmin(`Low stock alert: ${sku} has only ${currentStock} units`)
    })

    // Stale order alerts
    $.on.Order.stale(async (event) => {
      const { orderId, customerId } = event.data
      // Escalate to support team
      await this.escalateToSupport(orderId, customerId)
    })
  }

  async escalateToSupport(orderId: string, customerId: string) {
    console.log(`Escalating stale order ${orderId} for customer ${customerId}`)
  }

  async sendOrderConfirmation(data: any) {
    // Integrate with email service (SendGrid, Resend, etc.)
    console.log('Sending order confirmation:', data)
  }

  async sendPaymentFailedNotification(orderId: string) {
    console.log('Sending payment failed notification for:', orderId)
  }

  async notifyAdmin(message: string) {
    console.log('Admin notification:', message)
  }
}
```

## Step 6: Scheduled Tasks

Set up automated tasks using `$.every`:

```typescript
export class EcommerceStore extends DO {
  // Helper for date calculations - defined as a static method
  private static twoDaysAgo(): Date {
    return new Date(Date.now() - 2 * 24 * 60 * 60 * 1000)
  }

  async setup() {
    const $ = this.$

    // Daily abandoned cart reminders at 10am
    $.every.day.at10am(async () => {
      await this.sendAbandonedCartReminders()
    })

    // Weekly inventory report on Monday at 9am
    $.every.Monday.at9am(async () => {
      await this.generateInventoryReport()
    })

    // Hourly low stock check
    $.every.hour(async () => {
      await this.checkLowStockProducts()
    })

    // Check for stale orders twice daily
    $.every.day.at('9am')(async () => {
      await this.checkStaleOrders()
    })
    $.every.day.at('5pm')(async () => {
      await this.checkStaleOrders()
    })

    // Monthly sales summary on the 1st
    $.every('first of month at 9am', async () => {
      await this.generateMonthlySalesReport()
    })
  }

  // Check for orders stuck in processing
  async checkStaleOrders() {
    const $ = this.$

    const staleOrders = await this.things.find({
      $type: 'Order',
      status: 'processing',
      createdAt: { $lt: EcommerceStore.twoDaysAgo() }
    })

    for (const order of staleOrders) {
      $.send('Order.stale', {
        orderId: order.$id,
        customerId: order.customerId,
        createdAt: order.createdAt
      })

      await this.notifyAdmin(
        `Stale order detected: ${order.$id} has been processing for over 2 days`
      )
    }
  }

  async sendAbandonedCartReminders() {
    const $ = this.$

    // Find carts updated more than 24 hours ago with items
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000)

    const abandonedCarts = await this.things.find({
      $type: 'Cart',
      updatedAt: { $lt: oneDayAgo },
      'items.0': { $exists: true }  // Has at least one item
    })

    for (const cart of abandonedCarts) {
      // Send reminder email
      await this.sendAbandonedCartEmail(cart.customerId, cart.items)

      // Track the reminder
      $.track('Cart.reminderSent', {
        customerId: cart.customerId,
        itemCount: cart.items.length
      })
    }
  }

  async checkLowStockProducts() {
    const $ = this.$

    const lowStockProducts = await this.things.find({
      $type: 'Product',
      inventory: { $lt: 10 }
    })

    for (const product of lowStockProducts) {
      $.send('Product.lowStock', {
        sku: product.sku,
        currentStock: product.inventory
      })
    }
  }

  async sendAbandonedCartEmail(customerId: string, items: any[]) {
    console.log(`Sending abandoned cart reminder to ${customerId}`)
  }

  async generateInventoryReport() {
    console.log('Generating weekly inventory report')
  }

  async generateMonthlySalesReport() {
    console.log('Generating monthly sales report')
  }
}
```

## Step 7: Cross-DO Communication

For larger applications, split into multiple DOs and use `$.Noun(id)` for RPC:

```typescript
export class EcommerceStore extends DO {
  // Call methods on the Customer DO
  async notifyCustomer(customerId: string, message: string) {
    const $ = this.$

    // $.Customer() returns a proxy to the Customer DO
    await $.Customer(customerId).notify({
      type: 'order',
      message
    })
  }

  // Get customer details from Customer DO
  async getCustomerDetails(customerId: string) {
    const $ = this.$

    // Property access works through promise pipelining
    const email = await $.Customer(customerId).profile.email
    const name = await $.Customer(customerId).profile.name

    return { email, name }
  }

  // Chain multiple calls with promise pipelining
  async getCustomerOrderHistory(customerId: string) {
    const $ = this.$

    // Single round-trip thanks to Cap'n Web RPC
    const orders = await $.Customer(customerId)
      .orders
      .recent(10)
      .withDetails()

    return orders
  }
}
```

## Step 8: Deploy Your Store

Create `wrangler.jsonc`:

```json
{
  "name": "ecommerce-store",
  "main": "src/index.ts",
  "compatibility_date": "2024-01-01",
  "durable_objects": {
    "bindings": [
      {
        "name": "STORE",
        "class_name": "EcommerceStore"
      }
    ]
  }
}
```

Create the worker entry point `src/index.ts`:

```typescript
import { API } from 'dotdo'
import { EcommerceStore } from './store'

export { EcommerceStore }

// Route requests to the store DO
export default API()
```

Deploy:

```bash
npm run deploy
```

## Complete Example

Here's the full `store.ts` with all features:

```typescript
import { DO } from 'dotdo'

export class EcommerceStore extends DO {
  // Date helpers as static methods for proper scoping
  private static twoDaysAgo(): Date {
    return new Date(Date.now() - 2 * 24 * 60 * 60 * 1000)
  }

  async setup() {
    // $ is the WorkflowContext - the primary API for all DO operations
    const $ = this.$

    // Scheduled tasks
    $.every.day.at10am(() => this.sendAbandonedCartReminders())
    $.every.Monday.at9am(() => this.generateInventoryReport())
    $.every.hour(() => this.checkLowStockProducts())
    $.every.day.at('9am')(() => this.checkStaleOrders())

    // Event handlers
    $.on.Order.placed(async (event) => {
      await this.updateInventory(event.data.items)
      await this.sendOrderConfirmation(event.data)
    })

    $.on.Payment.captured(async (event) => {
      await this.fulfillOrder(event.data.orderId)
    })

    $.on.Order.stale(async (event) => {
      await this.escalateToSupport(event.data.orderId, event.data.customerId)
    })
  }

  // Products
  async createProduct(data: { name: string; price: number; inventory: number; sku: string }) {
    const product = await this.things.create({ $type: 'Product', ...data })
    this.$.send('Product.created', { productId: product.$id })
    return product
  }

  // Carts
  async addToCart(customerId: string, item: { sku: string; quantity: number }) {
    const cart = await this.getCart(customerId)
    // ... cart logic
    this.$.track('Cart.itemAdded', { customerId, sku: item.sku })
    return cart
  }

  // Orders
  async createOrder(customerId: string, paymentMethod: string) {
    const $ = this.$
    const order = await $.do('createOrder', async () => {
      // ... order creation logic
    })
    $.send('Order.placed', { orderId: order.$id, customerId })
    return order
  }

  // Stale order detection
  async checkStaleOrders() {
    const staleOrders = await this.things.find({
      $type: 'Order',
      status: 'processing',
      createdAt: { $lt: EcommerceStore.twoDaysAgo() }
    })
    for (const order of staleOrders) {
      this.$.send('Order.stale', { orderId: order.$id, customerId: order.customerId })
    }
  }

  // Cross-DO communication
  async notifyCustomer(customerId: string, message: string) {
    await this.$.Customer(customerId).notify({ message })
  }
}
```

## Next Steps

- Add [Stripe integration](/docs/integrations/stripe) for real payments
- Implement [rate limiting](/docs/sdk/rate-limit) to protect your API
- Add [observability](/docs/observability) for monitoring
- Explore [advanced patterns](/docs/guides/advanced) for scaling

## Related

- [WorkflowContext Reference](/docs/sdk/workflow-context) - Complete $ API documentation
- [Things](/docs/database/things) - Data persistence
- [Events](/docs/concepts/events) - Event-driven architecture
- [Scheduling](/docs/workflows/scheduling) - Cron-like scheduling
