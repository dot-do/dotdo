---
title: Workflow Triggers
description: Event-driven, scheduled, manual, and webhook triggers for starting workflows
---

import { Callout } from 'fumadocs-ui/components/callout'

# Workflow Triggers

Workflows can be triggered by events, schedules, manual invocations, or webhooks. The `$` context provides a unified API for all trigger types.

## Overview

dotdo supports four types of workflow triggers:

| Trigger Type | Use Case | Example |
|-------------|----------|---------|
| **Event** | React to domain events | `$.on.Customer.signup` |
| **Schedule** | Run at specific times | `$.every.monday.at('9am')` |
| **Manual** | Programmatic invocation | `workflow.run(data)` |
| **Webhook** | External integrations | Stripe, GitHub, custom APIs |

<Callout type="info">
All triggers use the same workflow execution engine. Whether triggered by an event, schedule, or webhook, your workflow gets the same durability guarantees.
</Callout>

## Event Triggers

Subscribe to domain events with `$.on.Noun.verb()`. When an event fires, your handler executes.

```typescript
import { on } from 'dotdo/workflows'

// Subscribe to customer signup events
on.Customer.signup(async (event) => {
  const { id, email, name } = event.data
  await sendWelcomeEmail(email, name)
  await createTrialAccount(id)
})

// Subscribe to payment events
on.Payment.failed(async (event) => {
  const { customerId, amount, reason } = event.data
  await notifyCustomer(customerId, reason)
  await scheduleRetry(event.data)
})

// Subscribe to order events
on.Order.shipped(async (event) => {
  const { orderId, trackingNumber } = event.data
  await updateOrderStatus(orderId, 'shipped')
  await sendTrackingEmail(event.data)
})
```

### Event Payload Types

Events are strongly typed through the `EventPayloadMap` interface. Extend it for type-safe handlers:

```typescript
// types/events.ts
declare module 'dotdo/types/WorkflowContext' {
  interface EventPayloadMap {
    'Customer.signup': { id: string; email: string; name: string }
    'Payment.failed': { customerId: string; amount: number; reason: string }
    'Order.shipped': { orderId: string; trackingNumber: string }
  }
}
```

### Handler Options

Register handlers with additional options for priority, filtering, and metadata:

```typescript
on.Customer.signup(handler, {
  // Higher priority runs first (default: 0)
  priority: 10,

  // Filter events before handler runs
  filter: (event) => event.data.source === 'web',

  // Handler name for debugging
  name: 'welcome-email-handler',

  // Max retries before DLQ
  maxRetries: 3,
})
```

### Wildcard Patterns

Subscribe to multiple events with wildcards:

```typescript
// All events for a noun
on.Customer['*']((event) => {
  console.log(`Customer ${event.verb}:`, event.data)
})

// All nouns with a specific verb
on['*'].created((event) => {
  await auditLog.record(event)
})

// All events (global handler)
on['*']['*']((event) => {
  metrics.increment(`events.${event.source}.${event.verb}`)
})
```

### Unsubscribing

Handlers return an unsubscribe function:

```typescript
const unsubscribe = on.Customer.signup(handler)

// Later, remove the handler
unsubscribe()
```

For Durable Object cleanup, use context-based unsubscription:

```typescript
import { clearHandlersByContext } from 'dotdo/workflows'

// When DO is destroyed
clearHandlersByContext('my-do-namespace')
```

## Schedule Triggers

Schedule recurring tasks with `$.every`. Supports fluent syntax and natural language.

### Fluent Syntax

```typescript
import { every } from 'dotdo/workflows'

// Every hour
every.hour(async () => {
  await syncInventory()
})

// Every minute (use sparingly)
every.minute(async () => {
  await checkHeartbeats()
})

// Specific day and time
every.Monday.at9am(async () => {
  await generateWeeklyReport()
})

// Daily at specific time
every.day.at6am(async () => {
  await runMorningChecks()
})

// Weekdays only
every.weekday.at8am(async () => {
  await sendDailyBrief()
})

// Weekends
every.weekend.atnoon(async () => {
  await checkWeekendMetrics()
})
```

### Preset Times

Available time presets:

| Preset | Time |
|--------|------|
| `at6am` | 6:00 AM |
| `at7am` | 7:00 AM |
| `at8am` | 8:00 AM |
| `at9am` | 9:00 AM |
| `at10am` | 10:00 AM |
| `at11am` | 11:00 AM |
| `at12pm` | 12:00 PM |
| `at1pm` | 1:00 PM |
| `at2pm` | 2:00 PM |
| `at3pm` | 3:00 PM |
| `at4pm` | 4:00 PM |
| `at5pm` | 5:00 PM |
| `at6pm` | 6:00 PM |
| `atnoon` | 12:00 PM |
| `atmidnight` | 12:00 AM |

### Custom Times

Use `.at()` for custom times:

```typescript
// Custom time on specific day
every.Tuesday.at('3:30pm')(async () => {
  await runAnalysis()
})

// 24-hour format
every.day.at('14:30')(async () => {
  await afternoonSync()
})
```

### Natural Language

Pass a natural language string:

```typescript
every('Monday at 9am', async () => {
  await startWeek()
})

every('daily at 6am', async () => {
  await morningRoutine()
})

every('weekdays at 8:30am', async () => {
  await sendReminders()
})

every('every 5 minutes', async () => {
  await pollExternalAPI()
})

every('hourly', async () => {
  await aggregateMetrics()
})
```

### How Scheduling Works

Schedules convert to cron expressions and use the Durable Object alarm API:

```typescript
// Converted to: 0 9 * * 1 (Monday at 9am)
every.Monday.at9am(handler)

// Uses state.storage.setAlarm() for next occurrence
// Alarm fires, handler runs, next alarm is set
```

The `ScheduleManager` handles:
- Converting schedules to cron expressions
- Calculating next run times
- Managing DO alarms
- Executing handlers at the right time

## Manual Triggers

Invoke workflows programmatically from your application code.

### Direct Invocation

```typescript
import { Workflow } from 'dotdo/workflows'

const onboarding = Workflow('onboarding', async ($, input) => {
  await $.do('Email.sendWelcome', input)
  await $.do('Account.createTrial', input)
  await $.do('Analytics.track', { event: 'signup', ...input })
})

// Trigger from API route
app.post('/signup', async (c) => {
  const user = await createUser(c.req.body)
  await onboarding.run({ userId: user.id, email: user.email })
  return c.json({ success: true })
})
```

### From Durable Objects

Trigger workflows from within a Durable Object:

```typescript
export class CustomerDO extends DO {
  async onSignup(data: SignupData) {
    // Emit event that triggers handlers
    this.$.send('Customer.signup', data)

    // Or call directly
    await this.$.do('Onboarding.start', data)
  }
}
```

### Cross-DO Triggers

Call methods on other Durable Objects:

```typescript
// From any DO or workflow
await $.Customer(customerId).notify()
await $.Order(orderId).process()
await $.Invoice(invoiceId).send()
```

## Webhook Triggers

Expose workflows as HTTP endpoints for external integrations.

### Basic Webhook

```typescript
// api/webhooks/stripe.ts
import { Workflow } from 'dotdo/workflows'

const stripeWebhook = Workflow('stripe-webhook', async ($, event) => {
  switch (event.type) {
    case 'payment_intent.succeeded':
      await $.do('Payment.process', event.data.object)
      break
    case 'customer.subscription.deleted':
      await $.do('Subscription.cancel', event.data.object)
      break
  }
})

export default {
  async fetch(request: Request) {
    const signature = request.headers.get('stripe-signature')
    const body = await request.text()

    // Verify webhook signature
    const event = stripe.webhooks.constructEvent(body, signature, secret)

    // Trigger workflow
    await stripeWebhook.run(event)

    return new Response('OK')
  }
}
```

### GitHub Webhooks

```typescript
const githubWebhook = Workflow('github-webhook', async ($, payload) => {
  if (payload.action === 'opened' && payload.pull_request) {
    await $.do('PR.review', payload.pull_request)
  }

  if (payload.action === 'closed' && payload.pull_request?.merged) {
    await $.do('Deployment.trigger', {
      branch: payload.pull_request.base.ref,
      sha: payload.pull_request.merge_commit_sha,
    })
  }
})
```

### Webhook with Authentication

```typescript
// middleware/webhook-auth.ts
export function verifyWebhook(secret: string) {
  return async (c: Context, next: Next) => {
    const signature = c.req.header('x-webhook-signature')
    const body = await c.req.text()

    const expected = crypto
      .createHmac('sha256', secret)
      .update(body)
      .digest('hex')

    if (signature !== `sha256=${expected}`) {
      return c.json({ error: 'Invalid signature' }, 401)
    }

    await next()
  }
}
```

## Combining Triggers

A single workflow can respond to multiple trigger types:

```typescript
import { on, every, Workflow } from 'dotdo/workflows'

// Define the core workflow logic
const processInvoice = Workflow('process-invoice', async ($, invoice) => {
  await $.do('Invoice.validate', invoice)
  await $.do('Invoice.calculateTax', invoice)
  await $.do('Invoice.send', invoice)
})

// Trigger via event
on.Invoice.created(async (event) => {
  await processInvoice.run(event.data)
})

// Trigger via schedule (retry failed invoices)
every.day.at9am(async () => {
  const failed = await getFailedInvoices()
  for (const invoice of failed) {
    await processInvoice.run(invoice)
  }
})

// Trigger via webhook (external system)
app.post('/webhooks/invoice', async (c) => {
  const invoice = await c.req.json()
  await processInvoice.run(invoice)
  return c.json({ queued: true })
})

// Trigger manually (admin action)
app.post('/admin/retry-invoice/:id', async (c) => {
  const invoice = await getInvoice(c.req.param('id'))
  await processInvoice.run(invoice)
  return c.json({ retrying: true })
})
```

## Related

- [Workflows Overview](/docs/workflows) - The $ context DSL and durability levels
- [WorkflowContext](/docs/sdk/workflow-context) - Full $ API reference with durability, AI functions, and capabilities
- [Events](/docs/concepts/events) - 5W+H event model and domain event DSL
- [Actions](/docs/concepts/actions) - The Noun.verb pattern for business operations
