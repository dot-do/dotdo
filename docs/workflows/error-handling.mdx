---
title: Error Handling
description: Comprehensive guide to error handling, retry semantics, circuit breakers, and dead letter queues in dotdo
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

# Error Handling

Reliable systems anticipate and gracefully handle failures. dotdo provides a comprehensive error handling framework covering retry semantics, circuit breakers, dead letter queues, and recovery strategies.

## Overview

Error handling in dotdo follows a layered approach:

```
                        ERROR HANDLING LAYERS
                        =====================

    ┌─────────────────────────────────────────────────────────────┐
    │  Layer 1: Durability Modes                                  │
    │  $.track() → $.send() → $.try() → $.do()                   │
    │  Fire-and-forget ←──────────────────→ Durable with retries │
    └─────────────────────────────────────────────────────────────┘
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │  Layer 2: Retry Policy                                      │
    │  Exponential backoff, jitter, max attempts, retry budget    │
    └─────────────────────────────────────────────────────────────┘
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │  Layer 3: Circuit Breaker                                   │
    │  Closed → Open → Half-Open, failure thresholds, fallbacks   │
    └─────────────────────────────────────────────────────────────┘
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │  Layer 4: Dead Letter Queue (DLQ)                           │
    │  Failed events stored for replay, monitoring, alerting      │
    └─────────────────────────────────────────────────────────────┘
```

## Retry Semantics

### Durability Levels: $.try() vs $.do()

dotdo provides four execution modes with different durability guarantees:

| Method | Blocking | Durable | Retries | Use Case |
|--------|----------|---------|---------|----------|
| `$.track()` | No | No | No | Analytics, telemetry |
| `$.send()` | No | Yes | Internal | Domain events, notifications |
| `$.try()` | Yes | No | No | Validations, cache lookups |
| `$.do()` | Yes | Yes | Configurable | Payments, orders, critical operations |

### $.try() - Single Attempt

Use `$.try()` for operations that should fail fast without retries:

```typescript
// Quick validation - no retries needed
const valid = await $.try<boolean>('validate', { schema, input })

// Cache lookup - fail fast is acceptable
const cached = await $.try<CacheResult>('Cache.get', { key: 'user:123' })

// With timeout
const result = await $.try<Result>('externalApi', data, {
  timeout: 5000  // 5 second timeout
})
```

<Callout type="info">
`$.try()` is ideal for operations where failure is an acceptable outcome. No persistence, no retries - just a single attempt with optional timeout.
</Callout>

### $.do() - Durable Execution with Retries

Use `$.do()` for operations that must eventually succeed:

```typescript
// Process payment - must succeed
const result = await $.do<PaymentResult>('processPayment', {
  amount: 100,
  currency: 'USD',
  customerId: 'cus_123'
})

// With custom retry policy
const order = await $.do<Order>('fulfillOrder', orderData, {
  retry: {
    maxAttempts: 5,
    initialDelayMs: 500,
    maxDelayMs: 30000,
    backoffMultiplier: 3,
    jitter: true
  },
  timeout: 60000,
  stepId: 'order-fulfillment'
})
```

### Retry Policy Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `maxAttempts` | `number` | 3 | Maximum retry attempts |
| `initialDelayMs` | `number` | 100 | Initial delay before first retry |
| `maxDelayMs` | `number` | 30000 | Maximum delay between retries |
| `backoffMultiplier` | `number` | 2 | Exponential backoff multiplier |
| `jitter` | `boolean` | true | Add random jitter to prevent thundering herd |

### Exponential Backoff with Jitter

Retry delays follow exponential backoff with optional jitter:

```
Attempt 1: 100ms
Attempt 2: 200ms + jitter (0-80ms)
Attempt 3: 400ms + jitter (0-160ms)
Attempt 4: 800ms + jitter (0-320ms)
Attempt 5: 1600ms + jitter (0-640ms)
...capped at maxDelayMs
```

```typescript
// Delay calculation
function calculateDelay(attempt: number, config: RetryConfig): number {
  let delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt - 1)

  if (config.jitter) {
    const jitter = delay * (0.1 + Math.random() * 0.4)  // 10-50% jitter
    delay += jitter
  }

  return Math.min(delay, config.maxDelayMs)
}
```

## Error Types

### Retryable vs Non-Retryable Errors

dotdo distinguishes between errors that should be retried and those that shouldn't:

<Tabs items={['Retryable', 'Non-Retryable']}>
<Tab value="Retryable">
```typescript
import { RetryableError, NetworkError, RateLimitError } from 'dotdo'

// Transient network failure
throw new NetworkError('Connection refused', 'api.example.com')

// Rate limit with retry-after
throw new RateLimitError('Too many requests', 60000)  // retry after 60s

// Generic retryable error
throw new RetryableError('Service temporarily unavailable')
```

Retryable errors:
- Network timeouts and connection failures
- Rate limit errors (429)
- Service temporarily unavailable (503)
- Transient database errors
</Tab>

<Tab value="Non-Retryable">
```typescript
import {
  NonRetryableError,
  ValidationError,
  AuthorizationError,
  NotFoundError,
  BusinessRuleError
} from 'dotdo'

// Validation failure - retrying won't help
throw new ValidationError('Invalid email format', 'email', value)

// Authorization failure
throw new AuthorizationError('Insufficient permissions', 'admin:write')

// Resource not found
throw new NotFoundError('Customer', 'cust_123')

// Business rule violation
throw new BusinessRuleError('Insufficient funds', 'minimum_balance')
```

Non-retryable errors:
- Validation errors (400)
- Authentication/Authorization errors (401, 403)
- Not found errors (404)
- Business rule violations (422)
</Tab>
</Tabs>

### Error Type Guards

```typescript
import {
  isRetryableError,
  isNonRetryableError,
  shouldRetry,
  getRetryDelay
} from 'dotdo'

try {
  await $.do('Payment.charge', { amount: 100 })
} catch (error) {
  if (isRetryableError(error)) {
    console.log(`Retrying in ${getRetryDelay(error)}ms`)
  } else if (isNonRetryableError(error)) {
    console.log('Permanent failure:', error.message)
  }
}
```

## Circuit Breaker

The circuit breaker pattern prevents cascading failures by failing fast when a service is unhealthy.

### Circuit States

```
     ┌──────────────────────────────────────────────────┐
     │                                                  │
     ▼                                                  │
┌─────────┐  failures >= threshold  ┌────────┐         │
│ CLOSED  │ ─────────────────────▶  │  OPEN  │         │
│ (OK)    │                         │(Failed)│         │
└─────────┘                         └────────┘         │
     ▲                                   │             │
     │                                   │ timeout     │
     │ success                           ▼             │
     │                            ┌───────────┐        │
     └─────────────────────────── │ HALF-OPEN │ ───────┘
                                  │  (Test)   │  failure
                                  └───────────┘
```

| State | Description |
|-------|-------------|
| `closed` | Normal operation, requests pass through |
| `open` | Circuit tripped, requests fail immediately |
| `half-open` | Testing recovery, one request allowed |

### Basic Usage

```typescript
import { CircuitBreaker } from 'dotdo/primitives/circuit-breaker'

const breaker = new CircuitBreaker({
  failureThreshold: 5,    // Open after 5 failures
  resetTimeout: 30000,    // Try again after 30 seconds
  name: 'payment-api'
})

// Wrap external calls
const result = await breaker.execute(async () => {
  return await fetch('https://api.stripe.com/v1/charges', {
    method: 'POST',
    body: JSON.stringify({ amount, source })
  })
})
```

### Advanced Configuration

```typescript
const paymentCircuit = new CircuitBreaker({
  name: 'stripe-api',
  failureThreshold: 3,
  resetTimeout: 30000,

  // Sliding window for accurate failure tracking
  slidingWindow: {
    windowSize: 60000,    // 1 minute window
    minRequests: 10       // Need 10 requests before tripping
  },

  // Fallback when circuit is open
  fallback: {
    handler: () => ({
      success: false,
      error: 'Payment service temporarily unavailable'
    }),
    timeout: 5000
  },

  // Limit concurrent executions (bulkhead pattern)
  bulkhead: {
    maxConcurrent: 20,
    queueSize: 100,
    queueTimeout: 10000
  },

  // Retry before recording failure
  retryPolicy: {
    maxRetries: 2,
    baseDelay: 500,
    backoffMultiplier: 2,
    retryableErrors: (err) =>
      err.message.includes('rate_limit') ||
      err.message.includes('timeout')
  }
})
```

### Circuit Breaker Events

```typescript
breaker.onStateChange((from, to, stats) => {
  console.log(`Circuit ${from} -> ${to}`)

  if (to === 'open') {
    alertOps('Circuit breaker tripped!')
  }
})

breaker.on('failure', (event, data) => {
  metrics.increment('circuit.failure')
})

breaker.on('rejected', () => {
  metrics.increment('circuit.rejected')
})
```

### Cross-DO Circuit Breakers

Cross-DO calls automatically use circuit breakers:

```typescript
try {
  await $.PaymentProvider('stripe').charge({ amount, customerId })
} catch (error) {
  if (error.code === 'CIRCUIT_OPEN') {
    // Circuit is open - use fallback
    return this.getFallbackResponse(customerId, amount)
  }
  throw error
}
```

See [Circuit Breaker Primitive](/docs/primitives/circuit-breaker) for full documentation.

## Dead Letter Queue (DLQ)

When all retry attempts are exhausted, failed events go to the Dead Letter Queue for manual review and replay.

### DLQ Schema

```typescript
interface DeadLetterEntry {
  id: string
  event: string          // Event name (e.g., 'Order.placed')
  source: string         // Source DO or service
  data: unknown          // Original event payload
  error: string          // Error message
  errorCode?: string     // Error code if available
  attempts: number       // Number of attempts made
  maxRetries: number     // Maximum retries allowed
  createdAt: Date
  lastAttemptAt: Date
  nextRetryAt?: Date
  status: 'pending' | 'retrying' | 'exhausted' | 'resolved'
  metadata?: Record<string, unknown>
}
```

### DLQ Configuration

```typescript
const dlqConfig = {
  maxRetries: 5,              // Max automatic retries
  retryDelayMs: 60000,        // 1 minute initial delay
  retryBackoffMultiplier: 2,  // Exponential backoff
  maxRetryDelayMs: 3600000,   // 1 hour max delay
  expirationMs: 7 * 24 * 60 * 60 * 1000  // 7 days expiration
}
```

### Adding to DLQ

When `$.do()` exhausts retries, events are automatically added to the DLQ:

```typescript
// Automatic DLQ on exhausted retries
try {
  await $.do('Payment.charge', { amount: 100 })
} catch (error) {
  if (error instanceof WorkflowStepError) {
    console.error(`Step ${error.stepId} failed after ${error.attempts} attempts`)
    // Event is already in DLQ for later processing
  }
}

// Manual DLQ addition
await this.$.send('DLQ.add', {
  event: 'Order.process',
  source: 'OrderDO',
  data: orderData,
  error: 'Inventory system unavailable'
})
```

### DLQ Event Handlers

Handle DLQ events for monitoring and alerting:

```typescript
// Subscribe to DLQ events
$.on['dlq'].Order.placed(async (dlqEvent) => {
  console.error(`Order processing failed: ${dlqEvent.data.error}`)
  await alertOps(dlqEvent)
})

// Global DLQ handler
$.on['dlq']['*']['*'](async (event) => {
  await metrics.increment('dlq.entry')
  await notifySlack(`DLQ entry: ${event.verb}`)
})
```

### DLQ Replay

Replay failed events from the DLQ:

```typescript
// Manual replay
await errorsDO.replayEntry('dlq-entry-id')

// Get DLQ statistics
const stats = await errorsDO.getDLQStats()
// {
//   total: 50,
//   pending: 10,
//   retrying: 2,
//   exhausted: 5,
//   resolved: 33,
//   byEvent: { 'Order.placed': 20, 'Payment.charge': 15, ... },
//   oldestPending: Date
// }

// Get pending entries
const entries = await errorsDO.getDLQEntries({
  status: 'pending',
  event: 'Payment.charge',
  limit: 10
})

// Purge resolved entries
await errorsDO.purgeDLQ('resolved')
```

## Error Recovery Strategies

### Compensation Pattern (Saga)

For distributed operations, use compensating transactions to roll back partial failures:

```typescript
import { CrossDOSaga } from 'dotdo'

const checkoutSaga = new CrossDOSaga<Order, Shipment>()
  .addStep({
    name: 'reserveInventory',
    execute: async (order) => {
      return await $.Inventory('main').reserve(order.items)
    },
    compensate: async (reservation) => {
      await $.Inventory('main').release(reservation.id)
    },
  })
  .addStep({
    name: 'processPayment',
    execute: async (order) => {
      return await $.Payment(order.customerId).charge(order.total)
    },
    compensate: async (payment) => {
      await $.Payment(order.customerId).refund(payment.id)
    },
  })
  .addStep({
    name: 'createShipment',
    execute: async (order) => {
      return await $.Shipping('main').ship(order.id)
    },
    compensate: async (shipment) => {
      await $.Shipping('main').cancel(shipment.id)
    },
  })

const result = await checkoutSaga.execute(order, {
  idempotencyKey: order.id
})

if (!result.success) {
  // All completed steps were compensated
  console.log('Checkout failed:', result.error)
  console.log('Compensations run:', result.steps.filter(s => s.compensated))
}
```

### Fallback Pattern

Provide degraded functionality when services fail:

```typescript
async function getProductRecommendations(userId: string) {
  try {
    // Try primary recommendation service
    return await $.try('Recommendations.get', { userId }, { timeout: 2000 })
  } catch (error) {
    // Fall back to cached/static recommendations
    console.warn('Recommendations failed, using fallback:', error)
    return await getCachedRecommendations(userId)
  }
}
```

### Bulkhead Pattern

Isolate failures by limiting concurrent operations:

```typescript
import { Bulkhead, BulkheadFullError } from 'dotdo/primitives/circuit-breaker'

const bulkhead = new Bulkhead({
  maxConcurrent: 10,    // Max parallel executions
  queueSize: 50,        // Queue additional requests
  queueTimeout: 5000    // Timeout for queued requests
})

try {
  await bulkhead.execute(async () => {
    return await expensiveOperation()
  })
} catch (err) {
  if (err instanceof BulkheadFullError) {
    // Queue is full, return degraded response
    return { status: 'busy', retryAfter: 5000 }
  }
}
```

## Best Practices

### 1. Design for Idempotency

Actions may be replayed - ensure handlers can run multiple times safely:

```typescript
const Payment = Domain('Payment', {
  charge: async (payment, args, $) => {
    // Check if already processed using idempotency key
    const existing = await db.payments.findByIdempotencyKey(
      payment.idempotencyKey
    )
    if (existing) {
      return existing  // Return cached result
    }

    // Process payment
    const result = await stripe.charges.create({
      amount: payment.amount,
      idempotencyKey: payment.idempotencyKey
    })

    // Store for future replay
    await db.payments.insert({ ...result, idempotencyKey })
    return result
  }
})
```

### 2. Use Appropriate Durability

Choose the right execution mode for each operation:

```typescript
// Fire-and-forget for non-critical actions
$.track('Analytics.pageview', { path: '/dashboard' })

// Single attempt for fast operations
const valid = await $.try('Schema.validate', data)

// Durable for critical business operations
const result = await $.do('Payment.process', payment, {
  retry: { maxAttempts: 5 }
})
```

### 3. Handle Partial Failures

Design workflows to handle failures at any step:

```typescript
class OrderWorkflow extends WorkflowRuntime {
  async execute(order: Order) {
    try {
      await this.step('reserve', reserveInventory)
      await this.step('charge', chargePayment)
      await this.step('fulfill', fulfillOrder)
    } catch (error) {
      // Compensate for partial completion
      await this.compensate()
      throw error
    }
  }

  async compensate() {
    for (const result of this.stepResults.reverse()) {
      if (result.status === 'completed') {
        await this.reverseStep(result.name)
      }
    }
  }
}
```

### 4. Monitor and Alert

Set up monitoring for error patterns:

```typescript
// Set alert thresholds
errorsDO.setAlertThreshold('PAYMENT_FAILED', 10)
errorsDO.setAlertThreshold('INVENTORY_ERROR', 5)

// Get health status
const health = await errorsDO.getHealthStatus()
// {
//   healthy: false,
//   dlq: { pending: 150, exhausted: 3 },
//   compensations: { pending: 2 },
//   errors: { total: 500, recent: 45 }
// }

// Subscribe to alerts
$.on.Alert.triggered(async (event) => {
  await notifySlack(`Alert: ${event.data.errorCode} exceeded threshold`)
  await pagerDuty.trigger(event.data)
})
```

### 5. Test Failure Scenarios

Use chaos engineering to test error handling:

```typescript
// Inject failures for testing
if (process.env.CHAOS_ENABLED) {
  const random = Math.random()
  if (random < 0.1) {
    throw new NetworkError('Simulated network failure')
  }
  if (random < 0.05) {
    throw new RateLimitError('Simulated rate limit', 5000)
  }
}
```

## Related

- [WorkflowContext](/docs/sdk/workflow-context) - The $ proxy for durability
- [Circuit Breaker](/docs/primitives/circuit-breaker) - Fault tolerance primitive
- [Cross-DO RPC](/docs/architecture/cross-do-rpc) - Distributed error handling
- [Action Lifecycle](/docs/actions/lifecycle) - Action states and cleanup
- [Observability](/docs/observability) - Logging, metrics, and tracing
