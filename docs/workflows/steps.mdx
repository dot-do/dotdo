---
title: Workflow Steps
description: Conditional, parallel, and saga step patterns for workflow orchestration
---

import { Callout } from 'fumadocs-ui/components/callout'

# Workflow Steps

Workflow steps are the building blocks of durable execution. dotdo provides several step patterns for different orchestration needs: conditional branching, parallel execution, and saga-based compensating transactions.

## Step Types Overview

| Pattern | Use Case | Durability | Complexity |
|---------|----------|------------|------------|
| **Conditional** | Branch based on runtime data | Per-step | Low |
| **Parallel** | Run independent operations concurrently | Per-step | Medium |
| **Saga** | Multi-service transactions with compensation | Full | High |

## Conditional Steps

Conditional steps branch workflow execution based on runtime conditions.

### Using when()

The `when` helper provides declarative branching:

```typescript
import { when, send } from 'dotdo/workflows'
import { createWorkflowRuntime } from 'dotdo/workflows'

const runtime = createWorkflowRuntime()

// Simple condition
const result = when(order.total > 1000, {
  then: () => runtime.do('Order.requireApproval', order),
  else: () => runtime.do('Order.autoApprove', order)
})

// With pipeline promise conditions
const inventory = $.Inventory(product).check()

when(inventory.available, {
  then: () => $.Order(order).fulfill(),
  else: () => $.Order(order).backorder()
})
```

### Pattern Matching with branch()

For multi-way branching based on a discriminator:

```typescript
const result = $.branch(order.status, {
  pending: () => $.Order(order).process(),
  approved: () => $.Order(order).fulfill(),
  rejected: () => $.Order(order).cancel(),
  default: () => $.Order(order).hold()
})
```

### Complex Conditionals with match()

Use pattern matching for conditions beyond simple equality:

```typescript
const result = $.match(customer, [
  [(c) => c.tier === 'enterprise' && c.spend > 100000,
    () => $.Service.enterprise(customer)],
  [(c) => c.tier === 'premium',
    () => $.Service.premium(customer)],
  [(c) => true,
    () => $.Service.standard(customer)] // default
])
```

## Parallel Steps

Execute independent operations concurrently to reduce latency.

### Basic Parallel Execution

Use `Promise.all` for concurrent operations:

```typescript
import { on } from 'dotdo/workflows'
import { createWorkflowRuntime } from 'dotdo/workflows'

const runtime = createWorkflowRuntime()

on.Order.placed(async (event) => {
  const order = event.data

  // Run independent operations in parallel
  const [inventory, fraud, shipping] = await Promise.all([
    runtime.do('Inventory.reserve', order.items),
    runtime.do('Fraud.check', order.payment),
    runtime.do('Shipping.estimate', order.address),
  ])

  // Continue with dependent operations
  if (fraud.score < 0.8) {
    await runtime.do('Payment.charge', order.payment)
  }
})
```

### ParallelStepExecutor

For complex parallel workflows with detailed results:

```typescript
import { ParallelStepExecutor, step } from 'lib/executors/ParallelStepExecutor'

const executor = new ParallelStepExecutor([
  step('fetchUser', async (ctx) => fetchUser(ctx.input.userId)),
  step('fetchOrders', async (ctx) => fetchOrders(ctx.input.userId)),
  step('fetchPreferences', async (ctx) => getPreferences(ctx.input.userId)),
])

const result = await executor.execute({
  input: { userId: 'user-123' },
  workflowInstanceId: 'wf-456',
})

// Access individual results
console.log(result.results.fetchUser)
console.log(result.results.fetchOrders)

// Or use merged output
console.log(result.merged)
```

### Execution Modes

Control how parallel steps handle failures:

```typescript
// Fail fast: Stop on first error
new ParallelStepExecutor(steps, { mode: 'failFast' })

// Wait for all: Collect all results regardless of errors
new ParallelStepExecutor(steps, { mode: 'waitForAll' })

// Allow partial failure: Continue even if some steps fail
new ParallelStepExecutor(steps, { mode: 'allowPartialFailure' })
```

### Fan-Out / Fan-In

Process items in parallel batches and aggregate results:

```typescript
async function processLargeDataset(items: Item[]) {
  // Fan-out: Process in parallel batches
  const batchSize = 100
  const batches = chunk(items, batchSize)

  const results = await Promise.all(
    batches.map((batch, i) =>
      runtime.do('DataProcessor.processBatch', { batch, batchIndex: i })
    )
  )

  // Fan-in: Aggregate results
  return runtime.do('DataProcessor.aggregate', {
    results: results.flat(),
    totalItems: items.length,
  })
}
```

## Saga Pattern

Sagas maintain data consistency across distributed services without distributed transactions. Each step has a compensation that undoes its effects if a later step fails.

### Basic Saga

```typescript
import { SagaBuilder } from '@dotdo/compat-temporal/saga'

const orderSaga = new SagaBuilder()
  .addStep({
    name: 'reserveInventory',
    execute: async (order) => {
      return inventoryService.reserve(order.items)
    },
    compensate: async (reservation, error) => {
      await inventoryService.release(reservation.id)
    },
  })
  .addStep({
    name: 'processPayment',
    execute: async (reservation) => {
      return paymentService.charge({
        amount: reservation.total,
        customerId: reservation.customerId,
      })
    },
    compensate: async (payment, error) => {
      await paymentService.refund(payment.id)
    },
  })
  .addStep({
    name: 'createShipment',
    execute: async (payment) => {
      return shippingService.create({
        orderId: payment.orderId,
        address: payment.shippingAddress,
      })
    },
    compensate: async (shipment, error) => {
      await shippingService.cancel(shipment.id)
    },
  })
  .build()
```

### Executing Sagas

```typescript
import { on, send } from 'dotdo/workflows'

on.Order.placed(async (event) => {
  const result = await orderSaga.execute(event.data, {
    timeout: 30000,
    parallelCompensation: false, // Run compensations in reverse order
  })

  if (result.success) {
    send.Order.fulfilled({ orderId: event.data.id })
  } else {
    // Compensations ran automatically
    send.Order.failed({
      orderId: event.data.id,
      reason: result.error?.message,
      compensated: result.compensated,
    })
  }
})
```

### Parallel Steps in Sagas

Execute multiple validations concurrently:

```typescript
import { SagaBuilder, parallel } from '@dotdo/compat-temporal/saga'

const checkoutSaga = new SagaBuilder()
  .addStep(parallel({
    name: 'parallelValidations',
    steps: [
      {
        name: 'validateInventory',
        execute: async (cart) => inventoryService.validate(cart.items),
        compensate: async () => {}, // No compensation for validation
      },
      {
        name: 'validatePaymentMethod',
        execute: async (cart) => paymentService.validate(cart.paymentMethod),
      },
      {
        name: 'calculateShipping',
        execute: async (cart) => shippingService.estimate(cart.address),
      },
    ],
  }))
  .addStep({
    name: 'processOrder',
    execute: async ([inventory, payment, shipping]) => {
      return orderService.create({ inventory, payment, shipping })
    },
    compensate: async (order) => {
      await orderService.cancel(order.id)
    },
  })
  .build()
```

### Saga with Retry

Add retry policies to individual steps:

```typescript
import { withRetry, withTimeout } from '@dotdo/compat-temporal/saga'

const resilientSaga = new SagaBuilder()
  .addStep(withRetry({
    name: 'callExternalAPI',
    execute: async (data) => externalApi.process(data),
    compensate: async (result) => externalApi.rollback(result.id),
  }, {
    maxAttempts: 3,
    initialInterval: 1000,
    backoffCoefficient: 2,
    maxInterval: 10000,
  }))
  .addStep(withTimeout({
    name: 'slowOperation',
    execute: async (apiResult) => slowService.process(apiResult),
    compensate: async (result) => slowService.undo(result),
  }, 30000)) // 30 second timeout
  .build()
```

### Saga Result Structure

```typescript
interface SagaResult<T> {
  success: boolean           // Whether saga completed successfully
  result?: T                 // Final result if successful
  error?: Error              // Error if failed
  steps: SagaStepResult[]    // Results of all steps
  compensated: boolean       // Whether compensations ran
  compensationErrors?: Error[] // Errors during compensation
  duration: number           // Total execution time
}

interface SagaStepResult {
  stepName: string
  success: boolean
  result?: unknown
  error?: Error
  startedAt: number
  completedAt: number
  compensated: boolean
}
```

## Combining Patterns

### Conditional with Parallel

```typescript
on.Order.placed(async (event) => {
  const order = event.data

  // Parallel validation
  const [inventory, fraud] = await Promise.all([
    runtime.do('Inventory.check', order.items),
    runtime.do('Fraud.analyze', order),
  ])

  // Conditional branching based on results
  if (fraud.riskScore > 0.7) {
    await runtime.do('Review.createManualReview', order)
    return
  }

  if (!inventory.allAvailable) {
    await runtime.do('Notification.sendOutOfStock', order)
    return
  }

  // Continue with order processing
  await runtime.do('Order.process', order)
})
```

### Saga with Conditional Compensation

```typescript
const conditionalSaga = new SagaBuilder()
  .addStep({
    name: 'createOrder',
    execute: async (data) => orderService.create(data),
    compensate: async (order, error) => {
      // Only compensate if order is in cancellable state
      if (order.status !== 'shipped') {
        await orderService.cancel(order.id)
      } else {
        // Log for manual intervention
        await auditLog.record({
          type: 'COMPENSATION_SKIPPED',
          orderId: order.id,
          reason: 'Order already shipped',
        })
      }
    },
  })
  .build()
```

## Best Practices

### 1. Design Steps for Idempotency

Steps may be replayed - ensure they can run multiple times safely:

```typescript
.addStep({
  name: 'processPayment',
  execute: async (order) => {
    // Use idempotency key to prevent double charging
    const existing = await paymentService.findByIdempotencyKey(order.idempotencyKey)
    if (existing) return existing

    return paymentService.charge({
      amount: order.total,
      idempotencyKey: order.idempotencyKey,
    })
  },
})
```

### 2. Keep Steps Focused

Each step should do one thing well:

```typescript
// Good: Focused steps
.addStep({ name: 'validateOrder', execute: validateOrder })
.addStep({ name: 'reserveInventory', execute: reserveInventory })
.addStep({ name: 'processPayment', execute: processPayment })

// Less ideal: Monolithic step
.addStep({
  name: 'processEverything',
  execute: async (order) => {
    await validateOrder(order)
    await reserveInventory(order)
    await processPayment(order)
  },
})
```

### 3. Handle Partial Failures Gracefully

Design compensations that handle edge cases:

```typescript
.addStep({
  name: 'sendNotification',
  execute: async (data) => notificationService.send(data),
  compensate: async (result, error) => {
    // Notifications may not need compensation
    // Just log for audit purposes
    await auditLog.record({
      type: 'NOTIFICATION_COMPENSATION',
      notificationId: result.id,
      reason: error.message,
    })
  },
})
```

## Related

- [Workflows Overview](/docs/workflows) - The $ context DSL and durability levels
- [Workflow Triggers](/docs/workflows/triggers) - Event, schedule, manual, webhook triggers
- [Pipeline Promises](/docs/workflows/pipelines) - Deferred execution with promise pipelining
- [State Machines](/docs/workflows/state-machines) - XState v5 integration for complex state management
- [Functions](/docs/functions/executors) - Executor patterns for step execution
