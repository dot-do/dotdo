---
title: API Routing
description: Comprehensive guide to the API() factory and DO proxy routing patterns
---

# API Routing

The `API()` factory provides a clean, expressive interface for routing HTTP requests to Durable Objects. It supports multiple routing modes to handle different multi-tenant architectures.

## Quick Start

```typescript
import { API } from 'dotdo'

// Hostname-based routing (default)
// tenant.api.dotdo.dev -> DO('https://tenant.api.dotdo.dev')
export default API()

// Path param routing (Express-style)
// api.dotdo.dev/acme/users -> DO('https://api.dotdo.dev/acme')
export default API({ ns: '/:org' })

// Nested path params
// api.dotdo.dev/acme/proj1/tasks -> DO('https://api.dotdo.dev/acme/proj1')
export default API({ ns: '/:org/:project' })

// Fixed namespace (singleton DO)
// api.dotdo.dev/path -> DO('main')
export default API({ ns: 'main' })
```

## Routing Modes

### Hostname Mode (Default)

When no `ns` pattern is provided, the API factory uses hostname-based routing. It extracts the namespace from the subdomain.

```typescript
export default API()
```

**How it works:**

| Request URL | Namespace | Forwarded Path |
|------------|-----------|----------------|
| `https://tenant.api.dotdo.dev/users` | `https://tenant.api.dotdo.dev` | `/users` |
| `https://my-org.api.dotdo.dev/data` | `https://my-org.api.dotdo.dev` | `/data` |
| `https://api.dotdo.dev/users` | (404 - no subdomain) | - |

**Subdomain detection uses the 4-part heuristic:**

- 4+ parts: `tenant.api.dotdo.dev` - has subdomain (tenant)
- 3 parts: `api.dotdo.dev` - apex domain, no subdomain
- 2 parts: `dotdo.dev` - apex domain
- 1 part: `localhost` - no subdomain

This works well for multi-tenant SaaS where each tenant gets a subdomain.

### Path Param Mode

Use Express-style path parameters to extract the namespace from URL segments.

```typescript
// Single path param
export default API({ ns: '/:org' })
```

**How it works:**

| Request URL | Namespace | Forwarded Path |
|------------|-----------|----------------|
| `https://api.dotdo.dev/acme/users` | `https://api.dotdo.dev/acme` | `/users` |
| `https://api.dotdo.dev/acme/users/123` | `https://api.dotdo.dev/acme` | `/users/123` |
| `https://api.dotdo.dev/acme` | `https://api.dotdo.dev/acme` | `/` |
| `https://api.dotdo.dev/` | (404 - no namespace) | - |

### Nested Path Params

For hierarchical namespacing (org + project, team + repo, etc.):

```typescript
// Two-level namespace
export default API({ ns: '/:org/:project' })
```

**How it works:**

| Request URL | Namespace | Forwarded Path |
|------------|-----------|----------------|
| `https://api.dotdo.dev/acme/proj1/tasks` | `https://api.dotdo.dev/acme/proj1` | `/tasks` |
| `https://api.dotdo.dev/acme/proj1` | `https://api.dotdo.dev/acme/proj1` | `/` |
| `https://api.dotdo.dev/acme` | (404 - missing second param) | - |

### Fixed Namespace Mode

For singleton Durable Objects that handle all requests:

```typescript
export default API({ ns: 'main' })
```

**How it works:**

| Request URL | Namespace | Forwarded Path |
|------------|-----------|----------------|
| `https://api.dotdo.dev/users` | `main` | `/users` |
| `https://anything.com/data` | `main` | `/data` |
| `https://api.dotdo.dev/` | `main` | `/` |

Fixed namespace is ideal for:
- Single-tenant applications
- Global resources (config, settings)
- Shared services

## Namespace Resolution Algorithm

The namespace resolution follows this precedence:

```
1. If ns is undefined -> hostname mode (subdomain extraction)
2. If ns starts with '/' and contains ':' -> path param mode
3. Otherwise -> fixed namespace mode (literal value)
```

**Detection logic:**

```typescript
function resolveNs(request: Request, pattern?: string): ResolveResult {
  // No pattern = hostname mode
  if (!pattern) {
    return hostnameMode(request)
  }

  // Literal/fixed namespace (no colon = not a path param)
  if (!pattern.startsWith('/') || !pattern.includes(':')) {
    return { ns: pattern, remainingPath: url.pathname }
  }

  // Path params (/:org or /:org/:project)
  return pathParamMode(request, pattern)
}
```

## DO Binding Auto-Detection

The API factory automatically finds the DurableObjectNamespace binding in your environment:

```typescript
function findDOBinding(env: Record<string, unknown>): DurableObjectNamespace | null {
  for (const value of Object.values(env)) {
    if (
      value &&
      typeof value === 'object' &&
      'idFromName' in value &&
      'get' in value &&
      typeof value.idFromName === 'function' &&
      typeof value.get === 'function'
    ) {
      return value as DurableObjectNamespace
    }
  }
  return null
}
```

**Implications:**

- Works with any binding name (`DO`, `DURABLE_OBJECT`, `MyDO`, etc.)
- Finds the first matching binding if multiple exist
- Returns 500 error if no DO binding found

**wrangler.toml configuration:**

```toml
[[durable_objects.bindings]]
name = "DO"
class_name = "DOBase"

# Or any name you prefer
[[durable_objects.bindings]]
name = "MY_DO"
class_name = "MyDurableObject"
```

## Request Transformation

### Path Stripping

The API factory strips namespace segments from the path before forwarding:

| Mode | Original Path | Forwarded Path |
|------|--------------|----------------|
| Hostname | `/users/123` | `/users/123` |
| Path (`/:org`) | `/acme/users/123` | `/users/123` |
| Path (`/:org/:proj`) | `/acme/proj1/tasks` | `/tasks` |
| Fixed | `/users/123` | `/users/123` |

### Query Parameters

Query parameters are preserved:

```
Request:  https://api.dotdo.dev/acme/search?q=test&limit=10
Forward:  /search?q=test&limit=10
```

### Headers

All request headers are forwarded unchanged to the Durable Object:

```typescript
const forwardRequest = new Request(forwardUrl.toString(), {
  method: request.method,
  headers: request.headers,
  body: request.body,
  duplex: 'half',
})
```

### Request Body

Request bodies are streamed through without modification using `duplex: 'half'`.

## Error Handling

The API factory returns JSON error responses:

### 404 - Namespace Not Found

Returned when namespace cannot be extracted:

```json
{
  "error": "Namespace not found"
}
```

**Causes:**
- Hostname mode: No subdomain detected (apex domain)
- Path mode: Missing required path segments
- Nested params: Insufficient path segments

### 500 - No DO Binding

Returned when no DurableObjectNamespace binding exists:

```json
{
  "error": "No DO binding found"
}
```

**Solution:** Ensure your wrangler.toml has a durable_objects binding.

### 503 - Service Unavailable

Returned when DO stub.fetch() throws an error:

```json
{
  "error": "Connection timeout"
}
```

Includes the error message when available.

## Multi-Tenant Applications

### Subdomain per Tenant

Best for B2B SaaS where each customer has their own subdomain:

```typescript
// wrangler.toml routes: tenant.api.yourdomain.com/*
export default API()
```

```
acme.api.yourdomain.com/users -> DO('https://acme.api.yourdomain.com')
beta.api.yourdomain.com/users -> DO('https://beta.api.yourdomain.com')
```

### Path-based Tenants

Best for platforms with shared domain:

```typescript
export default API({ ns: '/:tenant' })
```

```
api.yourdomain.com/acme/users -> DO('https://api.yourdomain.com/acme')
api.yourdomain.com/beta/users -> DO('https://api.yourdomain.com/beta')
```

### Organization + Project

For hierarchical multi-tenancy (GitHub-style):

```typescript
export default API({ ns: '/:org/:repo' })
```

```
api.github.do/facebook/react/issues -> DO('https://api.github.do/facebook/react')
api.github.do/vercel/next/pulls    -> DO('https://api.github.do/vercel/next')
```

## createProxyHandler for Custom Routing

For more control, use `createProxyHandler` directly:

```typescript
import { createProxyHandler, type ProxyConfig } from 'dotdo/workers'

const config: ProxyConfig = {
  mode: 'hostname',
  hostname: {
    rootDomain: 'api.dotdo.dev',
    stripLevels: 1,
  },
  basepath: '/api/v1',
  defaultNs: 'public',
}

const handler = createProxyHandler(config)

export default {
  fetch: (request: Request, env: CloudflareEnv) => handler(request, env),
}
```

### ProxyConfig Options

```typescript
interface ProxyConfig {
  /** Namespace resolution mode */
  mode: 'hostname' | 'path' | 'fixed'

  /** Path prefix to strip before forwarding (e.g., '/api/v1') */
  basepath?: string

  /** Fallback namespace when resolution fails */
  defaultNs?: string

  /** Hostname mode configuration */
  hostname?: {
    /** Number of subdomain levels to use as namespace (default: 1) */
    stripLevels?: number
    /** Root domain to match against (e.g., 'api.dotdo.dev') */
    rootDomain: string
  }

  /** Fixed mode configuration */
  fixed?: {
    /** The namespace to always route to */
    namespace: string
  }
}
```

### Basepath Stripping

Strip API version prefixes before routing:

```typescript
const handler = createProxyHandler({
  mode: 'path',
  basepath: '/api/v1',
})

// Request:  https://api.dotdo.dev/api/v1/tenant/users
// Namespace: tenant
// Forward:  /users
```

### Default Namespace Fallback

Provide a fallback for requests that cannot extract a namespace:

```typescript
const handler = createProxyHandler({
  mode: 'hostname',
  hostname: { rootDomain: 'api.dotdo.dev' },
  defaultNs: 'public',
})

// Apex domain requests route to 'public' DO
// api.dotdo.dev/docs -> DO('public').fetch('/docs')
```

## Environment Variable Configuration

For deployment flexibility, configure via environment variables:

```typescript
import hostnameProxy from 'dotdo/workers/hostname-proxy'

export default hostnameProxy
```

**wrangler.toml:**

```toml
[vars]
PROXY_MODE = "hostname"
PROXY_ROOT_DOMAIN = "api.dotdo.dev"
PROXY_BASEPATH = "/api/v1"
PROXY_DEFAULT_NS = "public"
PROXY_FIXED_NS = "main"  # Only used if PROXY_MODE = "fixed"
```

## Simple JSON Worker

For APIs that want plain JSON without HATEOAS envelope:

```typescript
import { createSimpleHandler } from 'dotdo/workers'

// Strips { api, links, discover, data } envelope
// Returns just the data with $type and $id
export default {
  fetch: createSimpleHandler({ mode: 'path' }),
}
```

## Related

- [API Reference](/docs/api) - Complete REST API documentation
- [Durable Objects](/docs/architecture/durable-objects) - DO architecture
- [Authentication](/docs/api/authentication) - API authentication
- [DOBase](/docs/objects/do) - Base Durable Object class
