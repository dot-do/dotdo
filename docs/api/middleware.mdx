---
title: Middleware
description: Hono middleware for request processing, authentication, and rate limiting
---

# Middleware

dotdo uses [Hono](https://hono.dev) middleware for request processing. This page documents the available middleware and how to configure them.

## Global Middleware Stack

The following middleware runs on all requests in order:

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { errorHandler } from './middleware/error-handling'
import { requestIdMiddleware } from './middleware/request-id'

const app = new Hono()

app.use('*', errorHandler)
app.use('*', requestIdMiddleware)
app.use('*', logger())
app.use('*', cors())
```

| Order | Middleware | Purpose |
|-------|------------|---------|
| 1 | `errorHandler` | Catch and format errors |
| 2 | `requestIdMiddleware` | Request correlation |
| 3 | `logger` | Request logging |
| 4 | `cors` | Cross-origin requests |

---

## Error Handler

Catches all errors and returns consistent JSON responses.

```typescript
import { errorHandler } from 'dotdo/api/middleware/error-handling'

app.use('*', errorHandler)
```

### Custom Error Classes

```typescript
import {
  BadRequestError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
  MethodNotAllowedError,
  ConflictError,
  UnprocessableEntityError,
  InternalServerError,
} from 'dotdo/api/middleware/error-handling'

// Throw in route handlers
app.get('/resource/:id', (c) => {
  throw new NotFoundError('Resource not found')
})

// With validation details
app.post('/users', (c) => {
  throw new UnprocessableEntityError('Validation failed', {
    email: ['Invalid email format'],
    name: ['Name is required'],
  })
})

// Method not allowed with allowed methods
app.all('/readonly', (c) => {
  throw new MethodNotAllowedError(['GET', 'HEAD'])
})
```

### Error Response Format

All errors return this structure:

```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Resource not found",
    "details": {},
    "requestId": "req-uuid",
    "stack": "..."
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `code` | string | Machine-readable error code |
| `message` | string | Human-readable message |
| `details` | object | Field-specific errors (422 only) |
| `requestId` | string | Request correlation ID |
| `stack` | string | Stack trace (development only) |

### Error Codes

| Code | Status | Description |
|------|--------|-------------|
| `BAD_REQUEST` | 400 | Malformed request |
| `UNAUTHORIZED` | 401 | Authentication required |
| `FORBIDDEN` | 403 | Insufficient permissions |
| `NOT_FOUND` | 404 | Resource not found |
| `METHOD_NOT_ALLOWED` | 405 | HTTP method not supported |
| `CONFLICT` | 409 | Resource conflict |
| `UNPROCESSABLE_ENTITY` | 422 | Validation failed |
| `INTERNAL_SERVER_ERROR` | 500 | Server error |

---

## Request ID

Tracks requests across services for distributed tracing.

```typescript
import { requestIdMiddleware } from 'dotdo/api/middleware/request-id'

app.use('*', requestIdMiddleware)
```

Behavior:

1. Reads `X-Request-ID` header from incoming request
2. Generates a new UUID if not provided
3. Sets `X-Request-ID` on the response
4. Stores in context as `c.get('requestId')`

```typescript
app.get('/debug', (c) => {
  const requestId = c.get('requestId')
  return c.json({ requestId })
})
```

---

## Authentication

Multi-method authentication middleware supporting JWT, API keys, and sessions.

```typescript
import { authMiddleware, requireAuth, requireRole } from 'dotdo/api/middleware/auth'

// Apply authentication (sets context but doesn't block)
app.use('*', authMiddleware({
  jwtSecret: env.JWT_SECRET,
  publicPaths: ['/health', '/public'],
}))

// Require authentication on specific routes
app.use('/api/*', requireAuth())

// Require specific role
app.use('/admin/*', requireRole('admin'))
```

### Configuration Options

```typescript
interface AuthConfig {
  // JWT verification
  jwtSecret?: string
  jwksUrl?: string

  // API keys (loaded from env or KV)
  apiKeys?: Map<string, ApiKeyConfig>

  // Session configuration
  cookieName?: string
  validateSession?: SessionValidator
  sessionCache?: KVNamespace
  sessionCacheTtl?: number

  // Memory cache for sessions
  enableMemoryCache?: boolean
  memoryCacheMaxSize?: number

  // Paths that skip auth
  publicPaths?: string[]
}
```

### Authentication Methods

#### 1. JWT Bearer Token

```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

```typescript
// Generate a token (development/testing)
import { generateJWT } from 'dotdo/api/middleware/auth'

const token = await generateJWT({
  sub: 'user-123',
  email: 'user@example.com',
  role: 'user',
  permissions: ['read', 'write'],
}, 'your-secret', '1h')
```

#### 2. API Key

```http
X-API-Key: your-api-key
```

Configure via environment variable:

```json
// env.API_KEYS
{
  "prod-key-123": {
    "userId": "user-1",
    "role": "user",
    "permissions": ["read"],
    "name": "Production Key"
  }
}
```

Or register at runtime:

```typescript
import { registerApiKey, revokeApiKey } from 'dotdo/api/middleware/auth'

registerApiKey('new-key', {
  userId: 'user-123',
  role: 'admin',
  permissions: ['read', 'write', 'delete'],
})

revokeApiKey('old-key')
```

#### 3. Session Cookie

```http
Cookie: session=session-token-value
```

Configure with a custom validator:

```typescript
import { authMiddleware, createSessionValidator } from 'dotdo/api/middleware/auth'

// With Drizzle ORM
const validateSession = createSessionValidator(db)

app.use('*', authMiddleware({
  validateSession,
  sessionCache: env.KV,
  sessionCacheTtl: 300,
}))
```

### Auth Context

After authentication, the following is available in route handlers:

```typescript
app.get('/me', (c) => {
  const auth = c.get('auth')      // Full auth context
  const user = c.get('user')      // User info
  const session = c.get('session') // Session info

  return c.json({
    userId: auth.userId,
    role: auth.role,
    method: auth.method, // 'jwt' | 'session' | 'apikey'
  })
})
```

### Permission Checking

```typescript
import { requirePermission } from 'dotdo/api/middleware/auth'

app.delete('/things/:id', requirePermission('delete'), (c) => {
  // User has 'delete' permission
})
```

---

## Rate Limiting

Cloudflare Rate Limit binding integration.

```typescript
import { rateLimitMiddleware } from 'dotdo/api/middleware/rate-limit'

app.use('/api/*', rateLimitMiddleware({
  binding: env.RATE_LIMIT_API,
  limit: 100,
}))
```

### Configuration

```typescript
interface RateLimitMiddlewareConfig {
  // Cloudflare Rate Limit binding
  binding: RateLimitBinding

  // Key generator (default: X-User-ID header or 'anonymous')
  keyGenerator?: (c: Context) => string

  // Limit for header display (should match wrangler.jsonc)
  limit?: number

  // Custom rate limited response
  onRateLimited?: (c: Context, remaining: number) => Response
}
```

### Custom Key Generator

```typescript
// Rate limit by IP
app.use('/api/*', rateLimitMiddleware({
  binding: env.RATE_LIMIT_API,
  keyGenerator: (c) => c.req.header('CF-Connecting-IP') || 'unknown',
}))

// Rate limit by user ID (from auth)
app.use('/api/*', rateLimitMiddleware({
  binding: env.RATE_LIMIT_API,
  keyGenerator: (c) => c.get('auth')?.userId || 'anonymous',
}))
```

### Response Headers

The middleware sets these headers:

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests allowed |
| `X-RateLimit-Remaining` | Requests remaining in window |

### Rate Limited Response

Default 429 response:

```json
{
  "error": "Too many requests - rate limit exceeded",
  "remaining": 0
}
```

Custom response:

```typescript
app.use('/api/*', rateLimitMiddleware({
  binding: env.RATE_LIMIT_API,
  onRateLimited: (c, remaining) => {
    return c.json({
      error: { code: 'RATE_LIMITED', message: 'Slow down!' }
    }, 429)
  },
}))
```

### Accessing Rate Limit Info

```typescript
app.get('/status', (c) => {
  const rateLimit = c.get('rateLimit')
  return c.json({
    remaining: rateLimit.remaining,
    limit: rateLimit.limit,
  })
})
```

---

## CORS

Built-in Hono CORS middleware.

```typescript
import { cors } from 'hono/cors'

// Allow all origins
app.use('*', cors())

// Custom configuration
app.use('*', cors({
  origin: ['https://app.dotdo.dev', 'https://dashboard.dotdo.dev'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
  exposeHeaders: ['X-Request-ID', 'X-RateLimit-Remaining'],
  maxAge: 86400,
  credentials: true,
}))
```

---

## Custom Middleware

Create your own middleware:

```typescript
import type { MiddlewareHandler } from 'hono'

const myMiddleware: MiddlewareHandler = async (c, next) => {
  // Before request
  const start = Date.now()

  // Process request
  await next()

  // After response
  const duration = Date.now() - start
  c.header('X-Response-Time', `${duration}ms`)
}

app.use('*', myMiddleware)
```

### Middleware with Configuration

```typescript
function createTimingMiddleware(options: { headerName: string }) {
  return async (c, next) => {
    const start = Date.now()
    await next()
    c.header(options.headerName, `${Date.now() - start}ms`)
  }
}

app.use('*', createTimingMiddleware({ headerName: 'X-Duration' }))
```
