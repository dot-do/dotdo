---
title: Event Emission
description: Fire-and-forget event emission with $.send() for decoupled, asynchronous communication
---

# Event Emission

Event emission in dotdo follows a fire-and-forget pattern using the `$.send()` API. Events are emitted asynchronously without blocking the caller, enabling fully decoupled communication between components.

## Overview

The event emission system provides:

- **Fire-and-forget semantics**: Emit events without waiting for handlers
- **Noun.verb patterns**: Natural, domain-driven event naming
- **Pipeline integration**: Events are captured as pipeline expressions for batching
- **Delivery guarantees**: At-least-once delivery with configurable retries

## Basic Emission

Use `$.send.Noun.verb(payload)` to emit events:

```typescript
import { send } from 'dotdo/workflows'

// Emit a customer signup event
send.Customer.signup({
  id: 'cust_123',
  email: 'user@example.com',
  name: 'Jane Doe',
  plan: 'starter',
})

// Emit an order event
send.Order.placed({
  id: 'order_456',
  customerId: 'cust_123',
  items: [
    { productId: 'prod_1', quantity: 2 },
    { productId: 'prod_2', quantity: 1 },
  ],
  total: 149.99,
})

// Emit a payment event
send.Payment.succeeded({
  id: 'pay_789',
  orderId: 'order_456',
  amount: 149.99,
  method: 'card',
})
```

## Event Payload Structure

Events follow a structured format with automatic metadata:

```typescript
interface DomainEvent<T = unknown> {
  // Auto-generated unique identifier
  id: string

  // The verb from Noun.verb (e.g., "signup", "placed")
  verb: string

  // Source identifier (e.g., "https://namespace/Customer/signup")
  source: string

  // Your custom payload data
  data: T

  // Auto-generated timestamp
  timestamp: Date
}
```

### Custom Payloads

Define typed payloads for your events:

```typescript
interface CustomerSignupPayload {
  id: string
  email: string
  name: string
  plan: 'starter' | 'pro' | 'enterprise'
  referralCode?: string
}

// TypeScript provides autocomplete and validation
send.Customer.signup({
  id: 'cust_123',
  email: 'user@example.com',
  name: 'Jane Doe',
  plan: 'pro',
  referralCode: 'FRIEND50',
} satisfies CustomerSignupPayload)
```

## Event Routing

Events are routed based on their Noun.verb pattern:

```typescript
// This event...
send.Customer.signup(payload)

// ...is delivered to all handlers registered for:
$.on.Customer.signup(handler)  // Exact match
$.on.Customer.*(handler)       // Wildcard verb (all Customer events)
$.on.*.signup(handler)         // Wildcard noun (all signup events)
```

### Cross-DO Routing

Events can be routed to specific Durable Objects:

```typescript
// Emit to a specific DO instance
await $.Customer('cust_123').emit.upgraded({
  newPlan: 'enterprise',
  previousPlan: 'pro',
})

// Broadcast to all instances of a DO type
await $.Customer.broadcast.priceChange({
  effectiveDate: '2024-02-01',
  percentIncrease: 5,
})
```

## Durability Modes

The workflow context provides three emission modes:

### $.send() - Fire and Forget

Non-blocking, best-effort delivery:

```typescript
class OrderDO extends DO {
  async placeOrder(items: Item[]) {
    const order = await this.createOrder(items)

    // Emit without waiting - returns immediately
    this.$.send.Order.placed({
      id: order.id,
      items,
      total: order.total,
    })

    return order
  }
}
```

### $.try() - Single Attempt

Blocking with single delivery attempt:

```typescript
async function processPayment(payment: Payment) {
  // Wait for handlers to process, but don't retry on failure
  const result = await $.try.Payment.processed({
    id: payment.id,
    status: 'completed',
    amount: payment.amount,
  })

  return result
}
```

### $.do() - Durable with Retries

Full durability with automatic retries:

```typescript
async function criticalEvent(data: CriticalData) {
  // Durable emission with retry policy
  await $.do.Critical.action({
    data,
    timestamp: Date.now(),
  }, {
    retries: 5,
    backoff: 'exponential',
    maxDelay: '30s',
  })
}
```

## Delivery Guarantees

### At-Least-Once Delivery

By default, events use at-least-once delivery:

```typescript
// Event may be delivered multiple times on retry
send.Order.placed(order)

// Handlers should be idempotent
$.on.Order.placed(async (event) => {
  // Use event.id for deduplication
  const processed = await checkIfProcessed(event.id)
  if (processed) return

  await processOrder(event.data)
  await markAsProcessed(event.id)
})
```

### Exactly-Once Processing

Achieve exactly-once semantics with idempotency keys:

```typescript
// Include idempotency key in payload
send.Payment.captured({
  orderId: 'order_123',
  amount: 99.99,
  idempotencyKey: `capture-${orderId}-${attempt}`,
})

// Handler checks idempotency
$.on.Payment.captured(async (event) => {
  const { idempotencyKey } = event.data

  const existing = await this.events.findByIdempotencyKey(idempotencyKey)
  if (existing) {
    return existing.result // Return cached result
  }

  const result = await processCapture(event.data)
  await this.events.saveWithIdempotencyKey(idempotencyKey, result)
  return result
})
```

## Batching and Optimization

The pipeline system automatically batches independent events:

```typescript
async function orderComplete(order: Order) {
  // These events are batched and sent together
  send.Order.completed({ orderId: order.id })
  send.Inventory.decremented({ items: order.items })
  send.Analytics.orderTracked({ order })
  send.Customer.notified({
    customerId: order.customerId,
    message: 'Order shipped!'
  })

  // All events sent in a single batch when function completes
}
```

### Manual Batching

For explicit control over batching:

```typescript
import { batch } from 'dotdo/workflows'

await batch([
  send.Event.one(payload1),
  send.Event.two(payload2),
  send.Event.three(payload3),
])
```

## Error Handling

### Failed Deliveries

Events that fail delivery go to the Dead Letter Queue:

```typescript
// Configure DLQ handling
$.on.Order.placed(async (event) => {
  // If this throws, event goes to DLQ after retries exhausted
  await processOrder(event.data)
})

// Replay failed events from DLQ
await this.dlq.replay('Order.placed')

// Inspect DLQ
const failed = await this.dlq.list({
  eventType: 'Order.placed',
  since: '1 hour ago',
})
```

### Circuit Breaker

Protect downstream systems with circuit breakers:

```typescript
$.on.ExternalAPI.called(async (event) => {
  // Circuit breaker opens after 5 failures
  await this.circuitBreaker.call('external-api', async () => {
    await callExternalAPI(event.data)
  })
}, {
  circuitBreaker: {
    threshold: 5,
    timeout: '30s',
  },
})
```

## Related

- [SDK: Events](/docs/sdk/events) - Handling events with $.on subscriptions
- [Concepts: Events](/docs/concepts/events) - 5W+H event model and event sourcing patterns
- [Events Overview](/docs/events) - Event-driven architecture with Noun.verb patterns
- [SDK: WorkflowContext](/docs/sdk/workflow-context) - The $ proxy reference
