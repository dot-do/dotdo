---
title: Event Emission
description: Fire-and-forget event emission with $.send() for decoupled, asynchronous communication
---

# Event Emission

Event emission in dotdo follows a fire-and-forget pattern using the `$.send()` API. Events are emitted asynchronously without blocking the caller, enabling fully decoupled communication between components.

## Overview

The event emission system provides:

- **Fire-and-forget semantics**: Emit events without waiting for handlers
- **Noun.verb patterns**: Natural, domain-driven event naming
- **Database persistence**: Events stored in SQLite for durability
- **DLQ integration**: Failed handlers automatically retry via Dead Letter Queue

## Basic Emission

Use `$.send(eventKey, payload)` to emit events within a Durable Object:

```typescript
class OrderDO extends DO {
  async placeOrder(items: Item[]) {
    const order = await this.createOrder(items)

    // Fire-and-forget event emission
    this.$.send('Order.placed', {
      id: order.id,
      customerId: this.ns,
      items,
      total: order.total,
    })

    return order
  }

  async markShipped(trackingNumber: string) {
    this.$.send('Order.shipped', {
      orderId: this.ns,
      trackingNumber,
      shippedAt: new Date().toISOString(),
    })
  }
}
```

## Event Payload Structure

Events are stored and dispatched with this structure:

```typescript
interface DomainEvent<T = unknown> {
  // Auto-generated unique identifier
  id: string

  // The verb from Noun.verb (e.g., "signup", "placed")
  verb: string

  // Source DO namespace
  source: string

  // Your custom payload data
  data: T

  // Optional: action that triggered this event
  actionId?: string

  // Auto-generated timestamp
  timestamp: Date
}
```

## Durability Modes

The workflow context provides three execution modes with different durability guarantees:

### $.send() - Fire and Forget

Non-blocking, best-effort delivery. The method returns immediately without waiting:

```typescript
class CustomerDO extends DO {
  async signup(email: string, name: string) {
    const customer = await this.createCustomer({ email, name })

    // Returns immediately - does not block
    this.$.send('Customer.signup', {
      id: customer.id,
      email,
      name,
    })

    return customer
  }
}
```

**Behavior:**
- Uses `queueMicrotask()` for async execution
- Logs action to database
- Emits event to pipeline (if configured)
- Errors are logged but don't propagate

### $.try() - Single Attempt

Blocking execution with a single attempt and optional timeout:

```typescript
class PaymentDO extends DO {
  async process(amount: number) {
    // Wait for completion, but no retries on failure
    const result = await this.$.try('Payment.process', {
      amount,
      currency: 'USD',
    }, {
      timeout: 30000, // 30 second timeout
    })

    return result
  }
}
```

**Behavior:**
- Awaits action execution
- Single attempt only
- Configurable timeout (default: 30s)
- Emits success/failure events

### $.do() - Durable with Retries

Full durability with automatic retries and exponential backoff:

```typescript
class CriticalDO extends DO {
  async criticalOperation(data: unknown) {
    // Durable execution with retry policy
    const result = await this.$.do('Critical.action', data, {
      retry: {
        maxAttempts: 5,
        initialDelayMs: 100,
        maxDelayMs: 30000,
        backoffMultiplier: 2,
        jitter: true,
      },
      timeout: 60000,
      stepId: 'critical-step-1', // For replay
    })

    return result
  }
}
```

**Behavior:**
- Persisted step cache for replay
- Configurable retry policy with exponential backoff
- Step deduplication via stepId
- Emits `action.completed` or `action.failed` events

## Default Retry Policy

The default retry policy for `$.do()`:

```typescript
{
  maxAttempts: 3,
  initialDelayMs: 100,
  maxDelayMs: 30000,
  backoffMultiplier: 2,
  jitter: true,
}
```

## Event Routing

Events are routed based on their Noun.verb pattern to registered handlers:

```typescript
// This event...
this.$.send('Customer.signup', payload)

// ...is delivered to handlers registered for:
$.on.Customer.signup(handler)  // Exact match
$.on.Customer['*'](handler)    // Wildcard verb (all Customer events)
$.on['*'].signup(handler)      // Wildcard noun (all signup events)
$.on['*']['*'](handler)        // Global handler (all events)
```

## Error Handling

### DLQ Integration

When handlers fail, events are automatically added to the Dead Letter Queue:

```typescript
$.on.Order.placed(async (event) => {
  // If this throws, event goes to DLQ after maxRetries exhausted
  await processOrder(event.data)
}, {
  maxRetries: 3, // DLQ retry limit
})
```

### Idempotent Handlers

Handlers should be idempotent since events may be retried:

```typescript
$.on.Payment.captured(async (event) => {
  // Check for duplicate processing
  const existing = await this.events.get(event.id)
  if (existing) return // Already processed

  await processCapture(event.data)
  await this.events.put(event.id, { processed: true })
})
```

### Event Persistence

Events are stored in the DO's SQLite database via the events table:

```typescript
// Events are automatically persisted
this.$.send('Order.placed', order)

// Query historical events
const events = await this.events.list({
  verb: 'Order.placed',
  since: new Date('2024-01-01'),
})
```

## Pipeline Integration

When a `PIPELINE` binding is configured, events are also sent to Cloudflare Pipelines for streaming analytics:

```typescript
// In wrangler.toml
[[pipelines]]
name = "events"
binding = "PIPELINE"

// Events automatically stream to pipeline
this.$.send('Order.placed', order)
// -> Sent to both SQLite and PIPELINE
```

## Related

- [Events Overview](/docs/events) - Event handlers with $.on.Noun.verb
- [Concepts: Actions](/docs/concepts/actions) - The Noun.verb pattern
- [SDK: WorkflowContext](/docs/sdk/workflow-context) - The $ proxy reference
