---
title: Worker
description: Base class for work-performing entities - the common interface for AI Agents and Human workers.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Worker

The `Worker` class is the base class for all work-performing entities in dotdo. It provides a common interface for both AI Agents and Human workers, enabling consistent task execution, question answering, decision making, and approval workflows.

## Overview

```
        Worker
           |
    +------+------+
    |             |
  Agent        Human
```

Workers can operate in three modes:
- **autonomous** - Work independently without oversight
- **supervised** - Work with periodic human review
- **manual** - Require human approval for each action

## Basic Usage

```typescript
import { Worker } from 'dotdo'

class SupportWorker extends Worker {
  static override readonly $type = 'SupportWorker'

  protected async executeTask(task: Task, context?: Context): Promise<unknown> {
    // Handle support ticket
    const ticket = await this.things.get(task.id)
    await this.processTicket(ticket)
    return { resolved: true }
  }

  protected async generateAnswer(question: string, context?: Context): Promise<Answer> {
    // Generate response to customer question
    return {
      text: `Here's the answer to: ${question}`,
      confidence: 0.95,
      sources: ['knowledge-base', 'docs'],
    }
  }
}
```

## Execution Modes

### Setting the Mode

```typescript
// Get current mode
const mode = worker.getMode()  // 'autonomous' | 'supervised' | 'manual'

// Set mode
worker.setMode('supervised')

// Mode affects behavior
if (mode === 'autonomous') {
  // Agent can auto-approve
} else {
  // Requires human approval
}
```

## Core Operations

### Execute Work

Execute a task with full lifecycle tracking:

```typescript
const result = await worker.executeWork(task, context)
// result: {
//   success: boolean,
//   output?: unknown,
//   error?: string,
//   duration?: number
// }
```

Events emitted:
- `task.completed` - When task succeeds
- `task.failed` - When task fails

### Ask Questions

Get answers to questions:

```typescript
const answer = await worker.ask('What is the refund policy?', context)
// answer: {
//   text: string,
//   confidence?: number,
//   sources?: string[]
// }
```

Events emitted:
- `question.asked`
- `question.answered`

### Make Decisions

Choose between options:

```typescript
const decision = await worker.decide(
  'Should we escalate this ticket?',
  [
    { id: 'escalate', label: 'Escalate to manager' },
    { id: 'resolve', label: 'Resolve directly' },
    { id: 'defer', label: 'Defer for later' },
  ],
  context
)
// decision: {
//   selectedOption: Option,
//   reasoning?: string,
//   confidence?: number
// }
```

Events emitted:
- `decision.requested`
- `decision.made`

### Request Approval

Request approval for an action:

```typescript
const result = await worker.approve({
  id: 'approval-123',
  type: 'refund',
  description: 'Approve $500 refund for customer',
  requester: 'support-agent',
  data: { amount: 500, customerId: 'cust-123' },
  deadline: new Date('2024-01-15'),
})
// result: {
//   approved: boolean,
//   approver: string,
//   reason?: string,
//   approvedAt?: Date
// }
```

Events emitted:
- `approval.requested`
- `approval.processed`

### Generate Output

Generate structured output:

```typescript
interface ProductSummary {
  title: string
  features: string[]
  pricing: { monthly: number; annual: number }
}

const summary = await worker.generate<ProductSummary>(
  'Summarize this product',
  productSummarySchema
)
```

Events emitted:
- `generation.requested`
- `generation.completed`

### Send Notifications

Notify via channels:

```typescript
await worker.notify('Order shipped!', [
  { type: 'email', target: 'customer@example.com' },
  { type: 'slack', target: '#orders' },
  { type: 'sms', target: '+1234567890' },
])
```

Events emitted:
- `notification.sent`

## Extending Worker

To create a custom worker, extend the class and implement the abstract methods:

```typescript
class CustomWorker extends Worker {
  static override readonly $type = 'CustomWorker'

  // Required: How to execute tasks
  protected async executeTask(task: Task, context?: Context): Promise<unknown> {
    switch (task.type) {
      case 'email':
        return this.sendEmail(task.input)
      case 'report':
        return this.generateReport(task.input)
      default:
        throw new Error(`Unknown task type: ${task.type}`)
    }
  }

  // Required: How to answer questions
  protected async generateAnswer(question: string, context?: Context): Promise<Answer> {
    const knowledge = await this.search.query(question)
    return {
      text: knowledge[0]?.content || 'I don\'t know',
      sources: knowledge.map(k => k.id),
    }
  }

  // Required: How to make decisions
  protected async makeDecision(
    question: string,
    options: Option[],
    context?: Context
  ): Promise<Decision> {
    // Use AI or rules to decide
    const best = options[0]!
    return {
      selectedOption: best,
      reasoning: 'Selected first option',
    }
  }

  // Required: How to process approvals
  protected async processApproval(request: ApprovalRequest): Promise<ApprovalResult> {
    if (this.mode === 'autonomous') {
      return { approved: true, approver: this.ctx.id.toString() }
    }
    // Queue for human review
    return { approved: false, approver: '', reason: 'Pending review' }
  }

  // Required: How to generate structured output
  protected async generateOutput<T>(prompt: string, schema?: unknown): Promise<T> {
    // Use AI to generate
    throw new Error('Not implemented')
  }

  // Optional: Custom channel handling
  protected async sendToChannel(message: string, channel: Channel): Promise<void> {
    switch (channel.type) {
      case 'email':
        await this.emailService.send(channel.target, message)
        break
      case 'slack':
        await this.slackService.post(channel.target, message)
        break
    }
  }
}
```

## Types

### Task

```typescript
interface Task {
  id: string
  type: string
  description: string
  input: Record<string, unknown>
  priority?: number
  deadline?: Date
}
```

### TaskResult

```typescript
interface TaskResult {
  success: boolean
  output?: unknown
  error?: string
  duration?: number
}
```

### Context

```typescript
interface Context {
  conversationId?: string
  userId?: string
  metadata?: Record<string, unknown>
}
```

### Answer

```typescript
interface Answer {
  text: string
  confidence?: number
  sources?: string[]
}
```

### Option

```typescript
interface Option {
  id: string
  label: string
  description?: string
}
```

### Decision

```typescript
interface Decision {
  selectedOption: Option
  reasoning?: string
  confidence?: number
}
```

### ApprovalRequest

```typescript
interface ApprovalRequest {
  id: string
  type: string
  description: string
  requester: string
  data: Record<string, unknown>
  deadline?: Date
}
```

### ApprovalResult

```typescript
interface ApprovalResult {
  approved: boolean
  approver: string
  reason?: string
  approvedAt?: Date
}
```

### Channel

```typescript
interface Channel {
  type: 'email' | 'slack' | 'sms' | 'webhook'
  target: string
}
```

### WorkerMode

```typescript
type WorkerMode = 'autonomous' | 'supervised' | 'manual'
```

## API Reference

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `mode` | `WorkerMode` | Current operating mode |

### Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `executeWork(task, context?)` | `Promise<TaskResult>` | Execute a task |
| `ask(question, context?)` | `Promise<Answer>` | Ask a question |
| `decide(question, options, context?)` | `Promise<Decision>` | Make a decision |
| `approve(request)` | `Promise<ApprovalResult>` | Request approval |
| `generate<T>(prompt, schema?)` | `Promise<T>` | Generate output |
| `notify(message, channels)` | `Promise<void>` | Send notifications |
| `getMode()` | `WorkerMode` | Get current mode |
| `setMode(mode)` | `void` | Set operating mode |

## Subclasses

- [Agent](/docs/objects/agent) - AI-powered autonomous worker with tools and memory
- [Human](/docs/objects/human) - Human worker with notification channels and escalation

## See Also

- [Agent](/docs/objects/agent) - AI agent implementation
- [Human](/docs/objects/human) - Human worker implementation
- [Startup](/docs/objects/startup) - Binding workers to businesses
