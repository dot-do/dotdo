---
title: Startup
description: Complete guide to the Startup class hierarchy, lifecycle hooks, and building startup-focused applications with OKR tracking.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Startup Class

The `Startup` class represents a SaaS application with startup-specific metrics and OKR tracking. It provides pre-configured objectives for runway, burn rate, growth, and product-market fit, built on top of the full SaaS business infrastructure.

## Class Hierarchy

The Startup class sits at the top of a rich inheritance chain, each layer adding domain-specific functionality:

```
DOTiny (~15KB)
   |  - Identity (ns, $type)
   |  - Drizzle SQLite database
   |  - HTTP fetch handling
   |  - User context extraction
   v
DOBase (~80KB)
   |  - WorkflowContext ($)
   |  - Event handlers ($.on.*)
   |  - Scheduling ($.every.*)
   |  - Graph stores (things, rels, actions, events)
   |  - OKR framework
   v
DOFull (~120KB)
   |  - Lifecycle operations (fork, clone, compact)
   |  - Branching (branch, checkout, merge)
   |  - Sharding and promotion
   v
Business
   |  - Multi-tenant organization
   |  - Revenue, Costs, Profit OKRs
   |  - Apps and members management
   v
DigitalBusiness
   |  - Traffic, Conversion, Engagement OKRs
   |  - HTTP endpoints for OKR access
   v
SaaS
   |  - MRR, Churn, NRR, CAC, LTV OKRs
   |  - Subscription billing
   |  - Usage tracking
   |  - Plan management
   v
Startup
     - Runway, Burn, GrowthRate, PMFScore OKRs
     - Startup-specific metrics
```

## Lifecycle Hooks and Methods

### Construction Phase

When a Durable Object is instantiated, it follows this sequence:

```typescript
class MyStartup extends Startup {
  // 1. Static $type for type discrimination
  static override readonly $type = 'MyStartup'

  constructor(ctx: DurableObjectState, env: Env) {
    // 2. Parent constructor chain initializes:
    //    - Drizzle SQLite database (DOTiny)
    //    - WorkflowContext ($) (DOBase)
    //    - OKR framework (DOBase)
    //    - SaaS subscription system (SaaS)
    super(ctx, env)

    // 3. Custom initialization that doesn't require async
    // Note: For async setup, use onStart() instead
  }
}
```

### Lifecycle Sequence

```
                    Startup Lifecycle
                    =================

    +------------------+     +------------------+
    |   Construction   |---->| First Request    |
    | (synchronous)    |     | (identity set)   |
    +------------------+     +------------------+
            |                        |
            v                        v
    +------------------+     +------------------+
    | ctx.blockCon-    |     | deriveIdentity   |
    | currencyWhile()  |     | FromRequest()    |
    +------------------+     +------------------+
            |                        |
            v                        v
    +------------------+     +------------------+
    | Feature Init     |     | handleFetch()    |
    | (if DO.with())   |     | (request loop)   |
    +------------------+     +------------------+
                                     |
                                     v
                             +------------------+
                             | onStart()        |
                             | (custom setup)   |
                             +------------------+
                                     |
            +------------------------+------------------------+
            |                        |                        |
            v                        v                        v
    +------------------+     +------------------+     +------------------+
    | Event Handlers   |     | Scheduled Tasks  |     | HTTP Endpoints   |
    | ($.on.*)         |     | ($.every.*)      |     | (fetch)          |
    +------------------+     +------------------+     +------------------+
                                     |
                                     v
                             +------------------+
                             | Alarm            |
                             | (scheduled fire) |
                             +------------------+
                                     |
                                     v
                             +------------------+
                             | Hibernation/     |
                             | Eviction         |
                             +------------------+
```

### Key Lifecycle Methods

#### `initialize(config)`

Explicitly set the DO's identity and parent relationship:

```typescript
await this.initialize({
  ns: 'https://mystartup.do',
  parent: 'https://incubator.do'
})
```

<Callout type="info">
If you don't call `initialize()` explicitly, the namespace is derived from the first request's hostname subdomain.
</Callout>

#### `onStart()` (Override Pattern)

The `onStart()` method is the recommended place for async initialization:

```typescript
class MyStartup extends Startup {
  async onStart() {
    // Register event handlers
    this.$.on.Customer.signup(async (event) => {
      await this.updateGrowthMetrics()
    })

    // Set up scheduled tasks
    this.$.every.month(async () => {
      await this.calculatePMFScore()
    })

    // Initialize configuration
    await this.configureSaaS({
      plans: [
        { id: 'starter', name: 'Starter', price: 29, interval: 'monthly', features: ['core'], limits: { users: 5 } },
        { id: 'growth', name: 'Growth', price: 99, interval: 'monthly', features: ['core', 'analytics'], limits: { users: 25 } },
      ],
      trialDays: 14,
      features: ['core', 'analytics', 'api']
    })
  }
}
```

#### `fetch(request)`

Handle incoming HTTP requests. Call `super.fetch()` to use built-in endpoints:

```typescript
async fetch(request: Request): Promise<Response> {
  const url = new URL(request.url)

  // Custom startup endpoints
  if (url.pathname === '/metrics') {
    return Response.json({
      runway: this.okrs.Runway.progress(),
      pmf: this.okrs.PMFScore.progress(),
      growth: this.okrs.GrowthRate.progress()
    })
  }

  // Delegate to SaaS, DigitalBusiness, Business, DOFull handlers
  return super.fetch(request)
}
```

#### `alarm()`

Handle scheduled alarm callbacks:

```typescript
async alarm(): Promise<void> {
  // Process scheduled tasks
  await this.runDailyMetrics()
}
```

### `blockConcurrencyWhile()`

For critical initialization that must complete before any request processing:

```typescript
class EagerStartup extends Startup.with({ things: true, events: true }) {
  // The DO.with() pattern uses blockConcurrencyWhile internally
  // to ensure stores are initialized before requests
}

// Or manually:
constructor(ctx: DurableObjectState, env: Env) {
  super(ctx, env)
  ctx.blockConcurrencyWhile(async () => {
    await this.loadCriticalConfiguration()
  })
}
```

## Startup OKRs

Startup extends SaaS with startup-specific objectives:

### Built-in OKRs

| OKR | Objective | Key Results |
|-----|-----------|-------------|
| **Runway** | Maintain healthy cash runway | MonthsRemaining (target: 18 months) |
| **Burn** | Control monthly burn rate | MonthlyBurn (target: $50,000) |
| **GrowthRate** | Achieve sustainable growth | MoMGrowth (target: 15%) |
| **PMFScore** | Achieve Product-Market Fit | Score (target: 100) |

### Inherited OKRs

From **SaaS**:
- **MRR** - Monthly Recurring Revenue
- **Churn** - Customer churn rate
- **NRR** - Net Revenue Retention
- **CAC** - Customer Acquisition Cost
- **LTV** - Customer Lifetime Value

From **DigitalBusiness**:
- **Traffic** - Website visitors
- **Conversion** - Signup rates
- **Engagement** - DAU/MAU metrics

From **Business**:
- **Revenue** - Total revenue
- **Costs** - Operating expenses
- **Profit** - Profit margins

### Using OKRs

```typescript
class MyStartup extends Startup {
  async trackMetrics() {
    // Access OKR progress
    const runwayProgress = this.okrs.Runway.progress()
    const isPMFAchieved = this.okrs.PMFScore.isComplete()

    // Update key results
    this.okrs.Runway.keyResults[0].current = 12 // 12 months remaining
    this.okrs.GrowthRate.keyResults[0].current = 18 // 18% MoM growth
  }

  // Extend with custom OKRs
  override okrs = {
    ...super.okrs,
    TeamGrowth: this.defineOKR({
      objective: 'Build world-class team',
      keyResults: [
        { name: 'EngineersHired', target: 10, current: 0 },
        { name: 'RetentionRate', target: 95, current: 100, unit: '%' }
      ]
    })
  }
}
```

## Relationship to Other Classes

### vs DO / DOTiny / DOFull

| Class | Purpose | When to Use |
|-------|---------|-------------|
| `DOTiny` | Minimal storage | Simple counters, flags, minimal state |
| `DOBase` | WorkflowContext | Event-driven services without lifecycle ops |
| `DOFull` | Lifecycle operations | Services needing clone, branch, shard |
| `Startup` | Business metrics | SaaS products with startup KPIs |

### vs Business

`Business` is a generic multi-tenant organization container. `Startup` adds:
- SaaS subscription infrastructure
- Usage metering
- Startup-specific OKRs (runway, burn, PMF)

```typescript
// Business: Generic organization
class AcmeCorp extends Business {
  // Revenue, Costs, Profit OKRs
}

// Startup: SaaS with startup metrics
class AcmeSaaS extends Startup {
  // All Business OKRs + SaaS + Startup OKRs
  // + Subscription billing, usage tracking
}
```

### vs App / Site

`App` and `Site` are lightweight containers within a Business:

```
Business (or Startup)
   |
   +-- App (application container)
   |     |
   |     +-- Site (deployed domain)
   |     +-- Site (another domain)
   |
   +-- App (another application)
```

```typescript
// Create apps within a startup
class MyStartup extends Startup {
  async setupProducts() {
    await this.createApp('dashboard', 'Dashboard App')
    await this.createApp('api', 'Public API')
  }
}
```

### vs Entity / Collection

`Entity` and `Collection` are for domain modeling within any DO:

```typescript
class MyStartup extends Startup {
  async onStart() {
    // Use things store for entities (built into Startup)
    await this.things.create({
      $type: 'Customer',
      name: 'Acme Corp',
      plan: 'growth'
    })
  }
}

// For dedicated entity DOs, extend Entity
class CustomerEntity extends Entity {
  static override readonly $type = 'Customer'
}
```

## Configuration Options

### SaaS Configuration

Startup inherits all SaaS configuration:

```typescript
interface SaaSConfig {
  plans: SaaSPlan[]
  trialDays?: number
  features: string[]
  usageMetrics?: string[]
}

interface SaaSPlan {
  id: string
  name: string
  price: number
  interval: 'monthly' | 'yearly'
  features: string[]
  limits: Record<string, number>
}
```

### Feature Configuration with `DO.with()`

Eagerly initialize specific stores:

```typescript
class MyStartup extends Startup.with({
  things: true,      // Initialize things store
  relationships: true, // Initialize relationships
  events: true,      // Initialize events store
  search: true,      // Initialize search with FTS
  vectors: true      // Initialize vector embeddings
}) {
  // Stores are ready before any request
}
```

## HTTP Endpoints

Startup inherits endpoints from all parent classes:

### From Startup/SaaS

| Method | Path | Description |
|--------|------|-------------|
| GET | `/saas/config` | Get SaaS configuration |
| PUT | `/saas/config` | Set SaaS configuration |
| GET | `/saas/plans` | List subscription plans |
| POST | `/saas/subscribe` | Create subscription |
| POST | `/saas/usage` | Record usage |
| GET | `/saas/subscription/:id` | Get subscription details |

### From DigitalBusiness

| Method | Path | Description |
|--------|------|-------------|
| GET | `/okrs` | Get all OKRs with progress |
| GET | `/okrs/:name` | Get specific OKR |

### From Business

| Method | Path | Description |
|--------|------|-------------|
| GET/PUT | `/config` | Business configuration |
| GET | `/apps` | List apps |
| GET | `/members` | List members |

### From DOBase/DOFull

| Method | Path | Description |
|--------|------|-------------|
| GET | `/health` | Health check |
| GET | `/resolve` | Cross-DO resolution |
| Various | `/sync/*` | Sync protocol |

## Complete Example

```typescript
import { Startup } from 'dotdo'

class TechStartup extends Startup {
  static override readonly $type = 'TechStartup'

  // Extend OKRs with custom metrics
  override okrs = {
    ...super.okrs,
    Engineering: this.defineOKR({
      objective: 'Ship quality software fast',
      keyResults: [
        { name: 'DeployFrequency', target: 10, current: 0, unit: 'deploys/week' },
        { name: 'LeadTime', target: 24, current: 72, unit: 'hours' },
        { name: 'MTTR', target: 1, current: 4, unit: 'hours' }
      ]
    })
  }

  async onStart() {
    // Configure SaaS plans
    await this.configureSaaS({
      plans: [
        {
          id: 'free',
          name: 'Free',
          price: 0,
          interval: 'monthly',
          features: ['basic'],
          limits: { requests: 1000 }
        },
        {
          id: 'pro',
          name: 'Pro',
          price: 49,
          interval: 'monthly',
          features: ['basic', 'analytics', 'api'],
          limits: { requests: 100000 }
        },
        {
          id: 'enterprise',
          name: 'Enterprise',
          price: 499,
          interval: 'monthly',
          features: ['basic', 'analytics', 'api', 'sso', 'support'],
          limits: { requests: Infinity }
        }
      ],
      trialDays: 14,
      features: ['basic', 'analytics', 'api', 'sso', 'support']
    })

    // Track customer signups
    this.$.on.Customer.signup(async (event) => {
      await this.recordUsage(event.data.subscriptionId, 'signups', 1)
      await this.updateGrowthRate()
    })

    // Monthly PMF survey
    this.$.every.month(async () => {
      await this.sendPMFSurvey()
      await this.calculatePMFScore()
    })

    // Weekly runway update
    this.$.every.Monday.at9am(async () => {
      await this.updateRunwayMetrics()
    })
  }

  async updateRunwayMetrics() {
    const bankBalance = await this.getBankBalance()
    const monthlyBurn = await this.calculateMonthlyBurn()
    const runwayMonths = bankBalance / monthlyBurn

    this.okrs.Runway.keyResults[0].current = runwayMonths
    this.okrs.Burn.keyResults[0].current = monthlyBurn
  }

  async calculatePMFScore() {
    // Sean Ellis test: % who would be "very disappointed"
    const survey = await this.getSurveyResults()
    const veryDisappointed = survey.responses.filter(r => r.answer === 'very_disappointed').length
    const score = (veryDisappointed / survey.responses.length) * 100

    this.okrs.PMFScore.keyResults[0].current = score
  }

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)

    if (url.pathname === '/dashboard') {
      return Response.json({
        okrs: this.getAllOKRs(),
        subscriptions: await this.getActiveSubscriptionCount(),
        mrr: await this.calculateMRR()
      })
    }

    return super.fetch(request)
  }
}

export default TechStartup
```

## See Also

- [DO (Base Class)](/docs/objects/do) - Core Durable Object features
- [Lifecycle](/docs/objects/lifecycle) - Complete lifecycle guide
- [Entity](/docs/objects/entity) - Domain object modeling
- [Worker](/docs/objects/worker) - Building workers
