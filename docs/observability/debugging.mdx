---
title: Debugging
description: Remote debugging, log analysis, error tracking, and time-travel debugging for distributed systems
---

# Debugging

Debugging a single-process application is hard. Debugging 10,000 AI agents across 300+ edge locations is a different challenge entirely. dotdo provides tools designed for distributed debugging at scale.

## Remote Debugging

Inspect and debug running Durable Objects without deploying new code.

### Live Inspection

```typescript
// Connect to a running DO
const debug = await $.debug.connect('order-processor-001')

// Inspect current state
const state = await debug.getState()
// { orderId: 'ord_123', status: 'processing', items: [...] }

// Watch state changes in real-time
debug.watchState((newState, oldState) => {
  console.log('State changed:', diff(oldState, newState))
})

// Inspect pending alarms
const alarms = await debug.getAlarms()
// [{ scheduledFor: '2024-01-15T15:00:00Z', handler: 'processPayment' }]
```

### Remote REPL

Execute code in a running DO context:

```typescript
// Evaluate expressions
const result = await debug.eval('this.orders.length')
// 42

// Call methods
const order = await debug.eval('this.getOrder("ord_123")')
// { id: 'ord_123', ... }

// Inspect the $ context
const context = await debug.eval('$.requestId')
// 'req_abc123'
```

### Breakpoints

Set conditional breakpoints that log without stopping:

```typescript
// Log when condition is met
await debug.setBreakpoint({
  location: 'processOrder',
  condition: 'order.total > 10000',
  action: 'log',
  data: ['order', 'customer']
})

// Pause execution (use carefully in production)
await debug.setBreakpoint({
  location: 'processPayment',
  condition: 'payment.status === "declined"',
  action: 'pause',
  timeout: '5m'  // Auto-resume after 5 minutes
})
```

### Snapshot State

Capture complete state for offline analysis:

```typescript
// Capture snapshot
const snapshot = await debug.snapshot()
// {
//   state: { ... },
//   alarms: [...],
//   storage: { keys: 142, sizeBytes: 48291 },
//   metadata: { colo: 'SFO', createdAt: '...' }
// }

// Save for later analysis
await $.storage.put(`snapshots/${doId}/${Date.now()}`, snapshot)
```

## Log Analysis

Query and analyze logs across all DOs and requests.

### Structured Queries

```typescript
// Find all errors for a specific order
const logs = await $.logs.search({
  level: 'error',
  orderId: 'ord_123',
  timeRange: { last: '24h' }
})

// Find slow operations
const slowLogs = await $.logs.search({
  'context.duration': { gte: 5000 },
  timeRange: { last: '1h' },
  limit: 100
})

// Full-text search
const matches = await $.logs.search({
  message: { contains: 'timeout' },
  level: { in: ['error', 'warn'] },
  timeRange: { last: '6h' }
})
```

### Log Aggregation

```typescript
// Count errors by type
const errorCounts = await $.logs.aggregate({
  groupBy: 'error.code',
  count: true,
  where: { level: 'error' },
  timeRange: { last: '1h' },
  orderBy: { count: 'desc' },
  limit: 10
})

// Error rate by DO
const errorRates = await $.logs.aggregate({
  groupBy: 'context.doId',
  metrics: {
    total: { count: '*' },
    errors: { count: { where: { level: 'error' } } },
    errorRate: { expression: 'errors / total' }
  },
  timeRange: { last: '1h' }
})
```

### Log Correlation

Correlate logs across requests and DOs:

```typescript
// Get all logs for a trace
const traceLogs = await $.logs.search({
  'context.traceId': 'tr_abc123'
})
// Returns logs from all DOs involved in the request

// Get all logs for a user session
const sessionLogs = await $.logs.search({
  'context.sessionId': 'sess_xyz789',
  timeRange: { last: '2h' }
})
```

### Live Tail

Stream logs in real-time:

```typescript
// Stream all error logs
const stream = $.logs.tail({
  level: 'error'
})

for await (const log of stream) {
  console.log(`[${log.context.doId}] ${log.message}`)
}

// Stream logs for a specific DO
const doStream = $.logs.tail({
  'context.doId': 'order-processor-001'
})
```

Command-line log tailing:

```bash
# Tail all logs
npx dotdo logs --follow

# Filter by level
npx dotdo logs --follow --level error

# Filter by DO
npx dotdo logs --follow --do order-processor-001

# Filter by customer
npx dotdo logs --follow --filter 'customerId:cus_123'

# Complex filters
npx dotdo logs --follow --filter 'level:error AND agent:ralph'
```

## Error Tracking

Track, group, and analyze errors across your application.

### Automatic Error Capture

All unhandled errors are automatically captured:

```typescript
export class OrderProcessor extends DO {
  async processOrder(orderId: string) {
    const order = await this.getOrder(orderId)
    if (!order) {
      throw new Error(`Order not found: ${orderId}`)
      // Automatically captured with:
      // - Stack trace
      // - Request context (doId, requestId, agent)
      // - DO state snapshot
      // - Recent log entries
    }
  }
}
```

### Error Grouping

Errors are grouped by root cause:

```typescript
const errorGroups = await $.errors.groups({
  timeRange: { last: '24h' },
  status: 'unresolved'
})

// [
//   {
//     id: 'err_group_1',
//     title: 'PaymentError: Card declined',
//     count: 47,
//     firstSeen: '2024-01-14T10:00:00Z',
//     lastSeen: '2024-01-15T14:32:00Z',
//     affectedUsers: 23,
//     samples: [...]
//   },
//   ...
// ]
```

### Error Details

```typescript
const error = await $.errors.get('err_abc123')

// {
//   id: 'err_abc123',
//   type: 'PaymentError',
//   message: 'Card declined',
//   stack: 'PaymentError: Card declined\n    at processPayment...',
//   context: {
//     doId: 'order-processor-001',
//     requestId: 'req_xyz789',
//     traceId: 'tr_123456',
//     userId: 'usr_abc',
//     agent: null
//   },
//   state: {
//     orderId: 'ord_123',
//     paymentMethod: 'stripe',
//     amount: 9900
//   },
//   recentLogs: [...],
//   breadcrumbs: [
//     { type: 'http', url: '/api/orders/ord_123/pay' },
//     { type: 'function', name: 'validatePayment' },
//     { type: 'function', name: 'chargeCard' }
//   ]
// }
```

### Error Resolution

```typescript
// Mark as resolved
await $.errors.resolve('err_group_1', {
  resolvedBy: 'alice@example.com',
  resolution: 'fixed',
  commit: 'abc123',
  comment: 'Added retry logic for transient failures'
})

// Mark as ignored
await $.errors.ignore('err_group_2', {
  reason: 'expected_behavior',
  comment: 'This is a known edge case we handle gracefully'
})

// Reopen if it occurs again
// Happens automatically when a resolved error recurs
```

### Error Alerts

```typescript
export class MyStartup extends Startup {
  observability = {
    errors: {
      alerts: [
        {
          condition: { newErrors: { threshold: 10, window: '5m' } },
          severity: 'warning',
          notify: ['slack:#errors']
        },
        {
          condition: { errorRate: { threshold: 0.05, window: '5m' } },
          severity: 'critical',
          notify: ['pagerduty:oncall']
        },
        {
          match: { type: 'PaymentError' },
          severity: 'critical',
          notify: ['pagerduty:payments-team']
        }
      ]
    }
  }
}
```

## Time-Travel Debugging

Replay past requests to understand what happened.

### Request Replay

```typescript
// Replay a specific request
const replay = await $.debug.replay({
  requestId: 'req_abc123'
})

// {
//   originalResult: { status: 500, body: { error: 'Internal error' } },
//   steps: [
//     {
//       type: 'function_call',
//       name: 'getOrder',
//       args: ['ord_123'],
//       result: { id: 'ord_123', ... },
//       duration: 12
//     },
//     {
//       type: 'function_call',
//       name: 'validatePayment',
//       args: [{ orderId: 'ord_123', ... }],
//       result: null,
//       error: 'Card declined',
//       duration: 2340
//     },
//     ...
//   ],
//   stateChanges: [
//     { path: 'order.status', from: 'pending', to: 'payment_failed' }
//   ]
// }
```

### State History

View how state changed over time:

```typescript
// Get state history for a DO
const history = await $.debug.stateHistory({
  doId: 'order-processor-001',
  timeRange: { last: '1h' }
})

// [
//   {
//     timestamp: '2024-01-15T14:00:00Z',
//     requestId: 'req_001',
//     changes: [{ path: 'orders[0].status', from: 'created', to: 'processing' }]
//   },
//   {
//     timestamp: '2024-01-15T14:05:00Z',
//     requestId: 'req_002',
//     changes: [{ path: 'orders[0].status', from: 'processing', to: 'completed' }]
//   },
//   ...
// ]
```

### Point-in-Time State

```typescript
// Get state at a specific time
const pastState = await $.debug.stateAt({
  doId: 'order-processor-001',
  timestamp: '2024-01-15T14:00:00Z'
})

// Compare with current state
const currentState = await $.debug.getState('order-processor-001')
const diff = $.debug.diff(pastState, currentState)
```

### Agent Replay

Replay AI agent interactions:

```typescript
const agentReplay = await $.debug.replayAgent({
  traceId: 'tr_abc123',
  agent: 'priya'
})

// {
//   prompt: 'define the MVP for...',
//   model: 'claude-3-opus',
//   messages: [
//     { role: 'user', content: '...' },
//     { role: 'assistant', content: '...' }
//   ],
//   tokens: { input: 1247, output: 3891 },
//   duration: 4200,
//   result: '...'
// }
```

## Diagnostic Tools

### Health Checks

```typescript
// Check DO health
const health = await $.debug.health('order-processor-001')

// {
//   status: 'healthy',
//   storage: { used: 48291, limit: 1073741824 },
//   alarms: { pending: 2, overdue: 0 },
//   lastActivity: '2024-01-15T14:32:00Z',
//   errors: { last24h: 0 }
// }

// Check all DOs matching a pattern
const fleetHealth = await $.debug.healthCheck({
  pattern: 'order-processor-*',
  parallel: 100
})
```

### Network Debugging

```typescript
// Trace network calls
const networkTrace = await $.debug.traceNetwork({
  requestId: 'req_abc123'
})

// [
//   {
//     type: 'do_call',
//     from: 'order-processor-001',
//     to: 'customer-001',
//     method: 'getCustomer',
//     duration: 12,
//     colo: { from: 'SFO', to: 'SFO' }
//   },
//   {
//     type: 'http',
//     url: 'https://api.stripe.com/v1/charges',
//     method: 'POST',
//     status: 200,
//     duration: 892
//   }
// ]
```

### Memory Analysis

```typescript
// Analyze DO memory usage
const memory = await $.debug.analyzeMemory('order-processor-001')

// {
//   total: 2457600,
//   breakdown: {
//     orders: { count: 150, bytes: 1200000 },
//     cache: { count: 500, bytes: 800000 },
//     other: { bytes: 457600 }
//   },
//   suggestions: [
//     'Consider archiving orders older than 30 days',
//     'Cache entries have no TTL - consider adding expiration'
//   ]
// }
```

## Debugging Workflows

### Debugging Agent Failures

```typescript
// 1. Find failed agent calls
const failures = await $.trace.search({
  'agent.status': 'error',
  timeRange: { last: '1h' }
})

// 2. Get details for a failure
const trace = await $.trace.get(failures[0].traceId)
const agentSpan = trace.spans.find(s => s.name.startsWith('agent:'))

// 3. Replay the agent call
const replay = await $.debug.replayAgent({
  traceId: trace.id,
  agent: agentSpan.attributes['agent.name']
})

// 4. Compare with a working call
const workingCall = await $.trace.search({
  'agent.name': agentSpan.attributes['agent.name'],
  'agent.status': 'success',
  limit: 1
})
```

### Debugging Slow Requests

```typescript
// 1. Find slow requests
const slowTraces = await $.trace.search({
  minDuration: '10s',
  timeRange: { last: '1h' }
})

// 2. Analyze a slow trace
const analysis = await $.debug.analyzeLatency(slowTraces[0].traceId)

// {
//   totalDuration: 12400,
//   criticalPath: [
//     { span: 'external:anthropic', duration: 8900, percentage: 72 },
//     { span: 'agent:ralph', duration: 9100, percentage: 73 },
//     { span: 'root', duration: 12400, percentage: 100 }
//   ],
//   bottleneck: 'external:anthropic',
//   recommendation: 'Consider caching or reducing prompt size'
// }
```

### Debugging State Issues

```typescript
// 1. Capture current state
const current = await $.debug.snapshot('order-processor-001')

// 2. Check state history
const history = await $.debug.stateHistory({
  doId: 'order-processor-001',
  timeRange: { last: '24h' }
})

// 3. Find unexpected changes
const suspicious = history.filter(h =>
  h.changes.some(c => c.path.includes('status') && c.to === 'cancelled')
)

// 4. Get the request that caused the change
const request = await $.debug.replay({
  requestId: suspicious[0].requestId
})
```

## CLI Debugging Commands

```bash
# Connect to a DO
npx dotdo debug order-processor-001

# Inspect state
npx dotdo debug order-processor-001 --state

# Tail logs for a DO
npx dotdo logs --follow --do order-processor-001

# View a trace
npx dotdo trace tr_abc123

# Replay a request
npx dotdo replay req_abc123

# Analyze an error
npx dotdo error err_abc123

# Health check
npx dotdo health order-processor-*
```

## Configuration

```typescript
export class MyStartup extends Startup {
  observability = {
    debugging: {
      // Enable state history (increases storage usage)
      stateHistory: {
        enabled: true,
        retention: '7d',
        excludePaths: ['cache', 'temp']
      },

      // Enable request replay
      requestReplay: {
        enabled: true,
        sampleRate: 0.1,  // Record 10% of requests for replay
        retention: '24h'
      },

      // Remote debugging access
      remoteAccess: {
        enabled: true,
        allowedIps: ['10.0.0.0/8'],
        requireAuth: true
      }
    }
  }
}
```

## Best Practices

### Add Breadcrumbs

```typescript
// Leave a trail for debugging
$.debug.breadcrumb('validation', { orderId, result: 'passed' })
$.debug.breadcrumb('payment_initiated', { provider: 'stripe' })
$.debug.breadcrumb('webhook_sent', { url: webhookUrl })

// Breadcrumbs are included in error reports
```

### Use Debug IDs

```typescript
// Add debug IDs to business objects
const order = {
  id: orderId,
  debugId: $.debug.generateId(),  // Unique per operation
  // ...
}

// Now you can search: $.logs.search({ debugId: order.debugId })
```

### Structured Error Context

```typescript
try {
  await processPayment(order)
} catch (error) {
  // Add context before re-throwing
  throw $.debug.enrichError(error, {
    orderId: order.id,
    customerId: order.customerId,
    paymentMethod: order.paymentMethod,
    attempt: retryCount
  })
}
```

## Related

- [Logging](/docs/observability/logging) - Structured logging for analysis
- [Tracing](/docs/observability/tracing) - Distributed traces across DOs
- [Alerts](/docs/observability/alerts) - Get notified about issues
- [Dashboards](/docs/observability/dashboards) - Visualize system health
