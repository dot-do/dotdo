---
title: Distributed Tracing
description: Trace requests across Durable Objects, AI agents, and external services with OpenTelemetry-compatible spans
---

# Distributed Tracing

A single user action can touch dozens of DOs across multiple datacenters. Tracing shows you the full picture: every hop, every delay, every failure.

## How It Works

When a request enters your system, dotdo creates a trace. Every subsequent operation becomes a span within that trace.

```typescript
// Request comes in
// Trace: tr_abc123 starts

const span = $.trace.span('process-order')
// Span: process-order (parent: root)

await this.validatePayment()
// Span: validate-payment (parent: process-order)

await priya`review the order`
// Span: agent:priya (parent: process-order)
// Propagates trace context to agent execution

span.end()
// process-order ends, duration recorded
```

The trace context automatically propagates:
- Across DO boundaries
- Into agent calls
- Through HTTP requests
- To external services (if they support W3C Trace Context)

## Creating Spans

### Basic Spans

```typescript
const span = $.trace.span('operation-name')
try {
  // Do work
  span.end()
} catch (error) {
  span.recordException(error)
  span.setStatus('error')
  span.end()
  throw error
}
```

### Span Attributes

```typescript
const span = $.trace.span('process-payment')
span.setAttribute('payment.method', 'stripe')
span.setAttribute('payment.amount', 9900)
span.setAttribute('payment.currency', 'usd')
span.setAttribute('customer.id', customerId)
// ... work ...
span.end()
```

### Span Events

Record events within a span:

```typescript
const span = $.trace.span('checkout-flow')

span.addEvent('cart_validated', { items: cart.length })
await this.validateCart(cart)

span.addEvent('payment_initiated', { method: 'stripe' })
await this.processPayment()

span.addEvent('order_created', { orderId })
await this.createOrder()

span.end()
```

### Helper: traced()

Wrap functions for automatic tracing:

```typescript
const processPayment = $.trace.traced('process-payment', async (orderId: string) => {
  // Automatically creates span, handles errors, records duration
  return await stripe.charges.create(...)
})

await processPayment('ord_123')
```

## Agent Tracing

Agent calls automatically create spans:

```typescript
const spec = await priya`define the MVP for ${hypothesis}`
```

This creates a span with:

| Attribute | Value |
|-----------|-------|
| `span.name` | `agent:priya` |
| `agent.name` | `priya` |
| `agent.prompt` | `define the MVP for...` |
| `agent.model` | `claude-3-opus` |
| `agent.tokens.input` | `1247` |
| `agent.tokens.output` | `3891` |
| `agent.duration` | `4.2s` |

### Agent Chains

When agents call other agents, the trace shows the full chain:

```typescript
const spec = await priya`define the MVP`
const code = await ralph`build ${spec}`
const review = await tom`review ${code}`
```

Trace structure:
```
trace: tr_abc123
└── root (your handler)
    ├── agent:priya (2.3s)
    ├── agent:ralph (8.1s)
    │   └── external:anthropic (7.9s)
    └── agent:tom (1.2s)
```

### Parallel Agents

Parallel agent calls show as siblings:

```typescript
const [spec, marketing] = await Promise.all([
  priya`define the MVP`,
  mark`draft the announcement`
])
```

Trace structure:
```
trace: tr_abc123
└── root
    ├── agent:priya (2.3s)
    └── agent:mark (1.8s)   // Parallel, same parent
```

## Cross-DO Tracing

Traces propagate across Durable Object boundaries:

```typescript
// In OrderProcessor DO
const span = $.trace.span('process-order')
await $.Customer(customerId).notify()  // Trace context passed
span.end()

// In Customer DO
// Automatically receives trace context
// Spans appear as children of 'process-order'
```

### RPC Context Propagation

The `$` context handles propagation automatically:

```typescript
// All of these propagate trace context
await $.Customer(id).notify()
await $.Payment(id).charge(amount)
await $.Inventory(id).reserve(items)
```

## HTTP Context Propagation

### Outgoing Requests

Trace context is added to outgoing HTTP requests:

```typescript
const span = $.trace.span('external-api')
const response = await fetch('https://api.stripe.com/v1/charges', {
  method: 'POST',
  headers: $.trace.propagationHeaders(),  // Adds traceparent header
  body: JSON.stringify(payload)
})
span.end()
```

Or use the traced fetch:

```typescript
const response = await $.fetch('https://api.stripe.com/v1/charges', {
  method: 'POST',
  body: JSON.stringify(payload)
})
// Automatically creates span, propagates context
```

### Incoming Requests

dotdo extracts trace context from incoming requests:

```typescript
export default {
  async fetch(request: Request, env: Env) {
    // If request has traceparent header, trace continues
    // Otherwise, new trace starts
    return await handleRequest(request)
  }
}
```

## Querying Traces

### Find Traces

```typescript
// By trace ID
const trace = await $.trace.get('tr_abc123')

// By attributes
const traces = await $.trace.search({
  'agent.name': 'priya',
  minDuration: '5s',
  status: 'error',
  timeRange: { last: '1h' }
})

// By customer
const customerTraces = await $.trace.search({
  'customer.id': 'cus_123',
  timeRange: { last: '24h' }
})
```

### Analyze Latency

```typescript
// Find slowest spans
const slowSpans = await $.trace.query({
  spanName: 'agent:ralph',
  percentile: 99,
  timeRange: { last: '1h' }
})
// { p99: 12400, count: 847, mean: 4200 }

// Find bottlenecks
const bottlenecks = await $.trace.analyze({
  traceId: 'tr_abc123',
  metric: 'duration'
})
// [
//   { span: 'external:anthropic', duration: 7900, percentage: 65 },
//   { span: 'agent:ralph', duration: 8100, percentage: 67 },
//   ...
// ]
```

## Sampling

In high-volume systems, trace every request is expensive. Configure sampling:

```typescript
export class MyStartup extends Startup {
  observability = {
    tracing: {
      sampleRate: 0.1,  // 10% of requests

      // Always trace errors
      alwaysTraceOn: ['error', 'timeout'],

      // Always trace specific operations
      alwaysTraceOperations: ['process-payment', 'agent:*']
    }
  }
}
```

### Adaptive Sampling

Adjust sampling based on load:

```typescript
export class MyStartup extends Startup {
  observability = {
    tracing: {
      sampling: {
        strategy: 'adaptive',
        targetRate: 100,  // 100 traces per minute
        minRate: 0.01,    // Never below 1%
        maxRate: 1.0      // Up to 100%
      }
    }
  }
}
```

## OpenTelemetry Export

Export traces to your observability stack:

```typescript
export class MyStartup extends Startup {
  observability = {
    tracing: {
      exporters: [
        {
          type: 'otlp',
          endpoint: 'https://otel-collector.example.com.ai:4318',
          headers: { 'Authorization': 'Bearer ...' }
        },
        {
          type: 'jaeger',
          endpoint: 'https://jaeger.example.com.ai:14268'
        }
      ]
    }
  }
}
```

Supported exporters:
- OTLP (OpenTelemetry Protocol)
- Jaeger
- Zipkin
- Cloudflare Analytics (built-in)

## Debugging with Traces

### "Why is this request slow?"

```typescript
// Get the trace
const trace = await $.trace.get('tr_abc123')

// Find the critical path
const criticalPath = trace.spans
  .sort((a, b) => b.duration - a.duration)
  .slice(0, 5)

// Output:
// 1. external:anthropic - 7.9s (78%)
// 2. agent:ralph - 8.1s (includes anthropic)
// 3. db:query - 0.8s
// 4. process-order - 10.2s (total)
```

### "Where did this request fail?"

```typescript
const trace = await $.trace.get('tr_abc123')

const failedSpan = trace.spans.find(s => s.status === 'error')
// {
//   name: 'validate-payment',
//   status: 'error',
//   exception: {
//     type: 'PaymentError',
//     message: 'Card declined',
//     stack: '...'
//   },
//   attributes: {
//     'payment.method': 'stripe',
//     'customer.id': 'cus_123'
//   }
// }
```

### "What did this agent do?"

```typescript
const agentSpans = await $.trace.search({
  spanName: { match: 'agent:*' },
  'trace.id': 'tr_abc123'
})

for (const span of agentSpans) {
  console.log(`${span.name}: ${span.duration}ms`)
  console.log(`  Tokens: ${span.attributes['agent.tokens.input']} in / ${span.attributes['agent.tokens.output']} out`)
}
```

## Performance

| Operation | Overhead |
|-----------|----------|
| Span creation | ~100 microseconds |
| Span end | ~50 microseconds |
| Context propagation | ~5 microseconds |
| Attribute set | ~10 microseconds |

Traces are buffered and exported asynchronously.

## Best Practices

### Name Spans Consistently

```typescript
// Good: verb-noun, lowercase with hyphens
$.trace.span('process-order')
$.trace.span('validate-payment')
$.trace.span('send-notification')

// Bad: inconsistent naming
$.trace.span('ProcessOrder')
$.trace.span('VALIDATE PAYMENT')
$.trace.span('notification')
```

### Add Useful Attributes

```typescript
// Good: Context for debugging
span.setAttribute('order.id', orderId)
span.setAttribute('order.total', order.total)
span.setAttribute('customer.tier', customer.tier)

// Bad: Generic or missing
span.setAttribute('id', orderId)
// No attributes at all
```

### Trace Boundaries, Not Everything

```typescript
// Good: Trace meaningful operations
$.trace.span('process-order')
$.trace.span('external:stripe')
$.trace.span('agent:priya')

// Bad: Trace every function
$.trace.span('calculateTotal')
$.trace.span('formatCurrency')
$.trace.span('validateInput')
```

## Related

- [Logging](/docs/observability/logging) - Structured logs linked to traces
- [Metrics](/docs/observability/metrics) - Aggregate latency data
- [Dashboards](/docs/observability/dashboards) - Visualize traces
