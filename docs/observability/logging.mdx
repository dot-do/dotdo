---
title: Structured Logging
description: Production-ready logging with automatic context, log levels, and searchable structured data
---

# Structured Logging

Every log entry includes the DO id, request id, agent name, and datacenter. You don't configure this. You query it.

## Basic Usage

```typescript
$.log.info('Customer signed up', { customerId, plan })
$.log.warn('Payment retry', { attempt: 3, customerId })
$.log.error('Payment failed', { error, customerId })
$.log.debug('Cache miss', { key, ttl })
```

Each call produces a structured JSON entry:

```json
{
  "level": "info",
  "message": "Customer signed up",
  "customerId": "cus_abc123",
  "plan": "pro",
  "context": {
    "doId": "startup-main-001",
    "requestId": "req_7f3a8b2c",
    "agent": null,
    "colo": "SFO",
    "timestamp": "2024-01-15T14:32:01.847123Z",
    "duration": 12.4
  }
}
```

## Log Levels

| Level | Use Case | Production Default |
|-------|----------|-------------------|
| `debug` | Development details, cache hits, internal state | Off |
| `info` | Business events, state changes, normal operations | On |
| `warn` | Degraded service, retries, fallbacks | On |
| `error` | Failures, exceptions, unrecoverable states | On |

```typescript
// Set level per-DO
export class MyStartup extends Startup {
  observability = {
    logging: {
      level: process.env.LOG_LEVEL ?? 'info'
    }
  }
}

// Or dynamically
$.log.setLevel('debug')  // Enable debug for this request
```

## Automatic Context

Every log entry includes context without you passing it:

```typescript
export class OrderProcessor extends DO {
  async handle(request: Request) {
    // Automatic: doId, requestId, colo, timestamp
    $.log.info('Request received')

    await this.processOrder()

    // duration automatically calculated from request start
    $.log.info('Request complete')
  }
}
```

### Agent Context

When code runs inside an agent call, the agent name is included:

```typescript
const spec = await priya`define the MVP`
// Inside priya's execution:
// $.log.info('Analyzing requirements')
// Produces: { ..., "context": { "agent": "priya", ... } }
```

### Nested Context

Add context that applies to all subsequent logs:

```typescript
$.log.withContext({ orderId: 'ord_123', customerId: 'cus_456' })

$.log.info('Validating payment')   // Includes orderId, customerId
$.log.info('Charging card')        // Includes orderId, customerId
$.log.info('Sending confirmation') // Includes orderId, customerId
```

Use scoped context for a specific block:

```typescript
await $.log.withContext({ step: 'payment' }, async () => {
  $.log.info('Starting')           // step: 'payment'
  await this.chargeCard()
  $.log.info('Complete')           // step: 'payment'
})

$.log.info('Continuing')           // No step field
```

## Error Logging

Errors are automatically serialized with stack traces:

```typescript
try {
  await this.riskyOperation()
} catch (error) {
  $.log.error('Operation failed', { error })
  // Produces:
  // {
  //   "level": "error",
  //   "message": "Operation failed",
  //   "error": {
  //     "name": "PaymentError",
  //     "message": "Card declined",
  //     "stack": "PaymentError: Card declined\n    at chargeCard...",
  //     "code": "card_declined"
  //   }
  // }
}
```

### Error Classification

dotdo classifies errors for alerting:

```typescript
$.log.error('Payment failed', {
  error,
  classification: 'retriable'  // retriable, permanent, unknown
})
```

| Classification | Description | Alert Behavior |
|----------------|-------------|----------------|
| `retriable` | Temporary failure, will retry | No immediate alert |
| `permanent` | Unrecoverable, needs intervention | Alert immediately |
| `unknown` | Unclear, investigate | Alert after threshold |

## Querying Logs

Search logs programmatically:

```typescript
// Find all errors for a customer
const logs = await $.logs.search({
  level: 'error',
  customerId: 'cus_123',
  timeRange: { last: '24h' }
})

// Find slow operations
const slowOps = await $.logs.search({
  'context.duration': { gte: 1000 },
  message: { contains: 'complete' }
})

// Aggregate by error type
const errorCounts = await $.logs.aggregate({
  groupBy: 'error.code',
  count: true,
  timeRange: { last: '1h' }
})
```

## Log Sampling

High-volume applications can sample debug logs:

```typescript
export class MyStartup extends Startup {
  observability = {
    logging: {
      level: 'debug',
      sampling: {
        debug: 0.01,  // 1% of debug logs
        info: 1.0,    // 100% of info logs
        warn: 1.0,    // 100% of warn logs
        error: 1.0    // 100% of error logs
      }
    }
  }
}
```

## Sensitive Data

Automatically redact sensitive fields:

```typescript
export class MyStartup extends Startup {
  observability = {
    logging: {
      redact: [
        'password',
        'creditCard',
        'ssn',
        '*.secret',     // Any nested .secret field
        'headers.authorization'
      ]
    }
  }
}

// Now safe:
$.log.info('User login', { email, password: 'hunter2' })
// Produces: { ..., "password": "[REDACTED]" }
```

## Performance

Logging is async and buffered:

```typescript
// These don't block your code
$.log.info('Step 1')  // Buffered
$.log.info('Step 2')  // Buffered
$.log.info('Step 3')  // Buffered
// Buffer flushes automatically every 100ms or 100 entries
```

Force immediate flush when needed:

```typescript
$.log.info('Critical event')
await $.log.flush()  // Wait for write confirmation
```

## Best Practices

### Log Business Events

```typescript
// Good: Business context
$.log.info('Order placed', {
  orderId,
  customerId,
  total: order.total,
  items: order.items.length
})

// Bad: Technical details only
$.log.info('Called processOrder function')
```

### Include Correlation IDs

```typescript
// Good: Link related events
$.log.info('Payment initiated', { orderId, paymentId })
$.log.info('Payment confirmed', { orderId, paymentId })

// Bad: No way to correlate
$.log.info('Payment initiated')
$.log.info('Payment confirmed')
```

### Log State Transitions

```typescript
$.log.info('Order status changed', {
  orderId,
  from: order.previousStatus,
  to: order.status,
  reason: 'payment_confirmed'
})
```

### Don't Log Constantly in Loops

```typescript
// Bad: 10,000 log entries
for (const item of items) {
  $.log.debug('Processing item', { itemId: item.id })
  await process(item)
}

// Good: Summary
$.log.info('Processing items', { count: items.length })
for (const item of items) {
  await process(item)
}
$.log.info('Items processed', { count: items.length, duration: $.duration })
```

## Integration with Tracing

Logs are automatically linked to traces:

```typescript
const span = $.trace.span('process-order')
$.log.info('Starting order processing')  // Linked to span
// ...
span.end()
```

When you view a trace, you see all logs that occurred within that span.

## Related

- [Metrics](/docs/observability/metrics) - Counters and gauges for aggregation
- [Tracing](/docs/observability/tracing) - Distributed traces across DOs
- [Dashboards](/docs/observability/dashboards) - Visualize and alert on logs
