---
title: Metrics
description: Counters, gauges, histograms, and HUNCH metrics for measuring product-market fit
---

# Metrics

Logs tell you what happened. Metrics tell you how often it happens. dotdo provides three metric types plus HUNCH metrics for startup-specific product-market fit measurement.

## Metric Types

### Counters

Counters only go up. Use them for events.

```typescript
$.metrics.increment('orders.created')
$.metrics.increment('orders.created', { plan: 'pro' })
$.metrics.increment('orders.created', { plan: 'pro' }, 5)  // Increment by 5
```

Common counter patterns:
- `orders.created`, `orders.completed`, `orders.failed`
- `users.signup`, `users.login`, `users.churn`
- `payments.attempted`, `payments.succeeded`, `payments.declined`
- `agent.calls`, `agent.errors`, `agent.retries`

### Gauges

Gauges go up and down. Use them for current state.

```typescript
$.metrics.gauge('active_users', count)
$.metrics.gauge('queue_depth', queue.length)
$.metrics.gauge('memory_usage', process.memoryUsage().heapUsed)
```

Common gauge patterns:
- `active_users`, `active_sessions`
- `queue_depth`, `pending_jobs`
- `connection_pool_size`, `cache_size`
- `do_count`, `thing_count`

### Histograms

Histograms track distributions. Use them for latencies and sizes.

```typescript
$.metrics.histogram('response_time', duration)
$.metrics.histogram('payload_size', bytes)
$.metrics.histogram('agent.tokens', tokenCount)
```

Histograms automatically calculate:
- p50, p90, p95, p99 percentiles
- Mean, min, max
- Count and sum

```typescript
// Query histogram stats
const stats = await $.metrics.query({
  metric: 'response_time',
  percentiles: [50, 95, 99],
  timeRange: { last: '1h' }
})
// { p50: 45, p95: 120, p99: 890, count: 15420, mean: 67.3 }
```

## Labels and Dimensions

Add labels for filtering and grouping:

```typescript
$.metrics.increment('api.requests', {
  method: 'POST',
  path: '/orders',
  status: '200'
})

$.metrics.histogram('agent.duration', duration, {
  agent: 'priya',
  task: 'spec_review'
})
```

Query with label filters:

```typescript
const errorRate = await $.metrics.query({
  metric: 'api.requests',
  labels: { status: { match: '5*' } },
  rate: true,
  timeRange: { last: '5m' }
})
```

### Label Best Practices

```typescript
// Good: Low cardinality
$.metrics.increment('orders', { plan: 'pro' })       // ~5 plans
$.metrics.increment('orders', { region: 'us-west' }) // ~10 regions

// Bad: High cardinality (creates millions of series)
$.metrics.increment('orders', { customerId: 'cus_123' })
$.metrics.increment('orders', { orderId: 'ord_456' })
```

High-cardinality data belongs in logs, not metrics.

## HUNCH Metrics

Startups need to measure product-market fit, not just uptime. HUNCH metrics give you that.

```typescript
$.measure({
  hairOnFire: metrics.urgency,      // How badly do they need this?
  usage: metrics.weeklyActive,      // Are they using it?
  nps: metrics.netPromoterScore,    // Would they recommend it?
})
```

### Hair on Fire (Urgency)

How urgent is the problem you're solving?

```typescript
// Track urgency signals
$.hunch.urgency('order.expedited', { customerId })
$.hunch.urgency('support.priority_escalation', { customerId })
$.hunch.urgency('feature.requested_multiple_times', { featureId })

// Aggregate urgency score
const urgency = await $.hunch.query({
  metric: 'urgency',
  segment: 'enterprise',
  timeRange: { last: '30d' }
})
// { score: 7.8, signals: 142, trend: 'increasing' }
```

### Usage (Engagement)

Are people actually using it?

```typescript
// Track active usage
$.hunch.active(customerId)  // Mark customer as active today

// Weekly active users
const wau = await $.hunch.query({
  metric: 'weekly_active',
  timeRange: { last: '7d' }
})
// { count: 847, growth: 0.12, retention: 0.73 }

// Feature adoption
$.hunch.featureUsed('dark_mode', { customerId })
const adoption = await $.hunch.query({
  metric: 'feature_adoption',
  feature: 'dark_mode'
})
// { adoptionRate: 0.34, timeToAdopt: '3.2 days' }
```

### Net Promoter Score

Would they recommend you?

```typescript
// Record NPS response
$.hunch.nps(customerId, score)  // 0-10 scale

// Calculate NPS
const nps = await $.hunch.query({
  metric: 'nps',
  timeRange: { last: '30d' }
})
// { score: 42, promoters: 156, passives: 89, detractors: 34 }
```

### HUNCH Dashboard

```typescript
// Get full HUNCH summary
const hunch = await $.hunch.summary({
  segment: 'all',
  timeRange: { last: '30d' }
})
// {
//   hairOnFire: { score: 7.8, trend: 'stable' },
//   usage: { wau: 847, growth: 0.12, retention: 0.73 },
//   nps: { score: 42, trend: 'increasing' },
//   pmfScore: 0.68  // Composite product-market fit score
// }
```

## Agent Metrics

Agent calls are automatically instrumented:

```typescript
const spec = await priya`define the MVP`
// Automatically records:
// - agent.calls { agent: 'priya' }
// - agent.duration { agent: 'priya' }
// - agent.tokens.input { agent: 'priya' }
// - agent.tokens.output { agent: 'priya' }
// - agent.cost { agent: 'priya' }
```

Query agent performance:

```typescript
const agentStats = await $.metrics.query({
  metric: 'agent.duration',
  groupBy: 'agent',
  percentiles: [50, 99]
})
// {
//   priya: { p50: 2300, p99: 8900 },
//   ralph: { p50: 4500, p99: 25000 },
//   tom:   { p50: 1200, p99: 3400 }
// }
```

## Querying Metrics

### Basic Queries

```typescript
// Current value
const activeUsers = await $.metrics.get('active_users')

// Rate over time
const requestRate = await $.metrics.query({
  metric: 'api.requests',
  rate: true,
  timeRange: { last: '5m' }
})

// Aggregations
const orderStats = await $.metrics.query({
  metric: 'orders.created',
  aggregation: 'sum',
  groupBy: 'plan',
  timeRange: { last: '24h' }
})
```

### Time Series

```typescript
const timeSeries = await $.metrics.query({
  metric: 'response_time',
  percentile: 99,
  interval: '1h',
  timeRange: { last: '7d' }
})
// [
//   { timestamp: '2024-01-15T00:00:00Z', value: 890 },
//   { timestamp: '2024-01-15T01:00:00Z', value: 920 },
//   ...
// ]
```

### Alerts

```typescript
// Define alert thresholds
$.metrics.alert('high_error_rate', {
  metric: 'api.requests',
  labels: { status: { match: '5*' } },
  condition: {
    rate: true,
    threshold: 0.05,  // 5% error rate
    window: '5m'
  },
  notify: ['slack:#alerts', 'pagerduty:critical']
})

// Alert on latency
$.metrics.alert('slow_payments', {
  metric: 'payment.duration',
  condition: {
    percentile: 99,
    threshold: 5000,  // 5 seconds
    window: '10m'
  },
  notify: ['slack:#payments-alerts']
})
```

## Metric Aggregation

Metrics are aggregated across all DOs:

```typescript
// In DO-1 (SFO)
$.metrics.increment('orders.created')

// In DO-2 (FRA)
$.metrics.increment('orders.created')

// Global query returns combined total
await $.metrics.query({ metric: 'orders.created' })
// { count: 2 }
```

Group by datacenter for regional analysis:

```typescript
await $.metrics.query({
  metric: 'orders.created',
  groupBy: 'colo'
})
// { SFO: 1, FRA: 1 }
```

## Performance

Metrics are lightweight:

| Operation | Overhead |
|-----------|----------|
| `increment()` | ~10 microseconds |
| `gauge()` | ~10 microseconds |
| `histogram()` | ~25 microseconds |
| Flush (async) | Every 10 seconds |

Metrics are buffered locally and flushed to Cloudflare Analytics in batches.

## Best Practices

### Name Conventions

```typescript
// Good: Hierarchical, descriptive
$.metrics.increment('orders.created')
$.metrics.increment('payments.stripe.succeeded')
$.metrics.histogram('api.orders.create.duration')

// Bad: Flat, ambiguous
$.metrics.increment('created')
$.metrics.increment('success')
```

### Track the Business

```typescript
// Revenue metrics
$.metrics.increment('revenue', { plan }, order.total)

// Conversion funnel
$.metrics.increment('funnel.visited')
$.metrics.increment('funnel.signup_started')
$.metrics.increment('funnel.signup_completed')
$.metrics.increment('funnel.first_order')
```

### Measure Latency at Boundaries

```typescript
// Good: Measure external calls
const start = Date.now()
await stripe.charges.create(...)
$.metrics.histogram('external.stripe.duration', Date.now() - start)

// Good: Measure user-facing latency
$.metrics.histogram('api.orders.create.duration', requestDuration)
```

## Related

- [Logging](/docs/observability/logging) - Structured logs for debugging
- [Tracing](/docs/observability/tracing) - Distributed traces across DOs
- [Dashboards](/docs/observability/dashboards) - Visualize and alert on metrics
