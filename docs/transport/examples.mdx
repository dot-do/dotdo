---
title: Side-by-Side Examples
description: The same operations implemented in REST, RPC, and MCP protocols
---

import { Callout } from 'fumadocs-ui/components/callout'

# Side-by-Side Examples

See how the same operations look across all three protocols. These examples highlight the tradeoffs and advantages of each approach.

## Example 1: Create a Customer

The simplest case - a single operation.

### REST

```bash
curl -X POST https://api.example.com.ai/api/customers \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer token" \
  -d '{"name": "Acme Corp", "email": "hello@acme.com"}'
```

```json
// Response: 201 Created
{
  "id": "cust_abc123",
  "name": "Acme Corp",
  "email": "hello@acme.com",
  "createdAt": "2024-01-15T10:30:00Z"
}
```

### RPC

```typescript
import { $ } from 'dotdo'

const customer = await $.Customer.create({
  name: 'Acme Corp',
  email: 'hello@acme.com',
})
// customer = { id: 'cust_abc123', name: 'Acme Corp', ... }
```

### MCP

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "createCustomer",
    "arguments": {
      "name": "Acme Corp",
      "email": "hello@acme.com"
    }
  }
}

// Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [{
      "type": "text",
      "text": "{\"id\":\"cust_abc123\",\"name\":\"Acme Corp\",\"email\":\"hello@acme.com\"}"
    }]
  }
}
```

<Callout type="info" title="Single Operations">
For single operations, all three protocols are roughly equivalent. The differences emerge with chained operations.
</Callout>

---

## Example 2: Get User with Orders

Fetch a user and their recent orders - a common pattern.

### REST - 2 Round Trips

```typescript
// Two sequential requests
const user = await fetch('/api/users/alice').then(r => r.json())
const orders = await fetch(`/api/users/${user.id}/orders?limit=5`).then(r => r.json())

// Total: 2 round trips
```

### RPC - 1 Round Trip

```typescript
import { $ } from 'dotdo'

// Build the pipeline (no await yet)
const user = $.User('alice')
const orders = user.orders.recent(5)

// Single round trip when awaited
const [userData, orderData] = await Promise.all([user, orders])
```

### MCP - 2 Round Trips

```json
// Request 1: Get user
{ "jsonrpc": "2.0", "id": 1, "method": "tools/call",
  "params": { "name": "getUser", "arguments": { "id": "alice" } } }

// Request 2: Get orders (after receiving user)
{ "jsonrpc": "2.0", "id": 2, "method": "tools/call",
  "params": { "name": "getUserOrders", "arguments": { "userId": "alice", "limit": 5 } } }
```

Or with MCP batch request:

```json
// Both in one HTTP request (but still serial execution)
[
  { "jsonrpc": "2.0", "id": 1, "method": "tools/call",
    "params": { "name": "getUser", "arguments": { "id": "alice" } } },
  { "jsonrpc": "2.0", "id": 2, "method": "tools/call",
    "params": { "name": "getUserOrders", "arguments": { "userId": "alice", "limit": 5 } } }
]
```

---

## Example 3: Create Order with Inventory Check

Create an order after validating inventory - requires dependency.

### REST - 3 Round Trips

```typescript
// Check inventory
const inventory = await fetch(`/api/inventory/${productId}`).then(r => r.json())

if (inventory.available < quantity) {
  throw new Error('Insufficient inventory')
}

// Create order
const order = await fetch('/api/orders', {
  method: 'POST',
  body: JSON.stringify({ productId, quantity, customerId }),
}).then(r => r.json())

// Decrement inventory
await fetch(`/api/inventory/${productId}`, {
  method: 'PATCH',
  body: JSON.stringify({ available: inventory.available - quantity }),
})

// Total: 3 round trips (plus client-side branching)
```

### RPC - 1 Round Trip

```typescript
import { $ } from 'dotdo'

// Entire operation as one pipeline
const order = await $.Order.createWithInventoryCheck({
  productId,
  quantity,
  customerId,
})

// Server handles check + create + decrement atomically
// Total: 1 round trip
```

Or with explicit pipelining:

```typescript
// Build the dependency graph
const inventory = $.Inventory(productId)
const order = $.Order.create({
  productId,
  quantity,
  customerId,
  inventoryRef: inventory, // Server validates
})
const updated = $.Inventory(productId).decrement(quantity)

// Execute entire graph
await Promise.all([order, updated])
// Total: 1 round trip
```

### MCP - Server-Side Logic

```typescript
// Define a compound tool that handles the logic
static $mcp = {
  tools: {
    createOrderWithInventoryCheck: {
      description: 'Create order after validating inventory',
      inputSchema: {
        productId: { type: 'string' },
        quantity: { type: 'number' },
        customerId: { type: 'string' },
      },
      required: ['productId', 'quantity', 'customerId'],
    },
  },
}

// AI agent calls one tool
{ "method": "tools/call", "params": { "name": "createOrderWithInventoryCheck", "arguments": {...} } }

// Total: 1 round trip (logic is server-side)
```

---

## Example 4: Startup Launch Pipeline

The signature dotdo pattern - multiple agents coordinating.

### REST - 5+ Round Trips

```typescript
// Define spec
const spec = await fetch('/api/agents/priya/tasks', {
  method: 'POST',
  body: JSON.stringify({ prompt: 'define the MVP' }),
}).then(r => r.json())

// Build app
const app = await fetch('/api/agents/ralph/tasks', {
  method: 'POST',
  body: JSON.stringify({ prompt: 'build', context: spec }),
}).then(r => r.json())

// Ship
const deployed = await fetch('/api/agents/tom/tasks', {
  method: 'POST',
  body: JSON.stringify({ prompt: 'ship', context: app }),
}).then(r => r.json())

// Announce
const announcement = await fetch('/api/agents/mark/tasks', {
  method: 'POST',
  body: JSON.stringify({ prompt: 'announce', context: deployed }),
}).then(r => r.json())

// Sell
const sales = await fetch('/api/agents/sally/tasks', {
  method: 'POST',
  body: JSON.stringify({ prompt: 'start selling', context: announcement }),
}).then(r => r.json())

// Total: 5 round trips, 5x latency
```

### RPC - 1 Round Trip

```typescript
import { priya, ralph, tom, mark, sally } from 'agents.do'

// Build entire pipeline without awaiting
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = tom`ship ${app}`
const announced = mark`announce ${deployed}`
const selling = sally`start selling ${announced}`

// ONE round trip executes everything
const result = await selling

// Total: 1 round trip, 1x latency
```

<Callout type="warn" title="The Pipelining Advantage">
For this 5-agent pipeline with 200ms RTT, REST takes 1000ms. RPC takes 200ms. That's 5x faster.
</Callout>

### MCP - Agent Orchestration

```typescript
// Define an orchestration tool
static $mcp = {
  tools: {
    launchStartup: {
      description: 'Execute full startup launch pipeline',
      inputSchema: {
        hypothesis: { type: 'string', description: 'The startup hypothesis' },
      },
    },
  },
}

// AI agent calls one tool that orchestrates internally
{ "method": "tools/call", "params": { "name": "launchStartup", "arguments": { "hypothesis": "..." } } }

// Server internally uses RPC pipelining
// Total: 1 MCP round trip (wrapping internal RPC)
```

---

## Example 5: Bulk Update

Update multiple records efficiently.

### REST - N Round Trips (or bulk endpoint)

```typescript
// Option 1: N calls
for (const id of customerIds) {
  await fetch(`/api/customers/${id}`, {
    method: 'PATCH',
    body: JSON.stringify({ status: 'active' }),
  })
}
// Total: N round trips

// Option 2: Bulk endpoint (if implemented)
await fetch('/api/customers/bulk', {
  method: 'PATCH',
  body: JSON.stringify({
    ids: customerIds,
    update: { status: 'active' },
  }),
})
// Total: 1 round trip (requires custom endpoint)
```

### RPC - 1 Round Trip (Magic Map)

```typescript
import { $ } from 'dotdo'

// Magic Map transforms collection on server
const results = await $.Customer
  .where({ status: 'inactive' })
  .map(customer => customer.update({ status: 'active' }))

// Total: 1 round trip - map executes on server
```

### MCP - Tool with bulk support

```typescript
static $mcp = {
  tools: {
    bulkUpdateCustomers: {
      description: 'Update multiple customers at once',
      inputSchema: {
        filter: { type: 'object', description: 'Query filter' },
        update: { type: 'object', description: 'Fields to update' },
      },
    },
  },
}

// AI agent uses bulk tool
{ "method": "tools/call", "params": {
    "name": "bulkUpdateCustomers",
    "arguments": { "filter": { "status": "inactive" }, "update": { "status": "active" } }
  }
}
```

---

## Performance Summary

| Example | REST | RPC | MCP |
|---------|------|-----|-----|
| Create customer | 1 RT | 1 RT | 1 RT |
| User + orders | 2 RT | 1 RT | 1-2 RT |
| Order + inventory | 3 RT | 1 RT | 1 RT |
| 5-agent pipeline | 5 RT | 1 RT | 1 RT |
| Bulk update (100) | 1-100 RT | 1 RT | 1 RT |

**RT = Round Trip**

## Key Takeaways

1. **Single operations** - All protocols are equivalent
2. **Chained operations** - RPC wins with promise pipelining
3. **AI integration** - MCP provides native tool semantics
4. **Bulk operations** - RPC's Magic Map is most elegant
5. **External APIs** - REST is the standard choice

<Callout type="info" title="Choose Based on Caller">
The protocol you choose depends more on who's calling (browser, service, AI agent) than what operation you're performing.
</Callout>

## Related

- [Transport Decision Guide](/docs/transport) - Quick decision flowchart
- [Protocol Comparison](/docs/transport/comparison) - Feature comparison table
- [Promise Pipelining](/docs/rpc/pipelines) - Deep dive into RPC pipelining
- [MCP Tools](/docs/mcp) - Configuring tools for AI agents
