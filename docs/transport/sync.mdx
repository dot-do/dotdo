---
title: Sync Protocol
description: Real-time WebSocket synchronization for TanStack DB integration
---

import { Callout } from 'fumadocs-ui/components/callout'

# Sync Protocol

The Sync protocol provides real-time data synchronization over WebSocket. It enables live updates between Durable Objects and clients, powering reactive applications with TanStack DB integration.

```typescript
// Client subscribes to collection changes
const ws = new WebSocket('wss://api.example.com.ai/sync')

ws.send(JSON.stringify({
  type: 'subscribe',
  collection: 'Task',
  branch: 'main',
}))

// Server sends initial state + live updates
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data)
  if (msg.type === 'initial') {
    // Full collection state
    setTasks(msg.items)
  } else if (msg.type === 'insert' || msg.type === 'update' || msg.type === 'delete') {
    // Apply delta
    applyChange(msg)
  }
}
```

## Protocol Overview

The Sync protocol uses a simple message-based format over WebSocket:

### Client to Server Messages

| Message Type | Description |
|--------------|-------------|
| `subscribe` | Subscribe to a collection |
| `unsubscribe` | Unsubscribe from a collection |

### Server to Client Messages

| Message Type | Description |
|--------------|-------------|
| `initial` | Full collection state on subscribe |
| `insert` | New item created |
| `update` | Existing item modified |
| `delete` | Item removed |

## Message Formats

### Subscribe

Subscribe to receive updates for a collection:

```json
{
  "type": "subscribe",
  "collection": "Task",
  "branch": "main",
  "query": {
    "limit": 100,
    "offset": 0
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | `"subscribe"` | Yes | Message type |
| `collection` | string | Yes | Collection/type name |
| `branch` | string | No | Branch name (null for main) |
| `query.limit` | number | No | Max items (default: 100) |
| `query.offset` | number | No | Pagination offset |

### Unsubscribe

Stop receiving updates:

```json
{
  "type": "unsubscribe",
  "collection": "Task"
}
```

### Initial State

Sent immediately after subscribe with current collection data:

```json
{
  "type": "initial",
  "collection": "Task",
  "branch": "main",
  "items": [
    {
      "$id": "task-1",
      "$type": "Task",
      "name": "Build feature",
      "data": { "status": "in_progress" },
      "branch": "main",
      "createdAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-01-15T14:30:00Z"
    }
  ],
  "txid": 42
}
```

| Field | Type | Description |
|-------|------|-------------|
| `type` | `"initial"` | Message type |
| `collection` | string | Collection name |
| `branch` | string/null | Branch name |
| `items` | array | Current items in collection |
| `txid` | number | Transaction ID for ordering |

### Insert

Sent when a new item is created:

```json
{
  "type": "insert",
  "collection": "Task",
  "branch": "main",
  "txid": 43,
  "key": "task-2",
  "data": {
    "$id": "task-2",
    "$type": "Task",
    "name": "Review PR",
    "data": { "status": "pending" },
    "branch": "main",
    "createdAt": "2024-01-15T15:00:00Z",
    "updatedAt": "2024-01-15T15:00:00Z"
  }
}
```

### Update

Sent when an item is modified:

```json
{
  "type": "update",
  "collection": "Task",
  "branch": "main",
  "txid": 44,
  "key": "task-1",
  "data": {
    "$id": "task-1",
    "$type": "Task",
    "name": "Build feature",
    "data": { "status": "completed" },
    "branch": "main",
    "createdAt": "2024-01-15T10:00:00Z",
    "updatedAt": "2024-01-15T16:00:00Z"
  }
}
```

### Delete

Sent when an item is removed:

```json
{
  "type": "delete",
  "collection": "Task",
  "branch": "main",
  "txid": 45,
  "key": "task-2"
}
```

## Transaction IDs

Every change message includes a `txid` (transaction ID) that provides ordering guarantees:

- Transaction IDs are monotonically increasing
- Clients can detect missed messages by checking for gaps
- The initial state includes the latest txid
- Changes after the initial state will have txid > initial txid

<Callout type="info" title="Ordering Guarantees">
Messages for a single collection are delivered in txid order. Clients should process updates sequentially and can detect out-of-order delivery by comparing txids.
</Callout>

## Branching Support

The Sync protocol supports data branching for preview environments and A/B testing:

```json
{
  "type": "subscribe",
  "collection": "Task",
  "branch": "feature-branch"
}
```

Branches isolate changes:
- Changes on `main` don't appear on `feature-branch` subscriptions
- Changes on `feature-branch` don't appear on `main` subscriptions
- Use `null` or omit branch for the default (main) branch

## Client Implementation

### Basic Client

```typescript
class SyncClient {
  private ws: WebSocket
  private subscriptions = new Map<string, (items: any[]) => void>()

  constructor(url: string) {
    this.ws = new WebSocket(url)
    this.ws.onmessage = this.handleMessage.bind(this)
  }

  subscribe(collection: string, onChange: (items: any[]) => void) {
    this.subscriptions.set(collection, onChange)
    this.ws.send(JSON.stringify({
      type: 'subscribe',
      collection,
    }))
  }

  unsubscribe(collection: string) {
    this.subscriptions.delete(collection)
    this.ws.send(JSON.stringify({
      type: 'unsubscribe',
      collection,
    }))
  }

  private handleMessage(event: MessageEvent) {
    const msg = JSON.parse(event.data)
    const handler = this.subscriptions.get(msg.collection)
    if (!handler) return

    // Handle based on message type
    switch (msg.type) {
      case 'initial':
        handler(msg.items)
        break
      case 'insert':
      case 'update':
      case 'delete':
        // Emit change for client to handle
        this.emit('change', msg)
        break
    }
  }
}
```

### React Integration

```tsx
import { useEffect, useState } from 'react'

function useSyncCollection<T>(collection: string) {
  const [items, setItems] = useState<T[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const ws = new WebSocket(`wss://${window.location.host}/sync`)

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: 'subscribe', collection }))
    }

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data)
      if (msg.collection !== collection) return

      switch (msg.type) {
        case 'initial':
          setItems(msg.items)
          setLoading(false)
          break
        case 'insert':
          setItems(prev => [...prev, msg.data])
          break
        case 'update':
          setItems(prev => prev.map(item =>
            item.$id === msg.key ? msg.data : item
          ))
          break
        case 'delete':
          setItems(prev => prev.filter(item => item.$id !== msg.key))
          break
      }
    }

    ws.onclose = () => {
      // Reconnect logic here
    }

    return () => ws.close()
  }, [collection])

  return { items, loading }
}

// Usage
function TaskList() {
  const { items: tasks, loading } = useSyncCollection<Task>('Task')

  if (loading) return <div>Loading...</div>

  return (
    <ul>
      {tasks.map(task => (
        <li key={task.$id}>{task.name}</li>
      ))}
    </ul>
  )
}
```

## TanStack DB Integration

The Sync protocol is designed for TanStack DB integration:

```typescript
import { createSyncAdapter } from '@tanstack/db-sync'

const adapter = createSyncAdapter({
  url: 'wss://api.example.com.ai/sync',
  collections: ['Task', 'Project', 'User'],
})

// TanStack DB automatically syncs with the DO
const db = createDatabase({
  adapter,
  schema: {
    tasks: taskSchema,
    projects: projectSchema,
    users: userSchema,
  },
})
```

## Server-Side Hooks

Trigger sync broadcasts from your DO:

```typescript
class MyDO extends DO {
  private syncEngine: SyncEngine

  constructor(state: DurableObjectState, env: Env) {
    super(state, env)
    this.syncEngine = new SyncEngine(this.things)
  }

  async createTask(data: TaskData) {
    // Create in storage
    const task = await this.things.create({
      $type: 'Task',
      name: data.name,
      data: { status: 'pending' },
    })

    // Broadcast to subscribers
    this.syncEngine.onThingCreated({
      $id: task.$id,
      $type: task.$type,
      name: task.name,
      data: task.data,
      branch: task.branch ?? null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    }, task.version ?? 0)

    return task
  }

  // WebSocket handler
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    // SyncEngine handles subscribe/unsubscribe
    this.syncEngine.accept(ws)
  }
}
```

## Connection Management

### Reconnection

Implement exponential backoff for reconnection:

```typescript
class ReconnectingSyncClient {
  private url: string
  private ws: WebSocket | null = null
  private reconnectDelay = 1000
  private maxReconnectDelay = 30000

  connect() {
    this.ws = new WebSocket(this.url)

    this.ws.onopen = () => {
      this.reconnectDelay = 1000 // Reset on success
      this.resubscribe()
    }

    this.ws.onclose = () => {
      setTimeout(() => {
        this.reconnectDelay = Math.min(
          this.reconnectDelay * 2,
          this.maxReconnectDelay
        )
        this.connect()
      }, this.reconnectDelay)
    }
  }
}
```

### Health Monitoring

```typescript
// Server sends keepalive
setInterval(() => {
  for (const [socket, state] of this.connections) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'ping' }))
    }
  }
}, 30000)

// Client responds
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data)
  if (msg.type === 'ping') {
    ws.send(JSON.stringify({ type: 'pong' }))
    return
  }
  // ... handle other messages
}
```

## Multiple Subscriptions

A single WebSocket can subscribe to multiple collections:

```typescript
// Subscribe to multiple collections
ws.send(JSON.stringify({ type: 'subscribe', collection: 'Task' }))
ws.send(JSON.stringify({ type: 'subscribe', collection: 'Project' }))
ws.send(JSON.stringify({ type: 'subscribe', collection: 'User' }))

// Each sends its own initial state
// Changes are tagged with collection name
```

<Callout type="warn" title="Connection Limits">
Each Durable Object has connection limits. For large-scale applications, consider using Durable Object hibernation or fan-out patterns.
</Callout>

## Performance Considerations

### Selective Subscriptions

Only subscribe to what you need:

```typescript
// Good - specific collection
{ type: 'subscribe', collection: 'Task', branch: 'feature-123' }

// Avoid - subscribing to everything
// Don't implement a "subscribe all" pattern
```

### Pagination

Use pagination for large collections:

```typescript
{
  "type": "subscribe",
  "collection": "Order",
  "query": {
    "limit": 50  // Only recent orders
  }
}
```

### Delta Compression

The protocol sends full item data on each change. For bandwidth-sensitive applications, consider:

1. Implementing client-side diffing
2. Using a separate endpoint for large blob data
3. Limiting subscriptions to active/recent items

## Related

- [Transport Decision Guide](/docs/transport) - When to use Sync vs polling
- [Durable Objects Storage](/docs/storage/durable-objects) - Storage backing the sync
- [TanStack DB](/docs/database/tanstack) - Client-side database integration
- [Real-time Features](/docs/guides/realtime) - Building reactive applications
