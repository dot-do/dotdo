---
title: REST Transport
description: RESTful HTTP API with JSON-LD compatibility for Durable Objects
---

import { Callout } from 'fumadocs-ui/components/callout'

# REST Transport

The REST transport provides standard HTTP APIs with JSON-LD compatible responses. Every Durable Object automatically exposes RESTful endpoints for CRUD operations on its data.

```bash
# List all customers
curl https://api.example.com.ai/customers

# Get a specific customer
curl https://api.example.com.ai/customers/cust-123

# Create a customer
curl -X POST https://api.example.com.ai/customers \
  -H "Content-Type: application/json" \
  -d '{"name": "Acme Corp", "email": "hello@acme.com"}'
```

## Route Structure

The REST router automatically maps HTTP methods to operations:

| Method | Route | Operation | Handler |
|--------|-------|-----------|---------|
| `GET` | `/` | HATEOAS index | `handleGetIndex()` |
| `GET` | `/:type` | List items | `handleListByType()` |
| `GET` | `/:type/:id` | Get item | `handleGetById()` |
| `POST` | `/:type` | Create item | `handleCreate()` |
| `PUT` | `/:type/:id` | Replace item | `handleUpdate()` |
| `PATCH` | `/:type/:id` | Merge update | `handleUpdate()` |
| `DELETE` | `/:type/:id` | Delete item | `handleDelete()` |

### Type Singularization

Routes use plural type names that are automatically singularized:

```
/customers     → Customer
/products      → Product
/categories    → Category
/companies     → Company
```

## Response Format

REST responses use JSON-LD compatible structure with `$context`, `$id`, and `$type` fields:

### Single Item Response

```json
{
  "$context": "https://dotdo.dev/context",
  "$id": "/customers/cust-123",
  "$type": "Customer",
  "name": "Acme Corp",
  "email": "hello@acme.com",
  "status": "active"
}
```

### Collection Response

```json
{
  "$context": "https://dotdo.dev/context",
  "$id": "/customers",
  "$type": "Collection",
  "items": [
    {
      "$context": "https://dotdo.dev/context",
      "$id": "/customers/cust-123",
      "$type": "Customer",
      "name": "Acme Corp"
    }
  ],
  "total": 42,
  "totalItems": 42
}
```

### Index Response (HATEOAS)

```json
{
  "$context": "https://dotdo.dev/context",
  "$id": "/",
  "$type": "Startup",
  "ns": "acme",
  "collections": {
    "customers": {
      "$id": "/customers",
      "$type": "Collection",
      "count": 42
    },
    "orders": {
      "$id": "/orders",
      "$type": "Collection",
      "count": 156
    }
  }
}
```

## Content Negotiation

The REST transport supports content type negotiation via the `Accept` header:

| Accept Header | Response Content-Type |
|---------------|----------------------|
| `application/json` | `application/json` |
| `application/ld+json` | `application/ld+json` |
| (default) | `application/json` |

<Callout type="info" title="JSON-LD Compatibility">
All responses include JSON-LD fields (`$context`, `$id`, `$type`) regardless of content type. This enables semantic web compatibility while maintaining standard JSON usability.
</Callout>

## Query Parameters

### Pagination

```bash
# Limit results
curl "https://api.example.com.ai/customers?limit=10"

# Offset pagination
curl "https://api.example.com.ai/customers?limit=10&offset=20"

# Cursor pagination
curl "https://api.example.com.ai/customers?after=cust-100"
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | number | 100 | Maximum items to return |
| `offset` | number | 0 | Number of items to skip |
| `after` | string | - | Cursor for pagination |

## Error Responses

Errors follow a consistent structure:

```json
{
  "$type": "Error",
  "error": "Customer not found: cust-invalid",
  "code": "NOT_FOUND"
}
```

### Error Codes

| HTTP Status | Code | Description |
|-------------|------|-------------|
| 400 | `BAD_REQUEST` | Invalid JSON body |
| 404 | `NOT_FOUND` | Item or type not found |
| 405 | `METHOD_NOT_ALLOWED` | HTTP method not supported |
| 409 | `DUPLICATE` | Item already exists |
| 415 | `UNSUPPORTED_MEDIA_TYPE` | Invalid Content-Type |
| 500 | `CREATE_FAILED` | Server error during create |

## System Routes

Certain paths are reserved for system functions and bypass REST routing:

```
/health        → Health check
/rpc           → RPC transport
/mcp           → MCP transport
/sync          → WebSocket sync
/resolve       → Capability resolution
/$introspect   → Schema introspection
```

## REST Handler Configuration

The REST transport is automatically configured but can be customized:

```typescript
class MyDO extends DO {
  // Define available noun types for strict routing
  static $nouns = [
    { noun: 'Customer', plural: 'Customers' },
    { noun: 'Order', plural: 'Orders' },
  ]

  // Custom context URL for JSON-LD
  static $context = 'https://my-company.com/schema'
}
```

### Strict vs Permissive Mode

- **Permissive mode** (default): Any type name is accepted
- **Strict mode**: Only registered nouns are allowed

```typescript
// Permissive - accepts any type
class PermissiveDO extends DO {}

// Strict - only Customer and Order accepted
class StrictDO extends DO {
  static $nouns = [
    { noun: 'Customer', plural: 'Customers' },
    { noun: 'Order', plural: 'Orders' },
  ]
}
```

## Using with Handler Chain

The REST handler integrates with the transport handler chain:

```typescript
import { HandlerChain, RestHandler } from 'dotdo/transport'

const chain = new HandlerChain({ debug: true })

// REST has lower priority than MCP/RPC
chain.use(new McpHandler(), 50)    // MCP first
chain.use(new RpcHandler(), 40)    // Then RPC
chain.use(new RestHandler(), 30)   // REST last
```

Priority determines which handler processes ambiguous requests. REST is typically lowest priority since it matches many paths.

## Authentication

REST endpoints respect the `$auth` configuration:

```typescript
class SecureDO extends DO {
  static $auth = {
    list: { requireAuth: true },
    create: { requireAuth: true, roles: ['admin'] },
    delete: { requireAuth: true, roles: ['admin'] },
    get: { public: true }, // Public read access
  }
}
```

See [Authentication](/docs/security/authentication) for details.

## Examples

### CRUD Operations

```typescript
// Create
const customer = await fetch('/customers', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'Acme Corp' }),
}).then(r => r.json())
// customer.$id = '/customers/cust-abc123'

// Read
const fetched = await fetch(customer.$id).then(r => r.json())

// Update (replace)
await fetch(customer.$id, {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'Acme Corporation', status: 'premium' }),
})

// Update (merge)
await fetch(customer.$id, {
  method: 'PATCH',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ status: 'premium' }), // Only updates status
})

// Delete
await fetch(customer.$id, { method: 'DELETE' })
// Returns 204 No Content
```

### List with Pagination

```typescript
async function* paginateCustomers(limit = 100) {
  let after: string | undefined

  while (true) {
    const url = after
      ? `/customers?limit=${limit}&after=${after}`
      : `/customers?limit=${limit}`

    const response = await fetch(url).then(r => r.json())

    for (const customer of response.items) {
      yield customer
    }

    if (response.items.length < limit) break
    after = response.items[response.items.length - 1].$id.split('/').pop()
  }
}

// Usage
for await (const customer of paginateCustomers()) {
  console.log(customer.name)
}
```

## Related

- [Transport Decision Guide](/docs/transport) - When to use REST vs RPC vs MCP
- [Protocol Comparison](/docs/transport/comparison) - Feature comparison table
- [API Routes](/docs/api/routes) - Custom Hono route handlers
- [Authentication](/docs/security/authentication) - Securing REST endpoints
