---
title: Transport Decision Guide
description: Choose the right transport protocol for your use case - REST, RPC, or MCP
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Cards, Card } from 'fumadocs-ui/components/card'

# Transport Decision Guide

dotdo exposes three transport protocols. Each serves different use cases. This guide helps you choose in 30 seconds.

## Quick Decision

```
Is this for an AI agent?
├─ Yes → MCP
└─ No
   └─ Need backward compatibility with existing clients?
      ├─ Yes → REST
      └─ No
         └─ Internal service-to-service?
            ├─ Yes → RPC (promise pipelining)
            └─ No
               └─ Multiple chained calls?
                  ├─ Yes → RPC (one round trip)
                  └─ No
                     └─ Simple CRUD operations?
                        ├─ Yes → REST
                        └─ Browser with real-time updates? → RPC WebSocket
```

## The Three Protocols

### REST - External APIs

Standard HTTP with JSON bodies. Use when:

- External developers consume your API
- You need OpenAPI/Swagger documentation
- Clients expect familiar CRUD patterns
- Caching with standard HTTP semantics

```bash
curl -X POST https://api.example.com.ai/api/customers \
  -H "Content-Type: application/json" \
  -d '{"name": "Acme Corp"}'
```

[Full REST Documentation](/docs/api)

### RPC - Internal Efficiency

Cap'n Web with promise pipelining. Use when:

- Service-to-service communication
- Performance is critical
- Multiple operations need to chain
- Real-time updates via WebSocket

```typescript
// 5 operations, 1 network round trip
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const deployed = await tom`ship ${app}`
```

[Full RPC Documentation](/docs/rpc)

### MCP - AI Agents

Model Context Protocol (JSON-RPC 2.0). Use when:

- AI agents like Claude need to call your methods
- You want automatic tool schema generation
- Session-based interactions with state

```typescript
static $mcp = {
  tools: {
    searchCustomers: {
      description: 'Search customers by query',
      inputSchema: { query: { type: 'string' } },
    },
  },
}
```

[Full MCP Documentation](/docs/mcp)

## At a Glance

| Use Case | Protocol | Why |
|----------|----------|-----|
| Public API for third parties | REST | Standard, documented, cacheable |
| Browser CRUD | REST | Simple, familiar |
| Internal microservices | RPC | Performance, type safety |
| Chained operations | RPC | Promise pipelining (1 round trip) |
| Real-time updates | RPC | WebSocket streaming |
| Claude integration | MCP | Native tool protocol |
| AI agent actions | MCP | Auto-generated schemas |
| Chatbot backends | MCP | Session management |

## Common Patterns

### Expose All Three

Most DOs expose all three protocols simultaneously:

```typescript
class CustomerDO extends DO {
  // REST: Auto-generated from method signatures
  // RPC: Methods available via Cap'n Web
  // MCP: Configured tools for AI agents

  static $mcp = {
    tools: {
      search: { description: 'Search customers', inputSchema: { query: { type: 'string' } } },
    },
    resources: ['customers'],
  }

  // This method is available via REST, RPC, AND MCP
  search(query: string) {
    return this.customers.filter(c => c.name.includes(query))
  }

  // REST: GET /api/customers
  list() { return this.customers }

  // REST: POST /api/customers
  create(data: CustomerData) { /* ... */ }
}
```

### Protocol-Specific Routes

```
https://api.example.com.ai/api/*     → REST
https://api.example.com.ai/rpc/*     → Cap'n Web RPC
https://api.example.com.ai/mcp       → MCP JSON-RPC
```

<Callout type="info" title="Same DO, Three Doors">
All three protocols call the same underlying DO methods. Choose based on who's calling, not what they're doing.
</Callout>

## Decision Matrix

| Caller | Recommended | Alternative |
|--------|-------------|-------------|
| Mobile app | REST | RPC |
| Web app (simple) | REST | - |
| Web app (complex) | RPC | REST |
| Another Worker | RPC | REST |
| External service | REST | - |
| Claude/GPT | MCP | REST (fallback) |
| Custom AI agent | MCP | - |
| CLI tool | REST | RPC |

## Next Steps

<Cards>
  <Card title="Comparison Table" href="/docs/transport/comparison">
    Detailed feature-by-feature comparison of all three protocols.
  </Card>
  <Card title="Side-by-Side Examples" href="/docs/transport/examples">
    The same operation implemented in REST, RPC, and MCP.
  </Card>
  <Card title="REST API" href="/docs/api">
    Full REST documentation with routes, middleware, and responses.
  </Card>
  <Card title="RPC Protocol" href="/docs/rpc">
    Cap'n Web RPC with promise pipelining deep dive.
  </Card>
  <Card title="MCP Reference" href="/docs/mcp">
    Model Context Protocol for AI agent integration.
  </Card>
</Cards>

## Transport Subpages

<Cards>
  <Card title="REST Transport" href="/docs/transport/rest">
    Standard HTTP transport with JSON bodies.
  </Card>
  <Card title="Architecture" href="/docs/transport/architecture">
    Transport layer architecture and internals.
  </Card>
  <Card title="Handlers" href="/docs/transport/handlers">
    Transport handlers for custom protocols.
  </Card>
  <Card title="Sync" href="/docs/transport/sync">
    Real-time synchronization protocols.
  </Card>
</Cards>

## Related

<Cards>
  <Card title="Durable Objects" href="/docs/objects">
    DO class hierarchy that exposes these transport protocols.
  </Card>
  <Card title="Architecture" href="/docs/architecture">
    Technical deep dive into V8 isolates and DO internals.
  </Card>
  <Card title="Workflows" href="/docs/workflows">
    Durable workflow orchestration that uses these transports.
  </Card>
</Cards>
