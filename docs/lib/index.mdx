---
title: Core Library
description: Reusable infrastructure modules powering the dotdo platform
---

# Core Library (lib/)

The `lib/` directory contains the foundational modules that power dotdo's Business-as-Code runtime. These modules provide reusable infrastructure for Durable Objects, workflows, AI integration, and human-in-the-loop functionality.

## Overview

| Module | Purpose |
|--------|---------|
| [Functions](/docs/lib/functions) | Function registry, composition, and factory |
| [Channels](/docs/lib/channels) | Multi-channel notification adapters |
| [Humans](/docs/lib/humans) | Human escalation with template literals |
| [Auth](/docs/lib/auth) | JWT storage claims and authentication |
| [Response](/docs/lib/response) | JSON-LD style API response builders |
| [Storage](/docs/lib/storage) | JWT-authorized R2 with tenant isolation |
| [Executors](/docs/lib/executors) | Function execution strategies |
| [Cloudflare](/docs/lib/cloudflare) | KV, R2, Queues, AI, Vectorize wrappers |
| [Capabilities](/docs/lib/capabilities) | Lazy-loading capability system |
| [StateStorage](/docs/lib/state-storage) | Type-safe DO state wrapper |
| [Auto-Wiring](/docs/lib/auto-wiring) | Reflection-based API exposure |
| [Mixins](/docs/lib/mixins) | DO capability mixins (fs, git, bash) |
| [RPC](/docs/lib/rpc) | RPC binding architecture |

## Architecture

```
lib/
├── functions/       # Function registry and composition
├── channels/        # Slack, Discord, Email, MDXUI adapters
├── humans/          # Human escalation (humans.do)
├── auth/            # JWT storage claims extraction
├── response/        # JSON-LD response builders
├── storage/         # JWT-authorized R2 client
├── executors/       # Code, Generative, Agentic, Human executors
├── cloudflare/      # Cloudflare binding wrappers
├── mixins/          # DO capability mixins
├── ai/              # AI gateway and tool loop agent
├── browse/          # Browser automation
├── logging/         # Structured logging
├── rpc/             # RPC binding architecture
├── vault/           # Secure credential storage
└── sql/             # SQL parser abstraction
```

## Core Utilities

Beyond the module directories, `lib/` contains essential standalone utilities:

### auto-wiring.ts

Discovers public methods on DO subclasses and exposes them to multiple transports (SDK, RPC, MCP, REST, CLI).

```typescript
import { getExposedMethods } from 'lib/auto-wiring'

const methods = getExposedMethods(MyDO)
// ['createOrder', 'getCustomer', 'processPayment']
```

### capabilities.ts

Lazy-loading capability system for `$.fs`, `$.git`, `$.bash`, etc.

```typescript
import { CapabilityRegistry, createCapabilityProxy } from 'lib/capabilities'

const registry = new CapabilityRegistry()
registry.register('fs', FsModule)

const $ = createCapabilityProxy(registry)
await $.fs.write('/config.json', data)
```

### StateStorage.ts

Type-safe wrapper around Durable Object state with TTL, versioning, and migrations.

```typescript
import { StateStorage } from 'lib/StateStorage'

const storage = new StateStorage(state, {
  prefix: 'user:',
  defaultTTL: 3600000,
  versioned: true
})

await storage.set('profile', { name: 'Alice' })
```

### identity.ts

Identity management and actor context for DO operations.

### rate-limit.ts

Sliding window rate limiting for API protection.

### sqids.ts

Short unique ID generation using the Sqids algorithm.

### safe-stringify.ts

JSON stringify that handles circular references safely.

## Design Principles

### Lazy Loading

Capabilities and modules are loaded on first access, minimizing cold start times and memory usage.

### Type Safety

Every module provides full TypeScript types, with runtime validation where appropriate.

### Composition

Modules are designed to compose together. Functions chain, channels multiplex, capabilities stack.

### DO-First

All modules are optimized for the Durable Object execution model with persistent state and transactional guarantees.

## Quick Start

```typescript
import { createFunction } from 'lib/functions/createFunction'
import { createChannel } from 'lib/channels'
import { ceo } from 'lib/humans'
import { StateStorage } from 'lib/StateStorage'

// Create a human-approved function
const approveOrder = await createFunction({
  name: 'approveOrder',
  type: 'human',
  channel: 'slack:approvals',
  timeout: 14400000,
  prompt: (input) => `Approve order for $${input.amount}?`
}, { env })

// Or use the template literal syntax
const approved = await ceo`approve ${order} for production`

// Use channels directly
const slack = createChannel('slack', { webhookUrl: '...' })
await slack.send({ message: 'Deployment complete!' })

// Manage DO state with type safety
const storage = new StateStorage(state, { prefix: 'app:' })
await storage.set('config', { version: 2 })
```

## Related

- [Functions](/docs/functions) - High-level function documentation
- [Humans](/docs/humans) - Human-in-the-loop patterns
- [Workflows](/docs/workflows) - Workflow orchestration
- [Architecture](/docs/architecture) - System architecture
