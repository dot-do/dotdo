---
title: RPC Bindings
description: Type-safe RPC bindings for Cloudflare Workers service bindings
---

# RPC Bindings

The RPC module provides type-safe bindings for Cloudflare Workers service bindings, enabling capability modules (AI, KV, R2, D1, Queues, Vectorize) to run as separate Workers instead of bloating the core bundle.

## Overview

```typescript
import {
  RPCBinding,
  createAIBinding,
  createCapabilityProxy,
  BindingRegistry,
} from 'lib/rpc'

// Create typed binding for AI service
const ai = createAIBinding(env.AI_SERVICE)

// Call methods with type safety
const result = await ai.call('ai.generate', {
  prompt: 'Hello',
  temperature: 0.7,
})

// Or use proxy pattern with auto-fallback
const proxy = createCapabilityProxy({
  binding: env.AI_SERVICE,
  fallback: {
    'ai.generate': async (params) => inlineImplementation(params)
  }
})
```

## RPCBinding Class

The core class for making RPC calls to service bindings.

```typescript
import { RPCBinding, type MethodDefinition } from 'lib/rpc'

// Define capability methods
interface AIMethods {
  'ai.generate': MethodDefinition<
    { prompt: string; temperature?: number },
    { text: string }
  >
  'ai.embed': MethodDefinition<
    { text: string },
    { embedding: number[] }
  >
}

// Create binding
const aiBinding = new RPCBinding<AIMethods>(env.AI_SERVICE, {
  name: 'ai-service',
  timeout: 30000,
})

// Call methods with full type safety
const result = await aiBinding.call('ai.generate', {
  prompt: 'Hello world'
})
```

### Configuration

```typescript
interface RPCBindingConfig {
  name: string           // Service name for logging
  timeout?: number       // Default timeout in ms (default: 30000)
  retry?: RetryPolicy    // Retry configuration
  baseUrl?: string       // Base URL for HTTP bindings
  debug?: boolean        // Enable debug logging
}

interface RetryPolicy {
  maxAttempts: number       // Max retry attempts (default: 3)
  baseDelayMs: number       // Base delay in ms (default: 100)
  maxDelayMs: number        // Max delay in ms (default: 5000)
  backoffMultiplier: number // Exponential backoff (default: 2)
  jitterFactor: number      // Jitter factor 0-1 (default: 0.1)
  retryableErrors?: (string | number)[]
}
```

### Streaming Responses

```typescript
// Stream responses from AI generation
const stream = aiBinding.stream('ai.generateStream', {
  prompt: 'Write a long story...',
  temperature: 0.8
})

for await (const chunk of stream) {
  process.stdout.write(chunk)
}
```

### Checking Availability

```typescript
// Check if binding is available
if (aiBinding.isAvailable()) {
  // Use the service binding
  await aiBinding.call('ai.generate', params)
} else if (aiBinding.hasFallback()) {
  // Fallback will be used automatically
  await aiBinding.call('ai.generate', params)
}
```

## Factory Functions

Pre-configured factory functions for common capabilities:

```typescript
import {
  createAIBinding,
  createKVBinding,
  createR2Binding,
  createD1Binding,
  createQueueBinding,
  createVectorizeBinding,
  createToolBinding,
  createUnifiedBinding,
} from 'lib/rpc'

// AI binding (60s timeout for slow operations)
const ai = createAIBinding(env.AI_SERVICE)

// KV binding (5s timeout for fast lookups)
const kv = createKVBinding(env.KV_SERVICE)

// R2 binding (30s timeout for file operations)
const r2 = createR2Binding(env.R2_SERVICE)

// D1 binding (30s timeout for SQL queries)
const d1 = createD1Binding(env.D1_SERVICE)

// Queue binding (10s timeout for message sends)
const queue = createQueueBinding(env.QUEUE_SERVICE)

// Vectorize binding (30s timeout for vector operations)
const vectorize = createVectorizeBinding(env.VECTORIZE_SERVICE)

// Tool binding (60s timeout for jq, npm, etc.)
const tools = createToolBinding(env.TOOL_SERVICE)

// Unified binding with all capabilities
const unified = createUnifiedBinding(env.UNIFIED_SERVICE)
```

## Capability Methods

### AI Methods

```typescript
// Text generation
await ai.call('ai.generate', {
  prompt: 'Write a haiku',
  model: 'claude-sonnet-4-20250514',
  temperature: 0.7,
  maxTokens: 100
})

// Embeddings
await ai.call('ai.embed', {
  text: ['Document 1', 'Document 2'],
  model: 'text-embedding-3-small'
})

// Classification
await ai.call('ai.classify', {
  text: 'This product is great!',
  labels: ['positive', 'negative', 'neutral']
})
```

### Storage Methods

```typescript
// KV operations
await kv.call('kv.get', { key: 'user:123', namespace: 'sessions' })
await kv.call('kv.set', { key: 'user:123', value: data, ttl: 3600 })
await kv.call('kv.list', { prefix: 'user:', limit: 100 })

// R2 operations
await r2.call('r2.get', { key: 'documents/report.pdf' })
await r2.call('r2.put', { key: 'uploads/file.txt', body: content })
await r2.call('r2.list', { prefix: 'uploads/', limit: 50 })

// D1 operations
await d1.call('d1.query', {
  sql: 'SELECT * FROM users WHERE active = ?',
  params: [true]
})
await d1.call('d1.batch', {
  statements: [
    { sql: 'INSERT INTO logs (msg) VALUES (?)', params: ['event1'] },
    { sql: 'INSERT INTO logs (msg) VALUES (?)', params: ['event2'] }
  ]
})
```

### Messaging Methods

```typescript
// Send to queue
await queue.call('queue.send', {
  queue: 'jobs',
  body: { type: 'process', data: payload },
  delaySeconds: 60
})

// Batch send
await queue.call('queue.sendBatch', {
  queue: 'jobs',
  messages: [
    { body: { task: 1 } },
    { body: { task: 2 }, delaySeconds: 30 }
  ]
})
```

### Vector Methods

```typescript
// Insert vectors
await vectorize.call('vectorize.insert', {
  vectors: [
    { id: 'doc-1', values: [0.1, 0.2, ...], metadata: { title: 'Doc 1' } },
    { id: 'doc-2', values: [0.3, 0.4, ...], metadata: { title: 'Doc 2' } }
  ]
})

// Query similar vectors
await vectorize.call('vectorize.query', {
  vector: queryEmbedding,
  topK: 10,
  filter: { category: 'technical' },
  returnMetadata: true
})
```

### Tool Methods

```typescript
// jq transformation
await tools.call('tool.jq', {
  input: { users: [{ name: 'Alice' }, { name: 'Bob' }] },
  filter: '.users[].name'
})

// npm resolution
await tools.call('tool.npmResolve', {
  package: 'lodash',
  version: '^4.0.0'
})
```

## Binding Registry

Manage multiple bindings with automatic routing:

```typescript
import { BindingRegistry } from 'lib/rpc'

const registry = new BindingRegistry()

// Register bindings
registry.register('ai', createAIBinding(env.AI_SERVICE))
registry.register('kv', createKVBinding(env.KV_SERVICE))
registry.register('r2', createR2Binding(env.R2_SERVICE))

// Register fallbacks
registry.registerFallback('ai', async (method, params) => {
  // Inline AI implementation
  return await localAI.generate(params)
})

// Call methods - auto-routes to correct binding
await registry.call('ai.generate', { prompt: 'Hello' })
await registry.call('kv.get', { key: 'session:123' })

// Check availability
registry.has('ai')           // true if binding available
registry.list()              // ['ai', 'kv', 'r2']
registry.listAvailable()     // Only bindings with actual service binding
```

## Capability Proxy Pattern

Auto-detect binding availability with fallback:

```typescript
import { createCapabilityProxy, type AICapabilityMethods } from 'lib/rpc'

const ai = createCapabilityProxy<AICapabilityMethods>({
  binding: env.AI_SERVICE,
  config: { timeout: 60000 },
  fallback: {
    'ai.generate': async (params) => {
      // Use Workers AI directly when service binding unavailable
      const result = await env.AI.run('@cf/meta/llama-2-7b', {
        prompt: params.prompt
      })
      return { text: result.response }
    },
    'ai.embed': async (params) => {
      // Fallback embedding implementation
      const result = await env.AI.run('@cf/baai/bge-base-en-v1.5', {
        text: params.text
      })
      return { embeddings: [result.embedding], dimension: 768 }
    }
  }
})

// Automatically uses binding if available, fallback otherwise
const result = await ai.call('ai.generate', { prompt: 'Hello' })
```

## Error Handling

```typescript
import {
  RPCBindingError,
  RPCTimeoutError,
  RPCNetworkError,
  isRetryableError
} from 'lib/rpc'

try {
  await ai.call('ai.generate', { prompt: 'Hello' })
} catch (error) {
  if (error instanceof RPCTimeoutError) {
    console.log('Request timed out:', error.message)
    // error.data contains { method, timeoutMs }
  } else if (error instanceof RPCNetworkError) {
    console.log('Network error:', error.message)
    // Automatically retried based on retry policy
  } else if (error instanceof RPCBindingError) {
    console.log('RPC error:', error.code, error.message)

    if (error.code === 'BINDING_UNAVAILABLE') {
      // Service binding not configured
    }

    if (isRetryableError(error, DEFAULT_RETRY_POLICY)) {
      // Error would be retried by policy
    }
  }
}
```

### Error Codes

| Code | Description | Retryable |
|------|-------------|-----------|
| `BINDING_UNAVAILABLE` | Service binding not configured | No |
| `TIMEOUT` | Request timed out | Yes |
| `NETWORK_ERROR` | Network connectivity issue | Yes |
| `SERVICE_UNAVAILABLE` | Service temporarily down | Yes |
| `RATE_LIMITED` | Rate limit exceeded | Yes |
| `NO_FALLBACK` | No fallback for method | No |
| `CAPABILITY_UNAVAILABLE` | Capability not registered | No |

## Request/Response Types

```typescript
interface RPCRequest<T = unknown> {
  id: string               // Unique request ID
  method: string           // Method name
  params: T                // Method parameters
  timeout?: number         // Request timeout
  meta?: Record<string, unknown>  // Tracing metadata
}

interface RPCResponse<T = unknown> {
  id: string               // Correlation ID
  result?: T               // Success result
  error?: RPCError         // Error details
  meta?: Record<string, unknown>
}

interface RPCError {
  code: string | number    // Error code
  message: string          // Human-readable message
  data?: unknown           // Debug data
  retryable?: boolean      // Can retry
}

interface RPCStreamChunk<T = unknown> {
  seq: number              // Chunk sequence
  data: T                  // Chunk data
  done: boolean            // Final chunk flag
}
```

## Utility Functions

```typescript
import {
  generateRequestId,
  calculateBackoffDelay,
  isRetryableError,
  DEFAULT_RETRY_POLICY
} from 'lib/rpc'

// Generate unique request ID
const id = generateRequestId()
// => 'rpc_1699920000000_abc123def'

// Calculate backoff delay for retry
const delay = calculateBackoffDelay(2, DEFAULT_RETRY_POLICY)
// => ~400ms (with jitter)

// Check if error should be retried
const shouldRetry = isRetryableError(error, DEFAULT_RETRY_POLICY)
```

## Related

- [Cloudflare Integrations](/docs/lib/cloudflare) - Cloudflare binding wrappers
- [Capabilities](/docs/lib/capabilities) - Capability system
- [Deployment](/docs/deployment/cloudflare) - Service binding configuration
