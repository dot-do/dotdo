---
title: Auto-Wiring
description: Reflection-based API exposure for Durable Objects
---

# Auto-Wiring

The auto-wiring module discovers public methods on DO subclasses and exposes them to multiple transports (SDK, RPC, MCP, REST, CLI). This enables a single class definition to automatically provide multiple API interfaces.

## Overview

```typescript
import { getExposedMethods, isExposed, getMethodSignature } from 'lib/auto-wiring'

class OrderDO extends DO {
  // Exposed (public)
  async createOrder(items: Item[]) { /* ... */ }
  async getOrder(id: string) { /* ... */ }

  // Not exposed (underscore prefix)
  _validateItems(items: Item[]) { /* ... */ }

  // Not exposed (protected style)
  __internalLog(msg: string) { /* ... */ }
}

// Discover public methods
const methods = getExposedMethods(OrderDO)
// => ['createOrder', 'getOrder']
```

## Method Visibility

### Public Methods (Exposed)

Methods without underscore prefixes are exposed:

```typescript
class MyDO extends DO {
  // All exposed
  async create() {}
  async read() {}
  async update() {}
  async delete() {}
  list() {}
  processOrder() {}
}
```

### Private Methods (Not Exposed)

Single underscore prefix marks private methods:

```typescript
class MyDO extends DO {
  _validateInput() {}    // Not exposed
  _formatOutput() {}     // Not exposed
  _helper() {}           // Not exposed
}
```

### Protected Methods (Not Exposed)

Double underscore prefix marks protected methods:

```typescript
class MyDO extends DO {
  __internalLog() {}     // Not exposed
  __cacheResult() {}     // Not exposed
}
```

### Framework Methods (Not Exposed)

DO base class methods are excluded:

- Lifecycle: `initialize`, `fork`, `compact`, `moveTo`
- Branching: `branch`, `checkout`, `merge`
- HTTP: `fetch`, `handleFetch`
- Workflow context: `send`, `try`, `do`, `emit`
- Internal helpers: `resolveLocal`, `log`, `sleep`, etc.

## getExposedMethods

Returns an array of exposed method names:

```typescript
import { getExposedMethods } from 'lib/auto-wiring'

const methods = getExposedMethods(MyDO)
// => ['createOrder', 'getOrder', 'listOrders', 'cancelOrder']
```

Results are cached per class for performance.

## isExposed

Check if a specific method is exposed:

```typescript
import { isExposed } from 'lib/auto-wiring'

isExposed(MyDO, 'createOrder')   // true
isExposed(MyDO, '_validate')     // false
isExposed(MyDO, 'fetch')         // false (framework method)
isExposed(MyDO, 'toString')      // false (Object.prototype)
```

## getMethodSignature

Get detailed signature information:

```typescript
import { getMethodSignature } from 'lib/auto-wiring'

const sig = getMethodSignature(MyDO, 'createOrder')
// {
//   name: 'createOrder',
//   parameterCount: 2,
//   parameters: [
//     { name: 'items', optional: false },
//     { name: 'options', optional: true }
//   ],
//   async: true
// }
```

### Parameter Detection

Parameters are detected from function source:

```typescript
class MyDO extends DO {
  // Required parameters
  process(data: Data) {}               // { name: 'data', optional: false }

  // Optional parameters (? suffix)
  fetch(url: string, options?: Options) {}  // options is optional

  // Default values
  paginate(page = 1, size = 10) {}     // page and size are optional

  // Rest parameters
  merge(...items: Item[]) {}           // { name: 'items', optional: true }

  // Destructured
  create({ name, email }: User) {}     // { name: 'data', optional: false }
}
```

### Optional Patterns

These parameter names are heuristically marked as optional:

- `options`, `opts`
- `config`, `params`
- `settings`, `args`
- `kwargs`, `extra`
- `additional`, `metadata`
- `context`, `props`

## getMethodMetadata

Get metadata including auto-generated descriptions:

```typescript
import { getMethodMetadata } from 'lib/auto-wiring'

const meta = getMethodMetadata(MyDO, 'createOrder')
// {
//   name: 'createOrder',
//   description: 'Create order',  // Auto-generated from camelCase
//   parameters: {
//     items: { description: undefined },
//     options: { description: undefined }
//   },
//   returns: { description: 'Return value of createOrder' }
// }
```

### Auto-Generated Descriptions

Method names are converted to readable descriptions:

| Method | Generated Description |
|--------|----------------------|
| `createOrder` | "Create order" |
| `getCustomerById` | "Get customer by id" |
| `processPayment` | "Process payment" |
| `sendNotificationEmail` | "Send notification email" |

## Prototype Chain

Methods from the full prototype chain are discovered:

```typescript
class BaseDO extends DO {
  async baseMethod() {}
}

class MyDO extends BaseDO {
  async myMethod() {}
}

getExposedMethods(MyDO)
// => ['baseMethod', 'myMethod']
```

Methods are discovered up to (but not including) `Object.prototype`.

## Getters and Setters

Properties with getters/setters are not exposed as methods:

```typescript
class MyDO extends DO {
  private _count = 0

  get count() { return this._count }      // Not exposed
  set count(v) { this._count = v }        // Not exposed

  getCount() { return this._count }       // Exposed
  setCount(v: number) { this._count = v } // Exposed
}
```

## Caching

Results are cached per class using `WeakMap`:

```typescript
// First call - computes and caches
const methods1 = getExposedMethods(MyDO)

// Second call - returns cached result
const methods2 = getExposedMethods(MyDO)

// Same reference
methods1 === methods2  // true
```

## Transport Integration

Auto-wiring enables multi-transport exposure:

```typescript
// SDK Client
const client = createClient(OrderDO)
await client.createOrder(items)

// RPC
await rpc.call('Order', 'createOrder', [items])

// REST
POST /api/Order/createOrder { "items": [...] }

// MCP (Model Context Protocol)
use_tool('OrderDO.createOrder', { items: [...] })

// CLI
dotdo call Order createOrder --items='[...]'
```

## Usage Example

Complete example with auto-wiring:

```typescript
import { DO } from 'objects/DO'
import { getExposedMethods, getMethodSignature } from 'lib/auto-wiring'

class ProductDO extends DO {
  // Public API
  async create(product: Product): Promise<Product> {
    this._validate(product)
    return await this._save(product)
  }

  async get(id: string): Promise<Product | null> {
    return await this._load(id)
  }

  async update(id: string, updates: Partial<Product>): Promise<Product> {
    const existing = await this._load(id)
    if (!existing) throw new Error('Not found')
    return await this._save({ ...existing, ...updates })
  }

  async delete(id: string): Promise<boolean> {
    return await this._remove(id)
  }

  async list(options?: ListOptions): Promise<Product[]> {
    return await this._query(options)
  }

  // Private implementation
  private _validate(product: Product) { /* ... */ }
  private async _save(product: Product) { /* ... */ }
  private async _load(id: string) { /* ... */ }
  private async _remove(id: string) { /* ... */ }
  private async _query(options?: ListOptions) { /* ... */ }
}

// Auto-discover public API
const api = getExposedMethods(ProductDO)
// => ['create', 'get', 'update', 'delete', 'list']

// Generate OpenAPI schema
for (const method of api) {
  const sig = getMethodSignature(ProductDO, method)
  console.log(`${method}(${sig.parameters.map(p => p.name).join(', ')})`)
}
```

## Type Definitions

```typescript
interface ParameterInfo {
  name: string
  optional: boolean
}

interface MethodSignature {
  name: string
  parameterCount: number
  parameters: ParameterInfo[]
  async: boolean
}

interface MethodMetadata {
  name: string
  description?: string
  parameters?: Record<string, { description?: string }>
  returns?: { description?: string }
  throws?: string[]
}

interface ExposedMethodInfo {
  name: string
  signature: MethodSignature
  metadata: MethodMetadata
}
```

## Related

- [RPC](/docs/rpc) - RPC transport layer
- [SDK](/docs/sdk) - TypeScript SDK
- [API](/docs/api) - REST API
