---
title: Cloudflare Integrations
description: Typed wrappers for Cloudflare KV, R2, Queues, AI, and Vectorize
---

# Cloudflare Integrations

The cloudflare module provides typed wrappers for Cloudflare bindings with enhanced functionality, namespacing, and helper methods.

## KV Store

Type-safe KV operations with namespacing, TTL helpers, rate limiting, and caching.

```typescript
import { createKVStore, KVStore } from 'lib/cloudflare'

const store = createKVStore(env.KV, {
  namespace: 'tenant-123'
})

// Basic operations
await store.set('key', { data: 'value' }, { ttl: store.ttl.hours(1) })
const value = await store.get('key')
await store.delete('key')
```

### TTL Helpers

```typescript
// Convenient TTL methods
await store.set('session', data, { ttl: store.ttl.minutes(30) })
await store.set('cache', data, { ttl: store.ttl.hours(6) })
await store.set('persistent', data, { ttl: store.ttl.days(30) })

// Available helpers
store.ttl.seconds(n)
store.ttl.minutes(n)
store.ttl.hours(n)
store.ttl.days(n)
store.ttl.weeks(n)
```

### Session Management

```typescript
// Set session with 7-day TTL
await store.setSession('sess-abc', {
  userId: 'user-123',
  roles: ['admin']
}, store.ttl.days(7))

// Get session
const session = await store.getSession('sess-abc')
```

### Rate Limiting

```typescript
// Check rate limit (100 requests per minute)
const result = await store.checkRateLimit(
  'user:123:api',
  100,
  store.ttl.minutes(1)
)

if (!result.allowed) {
  throw new Error(`Rate limit exceeded. Retry in ${result.retryAfter}ms`)
}

// result = {
//   allowed: true,
//   remaining: 99,
//   retryAfter: 0
// }
```

### Caching

```typescript
// Cache expensive operations
const data = await store.cache(
  'expensive-result',
  async () => {
    return await computeExpensiveResult()
  },
  { ttl: store.ttl.minutes(5) }
)
```

## R2 Object Storage

Object storage with path utilities and tenant isolation.

```typescript
import { createR2Store, R2Store, buildPath, parsePath } from 'lib/cloudflare'

const r2 = createR2Store(env.BUCKET, {
  prefix: 'uploads'
})

// Basic operations
await r2.put('documents/report.pdf', pdfBuffer, {
  httpMetadata: { contentType: 'application/pdf' }
})

const object = await r2.get('documents/report.pdf')
await r2.delete('documents/report.pdf')
```

### Path Utilities

```typescript
// Build structured paths
const path = buildPath({
  tenant: 'acme',
  type: 'documents',
  id: 'doc-123',
  filename: 'report.pdf'
})
// => 'acme/documents/doc-123/report.pdf'

// Parse paths
const { tenant, type, id, filename } = parsePath(path)
```

### Tenant Isolation

```typescript
// Tenant-scoped operations
await r2.putForTenant('acme', 'report.pdf', data, {
  metadata: { author: 'alice' }
})

const doc = await r2.getForTenant('acme', 'report.pdf')

// List tenant's objects
const objects = await r2.listForTenant('acme', {
  prefix: 'documents/',
  limit: 100
})
```

### Presigned URLs

```typescript
// Generate upload URL (expires in 1 hour)
const uploadUrl = await r2.getSignedUrl('uploads/file.pdf', {
  method: 'PUT',
  expiresIn: 3600
})

// Generate download URL
const downloadUrl = await r2.getSignedUrl('documents/report.pdf', {
  method: 'GET',
  expiresIn: 300
})
```

### Streaming

```typescript
// Stream large files
const stream = await r2.getAsStream('large-file.zip')

// Stream upload
await r2.putStream('output.log', readableStream, {
  contentLength: totalBytes
})
```

## Queues

Async job processing with message types, retry policies, and DLQ integration.

```typescript
import {
  createQueueClient,
  createJobMessage,
  createEventMessage,
  createRetryPolicy,
  processMessageBatch
} from 'lib/cloudflare'

// Create queue client
const queue = createQueueClient(env.JOBS_QUEUE, {
  retryPolicy: createRetryPolicy({
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 60000
  })
})

// Send job message
await queue.send(createJobMessage({
  type: 'process-order',
  payload: { orderId: 'ORD-123' },
  priority: 'high'
}))

// Send event message
await queue.send(createEventMessage({
  type: 'user.signup',
  payload: { userId: 'user-456' }
}))
```

### Message Types

```typescript
// Job message (for background processing)
const job = createJobMessage({
  type: 'send-email',
  payload: { to: 'user@example.com', template: 'welcome' },
  priority: 'normal',
  scheduledFor: Date.now() + 60000  // Delay 1 minute
})

// Event message (for event-driven workflows)
const event = createEventMessage({
  type: 'order.completed',
  payload: { orderId: 'ORD-123', total: 99.99 },
  source: 'checkout-service'
})

// Workflow trigger
const trigger = createWorkflowTrigger({
  workflowId: 'order-fulfillment',
  input: { orderId: 'ORD-123' }
})
```

### Batch Processing

```typescript
// Process message batch in consumer
export async function queue(batch: MessageBatch, env: Env) {
  const results = await processMessageBatch(batch, {
    handlers: {
      job: createJobHandler(async (job) => {
        await processJob(job)
      }),
      event: createEventHandler(async (event) => {
        await handleEvent(event)
      })
    },
    onError: async (message, error) => {
      await sendToDLQ(env.DLQ, message, { error })
    }
  })

  return results
}
```

### Retry Policies

```typescript
const policy = createRetryPolicy({
  maxRetries: 5,
  baseDelay: 1000,       // 1 second
  maxDelay: 300000,      // 5 minutes
  backoffMultiplier: 2,  // Exponential backoff
  jitter: true           // Add randomness
})

// Calculate backoff delay
const delay = calculateBackoffDelay(policy, attemptNumber)

// Check if should send to DLQ
const toDLQ = shouldSendToDLQ(policy, attemptNumber)
```

## Workers AI

AI inference with model configuration and fallbacks.

```typescript
import {
  createWorkersAI,
  createFastAI,
  createQualityAI,
  createAIWithFallback,
  AI_MODELS
} from 'lib/cloudflare'

// Create AI client
const ai = createWorkersAI(env)

// Text generation
const response = await ai.generate({
  prompt: 'Write a haiku about programming',
  maxTokens: 100,
  temperature: 0.8
})

// Chat completion
const chat = await ai.chat([
  { role: 'system', content: 'You are a helpful assistant.' },
  { role: 'user', content: 'Explain quantum computing.' }
])
```

### Model Presets

```typescript
// Fast model (lower latency)
const fast = createFastAI(env)

// Quality model (better output)
const quality = createQualityAI(env)

// AI with fallback chain
const resilient = createAIWithFallback(env, {
  primary: AI_MODELS.LLAMA_70B,
  fallback: AI_MODELS.LLAMA_8B
})
```

### Embeddings

```typescript
// Single embedding
const embedding = await ai.embed('Search query text')
// => { values: [0.1, -0.2, ...], model: '...' }

// Batch embeddings
const embeddings = await ai.embedBatch([
  'First document',
  'Second document',
  'Third document'
])
```

### Image Generation

```typescript
const image = await ai.generateImage({
  prompt: 'A futuristic city at sunset',
  width: 1024,
  height: 1024,
  steps: 30
})
// => { image: Uint8Array, format: 'png' }
```

### Speech to Text

```typescript
const transcript = await ai.transcribe(audioBuffer, {
  language: 'en'
})
// => { text: 'Transcribed text...', segments: [...] }
```

### Streaming

```typescript
const stream = await ai.stream({
  prompt: 'Write a long story about...',
  maxTokens: 2000
})

for await (const chunk of stream) {
  process.stdout.write(chunk.text)
}
```

## Vectorize

Vector search and semantic search client.

```typescript
import {
  createVectorizeClient,
  createSemanticSearchClient
} from 'lib/cloudflare'

// Create vector client
const vectors = createVectorizeClient(env, {
  index: env.VECTORIZE_INDEX
})

// Insert vectors
await vectors.upsert([
  { id: 'doc-1', values: [0.1, 0.2, ...], metadata: { title: 'Doc 1' } },
  { id: 'doc-2', values: [0.3, 0.4, ...], metadata: { title: 'Doc 2' } }
])

// Query similar vectors
const results = await vectors.query({
  vector: queryVector,
  topK: 10,
  filter: { category: 'technical' }
})
```

### Semantic Search

```typescript
// Create semantic search client (combines AI + Vectorize)
const search = createSemanticSearchClient(env, {
  ai: env.AI,
  index: env.VECTORIZE_INDEX
})

// Index documents
await search.indexDocument({
  id: 'doc-123',
  content: 'Full document text...',
  metadata: { category: 'technical', author: 'alice' }
})

// Search by natural language query
const results = await search.search('How to deploy to production?', {
  topK: 5,
  filter: { category: 'technical' }
})
// => [{ id: 'doc-123', score: 0.95, metadata: {...} }, ...]
```

### Namespaced Vectors

```typescript
// Create namespaced client for tenant isolation
const tenantVectors = createNamespacedVectorizeClient(env, {
  index: env.VECTORIZE_INDEX,
  namespace: 'tenant-acme'
})

// Operations scoped to namespace
await tenantVectors.upsert([...])
const results = await tenantVectors.query({ ... })
```

## Workflows

Durable workflow definitions with saga patterns.

```typescript
import {
  createWorkflowDefinition,
  WorkflowBuilder,
  SagaBuilder,
  DotdoWorkflowEntrypoint
} from 'lib/cloudflare'

// Define workflow
const orderWorkflow = createWorkflowDefinition({
  name: 'process-order',
  steps: [
    { name: 'validate', handler: validateOrder },
    { name: 'charge', handler: chargePayment },
    { name: 'fulfill', handler: fulfillOrder },
    { name: 'notify', handler: sendNotification }
  ]
})

// Saga with compensation
const saga = new SagaBuilder()
  .step('reserve', reserveInventory, releaseInventory)
  .step('charge', chargeCard, refundCard)
  .step('ship', createShipment, cancelShipment)
  .build()
```

See [Workflows documentation](/docs/workflows) for detailed workflow patterns.

## Related

- [Storage](/docs/storage) - Storage tier documentation
- [Workflows](/docs/workflows) - Workflow orchestration
- [Deployment](/docs/deployment/cloudflare) - Cloudflare deployment
