---
title: Storage
description: JWT-authorized R2 storage with tenant isolation and chunked uploads
---

# Storage (lib/storage/)

The storage module provides secure, tenant-isolated access to Cloudflare R2 object storage. It combines JWT-based authorization with path construction to ensure data isolation between organizations and tenants.

## Overview

| Module | Purpose |
|--------|---------|
| `authorized-r2.ts` | JWT-authorized R2 client with tenant isolation |
| `chunked-upload.ts` | Resumable, chunked file uploads |

## AuthorizedR2Client

The `AuthorizedR2Client` constructs tenant-isolated storage paths from JWT claims and provides a secure interface to R2.

### Path Structure

All paths follow this structure for complete tenant isolation:

```
[pathPrefix/]orgs/{orgId}/tenants/{tenantId}/do/{doId}/{type}/
```

### Basic Usage

```typescript
import { AuthorizedR2Client, type R2Claims } from 'lib/storage/authorized-r2'

const claims: R2Claims = {
  orgId: 'acme',
  tenantId: 'tenant-123',
  bucket: 'production-data',
  pathPrefix: 'v1'
}

const client = new AuthorizedR2Client(claims, env.R2_BUCKET)

// All operations are scoped to this tenant's paths
await client.put('do-456', 'state.json', JSON.stringify(state))
const data = await client.get('do-456', 'state.json')
```

### Required Claims

```typescript
interface R2Claims {
  /** Organization ID (required) */
  orgId: string
  /** Tenant ID (required) */
  tenantId: string
  /** R2 bucket name (required) */
  bucket: string
  /** Path prefix for versioning or environment separation */
  pathPrefix: string
  /** Optional region hint */
  region?: string
}
```

### State Operations

```typescript
// Put state data
await client.put(doId, 'config.json', JSON.stringify(config))
await client.put(doId, 'data.bin', new Uint8Array([1, 2, 3]))

// Get state data
const obj = await client.get(doId, 'config.json')
if (obj) {
  const text = await obj.text()
  const config = JSON.parse(text)
}

// Check existence
const exists = await client.exists(doId, 'config.json')

// Delete state
await client.delete(doId, 'config.json')

// List objects
const list = await client.list(doId, 'state/', { limit: 100 })
```

### Conditional Operations

Support for conditional writes with etag matching:

```typescript
// Only create if not exists (for locking/fencing)
await client.putWithCondition(doId, 'lock.json', lockData, {
  onlyIfNotExists: true
})

// Update only if etag matches (optimistic concurrency)
await client.putWithCondition(doId, 'state.json', newState, {
  ifMatch: existingEtag
})

// Update only if etag doesn't match
await client.putWithCondition(doId, 'state.json', newState, {
  ifNoneMatch: staleEtag
})
```

### Snapshot Operations

Store and retrieve point-in-time snapshots:

```typescript
// Save a snapshot
await client.putSnapshot(doId, 'snap-001', 'state.json', stateData)
await client.putSnapshot(doId, 'snap-001', 'metadata.json', metadataJson)

// Retrieve a snapshot
const snapshot = await client.getSnapshot(doId, 'snap-001', 'state.json')
if (snapshot) {
  const data = await snapshot.json()
}

// List all snapshots
const snapshots = await client.listSnapshots(doId)
// Uses delimiter '/' to list snapshot directories
```

### Iceberg Operations

Support for Apache Iceberg table format:

```typescript
// Store Iceberg metadata
await client.putIcebergMetadata(doId, 'v1.metadata.json', metadataJson)
await client.putIcebergData(doId, '00001.parquet', parquetData)

// Read Iceberg metadata
const metadata = await client.getIcebergMetadata(doId, 'v1.metadata.json')

// List metadata files
const metadataFiles = await client.listIcebergMetadata(doId)
```

### Path Builders

Get paths for manual operations:

```typescript
// Base paths
client.getBasePath()
// => 'v1/orgs/acme/tenants/tenant-123/'

client.getDOBasePath('do-456')
// => 'v1/orgs/acme/tenants/tenant-123/do/do-456/'

// Specialized paths
client.getStatePath('do-456')
// => 'v1/orgs/acme/tenants/tenant-123/do/do-456/state/'

client.getSnapshotPath('do-456', 'snap-001')
// => 'v1/orgs/acme/tenants/tenant-123/do/do-456/snapshots/snap-001/'

client.getIcebergMetadataPath('do-456')
// => 'v1/orgs/acme/tenants/tenant-123/do/do-456/iceberg/metadata/'

client.getIcebergDataPath('do-456')
// => 'v1/orgs/acme/tenants/tenant-123/do/do-456/iceberg/data/'
```

## Security Features

### Path Traversal Protection

All path segments are validated to prevent directory traversal attacks:

```typescript
// These will throw errors
await client.put('do-456', '../escape.txt', data)
// Error: Path traversal detected in key

await client.getSnapshot('do-456', 'snap-../../attack', 'file.txt')
// Error: Path traversal detected in snapshotId
```

### Claim Validation

Required claims are validated at construction:

```typescript
// Missing required claims will throw
new AuthorizedR2Client({
  orgId: '',  // Error: Missing required claim: orgId
  tenantId: 'tenant-123',
  bucket: 'data',
  pathPrefix: ''
})
```

## Chunked Uploads

For large file uploads, use the chunked upload module:

```typescript
import { ChunkedUploadManager } from 'lib/storage/chunked-upload'

const manager = new ChunkedUploadManager({
  bucket: 'uploads',
  basePath: 'files',
  minChunkSize: 5 * 1024 * 1024,    // 5MB
  maxChunkSize: 100 * 1024 * 1024,  // 100MB
  maxTotalSize: 5 * 1024 * 1024 * 1024, // 5GB
  maxChunks: 1000,
  chunkTimeout: 30000,
  sessionTTL: 24 * 60 * 60 * 1000   // 24 hours
})

// Start a new upload session
const session = await manager.createSession({
  filename: 'large-file.zip',
  contentType: 'application/zip',
  totalSize: fileSize,
  metadata: { uploadedBy: 'user-123' }
})

// Upload chunks with progress tracking
for (let i = 0; i < session.expectedChunks; i++) {
  await manager.uploadChunk(session.id, {
    chunkIndex: i,
    data: chunkData,
    checksum: chunkMd5,
    checksumAlgorithm: 'md5'
  }, {
    onProgress: (progress) => {
      console.log(`${progress.percentage}% complete`)
    }
  })
}

// Complete the upload (reassembles chunks)
const result = await manager.complete(session.id)
console.log(`Uploaded to: ${result.finalPath}`)
```

### Upload Session Types

```typescript
interface UploadSession {
  id: string
  filename: string
  contentType: string
  totalSize: number
  expectedChunks: number
  metadata?: Record<string, string>
  status: 'pending' | 'in_progress' | 'completed' | 'aborted'
  createdAt: Date
  updatedAt: Date
  completedAt?: Date
  chunks: Map<number, ChunkInfo>
}

interface UploadProgress {
  percentage: number
  uploadedBytes: number
  totalBytes: number
  chunksUploaded: number
  totalChunks: number
  bytesPerSecond?: number
  estimatedTimeRemaining?: number
  elapsedTime: number
}
```

### Resume Interrupted Uploads

```typescript
// Get current upload state
const state = await manager.getState(sessionId)
console.log(`Missing chunks: ${state.missingChunks}`)

// Resume by uploading only missing chunks
for (const chunkIndex of state.missingChunks) {
  await manager.uploadChunk(sessionId, {
    chunkIndex,
    data: getChunkData(chunkIndex)
  })
}
```

### Abort Upload

```typescript
const result = await manager.abort(sessionId)
console.log(`Deleted ${result.chunksDeleted} chunks`)
```

### Verify Upload

```typescript
const verification = await manager.verify(sessionId)
if (!verification.valid) {
  console.log(`Corrupted chunks: ${verification.corruptedChunks}`)
}
```

## Integration with Auth

Common pattern combining auth and storage:

```typescript
import { extractStorageClaims } from 'lib/auth/jwt-storage-claims'
import { AuthorizedR2Client } from 'lib/storage/authorized-r2'

async function handleStorageRequest(request: Request, env: Env) {
  const jwt = request.headers.get('Authorization')?.replace('Bearer ', '')

  // Extract and validate claims
  const claims = await extractStorageClaims(jwt, env.JWT_SECRET)

  // Create tenant-isolated client
  const client = new AuthorizedR2Client({
    orgId: claims.orgId,
    tenantId: claims.tenantId || 'default',
    bucket: claims.bucket || env.DEFAULT_BUCKET,
    pathPrefix: claims.pathPrefix || 'v1'
  }, env.R2_BUCKET)

  // Operations are now safely scoped
  const doId = request.headers.get('X-DO-ID')
  const data = await client.get(doId, 'state.json')

  return new Response(data?.body, {
    headers: { 'Content-Type': 'application/json' }
  })
}
```

## R2 Types

The module provides TypeScript interfaces matching Cloudflare R2:

```typescript
import type {
  R2Bucket,
  R2Object,
  R2ObjectBody,
  R2Objects,
  R2PutOptions,
  R2ListOptions
} from 'lib/storage/authorized-r2'
```

## Type Exports

```typescript
import type {
  // R2 Client
  R2Claims,
  AuthorizedR2Client,
  R2Bucket,
  R2Object,
  R2ObjectBody,
  R2Objects,
  R2PutOptions,
  R2ListOptions,

  // Chunked Upload
  ChunkedUploadConfig,
  ChunkInfo,
  UploadSession,
  UploadProgress,
  UploadState,
  ChunkUploadRequest,
  ChunkUploadOptions,
  CompleteResult,
  AbortResult,
  VerifyResult
} from 'lib/storage'
```

## Related

- [Authentication](/docs/lib/auth) - JWT storage claims
- [Cloudflare Bindings](/docs/lib/cloudflare) - R2 wrapper utilities
- [State Storage](/docs/lib/state-storage) - DO state persistence
- [Iceberg](/docs/database/iceberg) - Iceberg table format
