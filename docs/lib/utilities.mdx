---
title: Common Utilities
description: Essential utility modules for identity, ID generation, type classification, and safe serialization
---

# Common Utilities

The `lib/` directory contains essential utility modules beyond the main capability systems. These utilities handle identity parsing, ID generation, type classification, and safe data handling.

## Identity Module

The `identity.ts` module provides utilities for parsing and building Durable Object identifiers.

### Parsing DO IDs

```typescript
import { parseDoId, buildDoId, resolveId } from 'lib/identity'

// Simple format: Type/id
const ref = parseDoId('Customer/alice')
// { type: 'Customer', id: 'alice' }

// URL format: https://namespace/Type/id
const ref2 = parseDoId('https://acme.api.do/Customer/alice')
// { namespace: 'https://acme.api.do', type: 'Customer', id: 'alice' }

// Nested path: Type/id/SubType/subId
const ref3 = parseDoId('Startup/acme/Product/widget')
// { type: 'Startup', id: 'acme', subPath: 'Product/widget' }
```

### Building DO IDs

```typescript
const doId = buildDoId({
  namespace: 'https://api.do',
  type: 'Order',
  id: 'ord-123'
})
// 'https://api.do/Order/ord-123'

const simpleId = buildDoId({ type: 'Customer', id: 'alice' })
// 'Customer/alice'
```

### Resolving IDs

```typescript
import { resolveId, TypeRegistry } from 'lib/identity'

const registry = new TypeRegistry()
registry.register('Customer', CustomerDO, { binding: 'CUSTOMER_DO' })

const result = await resolveId('Customer/alice', registry, env)
// {
//   DOClass: CustomerDO,
//   bindingName: 'CUSTOMER_DO',
//   doIdString: 'do:abc123:Customer/alice',
//   lookupKey: 'Customer/alice'
// }
```

### Type Definitions

```typescript
interface ParsedDoId {
  namespace?: string  // Optional URL namespace
  type: string        // The DO type (e.g., 'Customer')
  id: string          // The instance ID
  subPath?: string    // Nested path segments
}

interface BuildDoIdOptions {
  namespace?: string
  type: string
  id: string
}

interface ResolveIdResult {
  DOClass: DOClass           // The DO class constructor
  bindingName: string        // Environment binding name
  doIdString: string         // Generated DO ID string
  lookupKey: string          // Full lookup key with namespace
}
```

## Noun/ID Format

The `noun-id.ts` module parses the `Noun/id` format used throughout dotdo for Thing references.

### Basic Parsing

```typescript
import { parseNounId, formatNounId, isValidNounId } from 'lib/noun-id'

// Simple reference
const ref = parseNounId('Customer/acme')
// { noun: 'Customer', id: 'acme' }

// With special characters (URL-encoded)
const ref2 = parseNounId('Startup/headless.ly')
// { noun: 'Startup', id: 'headless.ly' }
```

### Nested Paths

```typescript
// Nested path: Startup/acme/Product/widget
const ref = parseNounId('Startup/acme/Product/widget')
// {
//   noun: 'Startup',
//   id: 'acme',
//   path: { noun: 'Product', id: 'widget' }
// }
```

### Version Modifiers

```typescript
// Branch reference
const ref = parseNounId('Startup/acme@experiment')
// { noun: 'Startup', id: 'acme', branch: 'experiment' }

// Specific version
const ref = parseNounId('Startup/acme@v1234')
// { noun: 'Startup', id: 'acme', version: 1234 }

// Relative version (one version back)
const ref = parseNounId('Startup/acme@~1')
// { noun: 'Startup', id: 'acme', relativeVersion: 1 }

// Version at timestamp
const ref = parseNounId('Startup/acme@2024-01-08')
// { noun: 'Startup', id: 'acme', timestamp: Date }
```

### Formatting

```typescript
const formatted = formatNounId({
  noun: 'Startup',
  id: 'acme',
  branch: 'experiment'
})
// 'Startup/acme@experiment'

const nested = formatNounId({
  noun: 'Startup',
  id: 'acme',
  path: { noun: 'Product', id: 'widget' }
})
// 'Startup/acme/Product/widget'
```

### Validation

```typescript
import { isValidNounId, isPascalCase } from 'lib/noun-id'

// Check validity
isValidNounId('Customer/acme')    // true
isValidNounId('customer/acme')    // false (noun must be PascalCase)
isValidNounId('Customer')         // false (must have id)

// Check PascalCase
isPascalCase('Customer')          // true
isPascalCase('customer')          // false
isPascalCase('CUSTOMER')          // false
isPascalCase('Customer123')       // true
```

### Type Definitions

```typescript
interface NounIdRef {
  noun: string              // PascalCase noun type
  id: string                // Instance identifier
  path?: NounIdRef          // Nested path
  branch?: string           // Branch name
  version?: number          // Specific version rowid
  relativeVersion?: number  // Relative version offset (~N)
  timestamp?: Date          // Version at timestamp
}
```

## Type Classifier

The `type-classifier.ts` module classifies function specifications into execution types.

### Classification Types

| Type | Description | Example Patterns |
|------|-------------|------------------|
| `code` | Pure deterministic functions | No AI/human patterns |
| `generative` | Single-shot AI generation | `ai\`...\``, OpenAI, Anthropic |
| `agentic` | Multi-step agent with tools | `amy\`...\``, agents, loops |
| `human` | Requires human input/approval | `user\`...\``, manual review |

### Usage

```typescript
import { classifyFunctionType, FunctionType } from 'lib/type-classifier'

// Pure code function
const result = classifyFunctionType(`
  function add(a, b) {
    return a + b
  }
`)
// { type: 'code', reasoning: 'No AI, agent, or human-in-the-loop patterns...' }

// Generative function
const result = classifyFunctionType(`
  const summary = await ai\`summarize \${document}\`
`)
// { type: 'generative', reasoning: 'Detected generative AI pattern...' }

// Agentic function
const result = classifyFunctionType(`
  const report = await amy\`research \${topic} and compile findings\`
`)
// { type: 'agentic', reasoning: 'Detected agentic pattern...' }

// Human function
const result = classifyFunctionType(`
  const approved = await user\`approve order \${orderId}\`
`)
// { type: 'human', reasoning: 'Detected human-in-the-loop pattern...' }
```

### Async Classification

```typescript
import { classifyFunctionTypeAsync } from 'lib/type-classifier'

// Async version for workflows
const result = await classifyFunctionTypeAsync(spec)
```

### Classification Priority

When multiple patterns are detected, the highest priority wins:

```
human > agentic > generative > code
```

## Safe Stringify

The `safe-stringify.ts` module provides JSON serialization that handles circular references.

### Basic Usage

```typescript
import { safeStringify, serializeError } from 'lib/safe-stringify'

// Handle circular references
const obj = { name: 'test' }
obj.self = obj  // Circular reference

const json = safeStringify(obj)
// '{"name":"test","self":"[Circular ~]"}'

// Safe error serialization
const error = new Error('Something went wrong')
error.cause = new Error('Root cause')

const errorJson = serializeError(error)
// {
//   name: 'Error',
//   message: 'Something went wrong',
//   stack: '...',
//   cause: { name: 'Error', message: 'Root cause', ... }
// }
```

### Options

```typescript
// Custom replacer
const json = safeStringify(data, (key, value) => {
  if (key === 'password') return '[REDACTED]'
  return value
})

// Custom indentation
const pretty = safeStringify(data, null, 2)
```

## Sqids (Short IDs)

The `sqids.ts` module generates short, unique, URL-safe IDs using the Sqids algorithm.

### Basic Usage

```typescript
import { sqids, Tag } from 'lib/sqids'

// Encode tag-value pairs
const id = sqids.encode([Tag.THING, 42, Tag.BRANCH, 7])
// 'Xk2Pf9'

// Decode to self-describing object
const decoded = sqids.decode('Xk2Pf9')
// { THING: 42, BRANCH: 7 }
```

### Available Tags

| Tag | Purpose |
|-----|---------|
| `THING` | Thing identifier |
| `BRANCH` | Branch identifier |
| `VERSION` | Version number |
| `ACTION` | Action identifier |
| `EVENT` | Event identifier |

### Custom Alphabet

```typescript
import { Sqids } from 'lib/sqids'

// Create with custom alphabet
const customSqids = new Sqids({
  alphabet: 'abcdefghijklmnopqrstuvwxyz0123456789'
})
```

## Rate Limiting

The `rate-limit.ts` module provides rate limiting utilities for API protection.

### Basic Usage

```typescript
import { RateLimitWrapper } from 'lib/rate-limit'

const limiter = new RateLimitWrapper(env.RATE_LIMIT_API)

// Check rate limit
const result = await limiter.checkLimit('user:123')

if (!result.success) {
  throw new Error(`Rate limited. Retry after ${result.retryAfter}ms`)
}
```

### Composite Keys

```typescript
// Build structured rate limit keys
const key = limiter.buildKey({
  userId: '123',
  endpoint: '/api/users',
  action: 'create'
})
// 'user:123:endpoint:/api/users:action:create'
```

## TypeRegistry

The `TypeRegistry.ts` module manages DO type registration for routing and resolution.

### Registration

```typescript
import { TypeRegistry } from 'lib/TypeRegistry'

const registry = new TypeRegistry()

// Register a DO type
registry.register('Customer', CustomerDO, {
  binding: 'CUSTOMER_DO',
  description: 'Customer management DO'
})

// Check if registered
registry.has('Customer')  // true

// Get class
const DOClass = registry.get('Customer')

// Get metadata
const meta = registry.getMetadata('Customer')
// { binding: 'CUSTOMER_DO', description: '...' }
```

### Iteration

```typescript
// List all types
const types = registry.list()
// ['Customer', 'Order', 'Product']

// Iterate with metadata
for (const [type, metadata] of registry.entries()) {
  console.log(`${type}: ${metadata.binding}`)
}
```

## Related

- [Auto-Wiring](/docs/lib/auto-wiring) - Reflection-based API exposure
- [Capabilities](/docs/lib/capabilities) - Lazy-loading system
- [StateStorage](/docs/lib/state-storage) - State management
- [DO Capabilities](/docs/lib/do-capabilities) - Filesystem, Git, Bash, NPM
