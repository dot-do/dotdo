---
title: Capability System
description: Lazy-loading capability modules for Durable Objects
---

# Capability System

The capability system provides lazy loading of modules like `$.fs`, `$.git`, and `$.bash`. Capabilities are loaded on first access and cached for subsequent use.

## Overview

```typescript
import {
  CapabilityRegistry,
  createCapabilityProxy,
  CapabilityError
} from 'lib/capabilities'

// Create a registry
const registry = new CapabilityRegistry()

// Register capabilities
registry.register('fs', FsModule)
registry.register('git', GitModule)

// Create a proxy for the $ context
const $ = createCapabilityProxy(registry)

// Access capabilities (lazy loaded)
await $.fs.write('/config.json', data)
await $.git.commit('Update config')
```

## CapabilityRegistry

The registry manages capability modules with lazy loading.

### Registering Modules

```typescript
const registry = new CapabilityRegistry()

// Register a module constructor
registry.register('fs', FsModule)

// Register with options
registry.register('git', GitModule, {
  passContext: true  // Pass registry context to constructor
})

// Force re-registration
registry.register('fs', NewFsModule, { force: true })
```

### Registering Factories

For async initialization:

```typescript
// Register async factory
registry.registerFactory('database', async () => {
  const db = new Database()
  await db.connect()
  return db
})

// Factory is called on first access
await $.database.query('SELECT * FROM users')
```

### Checking Registration

```typescript
// Check if registered
if (registry.has('fs')) {
  console.log('fs capability available')
}

// List all capabilities
const capabilities = registry.list()
// => ['fs', 'git', 'bash', 'database']

// Check if loaded (instantiated)
if (registry.isLoaded('fs')) {
  console.log('fs already initialized')
}
```

### Unregistering

```typescript
// Unregister a capability
const existed = registry.unregister('oldModule')
// => true if it was registered
```

## createCapabilityProxy

Creates a proxy object for accessing capabilities through the `$` context.

```typescript
import { createCapabilityProxy } from 'lib/capabilities'

const $ = createCapabilityProxy(registry, {
  reservedNames: ['on', 'every', 'send', 'do']
})

// Access capabilities
await $.fs.read('/config.json')
await $.git.status()
await $.bash.exec('ls -la')

// Reserved names return undefined instead of throwing
$.on  // => undefined (reserved for event handlers)
```

### Proxy Behavior

```typescript
// Property access gets capability
const fs = $.fs  // Loads FsModule on first access

// in operator works
'fs' in $  // => true
'unknown' in $  // => false

// Enumeration works
Object.keys($)  // => ['fs', 'git', 'bash', ...]

// Property descriptors
Object.getOwnPropertyDescriptor($, 'fs')
// => { configurable: true, enumerable: true, writable: false, value: FsModule }
```

## Lazy Loading

Capabilities are loaded only when first accessed:

```typescript
const registry = new CapabilityRegistry()

// Register - no instantiation yet
registry.register('heavy', HeavyModule)

console.log(registry.isLoaded('heavy'))  // false

// First access triggers instantiation
const heavy = $.heavy
console.log(registry.isLoaded('heavy'))  // true

// Subsequent access returns cached instance
const same = $.heavy
console.assert(heavy === same)
```

## Async Factories

For capabilities requiring async initialization:

```typescript
registry.registerFactory('redis', async () => {
  const client = new RedisClient()
  await client.connect()
  return client
})

// Returns a proxy that awaits the factory
const result = await $.redis.get('key')

// Methods are automatically awaited
const keys = await $.redis.keys('user:*')
```

The factory proxy:
1. Calls the factory on first method access
2. Awaits the factory result
3. Caches the resolved instance
4. Forwards method calls to the instance

## Error Handling

```typescript
import { CapabilityError } from 'lib/capabilities'

try {
  // Access unregistered capability
  $.unknown.doSomething()
} catch (error) {
  if (error instanceof CapabilityError) {
    console.log(error.capability)  // 'unknown'
    console.log(error.reason)      // 'not_available'
    // Error message includes available capabilities
  }
}
```

### Error Reasons

| Reason | Description |
|--------|-------------|
| `not_available` | Capability not registered |
| `permission_denied` | Access not allowed |
| `load_failed` | Module failed to load |

## Cleanup

The registry supports cleanup for loaded capabilities:

```typescript
// Destroy registry and cleanup all capabilities
const result = await registry.destroy()

if (result.errors.length > 0) {
  for (const { capability, error } of result.errors) {
    console.error(`Failed to cleanup ${capability}:`, error)
  }
}
```

### Disposable Pattern

Capabilities can implement cleanup:

```typescript
class DatabaseCapability {
  private connection: Connection

  async connect() {
    this.connection = await createConnection()
  }

  // Called by registry.destroy()
  async dispose() {
    await this.connection.close()
  }

  // Or use Symbol.dispose
  [Symbol.dispose]() {
    this.connection.closeSync()
  }
}
```

## Options

### CapabilityOptions

```typescript
interface CapabilityOptions {
  force?: boolean       // Re-register even if exists
  passContext?: boolean // Pass registry context to constructor
}
```

### CapabilityProxyOptions

```typescript
interface CapabilityProxyOptions {
  reservedNames?: string[]  // Names that return undefined
}
```

## Type Definitions

```typescript
// Capability module constructor
type CapabilityModule = new (...args: unknown[]) => unknown

// Async factory function
type CapabilityFactory = () => Promise<unknown>

// Destroy result
interface DestroyResult {
  errors: Array<{ capability: string; error: Error }>
}

// Proxy type
type CapabilityProxy = Record<string, unknown>
```

## Usage with Durable Objects

In DO classes, capabilities are typically set up during initialization:

```typescript
import { DO } from 'objects/DO'
import { CapabilityRegistry, createCapabilityProxy } from 'lib/capabilities'
import { FsModule } from 'lib/mixins/fs'
import { GitModule } from 'lib/mixins/git'

class MyDO extends DO {
  private registry = new CapabilityRegistry()
  protected $: CapabilityProxy

  constructor(state: DurableObjectState, env: Env) {
    super(state, env)

    // Register capabilities
    this.registry.register('fs', FsModule)
    this.registry.register('git', GitModule)

    // Create proxy
    this.$ = createCapabilityProxy(this.registry, {
      reservedNames: ['on', 'every', 'send', 'do', 'try']
    })
  }

  async initialize() {
    // Use capabilities
    await this.$.fs.mkdir('/data')
    await this.$.git.init()
  }
}
```

## Related

- [Mixins](/docs/lib/mixins) - DO capability mixins
- [StateStorage](/docs/lib/state-storage) - State management
- [Auto-Wiring](/docs/lib/auto-wiring) - API exposure
