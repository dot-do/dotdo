---
title: Function Executors
description: Execute functions via code, AI agents, generative models, or human input
---

# Function Executors

Function Executors provide a unified interface for executing functions across different execution strategies. They enable workflows to seamlessly route tasks to code, AI agents, generative models, or human reviewers based on the requirements.

## Overview

The executor system follows a common pattern:
- All executors operate within a Durable Object context
- They provide retry logic, timeout handling, and event emission
- Results include success status, duration, and execution metrics
- They integrate with the `$` workflow context

| Executor | Best For | Speed | Cost |
|----------|----------|-------|------|
| `CodeFunctionExecutor` | Deterministic logic, transformations | Fastest | Lowest |
| `GenerativeFunctionExecutor` | Content generation, structured outputs | Fast | Medium |
| `AgenticFunctionExecutor` | Multi-step reasoning with tools | Medium | Higher |
| `HumanFunctionExecutor` | Judgment calls, approvals | Slowest | Highest |
| `CascadeExecutor` | Automatic escalation on failure | Varies | Optimized |
| `ParallelStepExecutor` | Concurrent workflow steps | Fast | Varies |

## CodeFunctionExecutor

Executes TypeScript/JavaScript handlers in a controlled environment with sandboxing, timeout handling, and resource limits.

### Features

- Sandboxed execution with restricted globals
- Timeout and cancellation support
- Retry logic with configurable backoff strategies
- Streaming output support
- Resource limits (memory, CPU time, output size)
- Input/output schema validation

### Basic Usage

```typescript
import { CodeFunctionExecutor } from 'lib/executors/CodeFunctionExecutor'

const executor = new CodeFunctionExecutor({
  state: this.state,
  env: this.env,
  services: {
    ai: this.ai,
    kv: this.kv,
    db: this.db,
    queue: this.queue,
    fetch: fetch,
  },
  logger: console,
  onEvent: (event, data) => console.log(event, data),
})

// Execute a handler
const result = await executor.execute(
  async (input, ctx) => {
    ctx.log.info('Processing', { input })
    const data = await ctx.services.db.query('SELECT * FROM users WHERE id = ?', [input.userId])
    return { user: data[0] }
  },
  { userId: '123' },
  {
    timeout: 5000,
    sandboxed: true,
    retry: {
      maxAttempts: 3,
      delay: 100,
      backoff: 'exponential',
    },
  }
)

if (result.success) {
  console.log('User:', result.result.user)
} else {
  console.error('Error:', result.error)
}
```

### Execution Context

Handlers receive a rich execution context:

```typescript
interface ExecutionContext {
  functionId: string
  invocationId: string
  env: Record<string, string>  // Read-only environment variables
  state: {
    get: <T>(key: string) => Promise<T | null>
    put: <T>(key: string, value: T) => Promise<void>
    delete: (key: string) => Promise<boolean>
    list: (options?: { prefix?: string }) => Promise<Map<string, unknown>>
  }
  services: {
    ai: { generate: (opts) => Promise<{ text: string }> }
    kv: { get, put }
    db: { query }
    queue: { send }
    fetch: typeof fetch
  }
  log: { debug, info, warn, error }
  emit: (event: string, data: unknown) => Promise<void>
  signal: AbortSignal
}
```

### Streaming Execution

```typescript
const stream = await executor.executeStreaming(
  async function* (input, ctx) {
    for (const item of input.items) {
      await ctx.emit('stream.chunk', { data: item.name })
      yield { processed: item.id }
    }
    return { total: input.items.length }
  },
  { items: [{ id: 1, name: 'A' }, { id: 2, name: 'B' }] }
)

for await (const chunk of stream) {
  if (chunk.type === 'chunk') {
    console.log('Chunk:', chunk.data)
  } else if (chunk.type === 'result') {
    console.log('Final:', chunk.value)
  }
}
```

### Retry Strategies

```typescript
const result = await executor.execute(handler, input, {
  retry: {
    maxAttempts: 5,
    delay: 100,
    backoff: 'exponential-jitter',  // 'fixed' | 'exponential' | 'exponential-jitter' | 'linear'
    maxDelay: 10000,
    retryOnTimeout: false,
    retryIf: (error) => error.message.includes('transient'),
    onRetry: ({ attempt, delay, error }) => {
      console.log(`Retry ${attempt} after ${delay}ms: ${error.message}`)
    },
  },
})
```

### Options Reference

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | `number` | `30000` | Max execution time (ms) |
| `sandboxed` | `boolean` | `true` | Restrict global access |
| `exposeEnv` | `string[]` | all | Whitelist of env vars to expose |
| `retry.maxAttempts` | `number` | `1` | Max retry attempts |
| `retry.delay` | `number` | `1000` | Base delay between retries (ms) |
| `retry.backoff` | `string` | `'fixed'` | Backoff strategy |
| `resourceLimits.maxMemory` | `number` | `128MB` | Memory limit |
| `resourceLimits.maxCpuTime` | `number` | - | CPU time limit (ms) |
| `resourceLimits.maxOutputSize` | `number` | `10MB` | Max output size |
| `inputSchema` | `JSONSchema` | - | Validate input against schema |
| `outputSchema` | `JSONSchema` | - | Validate output against schema |

## GenerativeFunctionExecutor

Calls language models for AI-powered generation with schema validation.

```typescript
import { GenerativeFunctionExecutor } from 'lib/executors/GenerativeFunctionExecutor'

const executor = new GenerativeFunctionExecutor({
  model: 'claude-sonnet-4-20250514',
  temperature: 0.7,
  maxTokens: 1000
})

const result = await executor.execute({
  prompt: 'Summarize this article: {{text}}',
  input: { text: 'Long article content...' },
  schema: {
    type: 'object',
    properties: {
      summary: { type: 'string' },
      keyPoints: { type: 'array', items: { type: 'string' } }
    }
  }
})
```

### Template Substitution

Prompts support `{{variable}}` substitution:

```typescript
const result = await executor.execute({
  prompt: `
    Write a {{tone}} email to {{recipient}} about {{topic}}.
    Keep it under {{wordLimit}} words.
  `,
  input: {
    tone: 'professional',
    recipient: 'the engineering team',
    topic: 'the upcoming release',
    wordLimit: 200
  }
})
```

### Streaming

```typescript
const executor = new GenerativeFunctionExecutor({
  model: 'claude-sonnet-4-20250514',
  stream: true
})

const stream = await executor.execute({
  prompt: 'Write a long story about {{topic}}',
  input: { topic: 'space exploration' }
})

for await (const chunk of stream) {
  process.stdout.write(chunk.text)
}
```

### Structured Output

```typescript
const result = await executor.execute({
  prompt: 'Extract entities from: {{text}}',
  input: { text: 'John works at Acme Corp in New York' },
  schema: {
    type: 'object',
    properties: {
      people: { type: 'array', items: { type: 'string' } },
      organizations: { type: 'array', items: { type: 'string' } },
      locations: { type: 'array', items: { type: 'string' } }
    },
    required: ['people', 'organizations', 'locations']
  }
})

// result = {
//   people: ['John'],
//   organizations: ['Acme Corp'],
//   locations: ['New York']
// }
```

## AgenticFunctionExecutor

Orchestrates multi-step AI agents with tool access and iteration limits.

```typescript
import { AgenticFunctionExecutor } from 'lib/executors/AgenticFunctionExecutor'

const executor = new AgenticFunctionExecutor({
  agent: 'ralph',
  tools: ['code_search', 'file_read', 'file_edit', 'run_tests'],
  maxIterations: 15,
  systemPrompt: 'You are a senior software engineer.'
})

const result = await executor.execute({
  input: {
    task: 'Implement user authentication',
    requirements: ['JWT tokens', 'Password hashing']
  },
  onStep: async (step) => {
    console.log(`Step ${step.iteration}: ${step.thought}`)
    if (step.action) {
      console.log(`  Action: ${step.action}`)
    }
    if (step.observation) {
      console.log(`  Observation: ${step.observation}`)
    }
  }
})
```

### Agent Steps

```typescript
interface AgentStep {
  iteration: number
  thought: string
  action?: string
  observation?: string
}
```

### Tool Configuration

```typescript
const executor = new AgenticFunctionExecutor({
  agent: 'research-agent',
  tools: [
    'web_search',      // Search the web
    'scrape_url',      // Extract content from URLs
    'summarize',       // Summarize text
    'code_search',     // Search codebase
    'file_read',       // Read files
    'file_edit',       // Edit files
    'run_tests',       // Run test suites
    'shell_exec'       // Execute shell commands
  ],
  maxIterations: 20
})
```

## HumanFunctionExecutor

Queues tasks for human input through notification channels.

```typescript
import { HumanFunctionExecutor } from 'lib/executors/HumanFunctionExecutor'

const executor = new HumanFunctionExecutor({
  channel: 'slack:finance-approvals',
  timeout: 14400000, // 4 hours
  escalation: {
    timeout: 7200000, // 2 hours
    to: 'slack:vp-finance'
  }
})

const response = await executor.execute({
  prompt: (input) => `
    Refund Request
    Customer: ${input.customerId}
    Amount: $${input.amount.toFixed(2)}
    Reason: ${input.reason}

    Please approve or reject.
  `,
  input: {
    customerId: 'CUST-456',
    amount: 150.00,
    reason: 'Product defect'
  },
  form: {
    fields: [
      { name: 'decision', type: 'select', label: 'Decision',
        options: ['approve', 'reject'] },
      { name: 'notes', type: 'text', label: 'Notes' }
    ]
  }
})
```

### Form Fields

```typescript
interface FormField {
  name: string
  type: 'text' | 'number' | 'boolean' | 'select' | 'multiselect'
  label: string
  required?: boolean
  options?: string[]  // For select/multiselect
  validation?: (value: unknown) => boolean | string
}
```

### Escalation

If no response within the escalation timeout, the request is forwarded:

```typescript
const executor = new HumanFunctionExecutor({
  channel: 'slack:approvals',
  timeout: 14400000,     // Total timeout: 4 hours
  escalation: {
    timeout: 7200000,    // Escalate after: 2 hours
    to: 'slack:management'
  }
})
```

## CascadeExecutor

Tries multiple executors in sequence until one succeeds.

```typescript
import { CascadeExecutor } from 'lib/executors/CascadeExecutor'

const executor = new CascadeExecutor([
  new CodeFunctionExecutor({ timeout: 1000 }),
  new GenerativeFunctionExecutor({ model: 'claude-haiku' }),
  new GenerativeFunctionExecutor({ model: 'claude-sonnet-4-20250514' })
])

// Tries code first, falls back to AI if it fails
const result = await executor.execute({
  handler: computeResult,
  prompt: 'Generate a result for {{input}}',
  input: data
})
```

### Fallback Strategies

```typescript
const executor = new CascadeExecutor(
  executors,
  {
    stopOnSuccess: true,    // Stop at first success
    collectErrors: true,    // Gather all errors
    onFallback: (from, to, error) => {
      console.log(`Falling back from ${from} to ${to}: ${error.message}`)
    }
  }
)
```

## ParallelStepExecutor

Executes multiple workflow steps concurrently.

```typescript
import { ParallelStepExecutor } from 'lib/executors/ParallelStepExecutor'

const executor = new ParallelStepExecutor({
  maxConcurrency: 5,
  collectMode: 'allSettled'
})

const results = await executor.execute([
  { name: 'fetchUser', fn: () => fetchUser(userId) },
  { name: 'fetchOrders', fn: () => fetchOrders(userId) },
  { name: 'fetchRecommendations', fn: () => getRecommendations(userId) }
])

// Results keyed by step name
// {
//   fetchUser: { status: 'fulfilled', value: user },
//   fetchOrders: { status: 'fulfilled', value: orders },
//   fetchRecommendations: { status: 'rejected', reason: error }
// }
```

### Collection Modes

| Mode | Behavior |
|------|----------|
| `all` | Fail fast on first error |
| `allSettled` | Collect all results regardless of errors |

## BaseFunctionExecutor

Base class for creating custom executors:

```typescript
import { BaseFunctionExecutor } from 'lib/executors/BaseFunctionExecutor'

class CustomExecutor extends BaseFunctionExecutor {
  async execute(config) {
    // Pre-execution setup
    this.beforeExecute(config)

    try {
      // Custom execution logic
      const result = await this.customLogic(config)

      // Post-execution cleanup
      this.afterExecute(result)

      return result
    } catch (error) {
      this.onError(error)
      throw error
    }
  }
}
```

## Step Context

Executors receive a `StepContext` when running within workflows:

```typescript
interface StepContext {
  input: unknown
  previousStepOutput?: unknown
  stepName: string
  stepIndex: number
  workflowInstanceId: string
  waitForEvent: <T>(eventName: string, options?) => Promise<T>
  $: Record<string, unknown>  // Domain proxy
  emit: (event: string, data: unknown) => void
}
```

## Error Types

```typescript
import { ExecutionError } from 'lib/functions/createFunction'

try {
  await executor.execute(config)
} catch (error) {
  if (error instanceof ExecutionError) {
    console.error('Execution failed:', error.message)
  }
}
```

## Related

- [createFunction Factory](/docs/functions/create-function) - Create functions
- [Function Registry](/docs/lib/functions) - Register and discover
- [Workflows](/docs/workflows) - Orchestrate execution
