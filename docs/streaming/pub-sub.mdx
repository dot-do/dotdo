---
title: Pub/Sub (Subscriptions)
description: Topic-based publish/subscribe messaging with wildcard pattern matching
---

# Pub/Sub (Subscriptions)

The `SubscriptionManager` provides topic-based publish/subscribe messaging with support for wildcard patterns. It enables efficient message routing to interested subscribers.

## Basic Usage

```typescript
import { SubscriptionManager } from 'dotdo/streaming'

const manager = new SubscriptionManager()

// Subscribe to a topic
manager.subscribe(ws, 'orders.created')

// Publish to subscribers
manager.publish('orders.created', {
  orderId: '123',
  total: 99.99,
})
```

## Subscribing

### Single Topic

```typescript
manager.subscribe(ws, 'orders.created')
```

### Multiple Topics

```typescript
manager.subscribe(ws, 'orders.created')
manager.subscribe(ws, 'orders.updated')
manager.subscribe(ws, 'payments.received')
```

### Idempotent Subscription

Subscribing multiple times to the same topic is a no-op:

```typescript
manager.subscribe(ws, 'orders')
manager.subscribe(ws, 'orders') // No effect
manager.subscribe(ws, 'orders') // No effect

manager.getSubscriptions(ws) // ['orders']
```

## Topic Patterns

Topics use dot-separated segments (e.g., `orders.created`, `users.123.profile`). Patterns support two wildcard types for flexible matching.

> **Note:** Wildcards are matched when publishing, not when subscribing. Subscribe to patterns like `orders.*` and they will match published topics like `orders.created`.

### Exact Match

```typescript
manager.subscribe(ws, 'orders.created')
// Receives: orders.created
// Ignores: orders.updated, orders.items.added
```

### Single-Segment Wildcard (`*`)

The `*` wildcard matches exactly one segment:

```typescript
manager.subscribe(ws, 'orders.*')
// Receives: orders.created, orders.updated, orders.deleted
// Ignores: orders.items.added (has 3 segments, pattern has 2)
```

Segment count must match:
```
Topic:    orders.created      (2 segments)
Pattern:  orders.*            (2 segments) -> MATCH

Topic:    orders.items.added  (3 segments)
Pattern:  orders.*            (2 segments) -> NO MATCH
```

### Multi-Segment Wildcard (`**`)

The `**` wildcard matches one or more segments:

```typescript
manager.subscribe(ws, 'orders.**')
// Receives: orders.created
// Receives: orders.items.added
// Receives: orders.items.quantity.updated
```

Think of `**` as "everything under this prefix":
```
Pattern: orders.**

Matches:
  orders.created                -> YES (1 segment after orders)
  orders.items.added            -> YES (2 segments after orders)
  orders.items.qty.updated      -> YES (3 segments after orders)

Does NOT match:
  products.created              -> NO (different prefix)
```

### Pattern at Start

```typescript
manager.subscribe(ws, '*.created')
// Receives: orders.created, products.created, users.created
// Ignores: orders.updated
```

### Multiple Wildcards

```typescript
manager.subscribe(ws, '*.orders.*')
// Receives: us.orders.created, eu.orders.updated
// Ignores: orders.created (only 2 segments)
```

## Publishing

### Basic Publish

```typescript
const count = manager.publish('orders.created', {
  orderId: '123',
  customerId: 'cust-456',
})

console.log(`Notified ${count} subscribers`)
```

### Message Serialization

Objects are automatically JSON serialized:

```typescript
manager.publish('events', {
  type: 'order',
  data: { id: '123', total: 99.99 },
  timestamp: Date.now(),
})
// Sends: {"type":"order","data":{"id":"123","total":99.99},"timestamp":...}
```

### Pattern Matching on Publish

When publishing, all matching pattern subscribers are notified. Each subscriber receives the message at most once, even if multiple patterns match:

```typescript
// Subscribers
manager.subscribe(ws1, 'orders.created')  // Exact match
manager.subscribe(ws2, 'orders.*')        // Single wildcard
manager.subscribe(ws3, 'orders.**')       // Multi wildcard
manager.subscribe(ws4, '*.created')       // Prefix wildcard

// Publish
manager.publish('orders.created', { id: '123' })
// All 4 subscribers receive the message exactly once (deduplicated)
```

> **Important:** Messages are deduplicated per WebSocket. If a client subscribes to both `orders.created` and `orders.*`, they receive the message only once when publishing to `orders.created`.

### Closed Connections are Skipped

Publishing automatically skips WebSockets that are not in OPEN state:

```typescript
// If ws2 is closed, only ws1 and ws3 receive the message
const count = manager.publish('events', { data: 'test' })
console.log(`Sent to ${count} active connections`)
```

## Unsubscribing

### Single Topic

```typescript
manager.unsubscribe(ws, 'orders.created')
```

### All Topics

```typescript
manager.unsubscribeAll(ws)
```

## Querying

### Check Subscription

```typescript
if (manager.isSubscribed(ws, 'orders.created')) {
  console.log('Client is watching orders')
}
```

### Get Client's Subscriptions

```typescript
const topics = manager.getSubscriptions(ws)
// ['orders.created', 'orders.updated', 'payments.*']
```

### Get Topic's Subscribers

```typescript
const subscribers = manager.getSubscribers('orders.created')
// [ws1, ws2, ws3]
```

### Topic Statistics

```typescript
const stats = manager.getTopicStats()
// Map { 'orders.created' => 5, 'payments.*' => 3 }

for (const [topic, count] of stats) {
  console.log(`${topic}: ${count} subscribers`)
}
```

## Cleanup

### Remove Stale Connections

```typescript
const removed = manager.cleanupStale()
console.log(`Cleaned up ${removed} stale connections`)
```

### Dispose Manager

```typescript
manager.dispose()
```

## matchesTopic() Function

The `matchesTopic()` utility function is exported for custom matching logic:

```typescript
import { matchesTopic } from 'dotdo/streaming'

matchesTopic('orders.created', 'orders.created')  // true
matchesTopic('orders.created', 'orders.*')        // true
matchesTopic('orders.created', 'orders.**')       // true
matchesTopic('orders.items.added', 'orders.*')    // false
matchesTopic('orders.items.added', 'orders.**')   // true
matchesTopic('orders.created', '*.created')       // true
```

## Complete Example

```typescript
import { WebSocketHub, SubscriptionManager } from 'dotdo/streaming'

export class EventBusDO extends DurableObject {
  private hub = new WebSocketHub()
  private subs = new SubscriptionManager()

  async fetch(request: Request): Promise<Response> {
    if (request.headers.get('Upgrade') === 'websocket') {
      return this.handleWebSocket(request)
    }

    // HTTP endpoint to publish events
    if (request.method === 'POST') {
      const { topic, data } = await request.json()
      const count = this.subs.publish(topic, data)
      return Response.json({ published: true, subscribers: count })
    }

    return new Response('Not found', { status: 404 })
  }

  private handleWebSocket(request: Request): Response {
    const [client, server] = Object.values(new WebSocketPair())

    this.hub.connect(server)
    server.accept()

    server.addEventListener('message', (event) => {
      const msg = JSON.parse(event.data as string)

      switch (msg.type) {
        case 'subscribe':
          this.subs.subscribe(server, msg.topic)
          server.send(JSON.stringify({
            type: 'subscribed',
            topic: msg.topic,
          }))
          break

        case 'unsubscribe':
          this.subs.unsubscribe(server, msg.topic)
          server.send(JSON.stringify({
            type: 'unsubscribed',
            topic: msg.topic,
          }))
          break

        case 'publish':
          const count = this.subs.publish(msg.topic, msg.data)
          server.send(JSON.stringify({
            type: 'published',
            topic: msg.topic,
            subscribers: count,
          }))
          break

        case 'list':
          server.send(JSON.stringify({
            type: 'subscriptions',
            topics: this.subs.getSubscriptions(server),
          }))
          break
      }
    })

    server.addEventListener('close', () => {
      this.subs.unsubscribeAll(server)
      this.hub.disconnect(server)
    })

    return new Response(null, { status: 101, webSocket: client })
  }
}
```

## Client Usage

```typescript
const ws = new WebSocket('wss://events.example.com')

ws.onopen = () => {
  // Subscribe to topics
  ws.send(JSON.stringify({
    type: 'subscribe',
    topic: 'orders.*',
  }))

  ws.send(JSON.stringify({
    type: 'subscribe',
    topic: 'users.123.**',  // All events for user 123
  }))
}

ws.onmessage = (event) => {
  const data = JSON.parse(event.data)

  if (data.type === 'subscribed') {
    console.log(`Subscribed to ${data.topic}`)
  } else {
    // Received published message
    console.log('Event:', data)
  }
}
```

## Pattern Syntax Reference

| Pattern | Matches | Does Not Match |
|---------|---------|----------------|
| `orders.created` | `orders.created` | `orders.updated` |
| `orders.*` | `orders.created`, `orders.updated` | `orders.items.added` |
| `orders.**` | `orders.created`, `orders.items.added`, `orders.items.qty.updated` | `products.created` |
| `*.created` | `orders.created`, `products.created` | `orders.updated` |
| `*.orders.*` | `us.orders.created`, `eu.orders.updated` | `orders.created` |

## API Reference

### SubscriptionManager

```typescript
class SubscriptionManager {
  subscribe(ws: WebSocket, topic: string): void
  unsubscribe(ws: WebSocket, topic: string): void
  unsubscribeAll(ws: WebSocket): void
  isSubscribed(ws: WebSocket, topic: string): boolean
  getSubscriptions(ws: WebSocket): string[]
  getSubscribers(topic: string): WebSocket[]
  publish(topic: string, message: unknown): number
  getTopicStats(): Map<string, number>
  cleanupStale(): number
  dispose(): void
}
```

### matchesTopic()

```typescript
function matchesTopic(topic: string, pattern: string): boolean
```

Returns `true` if the topic matches the pattern.

## Related

- [WebSocket Hub](/streaming/websocket-hub) - Connection management and rooms
- [Rate Limiting](/streaming/rate-limiting) - Limit publish/subscribe rates
