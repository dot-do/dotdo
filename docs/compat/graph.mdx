---
title: Graph
description: API-compatible graph database SDKs for Neo4j.
---

# Graph Compat SDKs

Neo4j API, rebuilt on Durable Objects. Graph queries at the edge.

## The Problem

When AI agents need to traverse relationships:

- **Neo4j** requires dedicated clusters with complex scaling
- **Graph queries** need low latency for interactive applications
- **Connection pooling** becomes a bottleneck at scale
- **Hosting costs** explode with graph size

The real problem: traditional graph databases are designed for batch analytics, not edge-native, per-tenant workloads.

The solution: DO-native graph storage. Each tenant's graph lives in a Durable Object with SQLite. Cypher queries execute at the edge. No connection pools. No cluster management.

## Quick Start

```typescript
import { driver } from '@dotdo/neo4j'

const neo4j = driver(
  'neo4j://localhost',
  { username: 'neo4j', password: 'password' }
)

const session = neo4j.session()

const result = await session.run(
  'MATCH (u:User {id: $userId})-[:FOLLOWS]->(following) RETURN following',
  { userId: 'user-123' }
)

for (const record of result.records) {
  console.log(record.get('following').properties)
}

await session.close()
```

## Available SDKs

### @dotdo/neo4j

Neo4j driver API compatible. Full Cypher query support.

```typescript
import { driver, auth } from '@dotdo/neo4j'

const neo4j = driver(
  process.env.NEO4J_URI,
  auth.basic('neo4j', process.env.NEO4J_PASSWORD),
  {
    shardKey: 'tenantId', // Partition graphs by tenant
  }
)

// Get a session
const session = neo4j.session({
  database: 'neo4j',
  defaultAccessMode: 'WRITE',
})

try {
  // Create nodes
  await session.run(`
    CREATE (u:User {
      id: $id,
      name: $name,
      email: $email,
      createdAt: datetime()
    })
  `, {
    id: 'user-123',
    name: 'Alice',
    email: 'alice@example.com',
  })

  // Create relationships
  await session.run(`
    MATCH (a:User {id: $fromId})
    MATCH (b:User {id: $toId})
    CREATE (a)-[:FOLLOWS {since: datetime()}]->(b)
  `, {
    fromId: 'user-123',
    toId: 'user-456',
  })

  // Query with traversal
  const result = await session.run(`
    MATCH (u:User {id: $userId})-[:FOLLOWS*1..2]->(fof:User)
    WHERE fof.id <> $userId
    RETURN DISTINCT fof.name as name, fof.id as id
    ORDER BY fof.name
    LIMIT 10
  `, { userId: 'user-123' })

  for (const record of result.records) {
    console.log('Friend of friend:', record.get('name'))
  }

} finally {
  await session.close()
}

await neo4j.close()
```

### Cypher Query Support

Full Cypher query language support:

```typescript
// Pattern matching
const result = await session.run(`
  MATCH (user:User)-[:PURCHASED]->(product:Product)
  WHERE user.id = $userId
  RETURN product
`, { userId: 'user-123' })

// Aggregations
const stats = await session.run(`
  MATCH (u:User)-[:FOLLOWS]->(following)
  WHERE u.id = $userId
  RETURN count(following) as followingCount
`, { userId: 'user-123' })

// Path finding
const path = await session.run(`
  MATCH path = shortestPath(
    (a:User {id: $fromId})-[:KNOWS*]-(b:User {id: $toId})
  )
  RETURN path
`, { fromId: 'user-123', toId: 'user-789' })

// Conditional updates
await session.run(`
  MATCH (u:User {id: $userId})
  SET u.lastActive = datetime()
  SET u.visitCount = coalesce(u.visitCount, 0) + 1
  RETURN u
`, { userId: 'user-123' })

// Delete with relationships
await session.run(`
  MATCH (u:User {id: $userId})
  DETACH DELETE u
`, { userId: 'user-123' })

// Merge (upsert)
await session.run(`
  MERGE (u:User {id: $userId})
  ON CREATE SET u.createdAt = datetime(), u.name = $name
  ON MATCH SET u.lastSeen = datetime()
  RETURN u
`, { userId: 'user-123', name: 'Alice' })
```

### Transactions

ACID transactions for complex graph operations:

```typescript
const session = neo4j.session()

// Explicit transactions
const tx = session.beginTransaction()

try {
  await tx.run(
    'CREATE (a:Account {id: $id, balance: $balance})',
    { id: 'acc-1', balance: 1000 }
  )

  await tx.run(
    'CREATE (a:Account {id: $id, balance: $balance})',
    { id: 'acc-2', balance: 500 }
  )

  await tx.run(`
    MATCH (from:Account {id: $fromId})
    MATCH (to:Account {id: $toId})
    CREATE (from)-[:TRANSFERRED {amount: $amount, at: datetime()}]->(to)
    SET from.balance = from.balance - $amount
    SET to.balance = to.balance + $amount
  `, { fromId: 'acc-1', toId: 'acc-2', amount: 100 })

  await tx.commit()
} catch (error) {
  await tx.rollback()
  throw error
} finally {
  await session.close()
}

// Transaction functions (auto-retry)
await session.executeWrite(async (tx) => {
  await tx.run('CREATE (u:User {id: $id})', { id: 'user-new' })
  await tx.run(
    'MATCH (u:User {id: $id}) MATCH (o:Org {id: $orgId}) CREATE (u)-[:MEMBER_OF]->(o)',
    { id: 'user-new', orgId: 'org-1' }
  )
})

await session.executeRead(async (tx) => {
  const result = await tx.run('MATCH (u:User) RETURN count(u) as count')
  return result.records[0].get('count')
})
```

### Graph Algorithms

Common graph algorithms built-in:

```typescript
// Shortest path
const shortestPath = await session.run(`
  MATCH path = shortestPath(
    (start:User {id: $startId})-[:KNOWS*]-(end:User {id: $endId})
  )
  RETURN [node in nodes(path) | node.name] as path,
         length(path) as hops
`, { startId: 'alice', endId: 'eve' })

// All paths (up to depth)
const allPaths = await session.run(`
  MATCH path = (start:User {id: $startId})-[:KNOWS*1..4]-(end:User {id: $endId})
  RETURN path
  LIMIT 10
`, { startId: 'alice', endId: 'eve' })

// PageRank-style influence
const influential = await session.run(`
  MATCH (u:User)
  OPTIONAL MATCH (u)<-[:FOLLOWS]-(follower)
  WITH u, count(follower) as followers
  ORDER BY followers DESC
  LIMIT 10
  RETURN u.name as name, followers
`)

// Community detection (connected components)
const communities = await session.run(`
  MATCH (u:User)-[:FRIENDS_WITH*]-(connected:User)
  WITH u, collect(DISTINCT connected) as community
  RETURN u.id as seed, size(community) as communitySize
  ORDER BY communitySize DESC
`)

// Recommendation (collaborative filtering)
const recommendations = await session.run(`
  MATCH (me:User {id: $userId})-[:PURCHASED]->(product)<-[:PURCHASED]-(other)
  MATCH (other)-[:PURCHASED]->(rec:Product)
  WHERE NOT (me)-[:PURCHASED]->(rec)
  RETURN rec.name as product, count(*) as score
  ORDER BY score DESC
  LIMIT 5
`, { userId: 'user-123' })
```

## Architecture

### DO-Native Graph Storage

Each tenant's graph is a Durable Object:

```
┌─────────────────────────────────────────────────────────────────┐
│                         Client                                   │
│     session.run('MATCH (u:User)-[:FOLLOWS]->(f) RETURN f')       │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Cypher Parser                               │
│            Parse → Plan → Optimize                               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Graph DO (per tenant)                          │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   SQLite Storage                          │   │
│  │                                                           │   │
│  │  nodes:        id | labels | properties                   │   │
│  │  relationships: id | type | from_id | to_id | properties  │   │
│  │  indexes:      label:property → node_ids                  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                 Adjacency Index                           │   │
│  │     In-memory for fast traversal                          │   │
│  │     node_id → [outgoing edges] + [incoming edges]         │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Schema Design

Graphs stored in SQLite with optimal indexes:

```sql
-- Nodes table
CREATE TABLE nodes (
  id TEXT PRIMARY KEY,
  labels TEXT NOT NULL,  -- JSON array: ["User", "Admin"]
  properties TEXT NOT NULL,  -- JSON object
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Relationships table
CREATE TABLE relationships (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  from_node_id TEXT NOT NULL REFERENCES nodes(id),
  to_node_id TEXT NOT NULL REFERENCES nodes(id),
  properties TEXT NOT NULL,
  created_at INTEGER NOT NULL
);

-- Indexes for traversal
CREATE INDEX idx_rel_from ON relationships(from_node_id, type);
CREATE INDEX idx_rel_to ON relationships(to_node_id, type);
CREATE INDEX idx_rel_type ON relationships(type);

-- Label indexes
CREATE INDEX idx_node_labels ON nodes(labels);

-- Property indexes (created dynamically)
CREATE INDEX idx_user_email ON nodes((json_extract(properties, '$.email')))
  WHERE labels LIKE '%"User"%';
```

### Query Execution

Cypher queries compile to optimized SQLite:

```typescript
// Cypher input
`MATCH (u:User {email: $email})-[:FOLLOWS]->(following:User)
 RETURN following.name as name`

// Compiled to SQLite
`SELECT json_extract(n2.properties, '$.name') as name
 FROM nodes n1
 JOIN relationships r ON r.from_node_id = n1.id AND r.type = 'FOLLOWS'
 JOIN nodes n2 ON n2.id = r.to_node_id
 WHERE n1.labels LIKE '%"User"%'
   AND json_extract(n1.properties, '$.email') = ?
   AND n2.labels LIKE '%"User"%'`
```

## Patterns

### Social Network

```typescript
// Model users and relationships
await session.run(`
  CREATE (alice:User {id: 'alice', name: 'Alice'})
  CREATE (bob:User {id: 'bob', name: 'Bob'})
  CREATE (charlie:User {id: 'charlie', name: 'Charlie'})
  CREATE (alice)-[:FOLLOWS]->(bob)
  CREATE (bob)-[:FOLLOWS]->(charlie)
  CREATE (charlie)-[:FOLLOWS]->(alice)
`)

// Find mutual follows (friends)
const friends = await session.run(`
  MATCH (me:User {id: $userId})-[:FOLLOWS]->(them)
  WHERE (them)-[:FOLLOWS]->(me)
  RETURN them.name as friend
`, { userId: 'alice' })

// Friend suggestions (friends of friends)
const suggestions = await session.run(`
  MATCH (me:User {id: $userId})-[:FOLLOWS]->()-[:FOLLOWS]->(suggestion)
  WHERE suggestion.id <> $userId
    AND NOT (me)-[:FOLLOWS]->(suggestion)
  RETURN suggestion.name as name, count(*) as mutualFriends
  ORDER BY mutualFriends DESC
  LIMIT 5
`, { userId: 'alice' })
```

### Knowledge Graph

```typescript
// Create entities and relationships
await session.run(`
  CREATE (claude:AI {name: 'Claude', company: 'Anthropic'})
  CREATE (gpt4:AI {name: 'GPT-4', company: 'OpenAI'})
  CREATE (llm:Concept {name: 'Large Language Model'})
  CREATE (transformer:Concept {name: 'Transformer Architecture'})

  CREATE (claude)-[:IS_A]->(llm)
  CREATE (gpt4)-[:IS_A]->(llm)
  CREATE (llm)-[:USES]->(transformer)
`)

// Query relationships
const knowledge = await session.run(`
  MATCH (ai:AI)-[:IS_A]->(type)-[:USES]->(tech)
  RETURN ai.name as ai, type.name as type, tech.name as technology
`)

// Find related concepts
const related = await session.run(`
  MATCH (c:Concept {name: $concept})-[*1..3]-(related)
  RETURN DISTINCT related.name as concept, labels(related) as type
`, { concept: 'Large Language Model' })
```

### Access Control

```typescript
// Model permissions as graph
await session.run(`
  CREATE (alice:User {id: 'alice'})
  CREATE (admins:Group {name: 'admins'})
  CREATE (editors:Group {name: 'editors'})
  CREATE (doc:Document {id: 'doc-1', title: 'Secret Plans'})

  CREATE (alice)-[:MEMBER_OF]->(editors)
  CREATE (editors)-[:MEMBER_OF]->(admins)
  CREATE (admins)-[:CAN_READ]->(doc)
  CREATE (admins)-[:CAN_WRITE]->(doc)
  CREATE (editors)-[:CAN_READ]->(doc)
`)

// Check permission (transitive)
const canAccess = await session.run(`
  MATCH (u:User {id: $userId})-[:MEMBER_OF*0..]->(g)-[:CAN_READ]->(d:Document {id: $docId})
  RETURN count(*) > 0 as hasAccess
`, { userId: 'alice', docId: 'doc-1' })

// List all permissions for user
const permissions = await session.run(`
  MATCH (u:User {id: $userId})-[:MEMBER_OF*0..]->(g)
  MATCH (g)-[perm]->(resource)
  WHERE type(perm) STARTS WITH 'CAN_'
  RETURN DISTINCT type(perm) as permission, labels(resource)[0] as resourceType, resource.id as resourceId
`, { userId: 'alice' })
```

### Dependency Graph

```typescript
// Model package dependencies
await session.run(`
  CREATE (react:Package {name: 'react', version: '18.2.0'})
  CREATE (reactDom:Package {name: 'react-dom', version: '18.2.0'})
  CREATE (scheduler:Package {name: 'scheduler', version: '0.23.0'})

  CREATE (reactDom)-[:DEPENDS_ON]->(react)
  CREATE (reactDom)-[:DEPENDS_ON]->(scheduler)
  CREATE (react)-[:DEPENDS_ON]->(scheduler)
`)

// Find all transitive dependencies
const deps = await session.run(`
  MATCH (pkg:Package {name: $name})-[:DEPENDS_ON*]->(dep)
  RETURN DISTINCT dep.name as dependency, dep.version as version
`, { name: 'react-dom' })

// Detect circular dependencies
const circular = await session.run(`
  MATCH path = (p:Package)-[:DEPENDS_ON*]->(p)
  RETURN [node in nodes(path) | node.name] as cycle
`)

// Find packages with most dependents
const popular = await session.run(`
  MATCH (pkg:Package)<-[:DEPENDS_ON]-(dependent)
  RETURN pkg.name as package, count(dependent) as dependents
  ORDER BY dependents DESC
  LIMIT 10
`)
```

## Migration Patterns

### From Neo4j Aura

```typescript
// Before: Neo4j Aura
import neo4j from 'neo4j-driver'

const driver = neo4j.driver(
  'neo4j+s://xxx.databases.neo4j.io',
  neo4j.auth.basic('neo4j', 'password')
)

// After: dotdo
import { driver, auth } from '@dotdo/neo4j'

const neo4j = driver(
  process.env.DOTDO_NEO4J_URI,
  auth.basic('neo4j', process.env.NEO4J_PASSWORD),
  { shardKey: 'tenantId' }
)

// Code stays the same
const session = neo4j.session()
const result = await session.run('MATCH (n) RETURN n LIMIT 10')
await session.close()
```

### Data Migration

```typescript
// Export from Neo4j
const exportSession = oldNeo4j.session()
const nodes = await exportSession.run('MATCH (n) RETURN n')
const relationships = await exportSession.run('MATCH ()-[r]->() RETURN r')

// Import to dotdo
const importSession = newNeo4j.session()

// Batch import nodes
for (const record of nodes.records) {
  const node = record.get('n')
  await importSession.run(
    `CREATE (n:${node.labels.join(':')} $props)`,
    { props: node.properties }
  )
}

// Batch import relationships
for (const record of relationships.records) {
  const rel = record.get('r')
  await importSession.run(`
    MATCH (a {id: $fromId})
    MATCH (b {id: $toId})
    CREATE (a)-[:${rel.type} $props]->(b)
  `, {
    fromId: rel.start.properties.id,
    toId: rel.end.properties.id,
    props: rel.properties,
  })
}
```

## Performance

| Operation | Latency | Capacity |
|-----------|---------|----------|
| Single node lookup | < 5ms | Index-based |
| 1-hop traversal | < 10ms | 10K edges |
| 2-hop traversal | < 30ms | 100K edges |
| 3-hop traversal | < 100ms | 1M edges |
| Shortest path | < 50ms | 100K nodes |
| Full-text search | < 20ms | With FTS5 |

### Scaling

Each tenant gets dedicated graph performance:

```typescript
// Per-tenant isolation
// Tenant A's complex query doesn't affect Tenant B
const driverA = driver(uri, auth, { shardKey: 'tenant-a' })
const driverB = driver(uri, auth, { shardKey: 'tenant-b' })
```

### Indexing

Create indexes for frequently queried properties:

```typescript
// Create index
await session.run('CREATE INDEX user_email FOR (u:User) ON (u.email)')
await session.run('CREATE INDEX user_name FOR (u:User) ON (u.name)')

// Composite index
await session.run('CREATE INDEX user_org FOR (u:User) ON (u.orgId, u.role)')

// Full-text search index
await session.run(`
  CREATE FULLTEXT INDEX user_search FOR (u:User) ON EACH [u.name, u.bio]
`)

// Use full-text search
const results = await session.run(`
  CALL db.index.fulltext.queryNodes('user_search', $query) YIELD node, score
  RETURN node.name as name, score
  ORDER BY score DESC
  LIMIT 10
`, { query: 'engineer San Francisco' })
```

## Limitations

What's different from hosted Neo4j:

- **No distributed transactions** - Each tenant graph is single-node
- **No APOC procedures** - Use native Cypher only
- **Graph size limit** - 10M nodes per tenant (SQLite constraint)
- **No causal clustering** - Single DO per tenant graph
- **No GDS library** - Basic algorithms only, no ML features

## Individual Integrations

Detailed guides for specific graph database services:

- [Neo4j](/docs/integrations/neo4j) - Neo4j driver with full Cypher support

## Related Categories

- [Database SDKs](/docs/compat/databases) - Postgres, MySQL, MongoDB
- [Vector SDKs](/docs/compat/vector) - Pinecone, Qdrant, Weaviate
- [Search SDKs](/docs/compat/search) - Elasticsearch, Algolia, Meilisearch
