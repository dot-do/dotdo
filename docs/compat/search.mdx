---
title: Search
description: API-compatible search SDKs for Elasticsearch, Algolia, Meilisearch, Typesense, and Orama.
---

# Search Compat SDKs

Five search APIs, rebuilt on Durable Objects. Full-text search that runs at the edge.

## The Problem

When 10,000 AI agents start indexing and searching:

- **Elasticsearch** hits JVM heap pressure and GC pauses
- **Algolia** rate limits indexing operations
- **Meilisearch** struggles with concurrent write loads
- **Typesense** memory limits constrain index size

The solution: sharded search indices in Durable Objects. Each shard runs its own libsql FTS5 index. Queries fan out and merge. No JVM. No external dependencies.

## Quick Start

```typescript
import { Client } from '@dotdo/elasticsearch'

const client = new Client({
  node: process.env.SEARCH_URL,
})

await client.index({
  index: 'products',
  id: 'prod-123',
  document: {
    name: 'Wireless Headphones',
    description: 'High-quality bluetooth headphones',
    price: 99.99,
  },
})

const results = await client.search({
  index: 'products',
  query: {
    match: { description: 'bluetooth' },
  },
})
```

## Available SDKs

### @dotdo/elasticsearch

Elasticsearch query DSL compatible.

```typescript
import { Client } from '@dotdo/elasticsearch'

const client = new Client({
  node: process.env.ELASTICSEARCH_URL,
  shardKey: 'tenant_id',
})

// Index documents
await client.index({
  index: 'products',
  id: 'prod-123',
  document: {
    tenant_id: 'tenant-1',
    name: 'Wireless Headphones',
    description: 'Bluetooth noise-canceling headphones',
    price: 99.99,
    category: 'electronics',
    tags: ['audio', 'wireless', 'bluetooth'],
  },
})

// Bulk indexing
await client.bulk({
  operations: products.flatMap((product) => [
    { index: { _index: 'products', _id: product.id } },
    product,
  ]),
})

// Search with query DSL
const results = await client.search({
  index: 'products',
  query: {
    bool: {
      must: [
        { match: { description: 'bluetooth headphones' } },
      ],
      filter: [
        { term: { tenant_id: 'tenant-1' } },
        { range: { price: { gte: 50, lte: 200 } } },
      ],
    },
  },
  sort: [
    { _score: 'desc' },
    { price: 'asc' },
  ],
  size: 10,
  from: 0,
})

// Aggregations
const aggs = await client.search({
  index: 'products',
  size: 0,
  aggs: {
    categories: {
      terms: { field: 'category' },
    },
    price_ranges: {
      range: {
        field: 'price',
        ranges: [
          { to: 50 },
          { from: 50, to: 100 },
          { from: 100 },
        ],
      },
    },
  },
})

// Faceted search
const faceted = await client.search({
  index: 'products',
  query: { match_all: {} },
  aggs: {
    categories: { terms: { field: 'category' } },
    brands: { terms: { field: 'brand' } },
    price_stats: { stats: { field: 'price' } },
  },
})
```

Supported query types:
- `match`, `match_phrase`, `multi_match`
- `term`, `terms`, `range`
- `bool` (must, should, filter, must_not)
- `exists`, `prefix`, `wildcard`
- `fuzzy` (edit distance)

### @dotdo/algolia

Algolia InstantSearch compatible.

```typescript
import algoliasearch from '@dotdo/algolia'

const client = algoliasearch('APP_ID', 'API_KEY')
const index = client.initIndex('products')

// Index records
await index.saveObject({
  objectID: 'prod-123',
  name: 'Wireless Headphones',
  description: 'Bluetooth noise-canceling',
  price: 99.99,
  _tags: ['electronics', 'audio'],
})

// Batch indexing
await index.saveObjects(products)

// Search
const results = await index.search('bluetooth headphones', {
  filters: 'price < 200 AND category:electronics',
  facets: ['category', 'brand'],
  hitsPerPage: 20,
  page: 0,
})

console.log(results.hits)
console.log(results.facets)

// Configure index
await index.setSettings({
  searchableAttributes: ['name', 'description', 'brand'],
  attributesForFaceting: ['category', 'brand', 'filterOnly(price)'],
  ranking: ['typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],
  customRanking: ['desc(popularity)', 'asc(price)'],
})

// Synonyms
await index.saveSynonym({
  objectID: 'headphones-synonyms',
  type: 'synonym',
  synonyms: ['headphones', 'earphones', 'earbuds'],
})

// Rules for query understanding
await index.saveRule({
  objectID: 'cheap-rule',
  conditions: [{ pattern: 'cheap {facet:category}', anchoring: 'contains' }],
  consequence: {
    params: {
      filters: 'price < 50',
    },
  },
})
```

Works with Algolia InstantSearch UI libraries:
- `react-instantsearch`
- `vue-instantsearch`
- `instantsearch.js`

### @dotdo/meilisearch

Meilisearch SDK compatible.

```typescript
import { MeiliSearch } from '@dotdo/meilisearch'

const client = new MeiliSearch({
  host: process.env.MEILISEARCH_URL,
  apiKey: process.env.MEILISEARCH_KEY,
})

// Create index
const index = client.index('movies')

// Add documents
await index.addDocuments([
  { id: 1, title: 'The Matrix', year: 1999, genres: ['sci-fi', 'action'] },
  { id: 2, title: 'Inception', year: 2010, genres: ['sci-fi', 'thriller'] },
])

// Search with typo tolerance
const results = await index.search('matirx', {
  limit: 10,
  attributesToRetrieve: ['title', 'year'],
  attributesToHighlight: ['title'],
  filter: 'year > 1990',
  sort: ['year:desc'],
})

// Multi-search
const multiResults = await client.multiSearch({
  queries: [
    { indexUid: 'movies', q: 'action' },
    { indexUid: 'actors', q: 'keanu' },
  ],
})

// Configure searchable attributes
await index.updateSettings({
  searchableAttributes: ['title', 'overview', 'genres'],
  filterableAttributes: ['year', 'genres', 'rating'],
  sortableAttributes: ['year', 'rating'],
  rankingRules: [
    'words',
    'typo',
    'proximity',
    'attribute',
    'sort',
    'exactness',
  ],
})

// Faceted search
const faceted = await index.search('', {
  facets: ['genres', 'year'],
  filter: 'genres = "sci-fi"',
})
```

### @dotdo/typesense

Typesense client compatible.

```typescript
import Typesense from '@dotdo/typesense'

const client = new Typesense.Client({
  nodes: [{ host: 'search.dotdo.io', port: 443, protocol: 'https' }],
  apiKey: process.env.TYPESENSE_KEY,
})

// Create collection with schema
await client.collections().create({
  name: 'products',
  fields: [
    { name: 'name', type: 'string' },
    { name: 'description', type: 'string' },
    { name: 'price', type: 'float' },
    { name: 'category', type: 'string', facet: true },
    { name: 'rating', type: 'float' },
  ],
  default_sorting_field: 'rating',
})

// Index documents
await client.collections('products').documents().create({
  id: 'prod-123',
  name: 'Wireless Headphones',
  description: 'High-quality bluetooth',
  price: 99.99,
  category: 'electronics',
  rating: 4.5,
})

// Upsert multiple
await client.collections('products').documents().import(products, {
  action: 'upsert',
})

// Search
const results = await client.collections('products').documents().search({
  q: 'wireless headphones',
  query_by: 'name,description',
  filter_by: 'price:<200 && category:electronics',
  sort_by: 'rating:desc',
  facet_by: 'category',
  max_hits: 20,
})

// Multi-search
const multiResults = await client.multiSearch.perform({
  searches: [
    { collection: 'products', q: 'headphones' },
    { collection: 'accessories', q: 'headphones' },
  ],
})

// Geosearch
const nearby = await client.collections('stores').documents().search({
  q: '*',
  filter_by: 'location:(48.8566, 2.3522, 10 km)',
  sort_by: 'location(48.8566, 2.3522):asc',
})
```

### @dotdo/orama

Orama full-text search (runs entirely in the Worker).

```typescript
import { create, insert, insertMultiple, search } from '@dotdo/orama'
import { persist, restore } from '@dotdo/orama/plugin-data-persistence'

// Create in-memory index
const db = await create({
  schema: {
    name: 'string',
    description: 'string',
    price: 'number',
    category: 'string',
    inStock: 'boolean',
  },
})

// Insert documents
await insert(db, {
  name: 'Wireless Headphones',
  description: 'Bluetooth noise-canceling headphones',
  price: 99.99,
  category: 'electronics',
  inStock: true,
})

// Batch insert
await insertMultiple(db, products)

// Search
const results = await search(db, {
  term: 'bluetooth headphones',
  properties: ['name', 'description'],
  where: {
    price: { lt: 200 },
    inStock: true,
  },
  limit: 10,
  offset: 0,
})

// Facets
const faceted = await search(db, {
  term: '',
  facets: {
    category: { limit: 10 },
    inStock: {},
  },
})

// Vector search (hybrid)
const hybrid = await search(db, {
  term: 'headphones',
  vector: {
    value: embedding,
    property: 'embedding',
  },
  similarity: 0.8,
})

// Save to DO storage
await saveIndex(db, env.DO_STORAGE)

// Load from DO storage
const loaded = await loadIndex(env.DO_STORAGE)
```

Orama is unique: it runs entirely in the V8 isolate with no external dependencies. Perfect for small indices (< 100K documents) that need sub-millisecond latency.

## Architecture

### Sharded FTS5 Indices

Each shard maintains its own FTS5 full-text index in libsql:

```
┌─────────────────────────────────────────────────────────────────┐
│                       Search Query                               │
│              client.search({ query: { match: 'headphones' } })   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Query Router                                │
│         Parse query → determine shards → fan out                 │
└─────────────────────────────────────────────────────────────────┘
                                │
                    ┌───────────┼───────────┐
                    ▼           ▼           ▼
               ┌────────┐  ┌────────┐  ┌────────┐
               │ Shard  │  │ Shard  │  │ Shard  │
               │  FTS5  │  │  FTS5  │  │  FTS5  │
               └────────┘  └────────┘  └────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Result Merger                               │
│         Merge results → re-rank → apply limits                   │
└─────────────────────────────────────────────────────────────────┘
```

### FTS5 Under the Hood

```sql
-- Each shard creates an FTS5 virtual table
CREATE VIRTUAL TABLE documents_fts USING fts5(
  content,
  tenant_id UNINDEXED,  -- Shard key (not searchable)
  tokenize='porter unicode61'
);

-- Queries use FTS5 syntax
SELECT * FROM documents_fts
WHERE documents_fts MATCH 'bluetooth headphones'
AND tenant_id = 'tenant-123'
ORDER BY rank;
```

### Index Configuration

```typescript
const client = new Client({
  indices: {
    products: {
      shardCount: 16,
      shardKey: 'tenant_id',
      analyzer: {
        tokenizer: 'porter',  // Stemming
        filters: ['lowercase', 'stopwords'],
      },
      fields: {
        name: { boost: 2.0 },
        description: { boost: 1.0 },
        category: { type: 'keyword' },  // Exact match only
      },
    },
  },
})
```

## Scoring and Ranking

### BM25 Ranking

All search SDKs use BM25 (Okapi BM25) for relevance scoring:

```
score(D,Q) = IDF(qi) * (f(qi,D) * (k1 + 1)) / (f(qi,D) + k1 * (1 - b + b * |D|/avgdl))
```

Parameters:
- `k1` = 1.2 (term frequency saturation)
- `b` = 0.75 (document length normalization)

### Custom Ranking

Combine text relevance with business signals:

```typescript
const results = await client.search({
  index: 'products',
  query: { match: { description: 'headphones' } },
  sort: [
    '_score',  // BM25 relevance
    { popularity: 'desc' },
    { price: 'asc' },
  ],
  // Custom scoring function
  script_score: {
    script: {
      source: "_score * doc['popularity'].value * (1 / (1 + doc['price'].value / 100))",
    },
  },
})
```

### Boosting

Boost specific fields or terms:

```typescript
// Field boosting
const results = await client.search({
  index: 'products',
  query: {
    multi_match: {
      query: 'wireless headphones',
      fields: ['name^3', 'description^1', 'category^0.5'],
    },
  },
})

// Term boosting
const results = await client.search({
  index: 'products',
  query: {
    bool: {
      should: [
        { match: { name: { query: 'wireless', boost: 2.0 } } },
        { match: { description: 'wireless' } },
      ],
    },
  },
})
```

## Patterns

### Autocomplete / Typeahead

```typescript
// Prefix search with edge n-grams
await index.setSettings({
  searchableAttributes: ['name'],
  customRanking: ['desc(popularity)'],
})

// Fast prefix matching
const suggestions = await index.search('head', {
  hitsPerPage: 5,
  attributesToRetrieve: ['name'],
})
```

### Faceted Navigation

```typescript
const results = await client.search({
  index: 'products',
  query: { match_all: {} },
  aggs: {
    categories: { terms: { field: 'category', size: 10 } },
    brands: { terms: { field: 'brand', size: 10 } },
    price_ranges: {
      range: {
        field: 'price',
        ranges: [
          { key: 'budget', to: 50 },
          { key: 'mid', from: 50, to: 150 },
          { key: 'premium', from: 150 },
        ],
      },
    },
  },
})

// Display facet counts in UI
for (const bucket of results.aggregations.categories.buckets) {
  console.log(`${bucket.key}: ${bucket.doc_count}`)
}
```

### Geosearch

```typescript
// Index with location
await client.index({
  index: 'stores',
  id: 'store-1',
  document: {
    name: 'Downtown Store',
    location: { lat: 40.7128, lon: -74.0060 },
  },
})

// Search within radius
const nearby = await client.search({
  index: 'stores',
  query: {
    geo_distance: {
      distance: '10km',
      location: { lat: 40.73, lon: -73.99 },
    },
  },
  sort: [
    {
      _geo_distance: {
        location: { lat: 40.73, lon: -73.99 },
        order: 'asc',
      },
    },
  ],
})
```

### Multi-Index Search

```typescript
// Search across multiple indices
const results = await client.msearch({
  searches: [
    { index: 'products' },
    { query: { match: { name: 'headphones' } } },
    { index: 'articles' },
    { query: { match: { title: 'headphones' } } },
  ],
})
```

## Performance

| Operation | Latency | Notes |
|-----------|---------|-------|
| Simple search | < 20ms | Single shard |
| Complex query | 20-50ms | Multi-shard fan-out |
| Faceted search | 30-100ms | Aggregation overhead |
| Autocomplete | < 10ms | Prefix index |
| Indexing | < 50ms | Per document |
| Bulk index | < 500ms | 1000 documents |

### Optimization Tips

1. **Use shard keys** - Route queries to single shard when possible
2. **Limit facets** - Only request facets you'll display
3. **Pagination** - Use `search_after` for deep pagination
4. **Field selection** - Only retrieve fields you need

## Migration Guide

### From Elasticsearch Cloud

```typescript
// Before: Elastic Cloud
import { Client } from '@elastic/elasticsearch'
const client = new Client({
  cloud: { id: 'deployment:xxx' },
  auth: { apiKey: 'xxx' },
})

// After: dotdo
import { Client } from '@dotdo/elasticsearch'
const client = new Client({
  node: process.env.DOTDO_SEARCH_URL,
})

// Code stays the same
const results = await client.search({
  index: 'products',
  query: { match: { name: 'headphones' } },
})
```

### From Algolia

```typescript
// Before: Algolia
import algoliasearch from 'algoliasearch'
const client = algoliasearch('APP_ID', 'API_KEY')

// After: dotdo
import algoliasearch from '@dotdo/algolia'
const client = algoliasearch('APP_ID', 'API_KEY')

// Code stays the same
const index = client.initIndex('products')
const results = await index.search('headphones')
```

## Limitations

What's different from managed services:

- **No nested/parent-child** - Flatten documents instead
- **No percolate queries** - Use messaging for alerts
- **Limited aggregation depth** - Single-level facets
- **No machine learning ranking** - BM25 + custom scoring

## Technical Details

For implementation details and SDK-specific documentation:

| SDK | README | Description |
|-----|--------|-------------|
| **Algolia** | [README](https://github.com/dotdo/dotdo/blob/main/compat/algolia/README.md) | Algolia InstantSearch compatibility |
| **Postgres** | [README](https://github.com/dotdo/dotdo/blob/main/compat/postgres/README.md) | Postgres wire protocol compatibility |
| **Supabase** | [README](https://github.com/dotdo/dotdo/blob/main/compat/supabase/README.md) | Supabase API compatibility |
| **SQS** | [README](https://github.com/dotdo/dotdo/blob/main/compat/sqs/README.md) | AWS SQS compatibility |
| **CouchDB** | [README](https://github.com/dotdo/dotdo/blob/main/compat/couchdb/README.md) | CouchDB API compatibility |

### Database Compat Layers

| Category | READMEs |
|----------|---------|
| **SQL** | [Postgres](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/postgres/README.md), [MySQL](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/mysql/README.md), [Turso](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/turso/README.md), [PlanetScale](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/planetscale/README.md), [Neon](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/neon/README.md), [CockroachDB](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/cockroach/README.md), [TiDB](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/tidb/README.md), [ClickHouse](https://github.com/dotdo/dotdo/blob/main/db/compat/sql/clickhouse/README.md) |
| **NoSQL** | [MongoDB](https://github.com/dotdo/dotdo/blob/main/db/compat/nosql/mongo/README.md), [DynamoDB](https://github.com/dotdo/dotdo/blob/main/db/compat/nosql/dynamodb/README.md), [Firebase](https://github.com/dotdo/dotdo/blob/main/db/compat/nosql/firebase/README.md), [Convex](https://github.com/dotdo/dotdo/blob/main/db/compat/nosql/convex/README.md) |
| **Graph** | [Neo4j](https://github.com/dotdo/dotdo/blob/main/db/compat/graph/neo4j/README.md), [Graph](https://github.com/dotdo/dotdo/blob/main/db/compat/graph/README.md) |
| **Cache** | [Redis](https://github.com/dotdo/dotdo/blob/main/db/compat/cache/redis/README.md) |

## Individual Integrations

Detailed guides for specific search services:

- [Elasticsearch](/docs/integrations/elasticsearch) - Full-text search with Query DSL
- [Algolia](/docs/integrations/algolia) - InstantSearch compatibility

## Related Categories

- [Database SDKs](/docs/compat/databases) - Postgres, MySQL, MongoDB
- [Messaging SDKs](/docs/compat/messaging) - Kafka, Redis, NATS
- [Vector SDKs](/docs/compat/vector) - Pinecone, Qdrant, Weaviate
