---
title: Messaging
description: API-compatible messaging SDKs for queuing and pub/sub on Durable Objects.
---

# Messaging Compat SDKs

Durable Object (DO)-native queues that scale with your agents. Messages persist to SQLite with overflow to R2.

## The Problem

When 10,000 AI agents start producing and consuming messages:

- **SQS** rate limits concurrent message operations
- **Kafka** hits partition rebalancing storms during scale-up
- **Pub/Sub** struggles with per-topic throughput limits

The solution: DO-native queues. Each queue is a Durable Object. No external coordination. Messages persist to SQLite with overflow to R2.

## Quick Start

```typescript
import { SQSClient, SendMessageCommand, ReceiveMessageCommand } from '@dotdo/sqs'

const sqs = new SQSClient({ region: 'auto' })
const queueUrl = 'https://sqs.dotdo.io/123456789/my-queue'

// Send message
await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify({ type: 'signup', userId: '123' }),
}))

// Receive messages
const response = await sqs.send(new ReceiveMessageCommand({
  QueueUrl: queueUrl,
  MaxNumberOfMessages: 10,
  WaitTimeSeconds: 20,
}))
```

## Available SDKs

### @dotdo/sqs

AWS SQS API compatible.

```typescript
import {
  SQSClient,
  SendMessageCommand,
  ReceiveMessageCommand,
  DeleteMessageCommand,
} from '@dotdo/sqs'

const sqs = new SQSClient({
  region: 'auto',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  },
})

const queueUrl = 'https://sqs.dotdo.io/123456789/my-queue'

// Send message
await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify({
    type: 'process-image',
    imageUrl: 'https://example.com.ai/image.jpg',
  }),
  MessageAttributes: {
    Priority: { DataType: 'String', StringValue: 'high' },
  },
}))

// Receive messages
const response = await sqs.send(new ReceiveMessageCommand({
  QueueUrl: queueUrl,
  MaxNumberOfMessages: 10,
  WaitTimeSeconds: 20, // Long polling
  MessageAttributeNames: ['All'],
}))

for (const message of response.Messages || []) {
  console.log('Processing:', JSON.parse(message.Body))

  // Delete after processing
  await sqs.send(new DeleteMessageCommand({
    QueueUrl: queueUrl,
    ReceiptHandle: message.ReceiptHandle,
  }))
}
```

Supports:
- Standard and FIFO queues
- Dead letter queues
- Visibility timeout
- Long polling
- Message attributes

## Planned SDKs

The following messaging SDKs are on the roadmap but not yet implemented:

| SDK | Status | Description |
|-----|--------|-------------|
| `@dotdo/kafka` | Planned | Kafka producer/consumer with KafkaJS compatibility |
| `@dotdo/redis` | Planned | Redis pub/sub, streams, and queues |
| `@dotdo/nats` | Planned | NATS pub/sub and JetStream |
| `@dotdo/pubsub` | Planned | Google Cloud Pub/Sub API |

For real-time messaging today, see the [Pusher compat SDK](/docs/compat/realtime) which provides WebSocket-based pub/sub.

## Architecture

### DO-Native Queues

Each queue is a Durable Object:

```
┌─────────────────────────────────────────────────────────────────┐
│                        Producer                                  │
│              sqs.send(new SendMessageCommand({ ... }))           │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Queue Router                               │
│            Queue URL → Queue DO                                  │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
                          ┌────────┐
                          │ Queue  │
                          │  (DO)  │
                          └────────┘
                                │
                                ▼
                   ┌─────────────────────────┐
                   │ SQLite (hot) + R2 (cold)│
                   └─────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Consumer                                  │
│              sqs.send(new ReceiveMessageCommand({ ... }))        │
└─────────────────────────────────────────────────────────────────┘
```

### Message Persistence

Messages tier automatically:

```typescript
// Hot: Recent messages in SQLite (< 10ms)
// Warm: Older messages in R2 (< 100ms)
// Cold: Archived to Iceberg Parquet

// Messages are retained based on queue configuration:
// - Standard queues: 4 days default, up to 14 days
// - FIFO queues: Exactly-once processing within deduplication window
```

### Visibility Timeout

Messages are hidden from other consumers while being processed:

```typescript
// Receive with 30 second visibility timeout
const response = await sqs.send(new ReceiveMessageCommand({
  QueueUrl: queueUrl,
  VisibilityTimeout: 30, // Message hidden for 30s
}))

// If processing takes longer, extend the timeout
await sqs.send(new ChangeMessageVisibilityCommand({
  QueueUrl: queueUrl,
  ReceiptHandle: message.ReceiptHandle,
  VisibilityTimeout: 60,
}))
```

## Patterns

### Fan-Out with SNS

Use SNS to broadcast to multiple SQS queues:

```typescript
// Create multiple queues subscribed to one topic
// Each queue receives a copy of every message

// Producer sends to SNS topic
await sns.send(new PublishCommand({
  TopicArn: topicArn,
  Message: JSON.stringify({ event: 'order.created', orderId: '123' }),
}))

// Each SQS queue subscribed to the topic receives the message
```

### Work Queue

Distribute work across workers:

```typescript
// Producer: Push work to queue
await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify({ job: 'process', id: 123 }),
}))

// Multiple workers compete for messages
const response = await sqs.send(new ReceiveMessageCommand({
  QueueUrl: queueUrl,
  MaxNumberOfMessages: 1,
  WaitTimeSeconds: 20, // Long polling
}))

if (response.Messages?.length) {
  await processTask(response.Messages[0])
  await sqs.send(new DeleteMessageCommand({
    QueueUrl: queueUrl,
    ReceiptHandle: response.Messages[0].ReceiptHandle,
  }))
}
```

### Delayed Messages

Schedule messages for future delivery:

```typescript
// SQS delay (up to 15 minutes)
await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify(message),
  DelaySeconds: 900, // 15 minutes
}))

// For longer delays, use message attributes + visibility timeout
await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify({
    ...message,
    deliverAt: Date.now() + 3600000, // 1 hour
  }),
}))
```

### Dead Letter Queue

Handle failed messages:

```typescript
// Configure DLQ when creating the queue
// Messages that fail maxReceiveCount times are moved to DLQ

// Process main queue
const response = await sqs.send(new ReceiveMessageCommand({
  QueueUrl: queueUrl,
}))

try {
  await processOrThrow(response.Messages[0])
  await sqs.send(new DeleteMessageCommand({
    QueueUrl: queueUrl,
    ReceiptHandle: response.Messages[0].ReceiptHandle,
  }))
} catch (error) {
  // Message will become visible again after visibility timeout
  // After maxReceiveCount failures, moves to DLQ
}
```

## Performance

| Operation | Latency | Throughput |
|-----------|---------|------------|
| Send message | < 10ms | 10K/s per queue |
| Send batch | < 50ms | 100K/s per queue |
| Receive | < 5ms | 50K/s per consumer |
| Long polling | ~20ms | Efficient for low-volume |

### Scaling

Throughput scales with multiple queues:

```typescript
// Use multiple queues for high throughput
// Partition messages by key to maintain ordering within partitions

const queueUrl = `https://sqs.dotdo.io/123456789/events-${hash(key) % 16}`

await sqs.send(new SendMessageCommand({
  QueueUrl: queueUrl,
  MessageBody: JSON.stringify(message),
}))
```

## Real-Time with WebSockets

For real-time pub/sub, use the [Pusher compat SDK](/docs/compat/realtime) with DO WebSockets:

```typescript
// In your Durable Object
export class ChatRoom extends DurableObject {
  async onMessage(ws: WebSocket, message: string) {
    // Broadcast to local connections
    for (const client of this.connections) {
      client.send(message)
    }
  }
}
```

For cross-DO communication, use SQS or the Pusher SDK for real-time pub/sub.

## Migration Guide

### From AWS SQS

```typescript
// Before: AWS SQS
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs'
const sqs = new SQSClient({ region: 'us-east-1' })

// After: dotdo
import { SQSClient, SendMessageCommand } from '@dotdo/sqs'
const sqs = new SQSClient({ region: 'auto' })

// Code stays the same
await sqs.send(new SendMessageCommand({ QueueUrl, MessageBody }))
```

## Limitations

What's different from AWS SQS:

- **Max message size: 256KB** - Same as AWS SQS
- **Max delay: 15 minutes** - Same as AWS SQS
- **At-least-once delivery** - Use FIFO queues or idempotency for exactly-once
- **No FIFO high throughput mode** - Standard FIFO limits apply

## Related Categories

- [Database SDKs](/docs/compat/databases) - Postgres, MySQL, MongoDB
- [Search SDKs](/docs/compat/search) - Elasticsearch, Algolia, Meilisearch
- [Vector SDKs](/docs/compat/vector) - Pinecone, Qdrant, Weaviate
- [Realtime SDKs](/docs/compat/realtime) - Pusher, Ably, Socket.IO
