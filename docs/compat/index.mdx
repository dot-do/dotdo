---
title: Compat SDKs
description: 40+ API-compatible SDKs. Same APIs you know. Durable Object (DO)-backed storage. Scales to millions of agents.
---

import { Cards, Card } from 'fumadocs-ui/components/card'

# Compat SDKs

Your existing code works. Your AI agents can use familiar APIs. It just scales. All backed by Durable Objects (DOs).

```typescript
// Drop-in replacement
import { createClient } from '@dotdo/supabase'

const supabase = createClient(url, key)
const { data } = await supabase.from('users').select('*')
```

## Why Compat Exists

Traditional infrastructure crumbles under 10,000 parallel AI agents.

| Service | The Problem | The Solution |
|---------|-------------|--------------|
| **Supabase** | Connection pooling limits | Sharded across DOs |
| **MongoDB** | Write lock contention | Single-threaded per shard |
| **Redis** | Memory limits | Tiered to R2 |
| **Kafka** | Partition rebalancing storms | DO-native queues |
| **Postgres** | Connection exhaustion | Per-tenant DO isolation |
| **Elasticsearch** | JVM heap pressure | libsql + Vectorize |
| **Pinecone** | Rate limits per namespace | Sharded namespaces |

When you spin up 10,000 agents to process customer requests, traditional databases hit their limits. Connection pools exhaust. Memory balloons. Queues back up. Partitions rebalance.

We rebuilt these APIs on Durable Objects. Each DO is a single-threaded JavaScript isolate with persistent storage. No connection pools. No locks. No coordination overhead.

## The Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Your Code (unchanged)                        │
│              supabase.from('users').select('*')                  │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      @dotdo/supabase                             │
│              API-compatible translation layer                    │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                       ShardRouter                                │
│         Consistent hashing → tenant → DO shard                   │
└─────────────────────────────────────────────────────────────────┘
                                │
                    ┌───────────┼───────────┐
                    ▼           ▼           ▼
               ┌────────┐  ┌────────┐  ┌────────┐
               │ Shard  │  │ Shard  │  │ Shard  │
               │  0-15  │  │ 16-31  │  │ 32-47  │
               └────────┘  └────────┘  └────────┘
                    │           │           │
                    ▼           ▼           ▼
               ┌─────────────────────────────────┐
               │          SQLite + R2            │
               │    Hot in DO, cold in storage   │
               └─────────────────────────────────┘
```

## Installation

Install any compat SDK from npm:

```bash
npm install @dotdo/supabase
# or
npm install @dotdo/mongo
# or
npm install @dotdo/redis
```

Configure your Durable Object bindings in `wrangler.jsonc`:

```json
{
  "durable_objects": {
    "bindings": [
      { "name": "DO", "class_name": "CompatDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_classes": ["CompatDO"] }
  ]
}
```

## Quick Start

Replace your existing imports and you're done:

```typescript
// Before: cloud-hosted service
import { createClient } from '@supabase/supabase-js'

// After: edge-native with DO-backed storage
import { createClient } from '@dotdo/supabase'

// Your code stays exactly the same
const supabase = createClient(url, key)
const { data } = await supabase.from('users').select('*')
```

For MongoDB:

```typescript
import { DocumentStore } from '@dotdo/mongodb'

const store = new DocumentStore()
const db = store.db('myapp')
const users = await db.collection('users').find({ active: true }).toArray()
```

For Redis:

```typescript
import { Redis } from '@dotdo/redis'

const redis = new Redis()
await redis.set('key', 'value')
const value = await redis.get('key')
```

## The Full List

### Databases

- `@dotdo/postgres` - PostgreSQL wire protocol
- `@dotdo/mysql` - MySQL wire protocol
- `@dotdo/mongodb` - MongoDB driver compatible
- `@dotdo/supabase` - Supabase client SDK
- `@dotdo/firebase` - Firebase Admin SDK
- `@dotdo/neon` - Neon serverless driver
- `@dotdo/planetscale` - PlanetScale database SDK
- `@dotdo/cockroach` - CockroachDB compatible
- `@dotdo/tidb` - TiDB compatible
- `@dotdo/turso` - Turso/libsql compatible
- `@dotdo/duckdb` - DuckDB for analytics
- `@dotdo/couchdb` - CouchDB document store

### Messaging

- `@dotdo/kafka` - Kafka producer/consumer
- `@dotdo/redis` - Redis commands
- `@dotdo/nats` - NATS pub/sub
- `@dotdo/sqs` - AWS SQS compatible
- `@dotdo/pubsub` - Google Cloud Pub/Sub

### Real-time

- `@dotdo/pusher` - Pusher channels
- `@dotdo/ably` - Ably realtime
- `@dotdo/socketio` - Socket.IO compatible

### Search

- `@dotdo/elasticsearch` - Elasticsearch queries
- `@dotdo/algolia` - Algolia search client
- `@dotdo/meilisearch` - Meilisearch SDK
- `@dotdo/typesense` - Typesense search
- `@dotdo/orama` - Orama full-text search

### Vector

- `@dotdo/pinecone` - Pinecone vector DB
- `@dotdo/qdrant` - Qdrant vector search
- `@dotdo/weaviate` - Weaviate vectors
- `@dotdo/chroma` - ChromaDB embeddings

### Graph

- `@dotdo/neo4j` - Neo4j graph database

## How It Works

### Sharding

Every compat SDK uses the ShardRouter for automatic data distribution.

```typescript
const router = new ShardRouter(env.DO, {
  key: 'tenant_id',
  count: 16,
  algorithm: 'consistent',
})

// Route to specific shard
const stub = await router.getShardStub('tenant-123')
await stub.fetch('/query', { method: 'POST', body: sql })

// Fan out to all shards
const results = await router.queryAll('/aggregate')
```

Three sharding algorithms:

- **Consistent hashing** - Minimal key redistribution when adding shards
- **Range sharding** - Good for time-series or alphabetical data
- **Simple hash** - Uniform distribution, full redistribution on resize

### Tiered Storage

Data lives in three tiers based on access patterns:

```
Hot  → SQLite in DO (< 10ms)
Warm → Cloudflare R2 (< 100ms)
Cold → Iceberg Parquet (analytics)
```

The TierManager automatically promotes and demotes data:

```typescript
// Recent data stays hot
await tier.write('users', row)

// Older data demotes to R2
await tier.compact('users', { olderThan: '7d' })

// Cold data queryable via DuckDB
const analytics = await tier.query('SELECT * FROM users_parquet')
```

### Replication

Read replicas scale reads across DOs:

```typescript
const replica = new ReplicaManager(env.DO, {
  readReplicas: 3,
  writeThrough: true,
})

// Writes go to primary
await replica.write('INSERT INTO users ...')

// Reads load-balance across replicas
const user = await replica.read('SELECT * FROM users WHERE id = ?')
```

## Migration Guide

Moving from managed services to compat SDKs is a one-line change:

```typescript
// Before: Supabase cloud
import { createClient } from '@supabase/supabase-js'

// After: dotdo compat
import { createClient } from '@dotdo/supabase'

// Your code stays exactly the same
const supabase = createClient(url, key)
const { data } = await supabase.from('users').select('*')
```

The compat layer handles:

- Connection management (no pools needed)
- Automatic sharding by tenant
- Tiered storage for cost efficiency
- Edge deployment (300+ cities)

## Cost Comparison

| Operation | Legacy | dotdo |
|-----------|--------|-------|
| 1M reads | ~$0.50 | ~$0.10 |
| 1M writes | ~$1.25 | ~$0.50 |
| 1GB storage | ~$0.25/mo | ~$0.015/mo |
| Egress | $0.09/GB | $0 |

Zero egress costs because everything runs on Cloudflare R2.

## Documentation Structure

dotdo documentation is organized into two sections:

- **Compat Categories** (this section) - Architecture overviews explaining how groups of SDKs work, including sharding, tiering, and patterns
- **[Individual Integrations](/docs/integrations)** - Detailed API reference and examples for specific services

## Browse by Category

<Cards>
  <Card title="Databases" href="/docs/compat/databases">
    Postgres, MySQL, MongoDB, Supabase, Firebase, and more.
  </Card>
  <Card title="Messaging" href="/docs/compat/messaging">
    Kafka, Redis, NATS, SQS, and Pub/Sub.
  </Card>
  <Card title="Realtime" href="/docs/compat/realtime">
    Pusher, Ably, Socket.IO for WebSocket communication.
  </Card>
  <Card title="Search" href="/docs/compat/search">
    Elasticsearch, Algolia, Meilisearch, Typesense, Orama.
  </Card>
  <Card title="Vector" href="/docs/compat/vector">
    Pinecone, Qdrant, Weaviate, Chroma for embeddings.
  </Card>
  <Card title="Graph" href="/docs/compat/graph">
    Neo4j graph database with Cypher support.
  </Card>
</Cards>

## Individual Service Guides

For detailed API documentation on specific services, see [Integrations](/docs/integrations).

## Related

<Cards>
  <Card title="Storage Architecture" href="/docs/storage">
    Tiered storage from DO SQLite to R2 and Iceberg.
  </Card>
  <Card title="Durable Objects" href="/docs/objects">
    DO class hierarchy that powers compat SDKs.
  </Card>
  <Card title="Architecture" href="/docs/architecture">
    Technical deep dive into V8 isolates and DO internals.
  </Card>
  <Card title="Integrations" href="/docs/integrations">
    Individual service integration guides and API references.
  </Card>
</Cards>
