---
title: Merge Strategies
description: Combine results from multiple scanners using union, intersect, sort, and limit operations
---

# Merge Strategies

The `merge` module provides strategies for combining query results from multiple scanner DOs. These operations are essential for aggregating distributed query results into a single coherent result set.

## Overview

| Strategy | Purpose | Use Case |
|----------|---------|----------|
| `union` | Combine all rows | SELECT * queries |
| `intersect` | Rows present in ALL sources | Set intersection |
| `sort` | Order combined results | ORDER BY queries |
| `limit` | Take first N results | LIMIT queries |

## Import

```typescript
import { merge, type QueryResult } from 'dotdo/fanout'
```

## Union

Combine all rows from multiple result sets, preserving order from each source.

### Basic Union

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: 2 }] },
  { rows: [{ id: 3 }, { id: 4 }] },
  { rows: [{ id: 5 }] },
]

const merged = merge.union(results)

// { rows: [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }] }
```

Order is preserved: source 0 rows first, then source 1, then source 2.

### Deduplication

Remove duplicates by a key field:

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }] },
  { rows: [{ id: 2, name: 'Bob Updated' }, { id: 3, name: 'Charlie' }] },
]

const merged = merge.union(results, { dedupeKey: 'id' })

// { rows: [
//   { id: 1, name: 'Alice' },
//   { id: 2, name: 'Bob' },      // First occurrence wins
//   { id: 3, name: 'Charlie' }
// ] }
```

### Empty Handling

Empty result sets are handled gracefully:

```typescript
const results: QueryResult[] = [
  { rows: [] },
  { rows: [{ id: 1 }] },
  { rows: [] },
]

const merged = merge.union(results)
// { rows: [{ id: 1 }] }
```

## Intersect

Return only rows present in ALL result sets (by key).

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: 2 }, { id: 3 }] },
  { rows: [{ id: 2 }, { id: 3 }, { id: 4 }] },
  { rows: [{ id: 3 }, { id: 4 }, { id: 5 }] },
]

const merged = merge.intersect(results, 'id')

// { rows: [{ id: 3 }] }  // Only id: 3 is in ALL three
```

### No Common Rows

Returns empty when no rows are in all sources:

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: 2 }] },
  { rows: [{ id: 3 }, { id: 4 }] },
]

const merged = merge.intersect(results, 'id')
// { rows: [] }
```

### Two-Way Intersection

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: 2 }, { id: 3 }] },
  { rows: [{ id: 2 }, { id: 3 }] },
]

const merged = merge.intersect(results, 'id')
// { rows: [{ id: 2 }, { id: 3 }] }
```

## Sort

Sort combined results by a key field.

### Ascending (default)

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 3 }, { id: 1 }] },
  { rows: [{ id: 4 }, { id: 2 }] },
]

const merged = merge.sort(results, 'id', 'asc')
// { rows: [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }] }
```

### Descending

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: 3 }] },
  { rows: [{ id: 2 }, { id: 4 }] },
]

const merged = merge.sort(results, 'id', 'desc')
// { rows: [{ id: 4 }, { id: 3 }, { id: 2 }, { id: 1 }] }
```

### String Sorting

Strings are sorted alphabetically using `localeCompare`:

```typescript
const results: QueryResult[] = [
  { rows: [{ name: 'Charlie' }, { name: 'Alice' }] },
  { rows: [{ name: 'Bob' }] },
]

const merged = merge.sort(results, 'name', 'asc')
// { rows: [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Charlie' }] }
```

### Date Sorting

ISO date strings sort correctly as strings:

```typescript
const results: QueryResult[] = [
  { rows: [{ created: '2024-01-15' }, { created: '2024-01-01' }] },
  { rows: [{ created: '2024-01-10' }] },
]

const merged = merge.sort(results, 'created', 'asc')
// { rows: [
//   { created: '2024-01-01' },
//   { created: '2024-01-10' },
//   { created: '2024-01-15' }
// ] }
```

### Null Handling

Null values sort last regardless of direction:

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 1 }, { id: null }] },
  { rows: [{ id: 2 }] },
]

const merged = merge.sort(results, 'id', 'asc')
// { rows: [{ id: 1 }, { id: 2 }, { id: null }] }
```

## Limit

Return only the first N rows.

### Basic Limit

```typescript
const result: QueryResult = {
  rows: [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }],
}

const limited = merge.limit(result, 3)
// { rows: [{ id: 1 }, { id: 2 }, { id: 3 }], hasMore: true }
```

### hasMore Flag

The `hasMore` flag indicates if more rows were available:

```typescript
const result: QueryResult = {
  rows: [{ id: 1 }, { id: 2 }],
  hasMore: false,
}

const limited = merge.limit(result, 3)
// { rows: [{ id: 1 }, { id: 2 }], hasMore: false }

const limited2 = merge.limit(result, 1)
// { rows: [{ id: 1 }], hasMore: true }  // More available locally
```

### Edge Cases

```typescript
// Limit 0 returns empty
merge.limit({ rows: [{ id: 1 }] }, 0)
// { rows: [], hasMore: true }

// Limit exceeds count
merge.limit({ rows: [{ id: 1 }, { id: 2 }] }, 10)
// { rows: [{ id: 1 }, { id: 2 }], hasMore: false }
```

## Combined Operations

Chain operations for complex queries like `SELECT ... ORDER BY ... LIMIT`.

### Sort + Limit (ORDER BY LIMIT)

```typescript
const results: QueryResult[] = [
  { rows: [{ id: 5 }, { id: 3 }, { id: 1 }] },
  { rows: [{ id: 4 }, { id: 2 }] },
]

// Get top 3 by id ascending
const sorted = merge.sort(results, 'id', 'asc')
const limited = merge.limit(sorted, 3)

// { rows: [{ id: 1 }, { id: 2 }, { id: 3 }], hasMore: true }
```

### Union + Sort + Limit

```typescript
// Combine, dedupe, sort, and limit
const unioned = merge.union(results, { dedupeKey: 'id' })
const sorted = merge.sort([unioned], 'created', 'desc')
const limited = merge.limit(sorted, 10)
```

### Distributed Top-N Pattern

For efficient distributed top-N queries, have each scanner return their top N, then merge:

```typescript
// Each scanner returns top 10
const scannerResults = await Promise.all(
  scanners.map(s => s.execute('SELECT * FROM events ORDER BY created DESC LIMIT 10'))
)

// Merge and re-sort to get global top 10
const sorted = merge.sort(scannerResults, 'created', 'desc')
const top10 = merge.limit(sorted, 10)
```

This is more efficient than returning all rows and sorting globally.

## Type Safety

The merge functions are generic and preserve types:

```typescript
interface User {
  id: number
  name: string
  email: string
}

const results: QueryResult<User>[] = [
  { rows: [{ id: 1, name: 'Alice', email: 'alice@example.com' }] },
  { rows: [{ id: 2, name: 'Bob', email: 'bob@example.com' }] },
]

const merged = merge.union<User>(results)
// merged.rows is User[]
```

## Performance Considerations

1. **Union**: O(n) where n is total rows. Dedupe adds overhead for maintaining seen set.

2. **Intersect**: O(n*m) where n is rows in first result and m is number of results. Uses count-based approach.

3. **Sort**: O(n log n) where n is total rows. Uses JavaScript's built-in sort.

4. **Limit**: O(1) - just slices the array.

For large result sets, consider:
- Limiting at each scanner before merge
- Streaming results instead of collecting all
- Using cursor-based pagination

## See Also

- [QueryCoordinator](/docs/fanout/coordinator) - Automatic aggregation
- [Consistent Hashing](/docs/fanout/hashing) - Single-shard routing
- [Subrequest Budget](/docs/fanout/budget) - Cloudflare limits
