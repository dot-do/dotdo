---
title: Quickstart
description: Build and deploy your first AI-powered startup in 5 minutes
---

# Quickstart

Five minutes. One startup. Let's go.

## Before You Start: Key Concepts

dotdo code looks like JavaScript but behaves differently. Understanding these three concepts will make everything click:

<Callout type="info">
**Template Literals = Agent Calls**

`ralph`build ${spec}`` isn't string interpolationâ€”it's an RPC call to the Ralph agent. The backticks invoke the agent, the template contents become the task, and you get back a promise-like proxy.
</Callout>

<Callout type="info">
**Don't Await Everything**

Unlike typical async code, you pass promises directly to other agents: `ralph`build ${spec}`` where `spec` is still a promise. The system uses *promise pipelining* to batch these into a single network round trip. Only `await` when you need the actual value for branching or logging.
</Callout>

<Callout type="info">
**The $ Context**

`$` is your workflow context, available as `this.$` inside DO methods. It provides event handlers (`$.on.Customer.signup`), scheduling (`$.every.monday.at('9am')`), and durability levels (`$.do()`, `$.try()`, `$.send()`). In code examples, we typically use `const $ = this.$` for cleaner syntax.
</Callout>

These patterns will make more sense as you see them in action below.

<Steps>

<Step>

## Create Your Startup

```bash
npx dotdo init saas-idea
cd saas-idea
npm install
```

This creates a new project with `wrangler.jsonc`, `tsconfig.json`, and a basic Durable Object in `src/index.ts`.

</Step>

<Step>

## Define Your Hypothesis

Open `src/index.ts` and replace its contents with your startup definition:

<Callout type="info">
**About `agents.do`:** This is a path alias configured by `npx dotdo init`. If you created your project manually, see [Installation: Import Aliases](/docs/getting-started/installation#import-aliases) to set it up.
</Callout>

```typescript title="src/index.ts"
import { Startup } from 'dotdo'
import { priya, ralph, tom, mark, sally, quinn } from 'agents.do'

export class SaasIdea extends Startup {
  hypothesis = 'Small teams need a simple way to track customer feedback'

  async launch() {
    // Priya defines what to build
    const spec = priya`define the MVP for ${this.hypothesis}`

    // Ralph builds it
    let app = ralph`build ${spec}`

    // Tom reviews, Ralph improves, loop until approved
    do {
      app = ralph`improve ${app} per ${tom}`
    } while (!await tom.approve(app))

    // Quinn runs the test suite
    const tests = quinn`test ${app}`

    // Ship it
    mark`announce the launch of ${app}`
    sally`start selling ${app}`
  }
}
```

</Step>

<Step>

## Start Development

```bash
npm run dev
```

You should see:

```
Starting local server...
Ready on http://localhost:8787
```

Your startup is now running locally as a Durable Object.

</Step>

<Step>

## Trigger the Launch

Call the launch API:

```bash
curl -X POST http://localhost:8787/launch
```

Watch the logs as the agents work. Priya writes the spec. Ralph builds. Tom reviews. The loop continues until Tom approves. Then Mark announces and Sally starts selling.

<Callout type="info">
**Viewing logs:** Run `npx wrangler tail` in a separate terminal to see real-time logs from your worker, or check the terminal where you ran `npm run dev`.
</Callout>

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Your startup is now live on Cloudflare's edge network. 300+ cities. 0ms cold starts.

</Step>

</Steps>

## Understanding the Code

Let's break down what's happening.

### The Signature Pattern

This is the core pattern you'll use everywhere:

```typescript
const spec = priya`define the MVP for ${this.hypothesis}`
let app = ralph`build ${spec}`

do {
  app = ralph`improve ${app} per ${tom}`
} while (!await tom.approve(app))
```

Three key observations:

1. **No `await` on `priya` or `ralph`** - They return proxies, not resolved values
2. **Proxies pass to other agents** - `ralph\`build ${spec}\`` receives the proxy
3. **`await` only where needed** - The `tom.approve(app)` needs the boolean result

### Promise Pipelining in Action

Without pipelining:

```typescript
// This makes 4 separate network calls
const spec = await priya`define the MVP`     // Call 1
const app = await ralph`build ${spec}`       // Call 2
const review = await tom`review ${app}`      // Call 3
const fixed = await ralph`fix ${review}`     // Call 4
```

With pipelining:

```typescript
// This makes 1 network call (batched)
const spec = priya`define the MVP`
const app = ralph`build ${spec}`
const review = tom`review ${app}`
await ralph`fix ${review}`  // Await at the end triggers the batch
```

The server receives all four operations at once. It knows `ralph` depends on `priya`, so it executes them in order, but without network round trips between each step.

### When to Await

| Scenario | Await? | Why |
|----------|--------|-----|
| Passing result to another agent | No | Let the pipeline batch |
| Branching on result | Yes | Need the value to branch |
| Looping until condition | Yes | Need the boolean |
| Returning from function | Yes | Caller needs resolved value |
| Logging the result | Yes | Need the actual value |

<Callout type="info">
**Rule of thumb:** Don't await unless you need to inspect the value or use it in JavaScript control flow.
</Callout>

## Adding Human Escalation

AI does the work. Humans make the hard decisions.

```typescript title="src/startup.ts"
import { Startup } from 'dotdo'
import { priya, ralph, tom, mark, sally } from 'agents.do'
import { ceo, legal } from 'humans.do'

export class SaasIdea extends Startup {
  hypothesis = 'Small teams need a simple way to track customer feedback'

  async launch() {
    const spec = priya`define the MVP for ${this.hypothesis}`
    let app = ralph`build ${spec}`

    do {
      app = ralph`improve ${app} per ${tom}`
    } while (!await tom.approve(app))

    // Human approval for launch
    const approved = await ceo`approve launching ${app}`

    if (approved) {
      mark`announce the launch`
      sally`start selling`
    }
  }

  // Define escalation rules
  escalation = this.HumanFunction({
    trigger: 'refund > $1000',
    role: 'founder',
    sla: '4 hours',
  })
}
```

The `ceo` import comes from `humans.do`. When called, it:

1. Routes to Slack, email, or SMS based on your config
2. Waits for a response (with timeout handling)
3. Returns the human's decision

## Event-Driven Workflows

Your startup can react to events:

```typescript title="src/startup.ts"
import { Startup } from 'dotdo'
import { priya, ralph, sally } from 'agents.do'

export class SaasIdea extends Startup {
  hypothesis = 'Small teams need a simple way to track customer feedback'

  async init() {
    // $ is the WorkflowContext, available as this.$ in DO methods
    const $ = this.$

    // When a customer signs up
    $.on.Customer.signup(async (event) => {
      sally`welcome ${event.customer}`
    })

    // When payment fails
    $.on.Payment.failed(async (event) => {
      sally`follow up on failed payment for ${event.customer}`
    })

    // Weekly product review
    $.every.monday.at('9am')(async () => {
      const feedback = await $.Customer.all().getFeedback()
      priya`analyze ${feedback} and update the roadmap`
    })
  }
}
```

The `$.on` and `$.every` patterns use proxies to build event handlers fluently. No await needed when registering - they just set up the handlers.

## Inspecting State

Your startup has persistent state:

```typescript
// In your startup class
async getStatus() {
  return {
    hypothesis: this.hypothesis,
    launchCount: this.state.launchCount ?? 0,
    lastLaunch: this.state.lastLaunch,
    agents: {
      priya: await priya.status(),
      ralph: await ralph.status(),
      tom: await tom.status(),
    }
  }
}
```

Access via API:

```bash
curl http://localhost:8787/status
```

## CLI Commands

The dotdo CLI provides commands for every stage of development:

### Development

```bash
# Start local development (recommended)
do start

# Or with wrangler backend
do dev
```

`do start` includes auto-scaffolding, multi-surface support, and hot reload. It's the recommended command for new projects.

### Multi-Surface Development

dotdo supports building complete applications with multiple frontends:

```bash
# Create surface files
touch App.tsx       # Main app at /
touch Admin.tsx     # Admin panel at /admin
touch Site.mdx      # Landing page at /site
touch Docs.mdx      # Documentation at /docs
touch Blog.mdx      # Blog at /blog

# Start and see all surfaces
do start
```

Each surface is automatically discovered and routed. See [Surfaces](/docs/cli/surfaces) for details.

### Configuration

Configure your project in `do.config.ts`:

```typescript title="do.config.ts"
import { defineConfig } from 'dotdo'

export default defineConfig({
  name: 'my-startup',
  port: 4000,
  surfaces: {
    app: './App.tsx',
    admin: './Admin.tsx',
    docs: { shell: './Docs.mdx', content: 'docs/' },
  },
})
```

See [Configuration](/docs/cli/config) for all options.

### Deployment

```bash
# Deploy to Cloudflare Workers
do deploy

# Preview deployment
do deploy --dry-run

# Deploy to staging
do deploy --env staging
```

### Other Commands

```bash
do init my-project     # Initialize new project
do generate agent foo  # Generate scaffolding
do logs               # Stream production logs
do config             # Manage CLI configuration
```

## Next Steps

You've built a startup. Here's what to explore next:

<Cards>
  <Card title="CLI Reference" href="/docs/cli">
    Complete command documentation
  </Card>
  <Card title="Surfaces" href="/docs/cli/surfaces">
    Multi-surface architecture
  </Card>
  <Card title="RPC & Pipelines" href="/docs/rpc">
    Deep dive into Cap'n Web
  </Card>
  <Card title="The $ Context" href="/docs/sdk/workflow-context">
    Event handling, scheduling, durability
  </Card>
  <Card title="Things" href="/docs/sdk/thing">
    Define custom entities
  </Card>
  <Card title="Deployment" href="/docs/deployment">
    Production configuration
  </Card>
</Cards>

---

**You're one person. You just shipped a team.**

Questions? [Discord](https://discord.gg/dotdo) or [GitHub Issues](https://github.com/dotdo/dotdo/issues).
