---
title: Why dotdo?
description: The semantic runtime for Cloudflare Durable Objects - model your domain with linguistic primitives, not database tables.
---

# Why dotdo?

dotdo is a runtime layer for Cloudflare Durable Objects that lets you model your domain using semantic primitives instead of raw database tables and boilerplate code.

## The Problem

Building applications on Durable Objects typically means:

- Writing boilerplate for state persistence
- Managing SQLite schemas manually
- Building your own event system
- Implementing retry logic and durability patterns
- Creating scheduling mechanisms from scratch
- Wiring up WebSockets and streaming

You end up spending more time on infrastructure than on your actual domain logic.

## The dotdo Approach

dotdo provides a progressive enhancement stack where you only pay for what you use:

```
DOCore      (~5KB)   State, alarms, routing
DOSemantic  (~20KB)  Nouns, Verbs, Things, Actions
DOStorage   (~40KB)  Pipeline-as-WAL, lazy checkpointing
DOWorkflow  (~60KB)  WorkflowContext ($), scheduling
DOFull      (~80KB)  AI, human-in-loop, streaming
```

Start with the smallest layer that meets your needs. Upgrade as your requirements grow.

## Semantic Modeling

Instead of thinking in tables and rows, model your domain using linguistic primitives:

```typescript
// Nouns name things
const Customer = noun('Customer')
const Order = noun('Order')

// Verbs describe actions
const purchase = verb('purchase')
const ship = verb('ship')

// Things are instances
const alice = thing(Customer, 'alice-123')
const order = thing(Order, 'order-456')

// Actions capture what happened
const action = alice.purchased(order).at(store).on(new Date())
```

This single action simultaneously represents:
- An **event** (something happened)
- An **edge** (alice relates to order)
- An **audit log entry** (who did what when)

No more maintaining separate tables for events, relationships, and audit logs.

## The WorkflowContext ($)

Your universal API for everything:

```typescript
// Event handling with infinite Noun.verb combinations
$.on.Customer.signup(async (event) => { ... })
$.on.Payment.failed(async (event) => { ... })
$.on.*.created(async (event) => { ... })  // Wildcards

// Scheduling with fluent DSL
$.every.Monday.at9am(sendWeeklyReport)
$.every.day.at('6pm')(endOfDayProcessing)
$.every.hour(healthCheck)

// Cross-DO RPC
await $.Customer(id).notify('Welcome!')

// Durable execution
$.do(action)      // Retries + persistence
$.try(action)     // Single attempt
$.send(event)     // Fire-and-forget
```

## Cost-Optimized Durability

dotdo's Pipeline-as-WAL architecture achieves 95%+ SQLite write cost reduction:

```
L0: InMemory   O(1) reads, dirty tracking
L1: Pipeline   WAL for durability, immediate ACK
L2: SQLite     Lazy checkpoint, batched writes
L3: Iceberg    Cold storage, time travel
```

Writes acknowledge immediately at L1, then lazily checkpoint to SQLite. Your application stays fast while maintaining full durability guarantees.

## Real Testing, No Mocks

Miniflare runs real Durable Objects with real SQLite locally. Test your actual code:

```typescript
import { env } from 'cloudflare:test'

const stub = env.DO.get(env.DO.idFromName('test'))

// Test via RPC
const customer = await stub.things.create({
  $type: 'Customer',
  name: 'Alice'
})
expect(customer.$id).toBeDefined()
```

No mocking, no faking, no surprises in production.

## When to Use dotdo

dotdo is ideal when you need:

- **Semantic data modeling** - your domain has clear nouns, verbs, and relationships
- **Event-driven architecture** - you want `Noun.verb` event patterns
- **Durable execution** - retries, persistence, and exactly-once semantics
- **Multi-tenant applications** - each tenant gets their own DO instance
- **Real-time collaboration** - WebSocket support built-in
- **AI integration** - template literal AI with cascade execution

## When Not to Use dotdo

Consider alternatives if you need:

- **Simple key-value storage** - use Cloudflare KV directly
- **Relational queries across entities** - use D1 or external PostgreSQL
- **Massive read scale** - add Cloudflare Workers + caching in front

## Next Steps

Ready to get started?

1. [Installation](/docs/getting-started/installation) - Set up your development environment
2. [Quick Start](/docs/getting-started/quick-start) - Build your first DO in 5 minutes
3. [Core Concepts](/docs/getting-started/concepts) - Understand the mental model
