---
title: Quick Start
description: Build your first Durable Object with dotdo in 5 minutes.
---

# Quick Start

Let's build a task manager DO that demonstrates dotdo's core features: state management, event handling, and scheduling.

## What We're Building

A `TaskManager` Durable Object that:
- Stores tasks with SQLite persistence
- Fires events when tasks are created or completed
- Schedules a daily summary at 9am

## Step 1: Extend DOCore

Start with `DOCore`, the foundation class providing state management and routing:

```typescript
// src/task-manager.ts
import { DOCore, type DOCoreEnv } from 'dotdo/core'

interface Task {
  id: string
  title: string
  completed: boolean
  createdAt: string
}

export class TaskManager extends DOCore {
  // Create a new task
  async createTask(title: string): Promise<Task> {
    const task: Task = {
      id: crypto.randomUUID(),
      title,
      completed: false,
      createdAt: new Date().toISOString(),
    }

    // Store in SQLite via DOCore's state management
    await this.set(`task:${task.id}`, task)

    return task
  }

  // Get a task by ID
  async getTask(id: string): Promise<Task | undefined> {
    return await this.get(`task:${id}`) as Task | undefined
  }

  // List all tasks
  async listTasks(): Promise<Task[]> {
    const entries = await this.list({ prefix: 'task:' })
    return Object.values(entries) as Task[]
  }

  // Complete a task
  async completeTask(id: string): Promise<Task | undefined> {
    const task = await this.getTask(id)
    if (!task) return undefined

    task.completed = true
    await this.set(`task:${id}`, task)

    return task
  }

  // Delete a task
  async deleteTask(id: string): Promise<boolean> {
    return await this.delete(`task:${id}`)
  }
}
```

## Step 2: Add HTTP Routes

Override `createApp()` to add HTTP endpoints:

```typescript
// src/task-manager.ts (continued)
import { Hono } from 'hono'

export class TaskManager extends DOCore {
  // ... previous methods ...

  protected createApp() {
    // Get the base app with built-in middleware
    const app = super.createApp()

    // GET /tasks - list all tasks
    app.get('/tasks', async (c) => {
      const tasks = await this.listTasks()
      return c.json({ tasks })
    })

    // POST /tasks - create a task
    app.post('/tasks', async (c) => {
      const { title } = await c.req.json()
      if (!title) {
        return c.json({ error: 'Title required' }, 400)
      }
      const task = await this.createTask(title)
      return c.json({ task }, 201)
    })

    // GET /tasks/:id - get a task
    app.get('/tasks/:id', async (c) => {
      const task = await this.getTask(c.req.param('id'))
      if (!task) {
        return c.json({ error: 'Not found' }, 404)
      }
      return c.json({ task })
    })

    // POST /tasks/:id/complete - complete a task
    app.post('/tasks/:id/complete', async (c) => {
      const task = await this.completeTask(c.req.param('id'))
      if (!task) {
        return c.json({ error: 'Not found' }, 404)
      }
      return c.json({ task })
    })

    // DELETE /tasks/:id - delete a task
    app.delete('/tasks/:id', async (c) => {
      const deleted = await this.deleteTask(c.req.param('id'))
      if (!deleted) {
        return c.json({ error: 'Not found' }, 404)
      }
      return c.json({ deleted: true })
    })

    return app
  }
}
```

## Step 3: Add RPC Methods

RPC methods allow direct method calls from other DOs or the worker:

```typescript
// The methods we already defined ARE RPC methods!
// DOCore exposes all public methods via RPC

// From the worker, you can call:
const stub = env.TaskManager.get(id)
const task = await stub.createTask('Buy milk')
const tasks = await stub.listTasks()
```

## Step 4: Wire Up the Worker

Create the worker entry point:

```typescript
// src/index.ts
import { TaskManager } from './task-manager'

interface Env {
  TaskManager: DurableObjectNamespace<TaskManager>
}

export { TaskManager }

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url)

    // Route: /api/:userId/tasks/*
    const match = url.pathname.match(/^\/api\/([^\/]+)\/tasks(.*)$/)
    if (match) {
      const [, userId, rest] = match

      // Each user gets their own DO instance
      const id = env.TaskManager.idFromName(userId)
      const stub = env.TaskManager.get(id)

      // Rewrite URL to task manager routes
      const taskUrl = new URL(request.url)
      taskUrl.pathname = `/tasks${rest}`

      return stub.fetch(new Request(taskUrl, request))
    }

    return new Response('Not Found', { status: 404 })
  },
}
```

## Step 5: Update wrangler.toml

```toml
name = "task-manager"
main = "src/index.ts"
compatibility_date = "2024-12-30"

[durable_objects]
bindings = [
  { name = "TaskManager", class_name = "TaskManager" }
]

[[migrations]]
tag = "v1"
new_sqlite_classes = ["TaskManager"]
```

## Step 6: Test It

```bash
# Start dev server
npm run dev

# Create a task
curl -X POST http://localhost:8787/api/alice/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "Learn dotdo"}'

# List tasks
curl http://localhost:8787/api/alice/tasks

# Complete a task
curl -X POST http://localhost:8787/api/alice/tasks/{id}/complete
```

## Step 7: Add Events (Optional)

Upgrade to `DOWorkflow` for event handling:

```typescript
import { DOWorkflow, createWorkflowContext } from 'dotdo/workflow'

export class TaskManager extends DOWorkflow {
  private $ = createWorkflowContext()

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)

    // Handle task created events
    this.$.on.Task.created(async (event) => {
      console.log('Task created:', event.data)
    })

    // Handle task completed events
    this.$.on.Task.completed(async (event) => {
      console.log('Task completed:', event.data)
    })
  }

  async createTask(title: string): Promise<Task> {
    const task = /* ... same as before ... */

    // Fire event (fire-and-forget)
    this.$.send('Task.created', { task })

    return task
  }

  async completeTask(id: string): Promise<Task | undefined> {
    const task = /* ... same as before ... */

    // Fire event
    this.$.send('Task.completed', { task })

    return task
  }
}
```

## Step 8: Add Scheduling (Optional)

Schedule a daily summary:

```typescript
constructor(ctx: DurableObjectState, env: Env) {
  super(ctx, env)

  // Daily summary at 9am
  this.$.every.day.at('9am')(async () => {
    const tasks = await this.listTasks()
    const incomplete = tasks.filter(t => !t.completed)
    console.log(`Daily summary: ${incomplete.length} tasks remaining`)
  })
}
```

## Full Example

Here's the complete `TaskManager` with all features:

```typescript
// src/task-manager.ts
import { DOWorkflow, createWorkflowContext } from 'dotdo/workflow'
import { Hono } from 'hono'

interface Task {
  id: string
  title: string
  completed: boolean
  createdAt: string
}

interface Env {
  TaskManager: DurableObjectNamespace<TaskManager>
}

export class TaskManager extends DOWorkflow<Env> {
  private $ = createWorkflowContext()

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)

    // Event handlers
    this.$.on.Task.created(async (event) => {
      console.log('Task created:', event.data)
    })

    this.$.on.Task.completed(async (event) => {
      console.log('Task completed:', event.data)
    })

    // Daily summary at 9am
    this.$.every.day.at('9am')(async () => {
      const tasks = await this.listTasks()
      const incomplete = tasks.filter(t => !t.completed)
      console.log(`${incomplete.length} tasks remaining`)
    })
  }

  async createTask(title: string): Promise<Task> {
    const task: Task = {
      id: crypto.randomUUID(),
      title,
      completed: false,
      createdAt: new Date().toISOString(),
    }
    await this.set(`task:${task.id}`, task)
    this.$.send('Task.created', { task })
    return task
  }

  async getTask(id: string): Promise<Task | undefined> {
    return await this.get(`task:${id}`) as Task | undefined
  }

  async listTasks(): Promise<Task[]> {
    const entries = await this.list({ prefix: 'task:' })
    return Object.values(entries) as Task[]
  }

  async completeTask(id: string): Promise<Task | undefined> {
    const task = await this.getTask(id)
    if (!task) return undefined
    task.completed = true
    await this.set(`task:${id}`, task)
    this.$.send('Task.completed', { task })
    return task
  }

  async deleteTask(id: string): Promise<boolean> {
    return await this.delete(`task:${id}`)
  }

  protected createApp() {
    const app = super.createApp()

    app.get('/tasks', async (c) => {
      return c.json({ tasks: await this.listTasks() })
    })

    app.post('/tasks', async (c) => {
      const { title } = await c.req.json()
      if (!title) return c.json({ error: 'Title required' }, 400)
      return c.json({ task: await this.createTask(title) }, 201)
    })

    app.get('/tasks/:id', async (c) => {
      const task = await this.getTask(c.req.param('id'))
      if (!task) return c.json({ error: 'Not found' }, 404)
      return c.json({ task })
    })

    app.post('/tasks/:id/complete', async (c) => {
      const task = await this.completeTask(c.req.param('id'))
      if (!task) return c.json({ error: 'Not found' }, 404)
      return c.json({ task })
    })

    app.delete('/tasks/:id', async (c) => {
      const deleted = await this.deleteTask(c.req.param('id'))
      return c.json({ deleted })
    })

    return app
  }
}
```

## Next Steps

You've built a complete task manager with:
- SQLite-backed state persistence
- HTTP API with Hono routing
- RPC methods for direct calls
- Event handling with `$.on`
- Scheduled tasks with `$.every`

Continue learning:
- [Core Concepts](/docs/getting-started/concepts) - Understand semantic types and the WorkflowContext
