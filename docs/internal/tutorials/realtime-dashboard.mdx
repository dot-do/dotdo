---
title: Real-time Dashboard
description: Build a real-time dashboard with live data updates, presence detection, and WebSocket-like functionality in 25 minutes
---

import { Callout } from 'fumadocs-ui/components/callout'

# Build a Real-time Dashboard in 25 Minutes

Live metrics. Real-time updates. Presence awareness. All without managing WebSocket servers - just Durable Objects and the Pusher-compatible SDK.

By the end, you'll have a dashboard that updates instantly when data changes, shows who's online, and handles thousands of concurrent connections.

---

## Prerequisites

Before starting this tutorial, you'll need:

- Node.js 18+
- A Cloudflare account (free tier works)
- Basic familiarity with TypeScript
- Understanding of event-driven patterns

---

<Steps>

<Step>

## Create the Project

```bash
npx dotdo init my-dashboard --template dashboard
cd my-dashboard
npm install
```

You get:
- Pusher compat SDK configured
- Real-time channel management
- Presence channel support
- Server-sent events fallback

</Step>

<Step>

## Configure Environment

```bash title=".env"
# Pusher compat (uses internal DO-backed channels)
PUSHER_APP_ID=your-app
PUSHER_KEY=your-key
PUSHER_SECRET=your-secret

# Optional: External analytics
PLAUSIBLE_DOMAIN=yourdomain.com
```

<Callout type="info">
The Pusher compat SDK is fully self-hosted on Durable Objects. You don't need an external Pusher account - the credentials are for your own internal use.
</Callout>

</Step>

<Step>

## Set Up the Pusher Server

Create `src/realtime.ts` - your real-time infrastructure:

```typescript title="src/realtime.ts"
import { PusherServer } from '@dotdo/pusher'

// Create server instance
export const pusher = new PusherServer({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.PUSHER_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: 'mt1', // Ignored - uses Cloudflare edge
  useTLS: true,
})

// Helper to broadcast to a channel
export async function broadcast(channel: string, event: string, data: unknown) {
  await pusher.trigger(channel, event, data)
}

// Helper to broadcast to multiple channels
export async function broadcastMany(
  channels: string[],
  event: string,
  data: unknown
) {
  await pusher.trigger(channels, event, data)
}
```

</Step>

<Step>

## Build the Metrics Engine

Create `src/metrics.ts` - the data source for your dashboard:

```typescript title="src/metrics.ts"
import { DO } from 'dotdo'
import { broadcast } from './realtime'

interface Metric {
  name: string
  value: number
  unit: string
  trend: 'up' | 'down' | 'stable'
  changedAt: Date
}

interface MetricsState {
  metrics: Record<string, Metric>
  history: Array<{ timestamp: Date; metrics: Record<string, number> }>
}

export class MetricsEngine extends DO {
  state: MetricsState = {
    metrics: {},
    history: []
  }

  async init() {
    // Collect metrics every minute
    $.every.minute(async () => {
      await this.collectMetrics()
    })

    // Trim history daily
    $.every.day.at3am(async () => {
      await this.trimHistory()
    })
  }

  /**
   * Update a single metric
   */
  async updateMetric(name: string, value: number, unit: string = '') {
    const previous = this.state.metrics[name]
    const trend = this.calculateTrend(previous?.value, value)

    const metric: Metric = {
      name,
      value,
      unit,
      trend,
      changedAt: new Date()
    }

    this.state.metrics[name] = metric

    // Broadcast update to all dashboard viewers
    await broadcast('dashboard', 'metric:updated', {
      metric,
      previous: previous?.value
    })

    return metric
  }

  /**
   * Update multiple metrics at once
   */
  async updateMetrics(updates: Array<{ name: string; value: number; unit?: string }>) {
    const results: Metric[] = []

    for (const update of updates) {
      const metric = await this.updateMetric(update.name, update.value, update.unit)
      results.push(metric)
    }

    return results
  }

  /**
   * Get current metrics
   */
  async getMetrics(): Promise<Record<string, Metric>> {
    return this.state.metrics
  }

  /**
   * Get metric history for charts
   */
  async getHistory(
    metricNames: string[],
    hours: number = 24
  ): Promise<Array<{ timestamp: Date; values: Record<string, number> }>> {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000)

    return this.state.history
      .filter(h => h.timestamp >= cutoff)
      .map(h => ({
        timestamp: h.timestamp,
        values: Object.fromEntries(
          metricNames.map(name => [name, h.metrics[name] ?? 0])
        )
      }))
  }

  /**
   * Collect and store metrics snapshot
   */
  private async collectMetrics() {
    const snapshot = {
      timestamp: new Date(),
      metrics: Object.fromEntries(
        Object.entries(this.state.metrics).map(([name, m]) => [name, m.value])
      )
    }

    this.state.history.push(snapshot)

    // Broadcast snapshot for real-time charts
    await broadcast('dashboard', 'metrics:snapshot', snapshot)
  }

  /**
   * Keep only 7 days of history
   */
  private async trimHistory() {
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
    this.state.history = this.state.history.filter(h => h.timestamp >= sevenDaysAgo)
    $.log('History trimmed', { remaining: this.state.history.length })
  }

  private calculateTrend(previous: number | undefined, current: number): Metric['trend'] {
    if (previous === undefined) return 'stable'
    if (current > previous * 1.05) return 'up'
    if (current < previous * 0.95) return 'down'
    return 'stable'
  }
}
```

</Step>

<Step>

## Build Real-time Event Channels

Create `src/channels.ts` for event management:

```typescript title="src/channels.ts"
import { DO } from 'dotdo'
import { pusher, broadcast } from './realtime'
import type { PresenceChannelData } from '@dotdo/pusher'

interface ChannelState {
  subscribers: Map<string, { userId: string; info: Record<string, unknown> }>
  eventLog: Array<{ event: string; data: unknown; timestamp: Date }>
}

export class DashboardChannel extends DO {
  state: ChannelState = {
    subscribers: new Map(),
    eventLog: []
  }

  async init() {
    // Clean up stale connections
    $.every('5 minutes', async () => {
      await this.cleanupStaleConnections()
    })
  }

  /**
   * Authenticate a user for private/presence channels
   */
  async authorize(socketId: string, channelName: string, userData?: PresenceChannelData) {
    // For private channels
    if (channelName.startsWith('private-')) {
      return pusher.authorizeChannel(socketId, channelName)
    }

    // For presence channels
    if (channelName.startsWith('presence-')) {
      if (!userData) {
        throw new Error('User data required for presence channels')
      }

      return pusher.authorizeChannel(socketId, channelName, userData)
    }

    throw new Error('Invalid channel type')
  }

  /**
   * Subscribe a user to the dashboard
   */
  async subscribe(userId: string, socketId: string, info: Record<string, unknown> = {}) {
    this.state.subscribers.set(socketId, { userId, info })

    // Notify others of new subscriber
    await broadcast('presence-dashboard', 'member:joined', {
      userId,
      info,
      totalMembers: this.state.subscribers.size
    })

    return {
      members: Array.from(this.state.subscribers.values()),
      count: this.state.subscribers.size
    }
  }

  /**
   * Unsubscribe a user from the dashboard
   */
  async unsubscribe(socketId: string) {
    const subscriber = this.state.subscribers.get(socketId)

    if (subscriber) {
      this.state.subscribers.delete(socketId)

      // Notify others
      await broadcast('presence-dashboard', 'member:left', {
        userId: subscriber.userId,
        totalMembers: this.state.subscribers.size
      })
    }

    return { removed: !!subscriber }
  }

  /**
   * Get current subscribers
   */
  async getMembers() {
    return {
      members: Array.from(this.state.subscribers.values()),
      count: this.state.subscribers.size
    }
  }

  /**
   * Broadcast an event to all dashboard viewers
   */
  async broadcastEvent(event: string, data: unknown) {
    // Log the event
    this.state.eventLog.push({
      event,
      data,
      timestamp: new Date()
    })

    // Trim log
    if (this.state.eventLog.length > 1000) {
      this.state.eventLog = this.state.eventLog.slice(-500)
    }

    // Broadcast
    await broadcast('dashboard', event, data)
  }

  private async cleanupStaleConnections() {
    // In production, check heartbeats
    $.log('Cleanup check', { subscribers: this.state.subscribers.size })
  }
}
```

</Step>

<Step>

## Build the Data Collectors

Create `src/collectors.ts` for gathering metrics:

```typescript title="src/collectors.ts"
import { DO } from 'dotdo'

export class DataCollector extends DO {
  async init() {
    // Collect different metrics at different intervals
    $.every.minute(async () => {
      await this.collectRealtimeMetrics()
    })

    $.every('5 minutes', async () => {
      await this.collectAggregateMetrics()
    })

    $.every.hour(async () => {
      await this.collectAnalytics()
    })
  }

  /**
   * Real-time operational metrics
   */
  async collectRealtimeMetrics() {
    const metrics = await $.MetricsEngine('default')

    // Example: Active users (from presence channel)
    const channel = await $.DashboardChannel('main')
    const { count: activeUsers } = await channel.getMembers()

    // Example: Request rate (from analytics)
    const requestRate = await this.getRequestRate()

    // Example: Error rate
    const errorRate = await this.getErrorRate()

    // Example: Response time
    const avgResponseTime = await this.getAverageResponseTime()

    await metrics.updateMetrics([
      { name: 'active_users', value: activeUsers, unit: 'users' },
      { name: 'request_rate', value: requestRate, unit: 'req/min' },
      { name: 'error_rate', value: errorRate, unit: '%' },
      { name: 'response_time', value: avgResponseTime, unit: 'ms' }
    ])
  }

  /**
   * Aggregate business metrics
   */
  async collectAggregateMetrics() {
    const metrics = await $.MetricsEngine('default')

    // Example metrics - replace with your data sources
    const revenue = await this.getTodayRevenue()
    const orders = await this.getTodayOrders()
    const signups = await this.getTodaySignups()

    await metrics.updateMetrics([
      { name: 'revenue_today', value: revenue, unit: '$' },
      { name: 'orders_today', value: orders, unit: 'orders' },
      { name: 'signups_today', value: signups, unit: 'users' }
    ])
  }

  /**
   * Collect analytics data
   */
  async collectAnalytics() {
    const metrics = await $.MetricsEngine('default')

    // Example: Page views, conversion rate, etc.
    const pageViews = await this.getHourlyPageViews()
    const conversionRate = await this.getConversionRate()

    await metrics.updateMetrics([
      { name: 'page_views_hourly', value: pageViews, unit: 'views' },
      { name: 'conversion_rate', value: conversionRate, unit: '%' }
    ])
  }

  // Example data fetching methods - implement with your data sources
  private async getRequestRate(): Promise<number> {
    // Query your analytics or monitoring system
    return Math.floor(Math.random() * 1000) + 500
  }

  private async getErrorRate(): Promise<number> {
    return Math.random() * 2 // 0-2%
  }

  private async getAverageResponseTime(): Promise<number> {
    return Math.floor(Math.random() * 50) + 20 // 20-70ms
  }

  private async getTodayRevenue(): Promise<number> {
    // Query your payments system
    return Math.floor(Math.random() * 10000) + 5000
  }

  private async getTodayOrders(): Promise<number> {
    return Math.floor(Math.random() * 100) + 50
  }

  private async getTodaySignups(): Promise<number> {
    return Math.floor(Math.random() * 50) + 10
  }

  private async getHourlyPageViews(): Promise<number> {
    return Math.floor(Math.random() * 5000) + 1000
  }

  private async getConversionRate(): Promise<number> {
    return Math.random() * 5 + 1 // 1-6%
  }
}
```

</Step>

<Step>

## Build the API

Create `src/api.ts`:

```typescript title="src/api.ts"
import { Hono } from 'hono'
import { streamSSE } from 'hono/streaming'
import { MetricsEngine } from './metrics'
import { DashboardChannel } from './channels'
import { pusher } from './realtime'

const app = new Hono()

// Get current metrics
app.get('/metrics', async (c) => {
  const engine = await MetricsEngine.get('default')
  const metrics = await engine.getMetrics()
  return c.json(metrics)
})

// Get metric history
app.get('/metrics/history', async (c) => {
  const engine = await MetricsEngine.get('default')
  const names = c.req.query('names')?.split(',') ?? []
  const hours = parseInt(c.req.query('hours') ?? '24')

  const history = await engine.getHistory(names, hours)
  return c.json(history)
})

// Update a metric (internal/webhook use)
app.post('/metrics/:name', async (c) => {
  const { value, unit } = await c.req.json()
  const name = c.req.param('name')

  const engine = await MetricsEngine.get('default')
  const metric = await engine.updateMetric(name, value, unit)

  return c.json(metric)
})

// Pusher auth endpoint
app.post('/pusher/auth', async (c) => {
  const { socket_id, channel_name, user_id, user_info } = await c.req.json()

  const channel = await DashboardChannel.get('main')

  try {
    const auth = await channel.authorize(socket_id, channel_name, {
      user_id,
      user_info
    })
    return c.json(auth)
  } catch (error) {
    return c.json({ error: (error as Error).message }, 403)
  }
})

// Get online users
app.get('/presence', async (c) => {
  const channel = await DashboardChannel.get('main')
  const members = await channel.getMembers()
  return c.json(members)
})

// Server-Sent Events fallback for real-time updates
app.get('/events', async (c) => {
  return streamSSE(c, async (sse) => {
    // Subscribe to metrics updates
    const engine = await MetricsEngine.get('default')

    // Send initial state
    const metrics = await engine.getMetrics()
    await sse.writeSSE({
      event: 'init',
      data: JSON.stringify({ metrics })
    })

    // Keep connection alive
    const keepAlive = setInterval(async () => {
      await sse.writeSSE({
        event: 'ping',
        data: JSON.stringify({ timestamp: Date.now() })
      })
    }, 30000)

    // Clean up on disconnect
    c.req.raw.signal.addEventListener('abort', () => {
      clearInterval(keepAlive)
    })

    // In production, subscribe to a message queue or pub/sub
    // For now, poll for changes
    let lastUpdate = Date.now()

    while (!c.req.raw.signal.aborted) {
      await new Promise(resolve => setTimeout(resolve, 1000))

      const currentMetrics = await engine.getMetrics()
      const hasUpdates = Object.values(currentMetrics).some(
        m => m.changedAt.getTime() > lastUpdate
      )

      if (hasUpdates) {
        await sse.writeSSE({
          event: 'update',
          data: JSON.stringify({ metrics: currentMetrics })
        })
        lastUpdate = Date.now()
      }
    }
  })
})

// Trigger a test event
app.post('/test-event', async (c) => {
  const channel = await DashboardChannel.get('main')
  await channel.broadcastEvent('test', {
    message: 'Hello from the server!',
    timestamp: new Date()
  })
  return c.json({ sent: true })
})

export default app
```

</Step>

<Step>

## Build the Dashboard Frontend

Create `src/dashboard.html`:

```html title="src/dashboard.html"
<!DOCTYPE html>
<html>
<head>
  <title>Real-time Dashboard</title>
  <script src="https://js.pusher.com/8.0/pusher.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, system-ui, sans-serif; background: #0f172a; color: #f1f5f9; }
    .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; padding: 20px; }
    .metric-card {
      background: #1e293b; border-radius: 12px; padding: 24px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .metric-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .metric-card.updated { animation: pulse 0.5s ease-out; }
    @keyframes pulse { 0% { background: #2563eb; } 100% { background: #1e293b; } }
    .metric-name { font-size: 14px; color: #94a3b8; margin-bottom: 8px; }
    .metric-value { font-size: 36px; font-weight: 700; }
    .metric-unit { font-size: 14px; color: #64748b; margin-left: 4px; }
    .metric-trend { font-size: 14px; margin-top: 8px; }
    .trend-up { color: #22c55e; }
    .trend-down { color: #ef4444; }
    .trend-stable { color: #94a3b8; }
    .presence { position: fixed; top: 20px; right: 20px; background: #1e293b; padding: 16px; border-radius: 8px; }
    .presence-count { font-size: 24px; font-weight: 700; }
    .presence-label { font-size: 12px; color: #94a3b8; }
    .connection-status { position: fixed; bottom: 20px; left: 20px; padding: 8px 16px; border-radius: 20px; font-size: 12px; }
    .connected { background: #166534; }
    .disconnected { background: #991b1b; }
  </style>
</head>
<body>
  <div class="presence">
    <div class="presence-count" id="viewer-count">0</div>
    <div class="presence-label">viewers online</div>
  </div>

  <div class="dashboard" id="metrics"></div>

  <div class="connection-status disconnected" id="status">Connecting...</div>

  <script>
    const API_URL = 'http://localhost:8787'

    // Initialize Pusher
    const pusher = new Pusher('your-key', {
      cluster: 'mt1',
      authEndpoint: `${API_URL}/pusher/auth`,
      auth: {
        params: {
          user_id: 'user_' + Math.random().toString(36).slice(2),
          user_info: { name: 'Dashboard Viewer' }
        }
      }
    })

    // Connection status
    pusher.connection.bind('connected', () => {
      document.getElementById('status').textContent = 'Connected'
      document.getElementById('status').className = 'connection-status connected'
    })

    pusher.connection.bind('disconnected', () => {
      document.getElementById('status').textContent = 'Disconnected'
      document.getElementById('status').className = 'connection-status disconnected'
    })

    // Subscribe to dashboard channel
    const channel = pusher.subscribe('dashboard')

    channel.bind('metric:updated', (data) => {
      updateMetricCard(data.metric)
    })

    channel.bind('metrics:snapshot', (data) => {
      console.log('Snapshot received:', data)
    })

    // Subscribe to presence channel
    const presence = pusher.subscribe('presence-dashboard')

    presence.bind('pusher:subscription_succeeded', (members) => {
      document.getElementById('viewer-count').textContent = members.count
    })

    presence.bind('pusher:member_added', (member) => {
      const count = parseInt(document.getElementById('viewer-count').textContent)
      document.getElementById('viewer-count').textContent = count + 1
    })

    presence.bind('pusher:member_removed', (member) => {
      const count = parseInt(document.getElementById('viewer-count').textContent)
      document.getElementById('viewer-count').textContent = Math.max(0, count - 1)
    })

    // Render metric card
    function updateMetricCard(metric) {
      const container = document.getElementById('metrics')
      let card = document.getElementById(`metric-${metric.name}`)

      if (!card) {
        card = document.createElement('div')
        card.id = `metric-${metric.name}`
        card.className = 'metric-card'
        container.appendChild(card)
      }

      const trendIcon = metric.trend === 'up' ? '↑' : metric.trend === 'down' ? '↓' : '→'
      const trendClass = `trend-${metric.trend}`

      card.innerHTML = `
        <div class="metric-name">${formatName(metric.name)}</div>
        <div>
          <span class="metric-value">${formatValue(metric.value)}</span>
          <span class="metric-unit">${metric.unit}</span>
        </div>
        <div class="metric-trend ${trendClass}">${trendIcon} ${metric.trend}</div>
      `

      // Flash animation
      card.classList.add('updated')
      setTimeout(() => card.classList.remove('updated'), 500)
    }

    function formatName(name) {
      return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
    }

    function formatValue(value) {
      if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M'
      if (value >= 1000) return (value / 1000).toFixed(1) + 'K'
      return value.toFixed(value % 1 === 0 ? 0 : 2)
    }

    // Load initial metrics
    async function loadMetrics() {
      const response = await fetch(`${API_URL}/metrics`)
      const metrics = await response.json()

      for (const metric of Object.values(metrics)) {
        updateMetricCard(metric)
      }
    }

    loadMetrics()
  </script>
</body>
</html>
```

</Step>

<Step>

## Test Locally

```bash
npm run dev
```

Open the dashboard in your browser at `http://localhost:8787/dashboard.html`.

Test real-time updates:

```bash
# Update a metric
curl -X POST http://localhost:8787/metrics/active_users \
  -H "Content-Type: application/json" \
  -d '{"value": 150, "unit": "users"}'

# Watch the dashboard update instantly!

# Update multiple metrics
curl -X POST http://localhost:8787/metrics/revenue_today \
  -H "Content-Type: application/json" \
  -d '{"value": 12500, "unit": "$"}'

curl -X POST http://localhost:8787/metrics/error_rate \
  -H "Content-Type: application/json" \
  -d '{"value": 0.5, "unit": "%"}'

# Check presence
curl http://localhost:8787/presence

# Send test event
curl -X POST http://localhost:8787/test-event
```

Open multiple browser tabs to see the presence counter update.

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Set production secrets:

```bash
npx wrangler secret put PUSHER_APP_ID
npx wrangler secret put PUSHER_KEY
npx wrangler secret put PUSHER_SECRET
```

Your real-time dashboard is now live at `my-dashboard.workers.dev`.

</Step>

</Steps>

---

## What You Built

In 25 minutes, you've deployed a real-time dashboard with:

| Feature | Implementation |
|---------|----------------|
| Live metric updates | Pusher channels with DO backend |
| Presence awareness | Who's viewing the dashboard |
| Automatic data collection | Scheduled metric gathering |
| Historical data | 7-day retention with charts |
| SSE fallback | For environments without WebSockets |
| Trend detection | Automatic up/down/stable indicators |

---

## Key Patterns Used

### Real-time Broadcasting

```typescript
// Broadcast to all subscribers
await broadcast('dashboard', 'metric:updated', { metric })

// Client receives instantly
channel.bind('metric:updated', (data) => {
  updateMetricCard(data.metric)
})
```

### Presence Channels

```typescript
// Track who's viewing
const presence = pusher.subscribe('presence-dashboard')

presence.bind('pusher:member_added', (member) => {
  console.log('New viewer:', member.info.name)
})
```

### Scheduled Collection

```typescript
// Collect metrics at different intervals
$.every.minute(async () => await this.collectRealtimeMetrics())
$.every('5 minutes')(async () => await this.collectAggregateMetrics())
$.every.hour(async () => await this.collectAnalytics())
```

---

## Extending Your Dashboard

### Add Alerting

```typescript
async updateMetric(name: string, value: number, unit: string) {
  const previous = this.state.metrics[name]

  // Check thresholds
  if (name === 'error_rate' && value > 5) {
    // Fire-and-forget alert
    $.send('alert:critical', {
      metric: name,
      value,
      threshold: 5,
      message: `Error rate exceeded 5%: ${value}%`
    })
  }

  // ... rest of update logic
}
```

### Add Custom Charts

```typescript
// API endpoint for chart data
app.get('/metrics/:name/chart', async (c) => {
  const name = c.req.param('name')
  const hours = parseInt(c.req.query('hours') ?? '24')

  const engine = await MetricsEngine.get('default')
  const history = await engine.getHistory([name], hours)

  return c.json({
    labels: history.map(h => h.timestamp),
    values: history.map(h => h.values[name])
  })
})
```

### Add Team Notifications

```typescript
import { mark, sally } from 'agents.do'

$.on.Alert.critical(async (event) => {
  const { metric, value, message } = event.data

  // Notify via Slack/email
  mark`post to #alerts: ${message}`

  // If high severity, escalate
  if (metric === 'error_rate' && value > 10) {
    sally`page on-call engineer about ${message}`
  }
})
```

---

## Next Steps

Your real-time dashboard is live. Explore:

- [Pusher Integration](/docs/integrations/pusher) - Full API documentation
- [SaaS tutorial](/docs/tutorials/saas-starter) - Add user auth
- [Events Overview](/docs/events) - Event-driven patterns
- [Deployment](/docs/deployment) - Custom domains and scaling

---

**You built a real-time dashboard. Metrics update instantly. You can see who's watching. Go add some alerts.**
