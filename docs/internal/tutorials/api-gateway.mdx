---
title: API Gateway
description: Build a production-ready API gateway with rate limiting, authentication, caching, and request routing in 25 minutes
---

import { Callout } from 'fumadocs-ui/components/callout'

# Build an API Gateway in 25 Minutes

Rate limiting per user. JWT authentication. Request routing. Response caching. All running on the edge with Durable Objects for distributed state.

By the end, you'll have a production-ready API gateway that protects your backend services and scales globally.

---

## Prerequisites

Before starting this tutorial, you'll need:

- Node.js 18+
- A Cloudflare account (free tier works)
- Basic familiarity with TypeScript
- Understanding of HTTP and REST APIs

---

<Steps>

<Step>

## Create the Project

```bash
npx dotdo init my-gateway --template api-gateway
cd my-gateway
npm install
```

You get:
- Rate limiting infrastructure
- JWT authentication middleware
- Request routing configuration
- Response caching layer

</Step>

<Step>

## Configure Environment

```bash title=".env"
# JWT Configuration
JWT_SECRET=your-super-secret-key-change-this
JWT_ISSUER=your-app.com
JWT_AUDIENCE=api.your-app.com

# Rate Limiting Defaults
DEFAULT_RATE_LIMIT=100
DEFAULT_RATE_WINDOW=60

# Backend Services (your upstream APIs)
BACKEND_USERS_URL=https://users-api.internal.com
BACKEND_ORDERS_URL=https://orders-api.internal.com
BACKEND_PRODUCTS_URL=https://products-api.internal.com
```

<Callout type="warn">
Never commit your JWT secret to version control. Use `wrangler secret` for production.
</Callout>

</Step>

<Step>

## Build the Rate Limiter

Create `src/rate-limiter.ts` - uses Durable Objects for distributed rate limiting:

```typescript title="src/rate-limiter.ts"
import { DO } from 'dotdo'

interface RateLimitState {
  requests: number
  windowStart: number
  blocked: boolean
  blockUntil?: number
}

interface RateLimitConfig {
  limit: number         // Max requests per window
  window: number        // Window size in seconds
  blockDuration?: number // How long to block after limit exceeded
}

export class RateLimiter extends DO {
  state: RateLimitState = {
    requests: 0,
    windowStart: Date.now(),
    blocked: false
  }

  /**
   * Check if a request should be allowed
   */
  async checkLimit(config: RateLimitConfig): Promise<{
    allowed: boolean
    remaining: number
    reset: number
    retryAfter?: number
  }> {
    const now = Date.now()
    const windowMs = config.window * 1000

    // Check if currently blocked
    if (this.state.blocked && this.state.blockUntil) {
      if (now < this.state.blockUntil) {
        return {
          allowed: false,
          remaining: 0,
          reset: Math.ceil((this.state.blockUntil - now) / 1000),
          retryAfter: Math.ceil((this.state.blockUntil - now) / 1000)
        }
      }
      // Block expired, reset
      this.state.blocked = false
      this.state.blockUntil = undefined
    }

    // Check if window has expired
    if (now - this.state.windowStart >= windowMs) {
      this.state.requests = 0
      this.state.windowStart = now
    }

    // Check limit
    if (this.state.requests >= config.limit) {
      // Exceeded limit
      if (config.blockDuration) {
        this.state.blocked = true
        this.state.blockUntil = now + config.blockDuration * 1000
      }

      const reset = Math.ceil((this.state.windowStart + windowMs - now) / 1000)

      // Log for monitoring
      $.send('rateLimit.exceeded', {
        id: this.id,
        limit: config.limit,
        window: config.window
      })

      return {
        allowed: false,
        remaining: 0,
        reset,
        retryAfter: reset
      }
    }

    // Allow and increment
    this.state.requests++

    return {
      allowed: true,
      remaining: config.limit - this.state.requests,
      reset: Math.ceil((this.state.windowStart + windowMs - now) / 1000)
    }
  }

  /**
   * Get current state without incrementing
   */
  async getState(config: RateLimitConfig) {
    const now = Date.now()
    const windowMs = config.window * 1000

    return {
      requests: this.state.requests,
      remaining: Math.max(0, config.limit - this.state.requests),
      reset: Math.ceil((this.state.windowStart + windowMs - now) / 1000),
      blocked: this.state.blocked
    }
  }

  /**
   * Reset rate limit (admin use)
   */
  async reset() {
    this.state = {
      requests: 0,
      windowStart: Date.now(),
      blocked: false
    }
    return { reset: true }
  }
}
```

</Step>

<Step>

## Build the Authentication Layer

Create `src/auth.ts` for JWT validation and API key management:

```typescript title="src/auth.ts"
import { DO } from 'dotdo'

interface ApiKey {
  key: string
  name: string
  userId: string
  permissions: string[]
  rateLimit?: { limit: number; window: number }
  createdAt: Date
  lastUsedAt?: Date
  expiresAt?: Date
}

interface JWTPayload {
  sub: string          // User ID
  iss: string          // Issuer
  aud: string          // Audience
  exp: number          // Expiration
  iat: number          // Issued at
  permissions?: string[]
  metadata?: Record<string, unknown>
}

export class AuthManager extends DO {
  private apiKeys: Map<string, ApiKey> = new Map()

  async init() {
    // Clean up expired keys daily
    $.every.day.at3am(async () => {
      await this.cleanupExpiredKeys()
    })
  }

  /**
   * Verify a JWT token
   */
  async verifyJWT(token: string): Promise<{
    valid: boolean
    payload?: JWTPayload
    error?: string
  }> {
    try {
      // Parse JWT (header.payload.signature)
      const parts = token.split('.')
      if (parts.length !== 3) {
        return { valid: false, error: 'Invalid token format' }
      }

      // Decode payload
      const payload = JSON.parse(atob(parts[1])) as JWTPayload

      // Check expiration
      if (payload.exp && payload.exp < Date.now() / 1000) {
        return { valid: false, error: 'Token expired' }
      }

      // Check issuer
      const expectedIssuer = process.env.JWT_ISSUER
      if (expectedIssuer && payload.iss !== expectedIssuer) {
        return { valid: false, error: 'Invalid issuer' }
      }

      // Check audience
      const expectedAudience = process.env.JWT_AUDIENCE
      if (expectedAudience && payload.aud !== expectedAudience) {
        return { valid: false, error: 'Invalid audience' }
      }

      // Verify signature (using Web Crypto API)
      const secret = process.env.JWT_SECRET!
      const encoder = new TextEncoder()
      const key = await crypto.subtle.importKey(
        'raw',
        encoder.encode(secret),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['verify']
      )

      const signatureValid = await crypto.subtle.verify(
        'HMAC',
        key,
        this.base64UrlDecode(parts[2]),
        encoder.encode(`${parts[0]}.${parts[1]}`)
      )

      if (!signatureValid) {
        return { valid: false, error: 'Invalid signature' }
      }

      return { valid: true, payload }
    } catch (error) {
      return { valid: false, error: (error as Error).message }
    }
  }

  /**
   * Verify an API key
   */
  async verifyApiKey(key: string): Promise<{
    valid: boolean
    apiKey?: ApiKey
    error?: string
  }> {
    const apiKey = this.apiKeys.get(key)

    if (!apiKey) {
      return { valid: false, error: 'Invalid API key' }
    }

    // Check expiration
    if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
      return { valid: false, error: 'API key expired' }
    }

    // Update last used
    apiKey.lastUsedAt = new Date()

    return { valid: true, apiKey }
  }

  /**
   * Create a new API key
   */
  async createApiKey(options: {
    name: string
    userId: string
    permissions: string[]
    rateLimit?: { limit: number; window: number }
    expiresIn?: number // seconds
  }): Promise<ApiKey> {
    // Generate secure key
    const keyBytes = new Uint8Array(32)
    crypto.getRandomValues(keyBytes)
    const key = 'sk_' + Array.from(keyBytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')

    const apiKey: ApiKey = {
      key,
      name: options.name,
      userId: options.userId,
      permissions: options.permissions,
      rateLimit: options.rateLimit,
      createdAt: new Date(),
      expiresAt: options.expiresIn
        ? new Date(Date.now() + options.expiresIn * 1000)
        : undefined
    }

    this.apiKeys.set(key, apiKey)

    // Don't include the full key in logs
    $.log('API key created', { name: options.name, userId: options.userId })

    return apiKey
  }

  /**
   * Revoke an API key
   */
  async revokeApiKey(key: string): Promise<boolean> {
    const deleted = this.apiKeys.delete(key)
    if (deleted) {
      $.log('API key revoked', { keyPrefix: key.slice(0, 10) })
    }
    return deleted
  }

  /**
   * List API keys for a user (without the actual key values)
   */
  async listApiKeys(userId: string): Promise<Array<Omit<ApiKey, 'key'> & { keyPrefix: string }>> {
    return Array.from(this.apiKeys.values())
      .filter(k => k.userId === userId)
      .map(k => ({
        ...k,
        key: undefined,
        keyPrefix: k.key.slice(0, 10) + '...'
      })) as any
  }

  private base64UrlDecode(str: string): Uint8Array {
    const base64 = str.replace(/-/g, '+').replace(/_/g, '/')
    const binary = atob(base64)
    return Uint8Array.from(binary, c => c.charCodeAt(0))
  }

  private async cleanupExpiredKeys() {
    const now = new Date()
    let removed = 0

    for (const [key, apiKey] of this.apiKeys) {
      if (apiKey.expiresAt && apiKey.expiresAt < now) {
        this.apiKeys.delete(key)
        removed++
      }
    }

    $.log('Expired API keys cleaned up', { removed })
  }
}
```

</Step>

<Step>

## Build the Request Router

Create `src/router.ts` for intelligent request routing:

```typescript title="src/router.ts"
import { DO } from 'dotdo'

interface Route {
  pattern: string        // URL pattern (e.g., "/users/*", "/orders/:id")
  backend: string        // Backend service URL
  methods: string[]      // Allowed HTTP methods
  auth: 'none' | 'jwt' | 'apikey' | 'any'
  rateLimit?: { limit: number; window: number }
  cache?: { ttl: number; staleWhileRevalidate?: number }
  transform?: {
    request?: Record<string, string>   // Header transformations
    response?: Record<string, string>
  }
}

interface RouteMatch {
  route: Route
  params: Record<string, string>
  backend: string
}

export class RequestRouter extends DO {
  private routes: Route[] = []

  async init() {
    // Load routes from configuration
    await this.loadRoutes()
  }

  /**
   * Load routes from environment or database
   */
  async loadRoutes() {
    // Default routes - customize for your services
    this.routes = [
      {
        pattern: '/users/*',
        backend: process.env.BACKEND_USERS_URL!,
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        auth: 'jwt',
        rateLimit: { limit: 100, window: 60 }
      },
      {
        pattern: '/orders/*',
        backend: process.env.BACKEND_ORDERS_URL!,
        methods: ['GET', 'POST', 'PUT'],
        auth: 'jwt',
        rateLimit: { limit: 50, window: 60 }
      },
      {
        pattern: '/products',
        backend: process.env.BACKEND_PRODUCTS_URL!,
        methods: ['GET'],
        auth: 'none',
        cache: { ttl: 300, staleWhileRevalidate: 60 }
      },
      {
        pattern: '/products/:id',
        backend: process.env.BACKEND_PRODUCTS_URL!,
        methods: ['GET'],
        auth: 'none',
        cache: { ttl: 300 }
      },
      {
        pattern: '/internal/*',
        backend: process.env.BACKEND_INTERNAL_URL!,
        methods: ['GET', 'POST'],
        auth: 'apikey',
        rateLimit: { limit: 1000, window: 60 }
      }
    ]
  }

  /**
   * Match a request to a route
   */
  async matchRoute(path: string, method: string): Promise<RouteMatch | null> {
    for (const route of this.routes) {
      // Check method
      if (!route.methods.includes(method)) continue

      // Match pattern
      const match = this.matchPattern(route.pattern, path)
      if (match) {
        return {
          route,
          params: match.params,
          backend: this.buildBackendUrl(route.backend, path, route.pattern)
        }
      }
    }

    return null
  }

  /**
   * Add a route dynamically
   */
  async addRoute(route: Route) {
    this.routes.push(route)
    $.log('Route added', { pattern: route.pattern })
  }

  /**
   * Remove a route
   */
  async removeRoute(pattern: string) {
    const index = this.routes.findIndex(r => r.pattern === pattern)
    if (index >= 0) {
      this.routes.splice(index, 1)
      $.log('Route removed', { pattern })
      return true
    }
    return false
  }

  /**
   * Get all routes
   */
  async getRoutes(): Promise<Route[]> {
    return this.routes
  }

  private matchPattern(pattern: string, path: string): { params: Record<string, string> } | null {
    const params: Record<string, string> = {}

    // Handle wildcard patterns
    if (pattern.endsWith('/*')) {
      const prefix = pattern.slice(0, -2)
      if (path.startsWith(prefix)) {
        params['*'] = path.slice(prefix.length)
        return { params }
      }
      return null
    }

    // Handle parameterized patterns
    const patternParts = pattern.split('/')
    const pathParts = path.split('/')

    if (patternParts.length !== pathParts.length) {
      return null
    }

    for (let i = 0; i < patternParts.length; i++) {
      if (patternParts[i].startsWith(':')) {
        params[patternParts[i].slice(1)] = pathParts[i]
      } else if (patternParts[i] !== pathParts[i]) {
        return null
      }
    }

    return { params }
  }

  private buildBackendUrl(backend: string, path: string, pattern: string): string {
    // For wildcard routes, append the remaining path
    if (pattern.endsWith('/*')) {
      const prefix = pattern.slice(0, -2)
      const remaining = path.slice(prefix.length)
      return `${backend}${remaining}`
    }

    return `${backend}${path}`
  }
}
```

</Step>

<Step>

## Build the Response Cache

Create `src/cache.ts` for response caching:

```typescript title="src/cache.ts"
import { DO } from 'dotdo'

interface CacheEntry {
  response: {
    status: number
    headers: Record<string, string>
    body: string
  }
  createdAt: number
  ttl: number
  staleWhileRevalidate?: number
}

export class ResponseCache extends DO {
  private cache: Map<string, CacheEntry> = new Map()

  async init() {
    // Clean up expired entries every hour
    $.every.hour(async () => {
      await this.cleanup()
    })
  }

  /**
   * Generate a cache key for a request
   */
  generateKey(url: string, method: string, vary?: string[]): string {
    const parts = [method, url]
    if (vary) {
      parts.push(...vary)
    }
    return parts.join(':')
  }

  /**
   * Get a cached response
   */
  async get(key: string): Promise<{
    hit: boolean
    stale: boolean
    entry?: CacheEntry
  }> {
    const entry = this.cache.get(key)

    if (!entry) {
      return { hit: false, stale: false }
    }

    const age = Date.now() - entry.createdAt
    const maxAge = entry.ttl * 1000

    // Fresh cache hit
    if (age < maxAge) {
      return { hit: true, stale: false, entry }
    }

    // Stale but within stale-while-revalidate window
    if (entry.staleWhileRevalidate) {
      const staleAge = maxAge + entry.staleWhileRevalidate * 1000
      if (age < staleAge) {
        return { hit: true, stale: true, entry }
      }
    }

    // Expired
    this.cache.delete(key)
    return { hit: false, stale: false }
  }

  /**
   * Cache a response
   */
  async set(
    key: string,
    response: CacheEntry['response'],
    options: { ttl: number; staleWhileRevalidate?: number }
  ) {
    const entry: CacheEntry = {
      response,
      createdAt: Date.now(),
      ttl: options.ttl,
      staleWhileRevalidate: options.staleWhileRevalidate
    }

    this.cache.set(key, entry)

    // Track cache size
    if (this.cache.size > 10000) {
      // Evict oldest entries
      await this.evictOldest(1000)
    }
  }

  /**
   * Invalidate a cache entry
   */
  async invalidate(key: string): Promise<boolean> {
    return this.cache.delete(key)
  }

  /**
   * Invalidate by prefix (e.g., all /products/* entries)
   */
  async invalidatePrefix(prefix: string): Promise<number> {
    let count = 0
    for (const key of this.cache.keys()) {
      if (key.includes(prefix)) {
        this.cache.delete(key)
        count++
      }
    }
    return count
  }

  /**
   * Get cache stats
   */
  async getStats(): Promise<{
    size: number
    oldest: number
    newest: number
  }> {
    if (this.cache.size === 0) {
      return { size: 0, oldest: 0, newest: 0 }
    }

    let oldest = Date.now()
    let newest = 0

    for (const entry of this.cache.values()) {
      if (entry.createdAt < oldest) oldest = entry.createdAt
      if (entry.createdAt > newest) newest = entry.createdAt
    }

    return {
      size: this.cache.size,
      oldest,
      newest
    }
  }

  private async cleanup() {
    const now = Date.now()
    let removed = 0

    for (const [key, entry] of this.cache) {
      const maxAge = entry.ttl * 1000
      const staleAge = entry.staleWhileRevalidate
        ? maxAge + entry.staleWhileRevalidate * 1000
        : maxAge

      if (now - entry.createdAt > staleAge) {
        this.cache.delete(key)
        removed++
      }
    }

    $.log('Cache cleanup', { removed, remaining: this.cache.size })
  }

  private async evictOldest(count: number) {
    const entries = Array.from(this.cache.entries())
      .sort((a, b) => a[1].createdAt - b[1].createdAt)

    for (let i = 0; i < count && i < entries.length; i++) {
      this.cache.delete(entries[i][0])
    }
  }
}
```

</Step>

<Step>

## Build the Gateway API

Create `src/api.ts` - the main gateway entry point:

```typescript title="src/api.ts"
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { RateLimiter } from './rate-limiter'
import { AuthManager } from './auth'
import { RequestRouter } from './router'
import { ResponseCache } from './cache'

const app = new Hono()

// Enable CORS
app.use('/*', cors({
  origin: '*',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Authorization', 'Content-Type', 'X-API-Key'],
  maxAge: 86400
}))

// Health check
app.get('/health', (c) => c.json({ status: 'ok', timestamp: Date.now() }))

// Admin endpoints
app.get('/admin/routes', async (c) => {
  const router = await RequestRouter.get('default')
  return c.json(await router.getRoutes())
})

app.get('/admin/cache/stats', async (c) => {
  const cache = await ResponseCache.get('default')
  return c.json(await cache.getStats())
})

app.post('/admin/cache/invalidate', async (c) => {
  const { prefix } = await c.req.json()
  const cache = await ResponseCache.get('default')
  const count = await cache.invalidatePrefix(prefix)
  return c.json({ invalidated: count })
})

// API Key management
app.post('/admin/api-keys', async (c) => {
  const body = await c.req.json()
  const auth = await AuthManager.get('default')
  const key = await auth.createApiKey(body)
  return c.json(key)
})

app.get('/admin/api-keys/:userId', async (c) => {
  const auth = await AuthManager.get('default')
  const keys = await auth.listApiKeys(c.req.param('userId'))
  return c.json(keys)
})

// Main gateway handler
app.all('/api/*', async (c) => {
  const path = c.req.path.replace('/api', '')
  const method = c.req.method

  // Get dependencies
  const router = await RequestRouter.get('default')
  const auth = await AuthManager.get('default')
  const cache = await ResponseCache.get('default')

  // Match route
  const match = await router.matchRoute(path, method)

  if (!match) {
    return c.json({ error: 'Not found' }, 404)
  }

  const { route, backend } = match

  // Authentication
  if (route.auth !== 'none') {
    let authenticated = false
    let userId: string | undefined
    let rateKey: string | undefined

    // Try JWT
    if (route.auth === 'jwt' || route.auth === 'any') {
      const authHeader = c.req.header('Authorization')
      if (authHeader?.startsWith('Bearer ')) {
        const token = authHeader.slice(7)
        const result = await auth.verifyJWT(token)

        if (result.valid && result.payload) {
          authenticated = true
          userId = result.payload.sub
          rateKey = `jwt:${userId}`
        } else if (route.auth === 'jwt') {
          return c.json({ error: result.error ?? 'Unauthorized' }, 401)
        }
      }
    }

    // Try API Key
    if (!authenticated && (route.auth === 'apikey' || route.auth === 'any')) {
      const apiKey = c.req.header('X-API-Key')
      if (apiKey) {
        const result = await auth.verifyApiKey(apiKey)

        if (result.valid && result.apiKey) {
          authenticated = true
          userId = result.apiKey.userId
          rateKey = `apikey:${result.apiKey.key.slice(0, 10)}`

          // Use API key specific rate limit if defined
          if (result.apiKey.rateLimit) {
            route.rateLimit = result.apiKey.rateLimit
          }
        } else if (route.auth === 'apikey') {
          return c.json({ error: result.error ?? 'Unauthorized' }, 401)
        }
      }
    }

    if (!authenticated) {
      return c.json({ error: 'Authentication required' }, 401)
    }

    // Rate limiting
    if (route.rateLimit && rateKey) {
      const limiter = await RateLimiter.get(rateKey)
      const result = await limiter.checkLimit(route.rateLimit)

      // Add rate limit headers
      c.header('X-RateLimit-Limit', String(route.rateLimit.limit))
      c.header('X-RateLimit-Remaining', String(result.remaining))
      c.header('X-RateLimit-Reset', String(result.reset))

      if (!result.allowed) {
        c.header('Retry-After', String(result.retryAfter))
        return c.json({
          error: 'Rate limit exceeded',
          retryAfter: result.retryAfter
        }, 429)
      }
    }
  }

  // Check cache for GET requests
  if (method === 'GET' && route.cache) {
    const cacheKey = cache.generateKey(path, method)
    const cached = await cache.get(cacheKey)

    if (cached.hit && cached.entry) {
      // Add cache headers
      c.header('X-Cache', cached.stale ? 'STALE' : 'HIT')
      c.header('Age', String(Math.floor((Date.now() - cached.entry.createdAt) / 1000)))

      // If stale, trigger background revalidation
      if (cached.stale) {
        // Fire and forget
        $.send('cache.revalidate', { key: cacheKey, backend })
      }

      // Return cached response
      const response = cached.entry.response
      for (const [key, value] of Object.entries(response.headers)) {
        c.header(key, value)
      }
      return c.body(response.body, response.status as any)
    }

    c.header('X-Cache', 'MISS')
  }

  // Forward to backend
  try {
    const backendUrl = new URL(backend)

    // Copy request headers
    const headers = new Headers()
    for (const [key, value] of c.req.raw.headers) {
      if (!['host', 'connection'].includes(key.toLowerCase())) {
        headers.set(key, value)
      }
    }

    // Add forwarding headers
    headers.set('X-Forwarded-For', c.req.header('CF-Connecting-IP') ?? '')
    headers.set('X-Forwarded-Proto', 'https')
    headers.set('X-Request-ID', $.id())

    // Apply request transformations
    if (route.transform?.request) {
      for (const [key, value] of Object.entries(route.transform.request)) {
        headers.set(key, value)
      }
    }

    // Make request to backend
    const backendResponse = await fetch(backendUrl.toString(), {
      method,
      headers,
      body: ['GET', 'HEAD'].includes(method) ? undefined : await c.req.text()
    })

    // Read response
    const responseBody = await backendResponse.text()

    // Cache successful GET responses
    if (method === 'GET' && route.cache && backendResponse.ok) {
      const cacheKey = cache.generateKey(path, method)
      await cache.set(
        cacheKey,
        {
          status: backendResponse.status,
          headers: Object.fromEntries(backendResponse.headers),
          body: responseBody
        },
        route.cache
      )
    }

    // Copy response headers
    for (const [key, value] of backendResponse.headers) {
      if (!['transfer-encoding', 'connection'].includes(key.toLowerCase())) {
        c.header(key, value)
      }
    }

    // Apply response transformations
    if (route.transform?.response) {
      for (const [key, value] of Object.entries(route.transform.response)) {
        c.header(key, value)
      }
    }

    return c.body(responseBody, backendResponse.status as any)

  } catch (error) {
    $.log('Backend error', { backend, error: (error as Error).message })
    return c.json({ error: 'Backend unavailable' }, 502)
  }
})

export default app
```

</Step>

<Step>

## Test Locally

```bash
npm run dev
```

Test the gateway:

```bash
# Health check
curl http://localhost:8787/health

# View routes
curl http://localhost:8787/admin/routes

# Create an API key
curl -X POST http://localhost:8787/admin/api-keys \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test Key",
    "userId": "user123",
    "permissions": ["read", "write"]
  }'

# Test rate limiting (run multiple times)
for i in {1..5}; do
  curl -i http://localhost:8787/api/products \
    -H "X-API-Key: sk_your_key_here"
done

# Check rate limit headers in response:
# X-RateLimit-Limit: 100
# X-RateLimit-Remaining: 95
# X-RateLimit-Reset: 58

# Test caching
curl -i http://localhost:8787/api/products
# First request: X-Cache: MISS
# Second request: X-Cache: HIT

# Check cache stats
curl http://localhost:8787/admin/cache/stats

# Invalidate cache
curl -X POST http://localhost:8787/admin/cache/invalidate \
  -H "Content-Type: application/json" \
  -d '{"prefix": "/products"}'
```

</Step>

<Step>

## Deploy to Production

```bash
npm run deploy
```

Set production secrets:

```bash
npx wrangler secret put JWT_SECRET
npx wrangler secret put BACKEND_USERS_URL
npx wrangler secret put BACKEND_ORDERS_URL
npx wrangler secret put BACKEND_PRODUCTS_URL
```

Your API gateway is now live at `my-gateway.workers.dev`.

</Step>

</Steps>

---

## What You Built

In 25 minutes, you've deployed an API gateway with:

| Feature | Implementation |
|---------|----------------|
| Rate limiting | Per-user/key limits with DO state |
| Authentication | JWT + API key verification |
| Request routing | Pattern matching to backends |
| Response caching | TTL + stale-while-revalidate |
| Header transformation | Request/response modification |
| Health checks | Endpoint monitoring |

---

## Key Patterns Used

### Distributed Rate Limiting

```typescript
// Each user/key gets their own DO
const limiter = await RateLimiter.get(`jwt:${userId}`)
const result = await limiter.checkLimit({ limit: 100, window: 60 })

if (!result.allowed) {
  return c.json({ error: 'Rate limit exceeded' }, 429)
}
```

### Multi-Auth Support

```typescript
// Support both JWT and API keys
if (route.auth === 'any') {
  // Try JWT first, then API key
}
```

### Stale-While-Revalidate

```typescript
if (cached.stale) {
  // Return stale response immediately
  // Trigger background refresh
  $.send('cache.revalidate', { key, backend })
}
```

---

## Extending Your Gateway

### Add Request Logging

```typescript
// Log every request
app.use('/*', async (c, next) => {
  const start = Date.now()

  await next()

  const duration = Date.now() - start
  $.send('request.completed', {
    method: c.req.method,
    path: c.req.path,
    status: c.res.status,
    duration,
    timestamp: new Date()
  })
})
```

### Add Circuit Breaker

```typescript
class CircuitBreaker extends DO {
  state = { failures: 0, lastFailure: 0, open: false }

  async call<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state.open) {
      if (Date.now() - this.state.lastFailure > 30000) {
        this.state.open = false // Try again after 30s
      } else {
        throw new Error('Circuit open')
      }
    }

    try {
      const result = await fn()
      this.state.failures = 0
      return result
    } catch (error) {
      this.state.failures++
      this.state.lastFailure = Date.now()

      if (this.state.failures >= 5) {
        this.state.open = true
      }

      throw error
    }
  }
}
```

### Add Request Validation

```typescript
import { z } from 'zod'

const schemas = {
  'POST /users': z.object({
    email: z.string().email(),
    name: z.string().min(2)
  })
}

// In gateway handler
const schemaKey = `${method} ${path}`
if (schemas[schemaKey]) {
  const body = await c.req.json()
  const result = schemas[schemaKey].safeParse(body)

  if (!result.success) {
    return c.json({ error: 'Validation failed', issues: result.error.issues }, 400)
  }
}
```

---

## Next Steps

Your API gateway is live. Explore:

- [Multi-tenant tutorial](/docs/tutorials/multi-tenant) - Add tenant isolation
- [Real-time dashboard](/docs/tutorials/realtime-dashboard) - Monitor your gateway
- [Deployment](/docs/deployment) - Custom domains and regions
- [SDK reference](/docs/sdk) - Full API documentation

---

**You built an API gateway. It rate limits. It caches. It authenticates. Go protect your APIs.**
