---
title: "@dotdo/neo4j"
description: Drop-in replacement for neo4j-driver with full Cypher support, graph algorithms, and edge compatibility.
---

# @dotdo/neo4j

Drop-in replacement for the Neo4j JavaScript driver. Your existing Neo4j code works unchanged - just swap the import.

```typescript
// Before: Neo4j
import neo4j from 'neo4j-driver'

// After: dotdo
import neo4j from '@dotdo/neo4j'

// Code stays the same
const driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('neo4j', 'password'))
const session = driver.session()

await session.run(
  'CREATE (a:Person {name: $name})-[:KNOWS]->(b:Person {name: $friend}) RETURN a, b',
  { name: 'Alice', friend: 'Bob' }
)

const result = await session.run('MATCH (n:Person)-[:KNOWS]->(friend) RETURN n.name, friend.name')
const records = await result.records()

await session.close()
await driver.close()
```

<Callout type="info">
Looking for persistent storage? See [neo4j.do](/docs/integrations/neo4j/service) for a fully managed Neo4j-compatible edge database.
</Callout>

## Why @dotdo/neo4j?

| Neo4j Driver | @dotdo/neo4j |
|--------------|--------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Requires Neo4j server | Local mode with no external dependencies |
| Bolt protocol over TCP | HTTP/DO-based communication |
| Connection management | Stateless, instant startup |
| Complex test setup | Perfect for unit tests |

**This is an in-memory implementation** with a Neo4j-compatible API. Data does not persist between restarts. Ideal for testing, prototyping, and edge environments where you need graph database semantics without external dependencies.

## Installation

```bash
npm install @dotdo/neo4j
```

## Features

### Implemented (Core APIs)

**Driver API**
- `neo4j.driver()` - Create driver instances
- `neo4j.auth.basic()`, `neo4j.auth.bearer()`, `neo4j.auth.kerberos()` - Authentication
- `driver.session()` - Create sessions
- `driver.verifyConnectivity()` - Verify connection
- `driver.executeQuery()` - Execute query directly

**Session API**
- `session.run()` - Execute Cypher queries
- `session.beginTransaction()` - Explicit transactions
- `session.executeRead()`, `session.executeWrite()` - Managed transactions
- `session.lastBookmarks()` - Causal consistency bookmarks

**Transaction API**
- `tx.run()` - Execute queries in transaction
- `tx.commit()`, `tx.rollback()` - Transaction control
- Full ACID guarantees

**Cypher Support**
- `CREATE` - Create nodes and relationships
- `MATCH` - Pattern matching with variable-length paths
- `OPTIONAL MATCH` - Optional pattern matching
- `MERGE` - Create or match patterns
- `WHERE` - Full predicate support (AND, OR, NOT, XOR)
- `SET`, `REMOVE` - Property updates
- `DELETE`, `DETACH DELETE` - Node/relationship deletion
- `RETURN` with `DISTINCT`, `ORDER BY`, `SKIP`, `LIMIT`
- `UNION` and `UNION ALL`
- Aggregations: `count`, `sum`, `avg`, `min`, `max`, `collect`
- String predicates: `CONTAINS`, `STARTS WITH`, `ENDS WITH`
- NULL checks: `IS NULL`, `IS NOT NULL`
- List membership: `IN`

**Graph Types**
- `Node` - Nodes with labels and properties
- `Relationship` - Typed relationships with properties
- `Path` - Path segments
- `Integer` - 64-bit integer support
- `Point` - Spatial points (2D/3D Cartesian and Geographic)
- `Date`, `DateTime`, `LocalDateTime`, `LocalTime`, `Time` - Temporal types
- `Duration` - Duration type

**Graph Algorithms**
- `shortestPath()` - BFS-based shortest path
- `allShortestPaths()` - All shortest paths between nodes
- `pageRank()` - PageRank centrality
- `connectedComponents()` - Weakly connected components
- `degreeCentrality()` - Degree centrality
- `betweennessCentrality()` - Betweenness centrality
- `closenessCentrality()` - Closeness centrality
- `bfs()`, `dfs()` - Graph traversal

### Not Yet Implemented

- Stored procedures (`CALL`)
- Full-text indexes
- Reactive sessions
- Connection to real Neo4j servers

## Quick Start

### Basic CRUD

```typescript
import neo4j from '@dotdo/neo4j'

const driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('neo4j', 'password'))
const session = driver.session()

// Create
await session.run('CREATE (n:Person {name: $name, age: $age})', { name: 'Alice', age: 30 })

// Read
const result = await session.run('MATCH (n:Person) WHERE n.age > 25 RETURN n')
const records = await result.records()

// Update
await session.run('MATCH (n:Person {name: $name}) SET n.age = $age', { name: 'Alice', age: 31 })

// Delete
await session.run('MATCH (n:Person {name: $name}) DETACH DELETE n', { name: 'Alice' })

await session.close()
await driver.close()
```

### Node Patterns

```typescript
// Multiple labels
await session.run('CREATE (n:Person:Employee {name: $name, department: $dept})', {
  name: 'Alice',
  dept: 'Engineering',
})

// Match by label and properties
const result = await session.run(
  'MATCH (n:Person {department: $dept}) RETURN n.name',
  { dept: 'Engineering' }
)
```

### Relationships

```typescript
// Create relationship between existing nodes
await session.run(
  'MATCH (a:Person {name: $from}) ' +
  'MATCH (b:Person {name: $to}) ' +
  'CREATE (a)-[:MANAGES {since: $year}]->(b)',
  { from: 'Alice', to: 'Bob', year: 2024 }
)

// Create nodes and relationship together
await session.run(
  'CREATE (a:Person {name: $a})-[:KNOWS {since: $since}]->(b:Person {name: $b})',
  { a: 'Alice', b: 'Bob', since: 2020 }
)
```

### Relationship Directions

```typescript
// Outgoing: ->
await session.run('MATCH (a)-[:FOLLOWS]->(b) RETURN a, b')

// Incoming: <-
await session.run('MATCH (a)<-[:FOLLOWS]-(b) RETURN a, b')

// Bidirectional: -
await session.run('MATCH (a)-[:FRIENDS]-(b) RETURN a, b')
```

### Variable-Length Paths

```typescript
// Friends of friends (1-3 hops)
const result = await session.run(
  'MATCH (a:Person {name: $name})-[:KNOWS*1..3]->(friend) RETURN friend',
  { name: 'Alice' }
)

// Any length path
await session.run('MATCH (a)-[:KNOWS*]->(b) RETURN a, b')

// Path assignment
await session.run(
  'MATCH p = (a:Person)-[r:KNOWS]->(b:Person) RETURN p, length(p)'
)
```

### WHERE Conditions

```typescript
// Comparison operators
await session.run('MATCH (n:Person) WHERE n.age >= 21 AND n.age < 65 RETURN n')

// String predicates
await session.run('MATCH (n:Person) WHERE n.name STARTS WITH $prefix RETURN n', { prefix: 'Al' })
await session.run('MATCH (n:Person) WHERE n.email CONTAINS $domain RETURN n', { domain: '@acme' })
await session.run('MATCH (n:Person) WHERE n.name ENDS WITH $suffix RETURN n', { suffix: 'son' })

// NULL checks
await session.run('MATCH (n:Person) WHERE n.email IS NOT NULL RETURN n')

// IN lists
await session.run('MATCH (n:Person) WHERE n.status IN $statuses RETURN n', {
  statuses: ['active', 'pending'],
})

// OR conditions
await session.run('MATCH (n) WHERE n.role = "admin" OR n.role = "superuser" RETURN n')
```

### Aggregations

```typescript
// Count
const result = await session.run('MATCH (n:Person) RETURN count(n) as total')

// Sum and average
await session.run('MATCH (n:Order) RETURN sum(n.amount), avg(n.amount)')

// Min and max
await session.run('MATCH (n:Product) RETURN min(n.price), max(n.price)')

// Collect into array
await session.run(
  'MATCH (n:Person)-[:WORKS_AT]->(c:Company) RETURN c.name, collect(n.name) as employees'
)
```

### Transactions

```typescript
// Managed transactions (recommended)
await session.executeWrite(async (tx) => {
  await tx.run('CREATE (n:Account {balance: $balance})', { balance: 1000 })
  await tx.run('MATCH (n:Account) SET n.balance = n.balance - 100')
  // Auto-commits on success, auto-rollbacks on error
})

await session.executeRead(async (tx) => {
  const result = await tx.run('MATCH (n:Account) RETURN n.balance')
  return result.records()
})

// Explicit transactions
const tx = session.beginTransaction()
try {
  await tx.run('CREATE (n:Order {id: $id})', { id: 'order-123' })
  await tx.run('CREATE (n:OrderItem {sku: $sku})', { sku: 'SKU-001' })
  await tx.commit()
} catch (error) {
  await tx.rollback()
  throw error
}
```

### 64-bit Integers

```typescript
import { int, isInt, Integer } from '@dotdo/neo4j'

// Create integers
const id = int(9007199254740993n) // Beyond JS safe integer range
const count = int(42)

// Check type
if (isInt(value)) {
  console.log(value.toNumber()) // Convert to JS number
  console.log(value.toString()) // String representation
  console.log(value.toBigInt()) // BigInt representation
}

// Arithmetic
const sum = id.add(count)
const diff = id.subtract(count)

// Range checks
if (id.inSafeRange()) {
  const jsNumber = id.toNumber()
} else {
  const bigint = id.toBigInt()
}
```

## Graph Algorithms

The `GraphAlgorithms` class provides common graph algorithms that operate on the session data.

```typescript
import neo4j, { GraphAlgorithms } from '@dotdo/neo4j'

const driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('neo4j', 'password'))
const session = driver.session()

// Create some test data
await session.run(`
  CREATE (alice:Person {name: 'Alice'})
  CREATE (bob:Person {name: 'Bob'})
  CREATE (carol:Person {name: 'Carol'})
  CREATE (alice)-[:KNOWS]->(bob)
  CREATE (bob)-[:KNOWS]->(carol)
  CREATE (carol)-[:KNOWS]->(alice)
`)

const algorithms = new GraphAlgorithms(session)
```

### Shortest Path

```typescript
// Find shortest path between two nodes
const path = await algorithms.shortestPath('Alice', 'Carol', {
  nodeLabel: 'Person',
  nodeProperty: 'name',
  relationshipType: 'KNOWS',
  direction: 'OUT',
  maxDepth: 5,
})

if (path) {
  console.log(`Path length: ${path.length}`)
  console.log('Nodes:', path.nodes.map(n => n.properties.name))
}

// Find all shortest paths
const allPaths = await algorithms.allShortestPaths('Alice', 'Carol', {
  nodeLabel: 'Person',
  nodeProperty: 'name',
  relationshipType: 'KNOWS',
})
```

### PageRank

```typescript
// Compute PageRank for all nodes
const rankings = await algorithms.pageRank({
  nodeLabel: 'Person',
  relationshipType: 'KNOWS',
  dampingFactor: 0.85,
  maxIterations: 20,
  tolerance: 0.0001,
})

for (const { nodeId, score } of rankings) {
  console.log(`${nodeId}: ${score.toFixed(4)}`)
}
```

### Connected Components

```typescript
// Find connected components
const components = await algorithms.connectedComponents({
  nodeLabel: 'Person',
  relationshipType: 'KNOWS',
})

console.log(`Found ${components.componentCount} components`)
console.log('Component sizes:', components.componentSizes)

for (const { nodeId, componentId } of components.nodes) {
  console.log(`${nodeId} is in component ${componentId}`)
}
```

### Centrality Measures

```typescript
// Degree centrality
const degrees = await algorithms.degreeCentrality({
  nodeLabel: 'Person',
  relationshipType: 'KNOWS',
  direction: 'BOTH',
})

// Betweenness centrality
const betweenness = await algorithms.betweennessCentrality({
  nodeLabel: 'Person',
  relationshipType: 'KNOWS',
  normalized: true,
})

// Closeness centrality
const closeness = await algorithms.closenessCentrality({
  nodeLabel: 'Person',
  relationshipType: 'KNOWS',
  normalized: true,
})
```

### Graph Traversal

```typescript
// Breadth-first search
await algorithms.bfs('Alice', {
  nodeLabel: 'Person',
  nodeProperty: 'name',
  relationshipType: 'KNOWS',
  direction: 'OUT',
  maxDepth: 3,
  onVisit: (node) => {
    console.log('Visited:', node.properties.name)
  },
})

// Depth-first search
await algorithms.dfs('Alice', {
  nodeLabel: 'Person',
  nodeProperty: 'name',
  relationshipType: 'KNOWS',
  direction: 'OUT',
  maxDepth: 3,
  onVisit: (node) => {
    console.log('Visited:', node.properties.name)
  },
})
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import neo4j from '@dotdo/neo4j'
import { DO } from 'dotdo'

export class GraphDO extends DO {
  private driver = neo4j.driver('bolt://internal', neo4j.auth.basic('', ''))

  async createUser(name: string, email: string) {
    const session = this.driver.session()
    try {
      const result = await session.run(
        'CREATE (u:User {id: $id, name: $name, email: $email}) RETURN u',
        { id: this.$.id, name, email }
      )
      const records = await result.records()
      return records[0]?.get('u')
    } finally {
      await session.close()
    }
  }

  async findConnections(userId: string, depth: number = 2) {
    const session = this.driver.session()
    try {
      const result = await session.run(
        `MATCH (u:User {id: $id})-[:KNOWS*1..${depth}]->(connection)
         RETURN DISTINCT connection`,
        { id: userId }
      )
      return result.records()
    } finally {
      await session.close()
    }
  }
}
```

## API Reference

### Driver Functions

| Function | Description |
|----------|-------------|
| `neo4j.driver(url, auth, config?)` | Create a driver instance |
| `neo4j.auth.basic(user, pass)` | Basic authentication |
| `neo4j.auth.bearer(token)` | Bearer token authentication |
| `neo4j.auth.kerberos(ticket)` | Kerberos authentication |
| `neo4j.auth.custom(...)` | Custom authentication |
| `neo4j.int(value)` | Create 64-bit integer |
| `neo4j.isInt(value)` | Check if value is Integer |

### Driver Methods

| Method | Description |
|--------|-------------|
| `driver.session(config?)` | Create a new session |
| `driver.verifyConnectivity()` | Verify connection |
| `driver.getServerInfo()` | Get server information |
| `driver.executeQuery(cypher, params?, config?)` | Execute query directly |
| `driver.supportsMultiDatabase()` | Check multi-database support |
| `driver.supportsTransactionConfig()` | Check transaction config support |
| `driver.close()` | Close driver |

### Session Methods

| Method | Description |
|--------|-------------|
| `session.run(cypher, params?, config?)` | Execute Cypher query |
| `session.beginTransaction(config?)` | Start explicit transaction |
| `session.executeRead(work, config?)` | Execute read transaction |
| `session.executeWrite(work, config?)` | Execute write transaction |
| `session.readTransaction(work, config?)` | Legacy read transaction |
| `session.writeTransaction(work, config?)` | Legacy write transaction |
| `session.lastBookmarks()` | Get causal consistency bookmarks |
| `session.close()` | Close session |

### Transaction Methods

| Method | Description |
|--------|-------------|
| `tx.run(cypher, params?)` | Execute query in transaction |
| `tx.commit()` | Commit transaction |
| `tx.rollback()` | Rollback transaction |
| `tx.close()` | Close transaction (rollback if not committed) |
| `tx.isOpen()` | Check if transaction is open |

### Result Methods

| Method | Description |
|--------|-------------|
| `result.records()` | Get all records as array |
| `result.summary()` | Get result summary |
| `result.consume()` | Consume and get summary |
| `result.keys()` | Get column names |
| `result.peek()` | Peek at first record |
| `result.subscribe(observer)` | Subscribe to results |
| `for await (const record of result)` | Async iteration |

### Record Methods

| Method | Description |
|--------|-------------|
| `record.get(key)` | Get value by key or index |
| `record.has(key)` | Check if record has key |
| `record.keys` | Get all keys |
| `record.length` | Number of fields |
| `record.toObject()` | Convert to plain object |
| `record.values()` | Get all values |
| `record.entries()` | Get key-value pairs |
| `record.forEach(visitor)` | Iterate over values |

### Cypher Clauses

| Clause | Description |
|--------|-------------|
| `CREATE` | Create nodes and relationships |
| `MATCH` | Find patterns in the graph |
| `OPTIONAL MATCH` | Match patterns, return null if not found |
| `MERGE` | Create if not exists, match if exists |
| `WHERE` | Filter results |
| `SET` | Update properties |
| `REMOVE` | Remove properties or labels |
| `DELETE` | Delete nodes (must have no relationships) |
| `DETACH DELETE` | Delete nodes and their relationships |
| `RETURN` | Return results |
| `WITH` | Chain query parts |
| `UNWIND` | Expand lists into rows |
| `ORDER BY` | Sort results |
| `SKIP` | Skip first N results |
| `LIMIT` | Limit result count |
| `DISTINCT` | Remove duplicates |
| `UNION` / `UNION ALL` | Combine query results |

### Graph Types

| Type | Description |
|------|-------------|
| `Node` | Graph node with labels and properties |
| `Relationship` | Relationship with type and properties |
| `Path` | Sequence of nodes and relationships |
| `Integer` | 64-bit integer |
| `Point` | Spatial point (Cartesian or Geographic) |
| `Date` | Date without time |
| `DateTime` | Date with time and timezone |
| `LocalDateTime` | Date with time, no timezone |
| `LocalTime` | Time without date or timezone |
| `Time` | Time with timezone offset |
| `Duration` | Time duration |

### Error Types

| Error | Description |
|-------|-------------|
| `Neo4jError` | Base error class |
| `ClientError` | Client-side error |
| `DatabaseError` | Database error |
| `TransientError` | Temporary error (retriable) |
| `ServiceUnavailableError` | Service unavailable |
| `SessionExpiredError` | Session expired |
| `ProtocolError` | Protocol error |

### Type Guards

| Function | Description |
|----------|-------------|
| `isInt(value)` | Check if value is Integer |
| `isNode(value)` | Check if value is Node |
| `isRelationship(value)` | Check if value is Relationship |
| `isPath(value)` | Check if value is Path |
| `isPoint(value)` | Check if value is Point |
| `isDate(value)` | Check if value is Date |
| `isDateTime(value)` | Check if value is DateTime |
| `isLocalDateTime(value)` | Check if value is LocalDateTime |
| `isDuration(value)` | Check if value is Duration |

## Testing with @dotdo/neo4j

@dotdo/neo4j is ideal for unit tests - no external Neo4j required:

```typescript
import neo4j, { Driver, Session } from '@dotdo/neo4j'

describe('User Graph', () => {
  let driver: Driver
  let session: Session

  beforeEach(() => {
    driver = neo4j.driver('bolt://test', neo4j.auth.basic('', ''))
    session = driver.session()
  })

  afterEach(async () => {
    await session.close()
    await driver.close()
  })

  it('creates and queries users', async () => {
    await session.run('CREATE (n:User {name: $name})', { name: 'Alice' })

    const result = await session.run('MATCH (n:User) RETURN n.name as name')
    const records = await result.records()

    expect(records[0]?.get('name')).toBe('Alice')
  })

  it('finds connections', async () => {
    await session.run(`
      CREATE (a:User {name: 'Alice'})
      CREATE (b:User {name: 'Bob'})
      CREATE (a)-[:KNOWS]->(b)
    `)

    const result = await session.run(
      'MATCH (a:User {name: $name})-[:KNOWS]->(friend) RETURN friend.name as name',
      { name: 'Alice' }
    )
    const records = await result.records()

    expect(records[0]?.get('name')).toBe('Bob')
  })
})
```

## Migration from neo4j-driver

### Package Change

```bash
# Remove
npm uninstall neo4j-driver

# Install
npm install @dotdo/neo4j
```

### Import Change

```typescript
// Before: Neo4j driver
import neo4j from 'neo4j-driver'

// After: dotdo
import neo4j from '@dotdo/neo4j'
```

### Code Migration

Most code works unchanged:

```typescript
// Before
const driver = neo4j.driver('bolt://localhost:7687', neo4j.auth.basic('neo4j', 'password'))
const session = driver.session()

const result = await session.run('MATCH (n:Person) RETURN n')
const records = await result.records()

await session.close()
await driver.close()

// After - identical code
const driver = neo4j.driver('bolt://localhost', neo4j.auth.basic('neo4j', 'password'))
const session = driver.session()

const result = await session.run('MATCH (n:Person) RETURN n')
const records = await result.records()

await session.close()
await driver.close()
```

## Related

- [neo4j.do](/docs/integrations/neo4j/service) - Managed Neo4j on the edge
- [MongoDB Integration](/docs/integrations/mongo) - Document database support
- [Postgres Integration](/docs/integrations/postgres) - SQL database support
