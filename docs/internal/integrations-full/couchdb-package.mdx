---
title: "@dotdo/couchdb"
description: CouchDB-compatible view API with MapReduce running in-memory for edge environments and testing.
---

# @dotdo/couchdb

CouchDB-compatible view API that runs entirely in-memory. Define MapReduce views using JavaScript functions and query them with familiar CouchDB semantics - ideal for edge environments (Cloudflare Workers) and testing scenarios.

```typescript
import { CouchDB } from '@dotdo/couchdb'

const db = new CouchDB('mydb')

// Store a document
await db.put({ _id: 'doc1', type: 'post', title: 'Hello World' })

// Define a view
await db.putDesign('posts', {
  views: {
    byType: {
      map: `function(doc) { if (doc.type) emit(doc.type, doc); }`
    }
  }
})

// Query the view
const results = await db.view('posts', 'byType', { key: 'post' })
```

<Callout type="info">
Looking for persistent storage? See [couchdb.do](/docs/integrations/couchdb/service) for a fully managed CouchDB-compatible edge database.
</Callout>

## Why @dotdo/couchdb?

| CouchDB Server | @dotdo/couchdb |
|----------------|----------------|
| Separate infrastructure | Runs on your edge workers |
| Erlang-based | TypeScript-native |
| Cluster management | Serverless, auto-scaling |
| Network latency | Data at the edge |
| Complex test setup | Perfect for unit tests |

**This is an in-memory implementation** with a CouchDB-compatible API. Data does not persist between restarts. Ideal for testing, prototyping, and edge environments where you need document storage without external dependencies.

## Installation

```bash
npm install @dotdo/couchdb
```

## Features

### Implemented (Core APIs)

**View API**
- MapReduce views with JavaScript
- Compound keys (arrays)
- Range queries (startkey/endkey)
- Reduce functions (`_count`, `_sum`, `_stats`)
- Custom reduce functions
- View collation
- Group levels

**Document Operations**
- `put()` - Create/update documents
- `get()` - Retrieve documents
- `remove()` - Delete documents
- `bulkDocs()` - Bulk insert/update
- `allDocs()` - List all documents
- Revision tracking
- Conflict detection

**Query Options**
- Key filtering (`key`, `keys`)
- Range queries (`startkey`, `endkey`)
- Limit/skip pagination
- Descending order
- Include docs

### Not Yet Implemented

- Change feeds (`_changes`)
- Replication
- Attachments
- Mango queries
- Purge/compact

## Quick Start

### Basic Usage

```typescript
import { CouchDB } from '@dotdo/couchdb'

const db = new CouchDB('mydb')

// Create/Update document
await db.put({
  _id: 'user:john',
  type: 'user',
  name: 'John Doe',
  email: 'john@example.com',
})

// Get document
const doc = await db.get('user:john')
console.log(doc._rev) // Revision ID

// Update document (must include _rev)
await db.put({
  ...doc,
  name: 'John Smith',
})

// Delete document
await db.remove('user:john', doc._rev)
```

### Durable Object Storage

When using with Cloudflare Workers, bind to a Durable Object for persistence:

```typescript
import { CouchDB } from '@dotdo/couchdb'

const db = new CouchDB('mydb', {
  storage: env.COUCHDB_DO, // Durable Object binding
})
```

## Map Functions

The map function defines how documents are indexed:

### Simple Emit

```typescript
await db.putDesign('users', {
  views: {
    all: {
      map: `function(doc) {
        emit(doc._id, doc);
      }`
    }
  }
})

const results = await db.view('users', 'all')
```

### Conditional Emit

```typescript
await db.putDesign('posts', {
  views: {
    byType: {
      map: `function(doc) {
        if (doc.type === 'post') {
          emit(doc._id, doc);
        }
      }`
    }
  }
})

// Only indexes documents where type === 'post'
```

### Multiple Emits

```typescript
await db.putDesign('tags', {
  views: {
    byTag: {
      map: `function(doc) {
        if (doc.tags) {
          for (var i = 0; i < doc.tags.length; i++) {
            emit(doc.tags[i], doc._id);
          }
        }
      }`
    }
  }
})

// A document with tags: ['javascript', 'node'] creates two index entries
const jsResults = await db.view('tags', 'byTag', { key: 'javascript' })
```

### Compound Keys

```typescript
await db.putDesign('events', {
  views: {
    byDate: {
      map: `function(doc) {
        if (doc.type === 'event') {
          emit([doc.year, doc.month, doc.day], doc);
        }
      }`
    }
  }
})

// Query events in 2024
const events2024 = await db.view('events', 'byDate', {
  startkey: [2024],
  endkey: [2024, {}],
})

// Query events in January 2024
const jan2024 = await db.view('events', 'byDate', {
  startkey: [2024, 1],
  endkey: [2024, 1, {}],
})

// Query specific date
const newYear = await db.view('events', 'byDate', {
  key: [2024, 1, 1],
})
```

### Computed Values

```typescript
await db.putDesign('users', {
  views: {
    byEmail: {
      map: `function(doc) {
        if (doc.email) {
          emit(doc.email.toLowerCase(), doc.name);
        }
      }`
    }
  }
})
```

### Arrow Function Syntax

```typescript
await db.putDesign('items', {
  views: {
    byName: {
      map: `(doc) => { emit(doc.name, doc._id); }`
    },
    byPrice: {
      map: `doc => emit(doc.price, doc.name)`
    }
  }
})
```

## Query Options

### Key Matching

```typescript
// Exact key match
const results = await db.view('posts', 'byType', {
  key: 'blog'
})

// Multiple keys
const results = await db.view('posts', 'byType', {
  keys: ['blog', 'article', 'news']
})
```

### Range Queries

```typescript
// Range with start and end
const results = await db.view('users', 'byName', {
  startkey: 'A',
  endkey: 'C',
})

// Inclusive/exclusive
const results = await db.view('users', 'byName', {
  startkey: 'A',
  endkey: 'C',
  inclusive_end: false, // Exclude 'C'
})

// With compound keys
const results = await db.view('events', 'byDate', {
  startkey: [2024, 1, 1],
  endkey: [2024, 12, 31],
})
```

### Pagination

```typescript
// Limit results
const page1 = await db.view('posts', 'all', {
  limit: 10,
})

// Skip results
const page2 = await db.view('posts', 'all', {
  limit: 10,
  skip: 10,
})

// Descending order
const recent = await db.view('posts', 'byDate', {
  descending: true,
  limit: 10,
})
```

### Include Documents

```typescript
// Just keys and values (default)
const results = await db.view('posts', 'byType', { key: 'blog' })
// [{ id: 'post1', key: 'blog', value: { title: '...' } }]

// Include full documents
const results = await db.view('posts', 'byType', {
  key: 'blog',
  include_docs: true,
})
// [{ id: 'post1', key: 'blog', value: ..., doc: { _id: 'post1', ... } }]
```

## Reduce Functions

Aggregate values across documents:

### Built-in Reduces

```typescript
await db.putDesign('stats', {
  views: {
    countByType: {
      map: `function(doc) { emit(doc.type, 1); }`,
      reduce: '_count'
    },
    sumByCategory: {
      map: `function(doc) { emit(doc.category, doc.amount); }`,
      reduce: '_sum'
    },
    statsByProduct: {
      map: `function(doc) { emit(doc.product, doc.price); }`,
      reduce: '_stats'
    }
  }
})

// Count documents by type
const counts = await db.view('stats', 'countByType', { group: true })
// [{ key: 'post', value: 42 }, { key: 'comment', value: 128 }]

// Sum amounts by category
const sums = await db.view('stats', 'sumByCategory', { group: true })
// [{ key: 'sales', value: 15000 }, { key: 'refunds', value: -500 }]

// Stats by product
const stats = await db.view('stats', 'statsByProduct', { group: true })
// [{ key: 'widget', value: { sum: 1000, count: 10, min: 50, max: 200, sumsqr: ... } }]
```

### Custom Reduce

```typescript
await db.putDesign('analytics', {
  views: {
    avgByCategory: {
      map: `function(doc) { emit(doc.category, doc.value); }`,
      reduce: `function(keys, values, rereduce) {
        if (rereduce) {
          var sum = 0, count = 0;
          for (var i = 0; i < values.length; i++) {
            sum += values[i].sum;
            count += values[i].count;
          }
          return { sum: sum, count: count };
        }
        var sum = 0;
        for (var i = 0; i < values.length; i++) {
          sum += values[i];
        }
        return { sum: sum, count: values.length };
      }`
    }
  }
})
```

### Group Levels

```typescript
// Map with compound key
await db.putDesign('sales', {
  views: {
    byDate: {
      map: `function(doc) {
        emit([doc.year, doc.month, doc.day], doc.amount);
      }`,
      reduce: '_sum'
    }
  }
})

// Group by year (level 1)
const byYear = await db.view('sales', 'byDate', {
  group_level: 1
})
// [{ key: [2024], value: 50000 }]

// Group by year and month (level 2)
const byMonth = await db.view('sales', 'byDate', {
  group_level: 2
})
// [{ key: [2024, 1], value: 5000 }, { key: [2024, 2], value: 6000 }]

// Group by exact date (level 3)
const byDay = await db.view('sales', 'byDate', {
  group: true // Same as group_level: exact
})
```

## Bulk Operations

```typescript
// Bulk insert/update
const results = await db.bulkDocs([
  { _id: 'doc1', type: 'post', title: 'First' },
  { _id: 'doc2', type: 'post', title: 'Second' },
  { _id: 'doc3', type: 'post', title: 'Third' },
])

// Bulk get
const docs = await db.allDocs({
  keys: ['doc1', 'doc2', 'doc3'],
  include_docs: true,
})

// All documents
const all = await db.allDocs({
  include_docs: true,
  startkey: 'post:',
  endkey: 'post:\ufff0',
})
```

## Design Documents

```typescript
// Get design document
const design = await db.get('_design/posts')

// List all design documents
const designs = await db.allDocs({
  startkey: '_design/',
  endkey: '_design/\ufff0',
  include_docs: true,
})

// Update design document
await db.putDesign('posts', {
  views: {
    byType: { map: '...' },
    byDate: { map: '...', reduce: '_count' },
    byAuthor: { map: '...' },
  }
})

// Delete design document
await db.remove('_design/posts', design._rev)
```

## Security

Map functions execute in a sandboxed environment:

### Safe Built-ins Available

- `JSON.parse()`, `JSON.stringify()`
- `Math.*` (all methods)
- `isNaN()`, `isFinite()`, `parseInt()`, `parseFloat()`
- `encodeURI()`, `decodeURI()`, `encodeURIComponent()`, `decodeURIComponent()`

### Blocked

- `process`, `require`, `module`
- `fetch`, `XMLHttpRequest`, `WebSocket`
- `setTimeout`, `setInterval`
- `eval`, `Function`
- `Proxy`, `Reflect`, `Symbol`
- Prototype manipulation

### Dangerous Patterns Blocked

```typescript
// These will throw security errors:
`function(doc) { doc.constructor.constructor('...')() }`
`function(doc) { doc.__proto__ = {} }`
`function(doc) { Object.prototype.x = 1 }`
`function(doc) { globalThis.process }`
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { CouchDB } from '@dotdo/couchdb'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const db = new CouchDB('api')
    const url = new URL(request.url)

    if (request.method === 'GET' && url.pathname === '/posts') {
      const results = await db.view('posts', 'byType', { key: 'post' })
      return Response.json(results)
    }

    if (request.method === 'POST' && url.pathname === '/posts') {
      const body = await request.json()
      const result = await db.put({ ...body, type: 'post' })
      return Response.json(result)
    }

    return new Response('Not Found', { status: 404 })
  },
}
```

## API Reference

### CouchDB Class

```typescript
class CouchDB {
  constructor(name: string, options?: CouchDBOptions)

  // Document operations
  get(id: string): Promise<Document>
  put(doc: Document): Promise<{ ok: boolean; id: string; rev: string }>
  remove(id: string, rev: string): Promise<{ ok: boolean; id: string; rev: string }>

  // Bulk operations
  bulkDocs(docs: Document[]): Promise<BulkDocsResult[]>
  allDocs(options?: AllDocsOptions): Promise<AllDocsResult>

  // Views
  putDesign(name: string, design: DesignDocument): Promise<void>
  view(design: string, view: string, options?: ViewOptions): Promise<ViewResult>
}
```

### parseMapFunction

```typescript
function parseMapFunction(source: string): ParsedMapFunction

// Execute directly
function executeMapFunction(
  source: string,
  doc: Record<string, unknown>
): EmitResult[]
```

## Types

```typescript
import type {
  // Document types
  Document,
  DesignDocument,
  ViewDefinition,

  // Query types
  ViewOptions,
  ViewResult,
  ViewRow,
  AllDocsOptions,
  AllDocsResult,

  // Map function types
  ParsedMapFunction,
  EmitResult,
} from '@dotdo/couchdb'
```

## Testing with CouchDB

CouchDB is ideal for unit tests - no external database required:

```typescript
import { CouchDB } from '@dotdo/couchdb'

describe('PostRepository', () => {
  let db: CouchDB

  beforeEach(async () => {
    // Fresh in-memory store for each test
    db = new CouchDB('test')
    await db.putDesign('posts', {
      views: {
        byType: {
          map: `function(doc) { emit(doc.type, doc); }`
        }
      }
    })
  })

  it('should create a post', async () => {
    const result = await db.put({
      _id: 'post:1',
      type: 'post',
      title: 'Hello World'
    })
    expect(result.ok).toBe(true)

    const posts = await db.view('posts', 'byType', { key: 'post' })
    expect(posts.rows).toHaveLength(1)
    expect(posts.rows[0].value.title).toBe('Hello World')
  })
})
```

## Related

- [couchdb.do](/docs/integrations/couchdb/service) - Managed CouchDB on the edge
- [MongoDB Integration](/docs/integrations/mongo) - MongoDB compatibility
- [Firebase Integration](/docs/integrations/firebase) - Firebase/Firestore compatibility
