---
title: "@dotdo/dynamodb"
description: DynamoDB-compatible in-memory SDK for edge environments and testing with AWS SDK v3 API compatibility.
---

# @dotdo/dynamodb

In-memory implementation of the AWS DynamoDB JavaScript SDK (v3) API. Ideal for testing and development without requiring AWS credentials or network access.

```typescript
import { DynamoDBClient, PutItemCommand, GetItemCommand } from '@dotdo/dynamodb'

const client = new DynamoDBClient({ region: 'us-east-1' })

await client.send(new PutItemCommand({
  TableName: 'Users',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
    name: { S: 'Alice' },
    age: { N: '30' },
  },
}))

const result = await client.send(new GetItemCommand({
  TableName: 'Users',
  Key: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
  },
}))
```

<Callout type="info">
Looking for persistent storage? See [dynamodb.do](/docs/integrations/dynamodb/service) for a fully managed DynamoDB-compatible edge database.
</Callout>

## Why @dotdo/dynamodb?

| AWS DynamoDB SDK | @dotdo/dynamodb |
|------------------|-----------------|
| Node.js runtime required | Edge-compatible (Cloudflare Workers) |
| Real API calls in tests | In-memory storage for fast testing |
| Network latency to AWS | Zero latency (in-memory) |
| AWS credentials required | No credentials needed |
| Pay per request/provisioned | Free (in-memory) |

**This is an in-memory DynamoDB implementation.** It provides a DynamoDB-compatible API backed by in-memory storage for testing and development. The API surface matches AWS SDK v3.

## Installation

```bash
npm install @dotdo/dynamodb
```

## Features

### Implemented (Core APIs)

**Table Operations**
- `CreateTableCommand` - Create tables with key schema and indexes
- `DeleteTableCommand` - Delete tables
- `DescribeTableCommand` - Get table metadata
- `ListTablesCommand` - List all tables with pagination

**Item Operations**
- `PutItemCommand` - Write items with optional conditions
- `GetItemCommand` - Read items by key with projections
- `UpdateItemCommand` - Update items with expressions
- `DeleteItemCommand` - Delete items with optional conditions

**Query & Scan**
- `QueryCommand` - Query by partition key with sort key conditions
- `ScanCommand` - Full table scans with filters

**Batch Operations**
- `BatchWriteItemCommand` - Batch put/delete (up to 25 items)
- `BatchGetItemCommand` - Batch get (up to 100 items)

**Transactions**
- `TransactWriteItemsCommand` - ACID transactions for writes
- `TransactGetItemsCommand` - Consistent reads across items

**Indexes**
- Global Secondary Indexes (GSI)
- Local Secondary Indexes (LSI)
- Index queries with `IndexName` parameter

**Expressions**
- KeyConditionExpression (partition key + sort key conditions)
- FilterExpression (post-query filtering)
- ProjectionExpression (attribute selection)
- UpdateExpression (SET, REMOVE, ADD, DELETE)
- ConditionExpression (conditional writes)

**Utilities**
- `marshall()` / `marshallItem()` - Convert JS objects to DynamoDB format
- `unmarshall()` / `unmarshallItem()` - Convert DynamoDB format to JS objects

### Not Yet Implemented

- DynamoDB Streams
- Time to Live (TTL)
- Global Tables
- Backup and Restore
- PartiQL queries
- Export to S3

## Quick Start

### Create a Table

```typescript
import { DynamoDBClient, CreateTableCommand } from '@dotdo/dynamodb'

const client = new DynamoDBClient({ region: 'us-east-1' })

await client.send(new CreateTableCommand({
  TableName: 'Users',
  KeySchema: [
    { AttributeName: 'pk', KeyType: 'HASH' },
    { AttributeName: 'sk', KeyType: 'RANGE' },
  ],
  AttributeDefinitions: [
    { AttributeName: 'pk', AttributeType: 'S' },
    { AttributeName: 'sk', AttributeType: 'S' },
  ],
}))
```

### Put and Get Items

```typescript
import { PutItemCommand, GetItemCommand } from '@dotdo/dynamodb'

// Put an item
await client.send(new PutItemCommand({
  TableName: 'Users',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
    name: { S: 'Alice' },
    email: { S: 'alice@example.com' },
    age: { N: '30' },
    tags: { L: [{ S: 'admin' }, { S: 'verified' }] },
  },
}))

// Get an item
const result = await client.send(new GetItemCommand({
  TableName: 'Users',
  Key: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
  },
}))

console.log(result.Item) // { pk: { S: 'USER#123' }, ... }
```

### Update Items

```typescript
import { UpdateItemCommand } from '@dotdo/dynamodb'

// Update with expressions
const result = await client.send(new UpdateItemCommand({
  TableName: 'Users',
  Key: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
  },
  UpdateExpression: 'SET #name = :name, age = age + :inc',
  ExpressionAttributeNames: {
    '#name': 'name',
  },
  ExpressionAttributeValues: {
    ':name': { S: 'Alice Smith' },
    ':inc': { N: '1' },
  },
  ReturnValues: 'ALL_NEW',
}))

console.log(result.Attributes)
```

### Query Items

```typescript
import { QueryCommand } from '@dotdo/dynamodb'

// Query by partition key
const result = await client.send(new QueryCommand({
  TableName: 'Users',
  KeyConditionExpression: 'pk = :pk',
  ExpressionAttributeValues: {
    ':pk': { S: 'USER#123' },
  },
}))

// Query with sort key condition
const orders = await client.send(new QueryCommand({
  TableName: 'Orders',
  KeyConditionExpression: 'pk = :pk AND begins_with(sk, :prefix)',
  ExpressionAttributeValues: {
    ':pk': { S: 'USER#123' },
    ':prefix': { S: 'ORDER#2024' },
  },
  ScanIndexForward: false, // Descending order
  Limit: 10,
}))
```

### Delete Items

```typescript
import { DeleteItemCommand } from '@dotdo/dynamodb'

await client.send(new DeleteItemCommand({
  TableName: 'Users',
  Key: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
  },
  ConditionExpression: 'attribute_exists(pk)',
  ReturnValues: 'ALL_OLD',
}))
```

## Testing with @dotdo/dynamodb

The client runs entirely in-memory, making it perfect for testing:

```typescript
import {
  DynamoDBClient,
  CreateTableCommand,
  PutItemCommand,
  QueryCommand,
  clearAllTables,
} from '@dotdo/dynamodb'

// Create client (no AWS credentials needed)
const client = new DynamoDBClient({ region: 'us-east-1' })

// Use exactly like real DynamoDB SDK
await client.send(new CreateTableCommand({
  TableName: 'TestTable',
  KeySchema: [
    { AttributeName: 'pk', KeyType: 'HASH' },
    { AttributeName: 'sk', KeyType: 'RANGE' },
  ],
  AttributeDefinitions: [
    { AttributeName: 'pk', AttributeType: 'S' },
    { AttributeName: 'sk', AttributeType: 'S' },
  ],
}))

await client.send(new PutItemCommand({
  TableName: 'TestTable',
  Item: {
    pk: { S: 'test#1' },
    sk: { S: 'data' },
    value: { N: '42' },
  },
}))

// Query works exactly like AWS
const result = await client.send(new QueryCommand({
  TableName: 'TestTable',
  KeyConditionExpression: 'pk = :pk',
  ExpressionAttributeValues: {
    ':pk': { S: 'test#1' },
  },
}))

// Clear all tables between tests
clearAllTables()
```

### Using in Vitest

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import {
  DynamoDBClient,
  CreateTableCommand,
  PutItemCommand,
  GetItemCommand,
  clearAllTables,
} from '@dotdo/dynamodb'

describe('User Repository', () => {
  const client = new DynamoDBClient({ region: 'us-east-1' })

  beforeEach(async () => {
    // Clear all data between tests
    clearAllTables()

    // Create test table
    await client.send(new CreateTableCommand({
      TableName: 'Users',
      KeySchema: [{ AttributeName: 'pk', KeyType: 'HASH' }],
      AttributeDefinitions: [{ AttributeName: 'pk', AttributeType: 'S' }],
    }))
  })

  it('should store and retrieve users', async () => {
    await client.send(new PutItemCommand({
      TableName: 'Users',
      Item: { pk: { S: 'user#1' }, name: { S: 'Alice' } },
    }))

    const result = await client.send(new GetItemCommand({
      TableName: 'Users',
      Key: { pk: { S: 'user#1' } },
    }))

    expect(result.Item?.name?.S).toBe('Alice')
  })
})
```

### Conditional Writes

```typescript
import { ConditionalCheckFailedException } from '@dotdo/dynamodb'

// Put with condition (prevents overwrite)
try {
  await client.send(new PutItemCommand({
    TableName: 'Users',
    Item: { pk: { S: 'user#1' }, sk: { S: 'profile' }, name: { S: 'Alice' } },
    ConditionExpression: 'attribute_not_exists(pk)',
  }))
} catch (error) {
  if (error instanceof ConditionalCheckFailedException) {
    console.log('Item already exists!')
  }
}
```

### Transactions

```typescript
import { TransactWriteItemsCommand } from '@dotdo/dynamodb'

// ACID transaction across multiple items
await client.send(new TransactWriteItemsCommand({
  TransactItems: [
    {
      Put: {
        TableName: 'Orders',
        Item: {
          pk: { S: 'ORDER#123' },
          sk: { S: 'INFO' },
          status: { S: 'confirmed' },
        },
        ConditionExpression: 'attribute_not_exists(pk)',
      },
    },
    {
      Update: {
        TableName: 'Users',
        Key: { pk: { S: 'USER#456' }, sk: { S: 'PROFILE' } },
        UpdateExpression: 'SET orderCount = orderCount + :inc',
        ExpressionAttributeValues: { ':inc': { N: '1' } },
      },
    },
  ],
}))
```

## API Reference

### DynamoDBClient

```typescript
const client = new DynamoDBClient(config?: DynamoDBClientConfig)

interface DynamoDBClientConfig {
  region?: string
  credentials?: {
    accessKeyId: string
    secretAccessKey: string
    sessionToken?: string
  }
  endpoint?: string
  maxAttempts?: number
  retryMode?: 'standard' | 'adaptive'
}

// Send a command
const result = await client.send(command)

// Cleanup
client.destroy()
```

### Table Commands

```typescript
// Create table
new CreateTableCommand({
  TableName: string,
  KeySchema: KeySchemaElement[],
  AttributeDefinitions: AttributeDefinition[],
  ProvisionedThroughput?: ProvisionedThroughput,
  GlobalSecondaryIndexes?: GlobalSecondaryIndex[],
  LocalSecondaryIndexes?: LocalSecondaryIndex[],
})

// Delete table
new DeleteTableCommand({ TableName: string })

// Describe table
new DescribeTableCommand({ TableName: string })

// List tables
new ListTablesCommand({
  Limit?: number,
  ExclusiveStartTableName?: string,
})
```

### Item Commands

```typescript
// Put item
new PutItemCommand({
  TableName: string,
  Item: Item,
  ConditionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ExpressionAttributeValues?: Record<string, AttributeValue>,
  ReturnValues?: 'NONE' | 'ALL_OLD',
})

// Get item
new GetItemCommand({
  TableName: string,
  Key: Key,
  ProjectionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ConsistentRead?: boolean,
})

// Update item
new UpdateItemCommand({
  TableName: string,
  Key: Key,
  UpdateExpression?: string,
  ConditionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ExpressionAttributeValues?: Record<string, AttributeValue>,
  ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW',
})

// Delete item
new DeleteItemCommand({
  TableName: string,
  Key: Key,
  ConditionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ExpressionAttributeValues?: Record<string, AttributeValue>,
  ReturnValues?: 'NONE' | 'ALL_OLD',
})
```

### Query & Scan Commands

```typescript
// Query
new QueryCommand({
  TableName: string,
  IndexName?: string,
  KeyConditionExpression?: string,
  FilterExpression?: string,
  ProjectionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ExpressionAttributeValues?: Record<string, AttributeValue>,
  Limit?: number,
  ExclusiveStartKey?: Key,
  ScanIndexForward?: boolean,
  Select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES' | 'SPECIFIC_ATTRIBUTES' | 'COUNT',
})

// Scan
new ScanCommand({
  TableName: string,
  IndexName?: string,
  FilterExpression?: string,
  ProjectionExpression?: string,
  ExpressionAttributeNames?: Record<string, string>,
  ExpressionAttributeValues?: Record<string, AttributeValue>,
  Limit?: number,
  ExclusiveStartKey?: Key,
  Select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES' | 'SPECIFIC_ATTRIBUTES' | 'COUNT',
})
```

### Batch Commands

```typescript
// Batch write (up to 25 items)
new BatchWriteItemCommand({
  RequestItems: {
    [tableName]: [
      { PutRequest: { Item: Item } },
      { DeleteRequest: { Key: Key } },
    ],
  },
})

// Batch get (up to 100 items)
new BatchGetItemCommand({
  RequestItems: {
    [tableName]: {
      Keys: Key[],
      ProjectionExpression?: string,
      ExpressionAttributeNames?: Record<string, string>,
    },
  },
})
```

### Transaction Commands

```typescript
// Transact write (ACID)
new TransactWriteItemsCommand({
  TransactItems: [
    { Put: { TableName, Item, ConditionExpression? } },
    { Update: { TableName, Key, UpdateExpression, ConditionExpression? } },
    { Delete: { TableName, Key, ConditionExpression? } },
    { ConditionCheck: { TableName, Key, ConditionExpression } },
  ],
})

// Transact get
new TransactGetItemsCommand({
  TransactItems: [
    { Get: { TableName, Key, ProjectionExpression? } },
  ],
})
```

### Marshalling Utilities

```typescript
import { marshall, marshallItem, unmarshall, unmarshallItem } from '@dotdo/dynamodb'

// Convert JS value to DynamoDB AttributeValue
marshall('hello')           // { S: 'hello' }
marshall(42)                // { N: '42' }
marshall(true)              // { BOOL: true }
marshall(null)              // { NULL: true }
marshall([1, 2, 3])         // { L: [{ N: '1' }, { N: '2' }, { N: '3' }] }
marshall({ name: 'Alice' }) // { M: { name: { S: 'Alice' } } }

// Convert JS object to DynamoDB Item
marshallItem({ pk: 'user#1', name: 'Alice', age: 30 })
// { pk: { S: 'user#1' }, name: { S: 'Alice' }, age: { N: '30' } }

// Convert DynamoDB AttributeValue to JS value
unmarshall({ S: 'hello' })  // 'hello'
unmarshall({ N: '42' })     // 42
unmarshall({ BOOL: true })  // true

// Convert DynamoDB Item to JS object
unmarshallItem({ pk: { S: 'user#1' }, age: { N: '30' } })
// { pk: 'user#1', age: 30 }
```

## Error Handling

```typescript
import {
  DynamoDBServiceException,
  ResourceNotFoundException,
  ResourceInUseException,
  ConditionalCheckFailedException,
  TransactionCanceledException,
  ValidationException,
} from '@dotdo/dynamodb'

try {
  await client.send(new GetItemCommand({
    TableName: 'NonExistentTable',
    Key: { pk: { S: 'test' } },
  }))
} catch (error) {
  if (error instanceof ResourceNotFoundException) {
    console.log('Table not found:', error.message)
  } else if (error instanceof ConditionalCheckFailedException) {
    console.log('Condition failed:', error.message)
    console.log('Existing item:', error.Item)
  } else if (error instanceof TransactionCanceledException) {
    console.log('Transaction cancelled:', error.CancellationReasons)
  } else if (error instanceof ValidationException) {
    console.log('Invalid input:', error.message)
  }
}
```

## Types

Full TypeScript support with comprehensive type definitions:

```typescript
import type {
  // Core types
  AttributeValue,
  Key,
  Item,
  KeySchemaElement,
  AttributeDefinition,
  TableDescription,

  // Index types
  GlobalSecondaryIndex,
  LocalSecondaryIndex,
  Projection,

  // Command I/O
  PutItemCommandInput,
  PutItemCommandOutput,
  QueryCommandInput,
  QueryCommandOutput,

  // Config
  DynamoDBClientConfig,

  // Response
  ResponseMetadata,
  ConsumedCapacity,
} from '@dotdo/dynamodb'
```

## Edge Compatibility

Works in Cloudflare Workers without Node.js dependencies:

```typescript
// worker.ts
import { DynamoDBClient, PutItemCommand, QueryCommand, clearAllTables } from '@dotdo/dynamodb'

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const client = new DynamoDBClient({ region: 'us-east-1' })
    const url = new URL(request.url)

    if (request.method === 'POST' && url.pathname === '/items') {
      const body = await request.json()
      await client.send(new PutItemCommand({
        TableName: 'Items',
        Item: body,
      }))
      return Response.json({ success: true })
    }

    return new Response('Not Found', { status: 404 })
  },
}
```

## Dependency Injection Pattern

For swappable implementations between test and production:

```typescript
// repository.ts
import type { DynamoDBClient as IDynamoDBClient } from '@dotdo/dynamodb'

export class UserRepository {
  constructor(private client: IDynamoDBClient) {}

  async getUser(id: string) {
    const result = await this.client.send(new GetItemCommand({
      TableName: 'Users',
      Key: { pk: { S: `USER#${id}` } },
    }))
    return result.Item
  }
}

// In tests
import { DynamoDBClient } from '@dotdo/dynamodb'
const repo = new UserRepository(new DynamoDBClient({}))

// In production
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
const repo = new UserRepository(new DynamoDBClient({ region: 'us-east-1' }))
```

## Common Patterns

### Single-Table Design

```typescript
// Users, orders, and products in one table
await client.send(new PutItemCommand({
  TableName: 'AppData',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
    GSI1PK: { S: 'USERS' },
    name: { S: 'Alice' },
    email: { S: 'alice@example.com' },
  },
}))

await client.send(new PutItemCommand({
  TableName: 'AppData',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'ORDER#2024-001' },
    GSI1PK: { S: 'ORDERS' },
    total: { N: '99.99' },
    status: { S: 'shipped' },
  },
}))

// Query user's orders
const orders = await client.send(new QueryCommand({
  TableName: 'AppData',
  KeyConditionExpression: 'pk = :pk AND begins_with(sk, :prefix)',
  ExpressionAttributeValues: {
    ':pk': { S: 'USER#123' },
    ':prefix': { S: 'ORDER#' },
  },
}))
```

### Pagination

```typescript
async function* paginateQuery(params: QueryCommandInput) {
  let lastKey: Key | undefined

  do {
    const result = await client.send(new QueryCommand({
      ...params,
      ExclusiveStartKey: lastKey,
    }))

    yield* result.Items ?? []
    lastKey = result.LastEvaluatedKey
  } while (lastKey)
}

// Usage
for await (const item of paginateQuery({
  TableName: 'Users',
  KeyConditionExpression: 'pk = :pk',
  ExpressionAttributeValues: { ':pk': { S: 'USER#123' } },
  Limit: 25,
})) {
  console.log(unmarshallItem(item))
}
```

### Optimistic Locking

```typescript
// Read item with version
const result = await client.send(new GetItemCommand({
  TableName: 'Items',
  Key: { pk: { S: 'item#1' } },
}))

const currentVersion = result.Item?.version?.N ?? '0'

// Update with version check
await client.send(new UpdateItemCommand({
  TableName: 'Items',
  Key: { pk: { S: 'item#1' } },
  UpdateExpression: 'SET #data = :data, version = :newVersion',
  ConditionExpression: 'version = :currentVersion',
  ExpressionAttributeNames: { '#data': 'data' },
  ExpressionAttributeValues: {
    ':data': { S: 'updated' },
    ':currentVersion': { N: currentVersion },
    ':newVersion': { N: String(Number(currentVersion) + 1) },
  },
}))
```

## API Coverage

| Resource | Coverage | Notes |
|----------|----------|-------|
| Table Operations | Full | Create, Delete, Describe, List |
| Item CRUD | Full | Put, Get, Update, Delete |
| Query | Full | Key conditions, filters, projections |
| Scan | Full | Filters, projections, pagination |
| Batch Write | Full | Up to 25 items |
| Batch Get | Full | Up to 100 items |
| Transactions | Full | TransactWrite, TransactGet |
| GSI/LSI | Full | Query on indexes |
| Expressions | Full | Key, Filter, Projection, Update, Condition |
| Marshalling | Full | marshall, unmarshall utilities |
| Streams | Not yet | |
| TTL | Not yet | |
| Global Tables | Not yet | |
| PartiQL | Not yet | |

## Related

- [dynamodb.do](/docs/integrations/dynamodb/service) - Managed DynamoDB on the edge
- [Postgres Integration](/docs/integrations/postgres) - SQL database integration
- [S3 Integration](/docs/integrations/s3) - Object storage integration
