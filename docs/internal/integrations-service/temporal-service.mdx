---
title: temporal.do
description: Edge-native durable workflows on Cloudflare Workers with zero infrastructure and FREE sleeping.
---

# temporal.do

**Edge-native Durable Workflows** - A workflow orchestration service that runs entirely on Cloudflare Workers, with native CF Workflows integration for FREE sleeping and guaranteed execution.

```typescript
import { Workflow, WorkflowEntrypoint } from 'temporal.do'

export class OrderWorkflow extends Workflow {
  async run(order: Order) {
    // Durable step - retries on failure
    const payment = await this.step.do('charge', async () => {
      return stripe.charges.create({ amount: order.amount, source: order.token })
    })

    // FREE sleep - doesn't consume DO time
    await this.step.sleep('wait-for-fulfillment', '1d')

    // Send confirmation
    await this.step.do('notify', async () => {
      return sendEmail(order.email, 'Order shipped!')
    })

    return { orderId: order.id, chargeId: payment.id }
  }
}

export default WorkflowEntrypoint
```

<Callout type="info">
Looking for Temporal SDK compatibility? See [@dotdo/temporal](/docs/integrations/temporal/package) for a drop-in replacement that works with existing Temporal code.
</Callout>

## Why temporal.do?

Traditional workflow orchestration requires managing infrastructure, handling state persistence, and paying for idle compute. temporal.do eliminates all of that:

- **Zero Infrastructure** - No servers, clusters, or databases to manage
- **FREE Sleeping** - CF Workflows means `sleep()` doesn't consume DO wall-clock time
- **Global Edge** - Workflows execute in 300+ cities, close to your users
- **Guaranteed Execution** - Durable steps survive crashes and restarts
- **Native Integrations** - Built-in support for R2, KV, Queues, AI
- **Serverless Economics** - Pay only for actual execution time

## Features

### Core Workflow

| Feature | Description |
|---------|-------------|
| **Durable Steps** | `step.do()` for retried, persistent operations |
| **FREE Sleep** | `step.sleep()` powered by CF Workflows (no DO time) |
| **State Persistence** | Workflow state survives crashes and restarts |
| **Automatic Retries** | Configurable retry policies per step |
| **Timeouts** | Step and workflow-level timeout controls |
| **Idempotency** | Built-in deduplication via step IDs |

### Orchestration

| Feature | Description |
|---------|-------------|
| **Child Workflows** | Spawn and coordinate nested workflows |
| **Parallel Execution** | `Promise.all()` for concurrent steps |
| **Conditional Logic** | Full JavaScript control flow |
| **Error Handling** | try/catch with automatic rollback support |
| **Continue-as-New** | Automatic history management for long-running workflows |

### Observability

| Feature | Description |
|---------|-------------|
| **Execution History** | Full audit trail of all steps |
| **Real-time Status** | Query workflow state via HTTP |
| **Webhooks** | Notify on completion, failure, or custom events |
| **Metrics** | Built-in latency and success rate tracking |

## Installation

```bash
npm install temporal.do
```

## Quick Start

### Define a Workflow

```typescript
// workflows/order.ts
import { Workflow } from 'temporal.do'

interface OrderInput {
  orderId: string
  customerId: string
  items: Array<{ sku: string; qty: number }>
  total: number
}

interface OrderResult {
  orderId: string
  status: 'completed' | 'failed'
  trackingNumber?: string
}

export class OrderWorkflow extends Workflow<OrderInput, OrderResult> {
  async run(order: OrderInput): Promise<OrderResult> {
    // Step 1: Reserve inventory
    const reservation = await this.step.do('reserve-inventory', async () => {
      return inventoryService.reserve(order.items)
    })

    // Step 2: Process payment
    const payment = await this.step.do('process-payment', async () => {
      return paymentService.charge(order.customerId, order.total)
    })

    // Step 3: Create shipment
    const shipment = await this.step.do('create-shipment', async () => {
      return shippingService.create({
        items: order.items,
        reservationId: reservation.id,
      })
    })

    // Step 4: Send confirmation
    await this.step.do('send-confirmation', async () => {
      return emailService.send({
        to: order.customerId,
        template: 'order-confirmed',
        data: { orderId: order.orderId, trackingNumber: shipment.trackingNumber },
      })
    })

    return {
      orderId: order.orderId,
      status: 'completed',
      trackingNumber: shipment.trackingNumber,
    }
  }
}
```

### Deploy to Cloudflare

```typescript
// src/index.ts
import { WorkflowEntrypoint, OrderWorkflow } from 'temporal.do'

export { OrderWorkflow }
export default WorkflowEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-workflows",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "workflows": [
    { "name": "order-workflow", "class_name": "OrderWorkflow" }
  ]
}
```

```bash
npx wrangler deploy
```

### Start a Workflow

```typescript
// From another worker or HTTP request
export default {
  async fetch(request: Request, env: Env) {
    const order = await request.json()

    // Start workflow
    const instance = await env.ORDER_WORKFLOW.create({
      id: `order-${order.orderId}`,
      params: order,
    })

    return Response.json({
      workflowId: instance.id,
      status: 'started',
    })
  }
}
```

## Durable Steps

### step.do() - Durable Operations

Execute operations that survive crashes with automatic retries:

```typescript
// Basic step
const result = await this.step.do('step-name', async () => {
  return await someOperation()
})

// Step with retry configuration
const result = await this.step.do('api-call', {
  retries: {
    limit: 5,
    delay: '1s',
    backoff: 'exponential',
  },
  timeout: '30s',
}, async () => {
  return await externalApi.call()
})
```

### step.sleep() - FREE Durable Sleep

Sleep without consuming Durable Object wall-clock time:

```typescript
// Sleep for a duration
await this.step.sleep('wait-period', '1h')

// Sleep until a specific time
await this.step.sleepUntil('scheduled-time', new Date('2025-01-15T09:00:00Z'))

// Sleep with human-readable durations
await this.step.sleep('short-wait', '30s')
await this.step.sleep('daily-check', '1d')
await this.step.sleep('weekly-report', '7d')
```

<Callout type="info">
**FREE Sleeping**: Unlike Durable Objects which charge for wall-clock time, CF Workflows sleep is completely free. A workflow sleeping for 30 days costs $0 in compute.
</Callout>

### Parallel Execution

Execute multiple steps concurrently:

```typescript
// Parallel steps with Promise.all
const [inventory, shipping, tax] = await Promise.all([
  this.step.do('check-inventory', () => inventoryService.check(items)),
  this.step.do('get-shipping', () => shippingService.quote(address)),
  this.step.do('calculate-tax', () => taxService.calculate(items, address)),
])

// Race - first to complete wins
const result = await Promise.race([
  this.step.do('primary-api', () => primaryApi.fetch()),
  this.step.do('fallback-api', () => fallbackApi.fetch()),
])
```

## Error Handling

### Automatic Retries

Steps automatically retry on failure:

```typescript
await this.step.do('flaky-operation', {
  retries: {
    limit: 3,
    delay: '1s',
    backoff: 'exponential', // 1s, 2s, 4s
  },
}, async () => {
  return await flakyExternalService.call()
})
```

### Manual Error Handling

Use try/catch for custom error handling:

```typescript
async run(order: Order) {
  try {
    await this.step.do('charge', () => paymentService.charge(order))
  } catch (error) {
    // Compensating transaction
    await this.step.do('refund', () => paymentService.refund(order))
    throw error
  }
}
```

### Saga Pattern

Implement distributed transactions with compensation:

```typescript
async run(booking: BookingRequest) {
  const compensations: Array<() => Promise<void>> = []

  try {
    // Book flight
    const flight = await this.step.do('book-flight', () => flightService.book(booking))
    compensations.push(() => flightService.cancel(flight.id))

    // Book hotel
    const hotel = await this.step.do('book-hotel', () => hotelService.book(booking))
    compensations.push(() => hotelService.cancel(hotel.id))

    // Book car
    const car = await this.step.do('book-car', () => carService.book(booking))

    return { flight, hotel, car }
  } catch (error) {
    // Run compensations in reverse order
    for (const compensate of compensations.reverse()) {
      await this.step.do(`compensate-${compensations.length}`, compensate)
    }
    throw error
  }
}
```

## Child Workflows

### Spawning Child Workflows

```typescript
async run(order: BatchOrder) {
  // Start child workflows for each item
  const children = await Promise.all(
    order.items.map((item, i) =>
      this.step.do(`process-item-${i}`, async () => {
        const child = await this.env.ITEM_WORKFLOW.create({
          id: `${order.id}-item-${i}`,
          params: item,
        })
        return child.id
      })
    )
  )

  // Wait for all children to complete
  const results = await Promise.all(
    children.map((childId, i) =>
      this.step.do(`wait-item-${i}`, async () => {
        const child = await this.env.ITEM_WORKFLOW.get(childId)
        return child.status()
      })
    )
  )

  return { processedItems: results.length }
}
```

## Scheduling

### Delayed Start

```typescript
// Start workflow after a delay
const instance = await env.WORKFLOW.create({
  id: 'scheduled-task',
  params: data,
  startAt: new Date(Date.now() + 3600000), // 1 hour from now
})
```

### Recurring Workflows

```typescript
export class DailyReportWorkflow extends Workflow {
  async run() {
    // Generate report
    const report = await this.step.do('generate', () => generateReport())

    // Send report
    await this.step.do('send', () => sendReport(report))

    // Schedule next run (continue-as-new pattern)
    await this.step.sleep('wait-24h', '24h')

    // Restart workflow
    return this.continueAsNew()
  }
}
```

## State & Queries

### Workflow State

Access and update workflow state:

```typescript
export class StatefulWorkflow extends Workflow {
  private progress = 0
  private status = 'running'

  async run(items: string[]) {
    for (let i = 0; i < items.length; i++) {
      await this.step.do(`process-${i}`, async () => {
        await processItem(items[i])
        this.progress = ((i + 1) / items.length) * 100
      })
    }

    this.status = 'completed'
    return { processed: items.length }
  }

  // Query handler
  getProgress() {
    return { progress: this.progress, status: this.status }
  }
}
```

### Querying Workflow State

```typescript
// Get workflow instance
const instance = await env.WORKFLOW.get('workflow-id')

// Get current status
const status = await instance.status()
// { status: 'running', output: null }

// Query custom state (if workflow exposes it)
const progress = await instance.query('getProgress')
// { progress: 75, status: 'running' }
```

## HTTP API

temporal.do exposes a REST API for workflow management:

### Workflow Endpoints

```bash
# Start a workflow
POST /workflows/:workflowType
{
  "id": "optional-custom-id",
  "params": { ... }
}

# Get workflow status
GET /workflows/:workflowType/:id

# Query workflow state
GET /workflows/:workflowType/:id/query/:queryName

# Cancel workflow
POST /workflows/:workflowType/:id/cancel

# List workflows
GET /workflows/:workflowType?status=running&limit=100
```

### Example: Start Workflow via HTTP

```bash
curl -X POST https://your-worker.workers.dev/workflows/order \
  -H "Content-Type: application/json" \
  -d '{
    "id": "order-123",
    "params": {
      "customerId": "cust-456",
      "items": [{"sku": "WIDGET", "qty": 2}],
      "total": 99.99
    }
  }'
```

## Configuration

### Wrangler Configuration

```jsonc
// wrangler.jsonc
{
  "name": "my-temporal-do",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],

  // Define workflows
  "workflows": [
    { "name": "order-workflow", "class_name": "OrderWorkflow" },
    { "name": "subscription-workflow", "class_name": "SubscriptionWorkflow" }
  ],

  // Optional: Durable Objects for state (if not using CF Workflows)
  "durable_objects": {
    "bindings": [
      { "name": "WORKFLOW_STATE", "class_name": "WorkflowStateDO" }
    ]
  }
}
```

### Environment Type

```typescript
interface Env {
  ORDER_WORKFLOW: Workflow
  SUBSCRIPTION_WORKFLOW: Workflow
  // Optional DO binding
  WORKFLOW_STATE?: DurableObjectNamespace
}
```

## Architecture

```
+--------------------------------------------------------------------+
|                      Your Workflow Code                             |
|   export class OrderWorkflow extends Workflow { ... }               |
+--------------------------------------------------------------------+
                                |
                                v
+--------------------------------------------------------------------+
|                     temporal.do Runtime                             |
+--------------------------------------------------------------------+
|  Step Executor  |  State Manager  |  Scheduler  |  Query Handler   |
+--------------------------------------------------------------------+
|                                                                     |
|   +--------------------------+  +-----------------------------+     |
|   |    CF Workflows          |  |    Durable Objects          |     |
|   |    (FREE sleep, retries) |  |    (State persistence)      |     |
|   +--------------------------+  +-----------------------------+     |
|                                                                     |
+--------------------------------------------------------------------+
                                |
                                v
+--------------------------------------------------------------------+
|               Cloudflare Global Network                             |
|                   300+ cities, <50ms                                |
+--------------------------------------------------------------------+
```

### How It Works

1. **Workflow Definition** - You define workflows as classes extending `Workflow`
2. **Step Execution** - Each `step.do()` is persisted and retried on failure
3. **State Management** - Workflow state survives crashes via DO or CF Workflows
4. **FREE Sleep** - `step.sleep()` uses CF Workflows scheduler (no compute cost)
5. **Edge Execution** - Workflows run globally, close to your users

## Best Practices

### Step Naming

Use descriptive, unique step names for debugging and idempotency:

```typescript
// Good - descriptive and unique
await this.step.do('reserve-inventory-sku-123', () => ...)
await this.step.do(`send-email-${customerId}`, () => ...)

// Bad - generic names make debugging hard
await this.step.do('step1', () => ...)
await this.step.do('do-thing', () => ...)
```

### Idempotent Operations

Ensure step operations are idempotent (safe to retry):

```typescript
// Good - uses idempotency key
await this.step.do('charge-payment', async () => {
  return stripe.charges.create({
    amount: order.total,
    idempotencyKey: `order-${order.id}`,
  })
})

// Risky - may double-charge on retry
await this.step.do('charge-payment', async () => {
  return stripe.charges.create({ amount: order.total })
})
```

### Long-Running Workflows

Use continue-as-new to prevent unbounded history:

```typescript
export class MonitoringWorkflow extends Workflow {
  private iterations = 0

  async run() {
    while (this.iterations < 1000) {
      await this.step.do(`check-${this.iterations}`, () => checkHealth())
      await this.step.sleep(`wait-${this.iterations}`, '1m')
      this.iterations++
    }

    // Reset history after 1000 iterations
    return this.continueAsNew()
  }
}
```

## Related

- [@dotdo/temporal](/docs/integrations/temporal/package) - Temporal SDK compatibility
- [Workflows Overview](/docs/workflows) - Durable execution primitives
- [Durable Objects](/docs/architecture/durable-objects) - Stateful edge computing
- [CF Workflows](/docs/cloudflare/workflows) - Native Cloudflare Workflows
