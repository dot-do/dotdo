---
title: pusher.do
description: Pusher on the Edge — A fully managed Pusher-compatible real-time service running on Cloudflare Workers with unlimited connections.
---

# pusher.do

**Pusher on the Edge** — A Pusher-compatible real-time service that runs entirely on Cloudflare Workers, with unlimited connections, zero per-message fees, and global edge deployment.

```typescript
import Pusher from 'pusher.do'

const pusher = new Pusher('your-app-key', {
  cluster: 'global',
})

const channel = pusher.subscribe('my-channel')
channel.bind('my-event', (data) => {
  console.log('Received:', data)
})
```

<Callout type="info">
Looking for a self-hosted solution? See [@dotdo/pusher](/docs/integrations/pusher/package) for a drop-in replacement you can deploy on your own Workers.
</Callout>

## Why pusher.do?

Traditional Pusher has connection limits, per-message fees, and single-region latency. pusher.do eliminates all of that by running directly on Cloudflare's edge network:

- **Unlimited Connections** — No per-connection or per-message fees
- **Global by Default** — WebSockets terminate at the nearest edge (300+ cities)
- **Zero Cold Starts** — V8 isolates spin up instantly
- **Pusher Compatible** — Drop-in replacement for pusher-js
- **Self-Hosted Option** — Deploy to your own Cloudflare account

## Comparison with Pusher Cloud

| | Pusher Cloud | pusher.do |
|---|--------------|-----------|
| **Connections/channel** | 100 (Free), 10K (Enterprise) | Unlimited |
| **Per-connection fees** | $0.0001/connection/day | None |
| **Per-message fees** | $0.000001/message | None |
| **Channel limit** | 100 per app (Free) | Unlimited |
| **Message size** | 10KB | 128KB |
| **Latency** | Single region | Edge (300+ cities) |
| **Cold start** | N/A (hosted) | 0ms (V8 isolates) |
| **Self-hosted** | No | Yes |

The math: 10,000 concurrent connections for 30 days on Pusher Cloud = $30/month minimum. On pusher.do, it's included in your Cloudflare Workers usage.

## Features

### Core Real-Time

| Feature | Description |
|---------|-------------|
| **Public Channels** | Open subscription, no auth required |
| **Private Channels** | Server-authorized access control |
| **Presence Channels** | Track online users with member info |
| **Client Events** | Direct client-to-client messaging |
| **Connection State** | Full lifecycle management |
| **Event Binding** | Per-channel and global handlers |

### Production Features

| Feature | Description |
|---------|-------------|
| **Server SDK** | Trigger events, batch operations, user authentication |
| **Channel Authorization** | Secure private/presence channel access |
| **Webhooks** | Connection, channel, and presence events |
| **Encrypted Channels** | End-to-end encryption for sensitive data |
| **Analytics** | Connection metrics, message throughput, channel stats |
| **Rate Limiting** | Configurable per-channel limits |

### Edge Architecture

| Feature | Description |
|---------|-------------|
| **Hibernatable WebSockets** | 0 CPU when idle, wake on message |
| **Durable Object State** | SQLite-backed persistence per channel |
| **Global Routing** | Automatic nearest-edge connection |
| **Zero Cold Start** | V8 isolate instant startup |

## Installation

```bash
npm install pusher.do
```

## Quick Start

### Client SDK

```typescript
import Pusher from 'pusher.do'

const pusher = new Pusher('your-app-key', {
  cluster: 'global',
  forceTLS: true,
})

// Subscribe to a public channel
const channel = pusher.subscribe('news')

channel.bind('breaking', (data) => {
  console.log('Breaking news:', data.headline)
})

// Connection state
pusher.connection.bind('connected', () => {
  console.log('Connected! Socket ID:', pusher.connection.socket_id)
})
```

### Server SDK

```typescript
import { PusherServer } from 'pusher.do/server'

const pusher = new PusherServer({
  appId: 'your-app-id',
  key: 'your-app-key',
  secret: 'your-app-secret',
  cluster: 'global',
})

// Trigger event to channel
await pusher.trigger('my-channel', 'my-event', {
  message: 'Hello from server!'
})

// Batch trigger
await pusher.triggerBatch([
  { channel: 'channel-1', name: 'event-1', data: { foo: 'bar' } },
  { channel: 'channel-2', name: 'event-2', data: { baz: 'qux' } },
])

// Get channel info
const info = await pusher.get({ path: '/channels/presence-room' })
console.log('User count:', info.user_count)
```

### Channel Authorization

```typescript
// Server endpoint for private/presence channel auth
import { PusherServer } from 'pusher.do/server'

export async function POST(request: Request) {
  const pusher = new PusherServer({
    appId: process.env.PUSHER_APP_ID,
    key: process.env.PUSHER_KEY,
    secret: process.env.PUSHER_SECRET,
    cluster: 'global',
  })

  const body = await request.formData()
  const socketId = body.get('socket_id') as string
  const channelName = body.get('channel_name') as string

  // Verify user is authorized for this channel
  const user = await getCurrentUser(request)
  if (!isAuthorized(user, channelName)) {
    return new Response('Forbidden', { status: 403 })
  }

  // For presence channels, include user data
  if (channelName.startsWith('presence-')) {
    const presenceData = {
      user_id: user.id,
      user_info: { name: user.name, avatar: user.avatar }
    }
    const auth = pusher.authorizeChannel(socketId, channelName, presenceData)
    return Response.json(auth)
  }

  // For private channels
  const auth = pusher.authorizeChannel(socketId, channelName)
  return Response.json(auth)
}
```

## Deploy to Cloudflare

### Using wrangler

```typescript
// src/index.ts
import { PusherEntrypoint, PusherChannel } from 'pusher.do'

export { PusherChannel }
export default PusherEntrypoint
```

```jsonc
// wrangler.jsonc
{
  "name": "my-pusher",
  "main": "src/index.ts",
  "compatibility_date": "2025-01-01",
  "compatibility_flags": ["nodejs_compat"],
  "durable_objects": {
    "bindings": [{ "name": "PUSHER_CHANNEL", "class_name": "PusherChannel" }]
  },
  "migrations": [{ "tag": "v1", "new_sqlite_classes": ["PusherChannel"] }]
}
```

```bash
npx wrangler deploy
```

### Configuration

```jsonc
{
  "vars": {
    "PUSHER_APP_ID": "your-app-id",
    "PUSHER_KEY": "your-app-key",
    "PUSHER_SECRET": "your-app-secret"
  }
}
```

## Webhooks

Configure webhooks to receive events about connections, channels, and presence:

```typescript
// Webhook endpoint
export async function POST(request: Request) {
  const signature = request.headers.get('X-Pusher-Signature')
  const body = await request.text()

  // Verify webhook signature
  if (!verifySignature(body, signature, process.env.PUSHER_SECRET)) {
    return new Response('Invalid signature', { status: 401 })
  }

  const events = JSON.parse(body)

  for (const event of events.events) {
    switch (event.name) {
      case 'channel_occupied':
        console.log('Channel became active:', event.channel)
        break
      case 'channel_vacated':
        console.log('Channel became empty:', event.channel)
        break
      case 'member_added':
        console.log('User joined:', event.user_id, 'in', event.channel)
        break
      case 'member_removed':
        console.log('User left:', event.user_id, 'from', event.channel)
        break
    }
  }

  return new Response('OK')
}
```

## Architecture

Each channel is backed by a Durable Object:

```
┌─────────────────────────────────────────────────────────────┐
│                        Client                                │
│           pusher.subscribe('my-channel')                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Edge (Nearest Colo)                       │
│              WebSocket terminates here                       │
│                  0ms cold start                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Channel DO                               │
│                                                              │
│   ┌────────────────────────────────────────────────────┐    │
│   │               SQLite State                          │    │
│   │   - Connection registry                             │    │
│   │   - Presence members                                │    │
│   │   - Channel metadata                                │    │
│   └────────────────────────────────────────────────────┘    │
│                                                              │
│   ┌────────────────────────────────────────────────────┐    │
│   │         Hibernatable WebSockets                     │    │
│   │   - 0 CPU when idle                                 │    │
│   │   - Wake on message                                 │    │
│   │   - Unlimited connections                           │    │
│   └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

Benefits over Pusher Cloud:
- **Edge-native**: Connections terminate at nearest location (300+ cities)
- **No connection limits**: Durable Objects scale horizontally
- **No per-message fees**: Pay only for compute
- **Self-hosted option**: Your data stays in your infrastructure

## Examples

### Real-Time Chat

```typescript
// Client
import Pusher from 'pusher.do'
import type { PresenceChannel } from 'pusher.do'

const pusher = new Pusher('your-app-key', { cluster: 'global' })
const chat = pusher.subscribe('presence-chat-room') as PresenceChannel

chat.bind('pusher:subscription_succeeded', (members) => {
  displayOnlineUsers(members.toArray())
})

chat.bind('pusher:member_added', (member) => {
  addOnlineUser(member)
})

chat.bind('pusher:member_removed', (member) => {
  removeOnlineUser(member)
})

chat.bind('new-message', (data) => {
  displayMessage(data)
})

// Server
import { PusherServer } from 'pusher.do/server'

const pusher = new PusherServer({ /* config */ })

async function sendMessage(roomId: string, message: Message) {
  await pusher.trigger(`presence-chat-${roomId}`, 'new-message', {
    id: message.id,
    user: message.user,
    text: message.text,
    timestamp: Date.now(),
  })
}
```

### Live Dashboard

```typescript
// Client - Real-time metrics
const dashboard = pusher.subscribe('private-dashboard')

dashboard.bind('metrics', (data) => {
  updateChart('cpu', data.cpu)
  updateChart('memory', data.memory)
  updateChart('requests', data.requests)
})

dashboard.bind('alert', (data) => {
  showAlert(data.severity, data.message)
})

// Server - Push metrics every second
setInterval(async () => {
  await pusher.trigger('private-dashboard', 'metrics', {
    cpu: getCpuUsage(),
    memory: getMemoryUsage(),
    requests: getRequestCount(),
  })
}, 1000)
```

### Collaborative Editing

```typescript
// Client
const doc = pusher.subscribe('presence-document-123') as PresenceChannel

// Track cursors
doc.bind('client-cursor', (data) => {
  updateCursor(data.userId, data.position)
})

// Track selections
doc.bind('client-selection', (data) => {
  updateSelection(data.userId, data.range)
})

// Broadcast local cursor
editor.on('cursorChange', (position) => {
  doc.trigger('client-cursor', {
    userId: doc.members.me?.id,
    position
  })
})

// Server - Persist changes
doc.bind('client-change', async (data) => {
  await pusher.trigger('presence-document-123', 'change', {
    ...data,
    version: await incrementVersion(data.docId)
  })
})
```

## API Reference

### Server SDK

| Method | Description |
|--------|-------------|
| `pusher.trigger(channel, event, data)` | Send event to channel |
| `pusher.triggerBatch(events)` | Send multiple events |
| `pusher.authorizeChannel(socketId, channel, presenceData?)` | Generate auth token |
| `pusher.authenticateUser(socketId, userData)` | Authenticate user |
| `pusher.get({ path })` | Query channel/user info |
| `pusher.terminateUserConnections(userId)` | Force disconnect user |

### Client SDK

| Method | Description |
|--------|-------------|
| `new Pusher(key, options)` | Create client instance |
| `pusher.subscribe(channel)` | Subscribe to channel |
| `pusher.unsubscribe(channel)` | Unsubscribe from channel |
| `pusher.channel(name)` | Get channel by name |
| `pusher.allChannels()` | Get all subscribed channels |
| `pusher.connect()` | Connect to server |
| `pusher.disconnect()` | Disconnect from server |
| `pusher.bind(event, callback)` | Bind to global event |
| `pusher.signin()` | Sign in user |

### Webhook Events

| Event | Description |
|-------|-------------|
| `channel_occupied` | First subscription to channel |
| `channel_vacated` | Last unsubscription from channel |
| `member_added` | User joined presence channel |
| `member_removed` | User left presence channel |
| `client_event` | Client triggered event |

## Migration from Pusher Cloud

### Client

```typescript
// Before: Pusher Cloud
import Pusher from 'pusher-js'
const pusher = new Pusher('your-key', { cluster: 'us2' })

// After: pusher.do
import Pusher from 'pusher.do'
const pusher = new Pusher('your-key', { cluster: 'global' })
```

### Server

```typescript
// Before: Pusher Cloud
import Pusher from 'pusher'
const pusher = new Pusher({
  appId: 'app-id',
  key: 'key',
  secret: 'secret',
  cluster: 'us2',
})

// After: pusher.do
import { PusherServer } from 'pusher.do/server'
const pusher = new PusherServer({
  appId: 'app-id',
  key: 'key',
  secret: 'secret',
  cluster: 'global',
})
```

All existing Pusher code works unchanged. Update imports and cluster, and you're done.

## Related

- [@dotdo/pusher](/docs/integrations/pusher/package) - Self-hosted Pusher compat
- [Durable Objects](/docs/architecture/durable-objects) - DO-backed storage
- [Realtime SDKs](/docs/compat/realtime) - Pusher, Ably, Socket.IO
- [WebSockets](/docs/websockets) - WebSocket primitives
