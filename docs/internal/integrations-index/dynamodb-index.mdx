---
title: DynamoDB
description: Choose between @dotdo/dynamodb (OSS package) and dynamodb.do (managed edge service) for your DynamoDB needs.
---

# DynamoDB Integration

dotdo provides two ways to work with DynamoDB-compatible APIs:

| | @dotdo/dynamodb | dynamodb.do |
|---|-----------------|-------------|
| **Type** | OSS npm package | Managed edge service |
| **Storage** | In-memory | Durable Object SQLite |
| **Persistence** | None (resets on restart) | Full durability |
| **Use case** | Testing, prototyping | Production workloads |
| **Infrastructure** | Zero | Zero (we manage it) |
| **Install** | `npm install @dotdo/dynamodb` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/dynamodb - In-memory, great for tests
import { DynamoDBClient, PutItemCommand, GetItemCommand } from '@dotdo/dynamodb'

const client = new DynamoDBClient({ region: 'us-east-1' })

await client.send(new PutItemCommand({
  TableName: 'Users',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
    name: { S: 'Alice' },
  },
}))
// Data lost on restart
```

```typescript
// dynamodb.do - Persistent edge database
import { DynamoDBClient, PutItemCommand, GetItemCommand } from 'dynamodb.do'

const client = new DynamoDBClient('https://your-worker.workers.dev')

await client.send(new PutItemCommand({
  TableName: 'Users',
  Item: {
    pk: { S: 'USER#123' },
    sk: { S: 'PROFILE' },
    name: { S: 'Alice' },
  },
}))
// Data persists globally
```

## When to Use Each

### Use @dotdo/dynamodb when:

- **Unit testing** - Fast, isolated tests without AWS credentials or network
- **Prototyping** - Quick iteration without infrastructure setup
- **Edge functions** - Need DynamoDB API but no persistence required
- **CI/CD pipelines** - Tests that need DynamoDB semantics

<Callout type="info">
@dotdo/dynamodb is a complete in-memory DynamoDB implementation with AWS SDK v3 API compatibility. Perfect for tests and development, but data doesn't persist between restarts.
</Callout>

### Use dynamodb.do when:

- **Production applications** - Real user data that must persist
- **Global edge deployment** - Data close to users worldwide
- **AI/Agent workloads** - Vector search, MCP protocol support
- **No AWS dependency** - Run DynamoDB workloads without AWS

<Callout type="info">
dynamodb.do is DynamoDB on the Edge - a fully managed service running on Cloudflare's global network with zero AWS infrastructure to manage.
</Callout>

## Feature Comparison

| Feature | @dotdo/dynamodb | dynamodb.do |
|---------|-----------------|-------------|
| CRUD Operations | Full | Full |
| Query & Scan | Full | Full |
| Batch Operations | Full (25/100 items) | Full |
| Transactions | Full ACID | Full ACID |
| GSI/LSI | Full | Full |
| Expressions | Full (Key, Filter, Update, Condition) | Full |
| DynamoDB Streams | Not yet | Real-time |
| TTL | Not yet | Full |
| Wire Protocol | N/A | AWS SDK compatible |
| MCP Protocol | N/A | AI agent integration |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/dynamodb/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/dynamodb</h3>
    <p className="text-sm text-muted-foreground">In-memory DynamoDB for testing and development</p>
  </a>
  <a href="/docs/integrations/dynamodb/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">dynamodb.do</h3>
    <p className="text-sm text-muted-foreground">Managed DynamoDB on the edge for production</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/dynamodb` for development, then upgrade to `dynamodb.do` for production:

```typescript
// Development (package)
import { DynamoDBClient, PutItemCommand, QueryCommand } from '@dotdo/dynamodb'
const client = new DynamoDBClient({ region: 'us-east-1' })

// Production (service) - same API!
import { DynamoDBClient, PutItemCommand, QueryCommand } from 'dynamodb.do'
const client = new DynamoDBClient('https://your-dynamodb.workers.dev')

// Your application code stays the same
await client.send(new PutItemCommand({
  TableName: 'Users',
  Item: { pk: { S: 'USER#123' }, name: { S: 'Alice' } },
}))

const result = await client.send(new QueryCommand({
  TableName: 'Users',
  KeyConditionExpression: 'pk = :pk',
  ExpressionAttributeValues: { ':pk': { S: 'USER#123' } },
}))
```

Both packages share the same AWS SDK v3-compatible API, making migration seamless.
