---
title: Pinecone
description: Choose between @dotdo/pinecone (OSS package) and pinecone.do (managed edge service) for vector search.
---

# Pinecone Integration

dotdo provides two ways to work with Pinecone-compatible vector search APIs:

| | @dotdo/pinecone | pinecone.do |
|---|-----------------|-------------|
| **Type** | OSS npm package | Managed edge service |
| **Storage** | In-memory HNSW | Durable Object SQLite + R2 |
| **Persistence** | None (resets on restart) | Full durability |
| **Use case** | Testing, prototyping | Production workloads |
| **Infrastructure** | Zero | Zero (we manage it) |
| **Install** | `npm install @dotdo/pinecone` | Deploy to Cloudflare |

## Quick Comparison

```typescript
// @dotdo/pinecone - In-memory, great for tests
import { Pinecone } from '@dotdo/pinecone'

const pinecone = new Pinecone()
const index = pinecone.index('products')
await index.upsert([{ id: 'vec1', values: embedding, metadata: { category: 'tech' } }])
// Data lost on restart
```

```typescript
// pinecone.do - Persistent edge vector database
import { Pinecone } from 'pinecone.do'

const pinecone = new Pinecone('https://your-worker.workers.dev')
const index = pinecone.index('products')
await index.upsert([{ id: 'vec1', values: embedding, metadata: { category: 'tech' } }])
// Data persists globally
```

## When to Use Each

### Use @dotdo/pinecone when:

- **Unit testing** - Fast, isolated tests without external dependencies
- **Prototyping** - Quick iteration without infrastructure setup
- **Edge functions** - Need Pinecone API but no persistence required
- **CI/CD pipelines** - Tests that need vector search semantics

<Callout type="info">
@dotdo/pinecone is a complete in-memory Pinecone implementation with HNSW indexing. Perfect for tests and development, but data doesn't persist between restarts.
</Callout>

### Use pinecone.do when:

- **Production applications** - Real vector data that must persist
- **Global edge deployment** - Vectors close to users worldwide
- **AI/Agent workloads** - Semantic search, RAG pipelines, embeddings
- **Large-scale similarity search** - Millions of vectors with sharding

<Callout type="info">
pinecone.do is Pinecone on the Edge - a fully managed service running on Cloudflare's global network with zero infrastructure to manage.
</Callout>

## Feature Comparison

| Feature | @dotdo/pinecone | pinecone.do |
|---------|-----------------|-------------|
| Upsert/Query/Fetch | Full | Full |
| Metadata Filters | All operators | All operators |
| Namespaces | Partition vectors | Partition vectors |
| Index Management | Create/delete/describe | Create/delete/describe |
| Batch Operations | Auto-chunking | Auto-chunking |
| HNSW Parameters | Configurable M, ef | Configurable M, ef |
| Distance Metrics | Cosine, Euclidean, Dot | Cosine, Euclidean, Dot |
| Persistence | None | Full (SQLite + R2) |
| Quantization | None | Product, Scalar |
| Horizontal Scaling | None | DO sharding |
| Edge Deployment | Yes | Yes (300+ cities) |
| 0ms Cold Starts | Yes | Yes |

## Getting Started

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <a href="/docs/integrations/pinecone/package" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">@dotdo/pinecone</h3>
    <p className="text-sm text-muted-foreground">In-memory Pinecone for testing and development</p>
  </a>
  <a href="/docs/integrations/pinecone/service" className="block p-4 border rounded-lg hover:border-primary">
    <h3 className="font-semibold">pinecone.do</h3>
    <p className="text-sm text-muted-foreground">Managed Pinecone on the edge for production</p>
  </a>
</div>

## Migration Path

Start with `@dotdo/pinecone` for development, then upgrade to `pinecone.do` for production:

```typescript
// Development (package)
import { Pinecone } from '@dotdo/pinecone'
const pinecone = new Pinecone()
const index = pinecone.index('products')

// Production (service) - same API!
import { Pinecone } from 'pinecone.do'
const pinecone = new Pinecone('https://your-pinecone.workers.dev')
const index = pinecone.index('products')

// Your application code stays the same
const results = await index.query({
  vector: queryEmbedding,
  topK: 10,
  filter: { category: { $eq: 'electronics' } },
  includeMetadata: true,
})
```

Both packages share the same Pinecone-compatible API, making migration seamless.
