---
title: dotdo vs Cloudflare Workers
description: Compare dotdo with raw Cloudflare Workers - when to use the framework vs the platform directly.
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Cards, Card } from 'fumadocs-ui/components/card'

# dotdo vs Cloudflare Workers

dotdo runs **on top of** Cloudflare Workers and Durable Objects. This page explains what dotdo adds and when you might use Workers directly.

## Quick Comparison

| Feature | dotdo | Raw Cloudflare Workers |
|---------|-------|------------------------|
| **Runtime** | Cloudflare (same) | Cloudflare |
| **Abstraction Level** | High-level framework | Low-level platform |
| **State Management** | Things, Actions, Events, Relationships | Raw SQLite API |
| **Routing** | Built-in REST + RPC | DIY with Hono/itty-router |
| **AI Agents** | First-class with identity | DIY |
| **Human Escalation** | Built-in HumanFunction | DIY |
| **40+ Compat APIs** | Yes (Postgres, Redis, etc.) | No |
| **Learning Curve** | Higher (framework concepts) | Lower (just JS/TS) |
| **Flexibility** | Opinionated patterns | Full control |

## What dotdo Adds

dotdo is a **framework** built on Cloudflare's primitives. Here's what it provides:

### 1. Data Model (Things, Actions, Events, Relationships)

**Raw Workers:**

```typescript
// Manual SQLite schema and queries
export class MyDO extends DurableObject {
  async fetch(request: Request) {
    const db = this.ctx.storage.sql

    // Create tables manually
    db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        name TEXT,
        email TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `)

    // Manual CRUD
    const userId = crypto.randomUUID()
    db.exec(`INSERT INTO users (id, name, email) VALUES (?, ?, ?)`, userId, 'Alice', 'alice@example.com')

    // Manual versioning? Audit trail? Events? Build it yourself.
  }
}
```

**dotdo:**

```typescript
// Built-in data model
export class MyApp extends DO {
  async createUser(data: UserData) {
    // Automatic schema, versioning, audit trail
    const user = await this.things.create({
      $type: 'User',
      name: data.name,
      data: { email: data.email },
    })

    // Automatic event emission
    await this.events.emit({
      verb: 'signup',
      source: user.$id,
      data,
    })

    // Automatic action logging
    // await this.actions.log({ verb: 'create', target: user.$id })

    return user
  }
}
```

dotdo provides:
- **Things** - Versioned entities with URL identity
- **Actions** - Complete audit trail of all operations
- **Events** - Domain events for pub/sub patterns
- **Relationships** - Typed edges between Things (graph model)

### 2. API Layer (REST + RPC)

**Raw Workers:**

```typescript
// Manual routing with Hono
import { Hono } from 'hono'

export class MyDO extends DurableObject {
  app = new Hono()

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)

    this.app.get('/users', async (c) => {
      const users = await this.getUsers()
      return c.json(users)
    })

    this.app.get('/users/:id', async (c) => {
      const user = await this.getUser(c.req.param('id'))
      if (!user) return c.json({ error: 'Not found' }, 404)
      return c.json(user)
    })

    this.app.post('/users', async (c) => {
      const data = await c.req.json()
      const user = await this.createUser(data)
      return c.json(user, 201)
    })

    // ... more routes
  }

  async fetch(request: Request) {
    return this.app.fetch(request)
  }
}
```

**dotdo:**

```typescript
// Automatic REST + RPC
export class MyApp extends DO {
  // REST routes auto-generated from Things
  // GET /users → things.list({ type: 'User' })
  // GET /users/:id → things.get(id)
  // POST /users → things.create(body)
  // PATCH /users/:id → things.update(id, body)
  // DELETE /users/:id → things.delete(id)

  // Custom RPC methods exposed automatically
  async upgradeUser(userId: string, plan: string) {
    // Available via RPC: stub.upgradeUser(userId, plan)
    const user = await this.things.get(userId)
    return this.things.update(userId, { data: { ...user.data, plan } })
  }
}
```

dotdo provides:
- **Auto-generated REST** for CRUD operations
- **RPC exposure** for custom methods
- **Promise pipelining** for efficient multi-call batching

### 3. Workflow Context ($)

**Raw Workers:**

```typescript
// Manual event handling
export class MyDO extends DurableObject {
  private handlers: Map<string, Function> = new Map()

  registerHandler(event: string, handler: Function) {
    this.handlers.set(event, handler)
  }

  async emitEvent(event: string, data: any) {
    const handler = this.handlers.get(event)
    if (handler) await handler(data)
  }

  // Manual scheduling
  async scheduleTask(taskId: string, runAt: Date, payload: any) {
    await this.ctx.storage.setAlarm(runAt)
    await this.ctx.storage.put(`task:${taskId}`, payload)
  }

  async alarm() {
    // Manual alarm handling
  }
}
```

**dotdo:**

```typescript
// Declarative workflow context
export class MyApp extends DO {
  // Event handlers via proxy
  handlers = {
    'Customer.signup': async (event) => {
      await this.sendWelcomeEmail(event.data.email)
    },
    'Payment.failed': async (event) => {
      await this.notifySupport(event)
    },
    '*.created': async (event) => {
      await this.logCreation(event)
    },
  }

  // Scheduling via fluent DSL
  schedules = {
    'every.Monday.at9am': async () => {
      await this.sendWeeklyReport()
    },
    'every.hour': async () => {
      await this.checkHealthMetrics()
    },
  }

  // Three durability levels
  async processOrder(order: Order) {
    $.send('analytics', order)        // Fire-and-forget
    await $.try('validate', order)    // Single attempt
    await $.do('charge', order)       // Durable with retries
  }
}
```

### 4. AI Agents

**Raw Workers:**

```typescript
// DIY AI agent
export class AIAgent extends DurableObject {
  async processTask(task: string) {
    // Manual LLM call
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [{ role: 'user', content: task }],
      }),
    })

    const result = await response.json()

    // Manual memory management
    const history = await this.ctx.storage.get('history') || []
    history.push({ task, result: result.choices[0].message })
    await this.ctx.storage.put('history', history)

    // Manual tool execution
    // Manual identity management
    // Manual escalation to humans
    // ...

    return result
  }
}
```

**dotdo:**

```typescript
// First-class agents
import { priya, ralph, tom } from 'agents.do'
import { ceo } from 'humans.do'

export class ProductTeam extends DO {
  async buildFeature(description: string) {
    // Agents have identity, memory, and tools
    const spec = await priya`define the MVP for ${description}`

    // Ralph commits to GitHub as @ralph-do
    const pr = await ralph`implement ${spec}`

    // Tom reviews with real GitHub comments
    const review = await tom`review ${pr}`

    // Human escalation when needed
    if (spec.estimatedCost > 50000) {
      await ceo`approve ${spec.title} budget of $${spec.estimatedCost}`
    }

    return pr
  }
}
```

### 5. Human Escalation

**Raw Workers:**

```typescript
// DIY human-in-the-loop
export class ApprovalWorkflow extends DurableObject {
  async requestApproval(data: ApprovalRequest) {
    const approvalId = crypto.randomUUID()

    // Store pending approval
    await this.ctx.storage.put(`approval:${approvalId}`, {
      ...data,
      status: 'pending',
      createdAt: new Date(),
    })

    // Send notification (external service)
    await fetch('https://slack.com/api/chat.postMessage', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${this.env.SLACK_TOKEN}` },
      body: JSON.stringify({
        channel: '#approvals',
        text: `Approval needed: ${data.title}`,
        attachments: [
          {
            actions: [
              { type: 'button', text: 'Approve', value: approvalId },
              { type: 'button', text: 'Reject', value: approvalId },
            ],
          },
        ],
      }),
    })

    // Wait for callback (need webhook handler)
    // Handle timeouts (need alarm)
    // Send reminders (need scheduled task)
    // Escalate if no response (need escalation logic)
    // ...
  }
}
```

**dotdo:**

```typescript
// Built-in human escalation
import { ceo, legal, finance } from 'humans.do'

export class ApprovalWorkflow extends DO {
  // Simple template literal
  async approveContract(contract: Contract) {
    const approved = await legal`review and approve ${contract.title}`
    return approved
  }

  // Declarative escalation policy
  escalation = this.HumanFunction({
    trigger: 'amount > $10000',
    role: 'finance-manager',
    sla: '4 hours',
    channels: ['slack', 'email'],
    reminder: '2 hours',
    escalateTo: 'cfo',
    fallback: async () => this.autoReject(),
  })
}
```

### 6. Compat SDKs (40+)

**Raw Workers:**

```typescript
// Manual integration with external services
export class MyDO extends DurableObject {
  async getCustomer(id: string) {
    // Direct Stripe API call
    const response = await fetch(`https://api.stripe.com/v1/customers/${id}`, {
      headers: { 'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}` },
    })
    return response.json()
  }

  async sendEmail(to: string, subject: string, body: string) {
    // Direct SendGrid API call
    await fetch('https://api.sendgrid.com/v3/mail/send', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.SENDGRID_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        personalizations: [{ to: [{ email: to }] }],
        from: { email: 'noreply@example.com' },
        subject,
        content: [{ type: 'text/plain', value: body }],
      }),
    })
  }
}
```

**dotdo:**

```typescript
// Familiar APIs, runs on edge
import { createClient } from '@dotdo/supabase'
import { Redis } from '@dotdo/redis'
import Stripe from '@dotdo/stripe'

export class MyApp extends DO {
  supabase = createClient()
  redis = new Redis()
  stripe = new Stripe(this.env.STRIPE_KEY)

  async getCustomer(id: string) {
    // Looks like Supabase
    const { data } = await this.supabase
      .from('customers')
      .select('*')
      .eq('id', id)
      .single()

    // Cache in Redis-compatible API
    await this.redis.set(`customer:${id}`, JSON.stringify(data), 'EX', 3600)

    return data
  }
}
```

40+ compat SDKs including:
- Databases: Postgres, MySQL, MongoDB, Supabase, Firebase
- Cache: Redis, Memcached
- Messaging: Kafka, SQS, RabbitMQ
- Search: Elasticsearch, Algolia
- Payments: Stripe
- Email: SendGrid, Postmark, Resend
- And more...

## When to Use Raw Workers

### Use Raw Cloudflare Workers If

- **You need maximum control** - Custom SQLite schemas, routing, everything
- **You're building something simple** - A single API endpoint, webhook handler
- **You want minimal abstractions** - Just JavaScript/TypeScript, no framework
- **You have unique requirements** - dotdo's patterns don't fit your use case
- **You're learning the platform** - Understanding the primitives first

### Example: Simple Webhook Handler

```typescript
// Raw Worker is fine for this
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const payload = await request.json()

    // Process webhook
    await env.KV.put(`webhook:${Date.now()}`, JSON.stringify(payload))

    return new Response('OK', { status: 200 })
  },
}
```

### Example: Counter with DO

```typescript
// Raw DO is fine for simple state
export class Counter extends DurableObject {
  async fetch(request: Request): Promise<Response> {
    const count = (await this.ctx.storage.get('count')) || 0
    await this.ctx.storage.put('count', count + 1)
    return new Response(String(count + 1))
  }
}
```

## When to Use dotdo

### Use dotdo If

- **You're building a business application** - Users, orders, workflows, not just APIs
- **You need AI agents** - Agents with identity, memory, and tools
- **You need human escalation** - Approvals, reviews, oversight
- **You want built-in patterns** - CRUD, events, audit trails, versioning
- **You're building multi-tenant SaaS** - Each tenant isolated automatically
- **You want familiar APIs** - Postgres, Redis, Stripe SDKs you already know

### Example: SaaS Application

```typescript
// dotdo handles the complexity
export class TenantApp extends DO {
  async createOrder(data: OrderData) {
    // Automatic versioning, audit trail, events
    const order = await this.things.create({
      $type: 'Order',
      ...data,
    })

    // Automatic event emission
    await this.events.emit({ verb: 'created', source: order.$id, data })

    // Human approval for large orders
    if (data.amount > 10000) {
      await finance`approve order ${order.$id} for $${data.amount}`
    }

    // Durable payment processing
    await $.do('processPayment', order)

    return order
  }

  // Auto-generated REST API
  // Auto-generated RPC methods
  // Built-in WebSocket for real-time
}
```

## Cost Comparison

Both use Cloudflare pricing. dotdo adds no additional cost - it's a framework, not a service.

| Component | Price |
|-----------|-------|
| Workers requests | $0.50 / million |
| Durable Objects requests | $0.15 / million |
| DO storage | $0.20 / GB-month |
| R2 storage | $0.015 / GB-month |
| R2 operations | $0.36 / million |

dotdo's compat SDKs replace external services:

| External Service | Typical Cost | dotdo Alternative |
|------------------|--------------|-------------------|
| Supabase | $25-500/mo | @dotdo/supabase (included) |
| Redis (Upstash) | $10-100/mo | @dotdo/redis (included) |
| Postgres (Neon) | $25-200/mo | @dotdo/postgres (included) |
| Auth (Clerk) | $25-500/mo | org.ai (included) |

## The Spectrum

```
Low-Level ◄─────────────────────────────────────────► High-Level

Raw Workers     Workers + Hono     dotdo             workers.do
    │                │                │                  │
    │                │                │                  │
    ▼                ▼                ▼                  ▼
Maximum          Better DX        Full framework    Hosted platform
control          still flexible   opinionated       fully managed
```

Choose your level based on needs:
- **Raw Workers** - Maximum control, minimum abstraction
- **Workers + Hono/itty** - Better routing, still low-level
- **dotdo** - Full framework with patterns for business apps
- **workers.do** - Hosted platform with named agents (Priya, Ralph, etc.)

## Summary

dotdo and Cloudflare Workers aren't competitors - dotdo **runs on** Workers. The question is whether you want:

- **Raw platform** - Full control, build everything yourself
- **Framework** - Opinionated patterns for business applications

If you're building a simple API or learning the platform, raw Workers are great. If you're building AI-powered business applications with users, orders, workflows, agents, and human oversight - dotdo provides the patterns and tools.

<Cards>
  <Card title="Getting Started" href="/docs/getting-started">
    Try dotdo in 5 minutes.
  </Card>
  <Card title="Architecture" href="/docs/architecture">
    How dotdo uses Durable Objects.
  </Card>
  <Card title="Data Model" href="/docs/architecture/data-model">
    Things, Actions, Events, Relationships.
  </Card>
</Cards>
