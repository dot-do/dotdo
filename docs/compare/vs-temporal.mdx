---
title: dotdo vs Temporal
description: Compare dotdo with Temporal for building durable workflows and orchestrating AI agents.
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Cards, Card } from 'fumadocs-ui/components/card'

# dotdo vs Temporal

Temporal is the gold standard for durable workflow orchestration. dotdo builds on similar ideas but optimizes for **AI agent orchestration** and **autonomous business operations**.

## Quick Comparison

| Feature | dotdo | Temporal |
|---------|-------|----------|
| **Primary Focus** | AI agents + autonomous business | Durable workflow orchestration |
| **Runtime** | Cloudflare Durable Objects | Self-hosted or Temporal Cloud |
| **Language** | TypeScript | Go, Java, Python, TypeScript |
| **State** | SQLite per instance | External (Postgres/MySQL/Cassandra) |
| **Determinism** | Not required | Required (replay-based) |
| **Cold Starts** | ~0-50ms | Depends on worker pool |
| **AI Agents** | First-class with identity | DIY (activities) |
| **Human Escalation** | Built-in HumanFunction | DIY (signals + queries) |
| **Operations** | Managed (Cloudflare) | Self-managed or Temporal Cloud |

## Architecture Differences

### Temporal: Deterministic Replay

Temporal uses **event sourcing with deterministic replay**. Workflows must be deterministic - same inputs produce same outputs.

```typescript
// Temporal workflow
import { proxyActivities, sleep } from '@temporalio/workflow'

const { processPayment, sendEmail, updateInventory } = proxyActivities<Activities>({
  startToCloseTimeout: '1 minute',
})

export async function orderWorkflow(orderId: string): Promise<void> {
  // Each step is recorded in event history
  await processPayment(orderId)

  // Timers are durable
  await sleep('1 hour')

  // Activities execute on workers
  await updateInventory(orderId)
  await sendEmail(orderId)

  // On failure, workflow replays from event history
  // All steps must be deterministic
}
```

Temporal's model:
- **Event history** - Every step recorded in database
- **Replay** - Failed workflows replay from history
- **Determinism** - Workflows can't use `Date.now()`, `Math.random()`, etc.
- **Activities** - Non-deterministic code runs in separate workers

### dotdo: Actor Model with Checkpoints

dotdo uses **Durable Objects** - single-threaded actors with local SQLite and hibernation.

```typescript
// dotdo workflow
export class OrderWorkflow extends DO {
  async processOrder(orderId: string) {
    // State stored in local SQLite
    const order = await this.things.get(orderId)

    // Checkpoint: payment processed
    await $.do('processPayment', order)
    await this.things.update(orderId, { status: 'paid' })

    // Durable timer (survives hibernation)
    await $.schedule.in('1 hour').do('followUp', orderId)

    // Continue processing
    await $.do('updateInventory', order)
    await $.do('sendEmail', order)

    // No replay needed - state is persisted at each step
  }
}
```

dotdo's model:
- **SQLite state** - Each checkpoint persists to local SQLite
- **No replay** - State is preserved, no need to replay
- **No determinism requirement** - Use `Date.now()`, `Math.random()` freely
- **Hibernation** - DOs sleep between requests, wake on demand

## Durability Model

### Temporal: Event History Replay

```
┌─────────────────────────────────────────────────────────────┐
│                     Temporal Server                          │
├─────────────────────────────────────────────────────────────┤
│  Event History:                                              │
│  1. WorkflowExecutionStarted                                │
│  2. ActivityTaskScheduled (processPayment)                  │
│  3. ActivityTaskStarted                                     │
│  4. ActivityTaskCompleted                                   │
│  5. TimerStarted (1 hour)                                   │
│  6. TimerFired                                              │
│  7. ActivityTaskScheduled (updateInventory)                 │
│  ...                                                         │
└─────────────────────────────────────────────────────────────┘
        │
        │ On failure: Replay entire history
        ▼
┌─────────────────────────────────────────────────────────────┐
│                     Worker Pool                              │
│  - Replay workflow from event 1                              │
│  - Skip completed activities                                 │
│  - Resume from last checkpoint                               │
└─────────────────────────────────────────────────────────────┘
```

Temporal replays the entire workflow history on recovery. This requires:
- Deterministic workflow code
- Versioning for code changes
- History management (can grow large)

### dotdo: Checkpoint-Based Recovery

```
┌─────────────────────────────────────────────────────────────┐
│                   Durable Object                             │
├─────────────────────────────────────────────────────────────┤
│  SQLite State:                                               │
│  - order: { status: 'paid', paymentId: 'pay_123' }          │
│  - nextStep: 'updateInventory'                               │
│                                                              │
│  Actions Table:                                              │
│  - processPayment: completed                                 │
│  - updateInventory: pending                                  │
└─────────────────────────────────────────────────────────────┘
        │
        │ On failure: Resume from current state
        ▼
┌─────────────────────────────────────────────────────────────┐
│                   Recovery                                   │
│  - Read current state from SQLite                           │
│  - Check pending actions                                     │
│  - Resume from nextStep                                      │
└─────────────────────────────────────────────────────────────┘
```

dotdo doesn't replay - it resumes from persisted state. Benefits:
- No determinism requirements
- No event history growth
- Simpler mental model

## Workflow Patterns

### Temporal: Signals and Queries

```typescript
// Temporal: Human approval with signals
import { defineSignal, defineQuery, setHandler, condition } from '@temporalio/workflow'

const approvalSignal = defineSignal<[boolean]>('approval')
const statusQuery = defineQuery<string>('status')

export async function approvalWorkflow(requestId: string): Promise<void> {
  let approved: boolean | undefined
  let status = 'pending'

  setHandler(approvalSignal, (result) => {
    approved = result
    status = result ? 'approved' : 'rejected'
  })

  setHandler(statusQuery, () => status)

  // Wait for signal (could be hours/days)
  await condition(() => approved !== undefined, '7 days')

  if (approved) {
    await processApproved(requestId)
  } else {
    await processRejected(requestId)
  }
}
```

External systems send signals to Temporal to approve/reject.

### dotdo: Native Human Escalation

```typescript
// dotdo: Built-in human approval
import { ceo, legal } from 'humans.do'

export class ApprovalWorkflow extends DO {
  async processRequest(requestId: string) {
    const request = await this.things.get(requestId)

    // Simple template literal syntax
    const approved = await ceo`approve ${request.title} for $${request.amount}`

    if (approved) {
      await this.processApproved(request)
    } else {
      await this.processRejected(request)
    }
  }
}

// Or declarative escalation
escalation = this.HumanFunction({
  trigger: 'amount > $10000',
  role: 'cfo',
  sla: '4 hours',
  channels: ['slack', 'email'],
  fallback: async () => this.autoReject(),
})
```

HumanFunction handles:
- Multi-channel notifications
- SLA tracking and reminders
- Escalation chains
- Timeout fallbacks

### Temporal: Child Workflows

```typescript
// Temporal: Orchestrating child workflows
import { executeChild } from '@temporalio/workflow'

export async function parentWorkflow(items: string[]): Promise<void> {
  const results = await Promise.all(
    items.map((item) =>
      executeChild(childWorkflow, {
        args: [item],
        workflowId: `child-${item}`,
      })
    )
  )

  await aggregateResults(results)
}
```

### dotdo: Cross-DO Orchestration

```typescript
// dotdo: Calling other Durable Objects
export class ParentWorkflow extends DO {
  async processItems(items: string[]) {
    // Each item processed by its own DO
    const results = await Promise.all(
      items.map((item) => $.ItemProcessor(item).process())
    )

    // Aggregate in parent
    await this.aggregateResults(results)
  }
}

// Promise pipelining: one network round trip
const results = await items
  .map((item) => $.ItemProcessor(item).process())
  .all()
```

dotdo's promise pipelining minimizes network round trips.

## AI Agent Orchestration

### Temporal: Build It Yourself

```typescript
// Temporal: DIY AI agent
const { callOpenAI, updateDatabase, sendNotification } = proxyActivities<AIActivities>({
  startToCloseTimeout: '5 minutes',
})

export async function aiAgentWorkflow(task: string): Promise<string> {
  // Call LLM (activity)
  const response = await callOpenAI({
    model: 'gpt-4',
    messages: [{ role: 'user', content: task }],
  })

  // Parse and execute tools (more activities)
  const tools = parseToolCalls(response)
  for (const tool of tools) {
    switch (tool.name) {
      case 'update_database':
        await updateDatabase(tool.args)
        break
      case 'send_notification':
        await sendNotification(tool.args)
        break
    }
  }

  return response.content
}
```

You'd need to build:
- Agent identity and authentication
- Memory and context persistence
- Tool definitions and execution
- Human escalation flows
- Multi-agent coordination

### dotdo: First-Class Agents

```typescript
// dotdo: Agents are built-in
import { priya, ralph, tom } from 'agents.do'
import { ceo } from 'humans.do'

export class ProductDevelopment extends DO {
  async buildFeature(description: string) {
    // Agents have identity, memory, and tools
    const spec = await priya`define requirements for: ${description}`

    // Ralph commits to your GitHub
    const pr = await ralph`implement ${spec}`

    // Tom reviews with real GitHub comments
    const review = await tom`review ${pr}`

    // Human approval when needed
    if (spec.budget > 50000) {
      await ceo`approve ${spec.title} budget of $${spec.budget}`
    }

    return pr
  }
}
```

Agents include:
- **Identity** - Email, GitHub, API keys
- **Memory** - Persistent across sessions
- **Tools** - File system, Git, bash, npm
- **Escalation** - Seamless handoff to humans

## Operations Comparison

### Temporal: Self-Hosted or Cloud

```yaml
# Temporal deployment (simplified)
services:
  temporal:
    image: temporalio/auto-setup:1.22
    ports:
      - 7233:7233
    depends_on:
      - postgresql
      - elasticsearch

  postgresql:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: temporal

  elasticsearch:
    image: elasticsearch:7.16.2

  worker:
    build: ./worker
    environment:
      TEMPORAL_ADDRESS: temporal:7233
```

Temporal Cloud exists but:
- Starts at $200/mo
- Still need to run workers
- Workers need infrastructure

### dotdo: Fully Managed

```typescript
// dotdo: Just deploy code
export class MyWorkflow extends DO {
  async process() {
    // Runs on Cloudflare's global network
    // No servers to manage
    // No workers to scale
    // No database to maintain
  }
}
```

```bash
# Deploy
npm run deploy

# That's it
```

dotdo runs on Cloudflare:
- 300+ edge locations
- Automatic scaling
- No infrastructure management
- Pay-per-request pricing

## Performance Comparison

### Temporal

| Metric | Typical Value |
|--------|---------------|
| Workflow start latency | 10-50ms |
| Activity dispatch | 10-20ms |
| Signal handling | 10-50ms |
| Cold start (worker) | 1-10s |
| Event history replay | Depends on history size |

### dotdo

| Metric | Typical Value |
|--------|---------------|
| DO request latency | 5-20ms |
| SQLite read | <1ms |
| SQLite write | 1-5ms |
| Cold start (warm) | 0ms |
| Cold start (cold) | 20-50ms |
| No replay | N/A |

## Pricing Comparison

Scenario: 1M workflow executions/month, 5 activities each

### Temporal Cloud

| Component | Cost |
|-----------|------|
| Actions (5M) | ~$25/mo |
| Storage | ~$10/mo |
| Base fee | $200/mo |
| **Total** | **~$235/mo** |

Plus: Worker infrastructure (EC2, EKS, etc.)

### Self-Hosted Temporal

| Component | Cost |
|-----------|------|
| EC2 instances (3x t3.medium) | ~$100/mo |
| RDS Postgres | ~$50/mo |
| Elasticsearch (optional) | ~$100/mo |
| Worker instances | ~$100/mo |
| **Total** | **~$350/mo** |

Plus: Operations overhead

### dotdo

| Component | Cost |
|-----------|------|
| DO requests (5M) | ~$25/mo |
| SQLite storage | ~$2/mo |
| **Total** | **~$27/mo** |

No infrastructure to manage.

## Migration Considerations

### From Temporal to dotdo

**Good candidates for migration:**
- Workflows with AI/LLM calls
- Workflows needing human approval
- Simple sequential workflows
- Workflows with timer-heavy logic

**Keep on Temporal:**
- Complex saga patterns with compensation
- Workflows requiring exactly-once semantics
- Heavy use of versioning/patching
- Existing large Temporal deployments

### Incremental Migration

```typescript
// Phase 1: Call dotdo from Temporal activities
const { callDotdo } = proxyActivities<Activities>({})

export async function hybridWorkflow(data: Input): Promise<void> {
  // Temporal orchestration
  await validateInput(data)

  // dotdo for AI-heavy work
  const result = await callDotdo('ai-processor', data)

  // Back to Temporal
  await finalizeWorkflow(result)
}
```

```typescript
// Phase 2: Move orchestration to dotdo
export class HybridWorkflow extends DO {
  async process(data: Input) {
    await this.validateInput(data)

    // AI agent work
    const spec = await priya`analyze ${data}`
    const result = await ralph`process ${spec}`

    await this.finalize(result)
  }
}
```

## When to Choose Each

### Choose Temporal If

- **You need exactly-once semantics** - Temporal's replay guarantees this
- **You have complex saga patterns** - Compensating transactions are built-in
- **You need workflow versioning** - Temporal handles long-running workflow updates
- **Your team knows Temporal** - It's a powerful, proven system
- **You're not using AI agents** - Traditional workflow orchestration
- **You prefer Go/Java/Python** - Temporal has mature SDKs

### Choose dotdo If

- **You're building with AI agents** - First-class agent support
- **You need human escalation** - Built-in HumanFunction
- **You want simpler operations** - No infrastructure to manage
- **You prefer TypeScript** - dotdo is TypeScript-first
- **You need edge performance** - 300+ locations, 0ms cold starts
- **You want predictable pricing** - Pay-per-request, no base fees
- **You're building autonomous businesses** - AI agents running operations

## Summary

Temporal is excellent for traditional durable workflow orchestration - complex sagas, exactly-once semantics, long-running processes. dotdo is for building **autonomous businesses** where AI agents orchestrate work and humans provide oversight.

If you're orchestrating microservices with complex compensation logic, Temporal is battle-tested. If you're building AI-powered products where agents have identity, memory, and the ability to escalate - dotdo is purpose-built for that.

<Cards>
  <Card title="Getting Started" href="/docs/getting-started">
    Try dotdo in 5 minutes.
  </Card>
  <Card title="Workflows" href="/docs/workflows">
    Learn the $ context DSL.
  </Card>
  <Card title="Human Escalation" href="/docs/humans">
    Built-in approval workflows.
  </Card>
</Cards>
