---
title: dotdo vs Vercel
description: Compare dotdo with Vercel for building AI-powered applications and autonomous businesses.
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Cards, Card } from 'fumadocs-ui/components/card'

# dotdo vs Vercel

Vercel revolutionized frontend deployment. dotdo builds on that foundation to enable **autonomous businesses** - applications where AI agents perform real work, not just respond to prompts.

## Quick Comparison

| Feature | dotdo | Vercel |
|---------|-------|--------|
| **Primary Focus** | Autonomous business runtime | Frontend deployment platform |
| **Compute Model** | Durable Objects (V8 + SQLite) | Serverless Functions (Lambda-style) |
| **State Management** | Built-in (per-instance SQLite) | External (databases, Redis) |
| **AI Agents** | First-class (identity, memory, tools) | v0 AI (code generation) |
| **Cold Starts** | ~0-50ms | 100-500ms (Edge), 1-5s (Node) |
| **Pricing** | Pay-per-request + storage | Pay-per-function-execution |
| **Human Escalation** | Built-in HumanFunction | DIY |
| **40+ Compat APIs** | Yes (Postgres, Redis, etc.) | No (external services) |

## Architecture Differences

### Vercel: Stateless Functions

Vercel functions follow the Lambda model - spin up, execute, terminate. State lives externally.

```typescript
// Vercel API route
export async function GET(request: Request) {
  // Must connect to external database
  const db = await connectToDB(process.env.DATABASE_URL)

  // Must connect to external cache
  const cache = await connectToRedis(process.env.REDIS_URL)

  // Must track state externally
  const user = await db.query('SELECT * FROM users WHERE id = $1', [userId])

  return Response.json(user)
}
```

Challenges at scale:
- **Connection overhead** - Each invocation reconnects to databases
- **Cold starts** - Establishing connections takes 100ms-5s
- **State coordination** - Race conditions between concurrent functions
- **Connection limits** - Databases cap concurrent connections

### dotdo: Durable Objects

dotdo uses Cloudflare Durable Objects - single-threaded actors with built-in SQLite.

```typescript
// dotdo Durable Object
export class MyApp extends DO {
  async getUser(userId: string) {
    // SQLite is local - no network hop
    const user = await this.things.get(userId)

    // State is in-memory between requests
    this.cache.set(userId, user)

    return user
  }
}
```

Benefits:
- **Zero connection overhead** - SQLite is local
- **0ms cold starts** (warm) - No connections to establish
- **No race conditions** - Single-threaded per instance
- **No connection limits** - Each instance has its own SQLite

## AI Integration

### Vercel: v0 for Code Generation

Vercel's v0 generates UI components from prompts. It's a developer tool, not a runtime.

```
Prompt: "Create a dashboard with user metrics"
Output: React component code you copy-paste
```

v0 helps developers write code faster. The AI doesn't run in production - you do.

### dotdo: Agents as Runtime Actors

dotdo agents are workers that run autonomously in production.

```typescript
import { ralph, tom } from 'agents.do'

// Ralph is an AI developer that commits to your repo
const pr = await ralph`implement user authentication`

// Tom is an AI reviewer with a GitHub account
await tom`review ${pr}` // Creates real GitHub comments from @tom-do

// Agents have persistent identity and memory
await ralph`what did you work on yesterday?`
// Ralph remembers the authentication PR
```

Key differences:

| Aspect | v0 | dotdo Agents |
|--------|-----|--------------|
| When it runs | Dev time | Production |
| Output | Code to copy | Completed work |
| Identity | None | Real accounts |
| Memory | None | Persistent |
| Escalation | None | Built-in |

## State Management

### Vercel + External Databases

```typescript
// Typical Vercel stack
import { neon } from '@neondatabase/serverless'
import { Redis } from '@upstash/redis'
import { PrismaClient } from '@prisma/client'

const sql = neon(process.env.DATABASE_URL)
const redis = new Redis({ url: process.env.REDIS_URL })
const prisma = new PrismaClient()

export async function processOrder(orderId: string) {
  // 3 network hops to external services
  const order = await prisma.order.findUnique({ where: { id: orderId } })
  const cached = await redis.get(`order:${orderId}`)
  const result = await sql`UPDATE orders SET status = 'processed' WHERE id = ${orderId}`

  return result
}
```

Cost breakdown:
- Neon: $0.25/GB storage + $0.09/compute hour
- Upstash: $0.20/100K commands
- PlanetScale: $29/mo + usage
- Plus Vercel function costs

### dotdo: Built-in Everything

```typescript
// dotdo - everything is local
export class OrderProcessor extends DO {
  async processOrder(orderId: string) {
    // One SQLite read (local, ~1ms)
    const order = await this.things.get(orderId)

    // In-memory cache (instant)
    this.cache.set(`order:${orderId}`, order)

    // One SQLite write (local, ~5ms)
    await this.things.update(orderId, { status: 'processed' })

    // Event emission (local, ~1ms)
    await this.events.emit({ verb: 'processed', source: orderId })

    return order
  }
}
```

No external services. No connection strings. No separate billing.

## Human-in-the-Loop

### Vercel: Build It Yourself

Vercel doesn't have built-in human escalation. You'd need:

```typescript
// DIY approval flow
export async function requestApproval(data: ApprovalRequest) {
  // Send email via external service
  await sendgrid.send({
    to: 'approver@company.com',
    subject: 'Approval needed',
    body: renderApprovalEmail(data),
  })

  // Store pending approval in external DB
  await db.approvals.create({ data, status: 'pending' })

  // Build webhook endpoint for approval
  // Build UI for approval dashboard
  // Handle timeouts, reminders, escalation...
}
```

### dotdo: Native HumanFunction

```typescript
import { ceo, legal } from 'humans.do'

// Simple template literal syntax
const approved = await ceo`approve the partnership with ${company}`

// Or declarative escalation policies
escalation = this.HumanFunction({
  trigger: 'contract_value > $50000',
  role: 'legal',
  sla: '4 hours',
  channels: ['slack', 'email'],
})
```

HumanFunction handles:
- Multi-channel notifications (Slack, Discord, Email, SMS)
- SLA tracking and reminders
- Escalation chains
- Audit trails
- Approval workflows

## Cost Comparison

Scenario: 100K monthly users, 1M API requests/month, 10GB data

### Vercel Stack

| Service | Cost |
|---------|------|
| Vercel Pro | $20/mo |
| Vercel Functions (1M) | ~$40/mo |
| Neon (10GB + compute) | ~$50/mo |
| Upstash Redis | ~$20/mo |
| SendGrid (email) | ~$20/mo |
| Clerk (auth) | ~$25/mo |
| **Total** | **~$175/mo** |

Plus integration complexity, connection pooling, cold start optimization...

### dotdo

| Component | Cost |
|-----------|------|
| Durable Objects (1M req) | ~$5/mo |
| SQLite storage (10GB) | ~$1.50/mo |
| R2 storage (overflow) | ~$1.50/mo |
| **Total** | **~$8/mo** |

Everything else (auth, email, caching, event streaming) is built-in.

<Callout type="info">
Actual costs vary based on usage patterns. dotdo's per-request pricing means you pay for what you use, not reserved capacity.
</Callout>

## When to Choose Each

### Choose Vercel If

- **You're building a marketing site** - Vercel excels at static site generation and edge caching
- **You have an existing Next.js app** - Vercel is the natural deployment target
- **You prefer BYO infrastructure** - You want to choose your own database, cache, auth provider
- **Your team knows the Vercel ecosystem** - Preview deployments, edge middleware, image optimization
- **You don't need AI agents** - Standard CRUD applications without autonomous behavior

### Choose dotdo If

- **You're building an AI-powered product** - Agents that work autonomously, not just chatbots
- **You need human escalation** - Approvals, reviews, oversight built into the workflow
- **You want built-in everything** - Database, cache, auth, events without external services
- **You're building multi-tenant SaaS** - Each tenant gets isolated state automatically
- **You want sub-10ms latency** - Local SQLite beats network hops to external databases
- **You're building an autonomous business** - AI agents running operations, not just assisting

## Migration Path

Already on Vercel? You can migrate incrementally.

### Keep Vercel for Frontend

```typescript
// pages/api/users/[id].ts (Vercel)
export default async function handler(req, res) {
  // Call dotdo for stateful operations
  const response = await fetch(`https://your-do.dotdo.dev/users/${req.query.id}`)
  const user = await response.json()
  res.json(user)
}
```

### Move State to dotdo

```typescript
// dotdo handles all stateful logic
export class UserService extends DO {
  async getUser(id: string) {
    return this.things.get(id)
  }

  async updateUser(id: string, data: UserUpdate) {
    // Audit trail automatic
    // Events automatic
    // Versioning automatic
    return this.things.update(id, data)
  }
}
```

### Eventually Move Everything

```typescript
// Full dotdo with MDXUI frontend
export class MyApp extends DO {
  // Backend: DO handles everything
  async api() {
    return this.router // Built-in REST/RPC
  }

  // Frontend: MDXUI components
  render() {
    return <Dashboard data={this.things.list()} />
  }
}
```

## Summary

Vercel is excellent for deploying frontends and serverless functions. dotdo is for building **autonomous businesses** where AI agents do real work.

If you're building a Next.js site with standard backend requirements, Vercel is great. If you're building AI-powered applications where agents have identity, memory, and the ability to escalate to humans - dotdo is purpose-built for that.

<Cards>
  <Card title="Getting Started" href="/docs/getting-started">
    Try dotdo in 5 minutes.
  </Card>
  <Card title="Architecture" href="/docs/architecture">
    Deep dive into Durable Objects.
  </Card>
  <Card title="Named Agents" href="/docs/agents">
    Meet the AI workforce.
  </Card>
</Cards>
