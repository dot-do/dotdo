---
title: WebSockets
description: Hibernatable WebSocket connections with tagging for pub/sub and broadcast patterns
---

# WebSockets

DOCore provides native WebSocket support with Cloudflare's hibernatable WebSocket API. This allows Durable Objects to maintain WebSocket connections while hibernating, dramatically reducing costs for idle connections.

## WebSocket Endpoints

DOCore includes two WebSocket endpoints:

| Endpoint | Description |
|----------|-------------|
| `/ws` | Standard WebSocket connection |
| `/ws/hibernatable` | Hibernatable WebSocket with auto-wake |

## Establishing Connections

### Client-Side

```typescript
// Standard WebSocket
const ws = new WebSocket('wss://your-do.workers.dev/ws')

// With room tag
const ws = new WebSocket('wss://your-do.workers.dev/ws?room=lobby')

// Hibernatable connection
const ws = new WebSocket('wss://your-do.workers.dev/ws/hibernatable')

ws.onopen = () => {
  console.log('Connected')
  ws.send(JSON.stringify({ type: 'hello' }))
}

ws.onmessage = (event) => {
  const data = JSON.parse(event.data)
  console.log('Received:', data)
}

ws.onclose = (event) => {
  console.log('Disconnected:', event.code, event.reason)
}
```

### Server-Side (DO)

WebSocket upgrades are handled in the `/ws` route:

```typescript
app.get('/ws', (c) => {
  const upgradeHeader = c.req.header('Upgrade')
  if (upgradeHeader !== 'websocket') {
    return c.json({ error: 'Upgrade Required' }, 426)
  }

  const room = c.req.query('room')
  const [client, server] = Object.values(new WebSocketPair())

  // Accept the WebSocket
  this.ctx.acceptWebSocket(server)

  // Tag for broadcasting
  const tags = room ? [`room:${room}`] : []
  this.websocketTags.set(server, tags)

  return new Response(null, {
    status: 101,
    webSocket: client,
  })
})
```

## Hibernatable WebSockets

Hibernatable WebSockets allow the DO to hibernate while maintaining active connections. When a message arrives, the DO wakes automatically.

```typescript
app.get('/ws/hibernatable', (c) => {
  const upgradeHeader = c.req.header('Upgrade')
  if (upgradeHeader !== 'websocket') {
    return c.json({ error: 'Upgrade Required' }, 426)
  }

  const [client, server] = Object.values(new WebSocketPair())

  // Accept with hibernation tag
  this.ctx.acceptWebSocket(server, ['hibernatable'])

  return new Response(null, {
    status: 101,
    webSocket: client,
  })
})
```

### Hibernation Benefits

| Aspect | Standard | Hibernatable |
|--------|----------|--------------|
| Memory while idle | Full DO in memory | Minimal (just connection) |
| Cost while idle | Full billing | Reduced billing |
| Wake on message | N/A | Automatic |
| Connection limit | Same | Same |

## Broadcasting

### broadcast(tag, message)

Send a message to all connections with a specific tag:

```typescript
// Via RPC
await stub.broadcast('room:lobby', {
  type: 'message',
  text: 'Hello everyone!'
})

// Returns count of messages sent
const result = await stub.broadcast('room:lobby', { event: 'update' })
console.log(`Sent to ${result.sent} connections`)
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `tag` | `string` | Yes | Tag to match connections |
| `message` | `unknown` | Yes | Message to send (JSON-serialized) |

**Returns:** `Promise<{ sent: number }>` - Count of messages sent

### Broadcast Patterns

```typescript
// Room-based messaging
await stub.broadcast('room:lobby', { type: 'chat', text: 'Hello!' })
await stub.broadcast('room:game-123', { type: 'move', x: 5, y: 3 })

// User-specific notifications
await stub.broadcast('user:alice', { type: 'notification', count: 3 })

// Global announcements
await stub.broadcast('all', { type: 'maintenance', message: 'Restarting soon' })
```

## Connection Tagging

Tags allow grouping connections for targeted broadcasts:

```typescript
app.get('/ws', (c) => {
  const room = c.req.query('room')
  const userId = c.req.query('userId')

  const [client, server] = Object.values(new WebSocketPair())
  this.ctx.acceptWebSocket(server)

  // Multiple tags per connection
  const tags = []
  if (room) tags.push(`room:${room}`)
  if (userId) tags.push(`user:${userId}`)
  tags.push('all') // Everyone gets 'all' tag

  this.websocketTags.set(server, tags)

  return new Response(null, { status: 101, webSocket: client })
})
```

### Getting Connection Tags

```typescript
// Via RPC - gets tags of last connected WebSocket
const tags = await stub.getWebSocketTags()
// ['room:lobby', 'user:alice', 'all']
```

<Callout type="info">
WebSocket objects cannot be passed via RPC. The `getWebSocketTags()` method returns tags for the most recently connected WebSocket.
</Callout>

## WebSocket Event Handlers

Override these methods to handle WebSocket events:

```typescript
export class MyDO extends DOCore {
  // Handle incoming messages
  webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void {
    const data = JSON.parse(message as string)

    switch (data.type) {
      case 'ping':
        ws.send(JSON.stringify({ type: 'pong' }))
        break
      case 'broadcast':
        this.broadcast(data.room, data.payload)
        break
    }
  }

  // Handle disconnection
  webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean): void {
    console.log(`Connection closed: ${code} ${reason}`)
    this.websocketTags.delete(ws)
  }

  // Handle errors
  webSocketError(ws: WebSocket, error: unknown): void {
    console.error('WebSocket error:', error)
    this.websocketTags.delete(ws)
  }
}
```

## Checking Hibernation Status

```typescript
// Via RPC - checks if last connected WebSocket is hibernatable
const isHibernatable = await stub.isWebSocketHibernatable()
// true or false
```

## Using getWebSockets()

Access WebSockets by tag within the DO:

```typescript
export class MyDO extends DOCore {
  async notifyRoom(room: string, message: unknown): Promise<number> {
    const sockets = this.ctx.getWebSockets(`room:${room}`)
    let sent = 0

    for (const ws of sockets) {
      try {
        ws.send(JSON.stringify(message))
        sent++
      } catch {
        // Socket may be closed
      }
    }

    return sent
  }
}
```

## Presence Tracking

Track active users with WebSockets:

```typescript
export class ChatRoom extends DOCore {
  private presence = new Map<string, { userId: string; joinedAt: number }>()

  webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void {
    const data = JSON.parse(message as string)

    if (data.type === 'join') {
      this.presence.set(data.userId, {
        userId: data.userId,
        joinedAt: Date.now()
      })
      this.broadcastPresence()
    }
  }

  webSocketClose(ws: WebSocket): void {
    // Remove from presence (need to track ws -> userId mapping)
    this.broadcastPresence()
  }

  private broadcastPresence(): void {
    const users = Array.from(this.presence.values())
    this.broadcast('all', { type: 'presence', users })
  }
}
```

## RPC vs Fetch for WebSockets

WebSocket establishment requires HTTP (fetch), but management uses RPC:

```typescript
// Establishing connection - must use fetch/HTTP
const response = await stub.fetch('https://do.local/ws', {
  headers: {
    Upgrade: 'websocket',
    Connection: 'Upgrade',
  },
})

// Broadcasting - use RPC
await stub.broadcast('room:lobby', { message: 'Hello!' })

// Checking status - use RPC
const tags = await stub.getWebSocketTags()
const isHibernatable = await stub.isWebSocketHibernatable()
```

## Error Handling

Handle WebSocket errors gracefully:

```typescript
webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void {
  try {
    const data = JSON.parse(message as string)
    this.handleMessage(ws, data)
  } catch (error) {
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Invalid message format'
    }))
  }
}

private handleMessage(ws: WebSocket, data: unknown): void {
  // Process message...
}
```

## Best Practices

### Use Hibernatable WebSockets for Idle Connections

```typescript
// For chat rooms, notifications, etc.
// Use /ws/hibernatable to reduce costs when users are idle
```

### Tag Connections Meaningfully

```typescript
// Good: Specific, queryable tags
const tags = [`room:${roomId}`, `user:${userId}`, 'all']

// Bad: Generic or no tags
const tags = ['connection']
```

### Clean Up on Disconnect

```typescript
webSocketClose(ws: WebSocket): void {
  this.websocketTags.delete(ws)
  this.hibernatableWebSockets.delete(ws)
  // Clean up any other per-connection state
}
```

### Handle Binary Messages

```typescript
webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void {
  if (message instanceof ArrayBuffer) {
    // Handle binary data
    const bytes = new Uint8Array(message)
    // Process bytes...
  } else {
    // Handle text/JSON
    const data = JSON.parse(message)
    // Process data...
  }
}
```

## Next Steps

- [Lifecycle Hooks](/core/lifecycle) - Wake handling for hibernatable WebSockets
- [State Management](/core/state) - Persist WebSocket-related state
- [HTTP Routing](/core/routing) - Custom WebSocket endpoints
