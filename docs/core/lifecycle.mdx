---
title: Lifecycle Hooks
description: Initialization, hibernation, wake, and alarm handlers for Durable Object lifecycle management
---

# Lifecycle Hooks

DOCore provides hooks for managing the Durable Object lifecycle, including cold starts, hibernation, waking, and scheduled alarms.

## Lifecycle Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                     Durable Object Lifecycle                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────┐    First Request    ┌─────────────┐              │
│   │  Evicted │ ─────────────────>  │  onStart()  │              │
│   └──────────┘                     └──────┬──────┘              │
│        ^                                  │                      │
│        │                                  v                      │
│        │                           ┌─────────────┐              │
│        │                           │   Active    │◄─── Requests │
│        │                           └──────┬──────┘              │
│        │                                  │                      │
│        │           Idle timeout           │                      │
│        │                                  v                      │
│        │                         ┌────────────────┐              │
│        │                         │ onHibernate()  │              │
│        │                         └───────┬────────┘              │
│        │                                 │                       │
│        │                                 v                       │
│        │    Eviction            ┌────────────────┐              │
│        └─────────────────────── │  Hibernating   │              │
│                                 └───────┬────────┘              │
│                                         │                        │
│                           Request/Alarm │                        │
│                                         v                        │
│                                 ┌────────────┐                   │
│                                 │  onWake()  │ ──> Active       │
│                                 └────────────┘                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## onStart (Cold Start)

The `onStart` hook runs once when the DO is first instantiated, before handling any requests.

### Default Behavior

DOCore tracks initialization state automatically:

```typescript
// These are set during construction
await stub.get('_lifecycle:onStart')      // true
await stub.get('_lifecycle:onStartCount') // 1 (increments on restart)
await stub.get('_initialized')            // true
```

### Customizing onStart

Override `initSync()` to add initialization logic:

```typescript
export class MyDO extends DOCore {
  private initSync(): void {
    // Call parent first
    super.initSync()

    // Initialize default state
    const hasConfig = this.ctx.storage.sql
      .exec('SELECT value FROM state WHERE key = ?', 'config')
      .toArray().length > 0

    if (!hasConfig) {
      this.ctx.storage.sql.exec(
        'INSERT INTO state (key, value) VALUES (?, ?)',
        'config',
        JSON.stringify({ theme: 'light', language: 'en' })
      )
    }
  }
}
```

<Callout type="warning">
`initSync()` runs in the constructor. It must be synchronous. For async initialization, use the first request or an alarm.
</Callout>

### Checking Ready State

The `/ready` endpoint reports initialization status:

```typescript
// Via fetch
const response = await stub.fetch('https://do.local/ready')
const data = await response.json()
// { ready: true }

// Via RPC (check internal state)
const ready = await stub.get('_initialized')
// true
```

## onHibernate (Before Eviction)

The `prepareHibernate()` method is called before the DO hibernates, allowing cleanup of temporary state.

### Default Behavior

```typescript
async prepareHibernate(): Promise<void> {
  // Mark hibernation
  await this.set('_lifecycle:onHibernate', true)

  // Clean up temp state
  const entries = await this.list({ prefix: 'temp:' })
  await this.deleteMany(Object.keys(entries))
}
```

### Customizing Hibernation

Override to add custom cleanup:

```typescript
export class MyDO extends DOCore {
  async prepareHibernate(): Promise<void> {
    await super.prepareHibernate()

    // Flush pending writes
    await this.flushWrites()

    // Close external connections
    await this.closeConnections()

    // Save session state
    await this.set('session:lastActive', Date.now())
  }

  private async flushWrites(): Promise<void> {
    // Flush any buffered writes...
  }

  private async closeConnections(): Promise<void> {
    // Close any external connections...
  }
}
```

### Triggering Hibernation

Hibernation happens automatically when the DO is idle. For testing, call explicitly:

```typescript
// Via RPC
await stub.prepareHibernate()
```

## onWake (After Hibernation)

The `wake()` method runs when the DO wakes from hibernation due to an incoming request or alarm.

### Default Behavior

```typescript
async wake(): Promise<void> {
  await this.set('_lifecycle:onWake', true)
  await this.set('_connections:restored', true)

  this.wakeCount++
  await this.set('_lifecycle:wakeCount', this.wakeCount)
}
```

### Customizing Wake

Override to restore state or connections:

```typescript
export class MyDO extends DOCore {
  private dbConnection: DatabaseClient | null = null

  async wake(): Promise<void> {
    await super.wake()

    // Restore external connections
    this.dbConnection = await createDatabaseClient()

    // Reload cached data
    await this.reloadCache()

    // Log wake event
    console.log(`DO woke up. Wake count: ${this.wakeCount}`)
  }

  private async reloadCache(): Promise<void> {
    // Reload frequently-accessed data into memory...
  }
}
```

### Wake Count

Track how many times the DO has woken:

```typescript
const wakeCount = await stub.get('_lifecycle:wakeCount')
// Number of times this DO has woken from hibernation
```

## Alarms

Alarms schedule the DO to wake at a specific time, even if no requests come in.

### setAlarm(time)

Schedule an alarm:

```typescript
// Via RPC
await stub.setAlarm(new Date(Date.now() + 60000)) // 1 minute from now

// Or with timestamp
await stub.setAlarm(Date.now() + 60000)
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `time` | `Date \| number` | Yes | When to trigger the alarm |

### getAlarm()

Check the currently scheduled alarm:

```typescript
const alarm = await stub.getAlarm()
if (alarm) {
  console.log(`Alarm scheduled for: ${alarm}`)
} else {
  console.log('No alarm scheduled')
}
```

**Returns:** `Promise<Date | null>` - The scheduled time, or `null` if no alarm

### deleteAlarm()

Cancel a scheduled alarm:

```typescript
await stub.deleteAlarm()
```

### alarm() Handler

Override to handle alarm triggers:

```typescript
export class MyDO extends DOCore {
  async alarm(): Promise<void> {
    // Default: mark alarm triggered
    await this.set('_alarm_triggered', true)

    // Custom logic
    await this.processScheduledWork()

    // Schedule next alarm if needed
    await this.setAlarm(Date.now() + 3600000) // Next hour
  }

  private async processScheduledWork(): Promise<void> {
    // Process queued items
    const queue = await this.list({ prefix: 'queue:' })
    for (const [key, item] of Object.entries(queue)) {
      await this.processItem(item)
      await this.delete(key)
    }
  }
}
```

### Alarm Patterns

```typescript
// One-time delayed task
await stub.setAlarm(Date.now() + 5000) // 5 seconds

// Recurring task (reschedule in alarm handler)
async alarm(): Promise<void> {
  await this.doPeriodicWork()
  await this.setAlarm(Date.now() + 60000) // Every minute
}

// Specific time
const tomorrow9am = new Date()
tomorrow9am.setDate(tomorrow9am.getDate() + 1)
tomorrow9am.setHours(9, 0, 0, 0)
await stub.setAlarm(tomorrow9am)
```

## Lifecycle State Keys

DOCore uses these internal keys to track lifecycle:

| Key | Type | Description |
|-----|------|-------------|
| `_lifecycle:onStart` | `boolean` | True after first init |
| `_lifecycle:onStartCount` | `number` | Times DO has started |
| `_lifecycle:onHibernate` | `boolean` | True after hibernation prep |
| `_lifecycle:onWake` | `boolean` | True after wake |
| `_lifecycle:wakeCount` | `number` | Times DO has woken |
| `_initialized` | `boolean` | True when ready |
| `_connections:restored` | `boolean` | True after wake restores connections |
| `_alarm_triggered` | `boolean` | True after alarm fires |

<Callout type="info">
Keys starting with `_` are internal. Use your own prefix (e.g., `app:`) for application state.
</Callout>

## Hibernation with WebSockets

Hibernatable WebSockets interact with lifecycle:

```typescript
export class ChatDO extends DOCore {
  async wake(): Promise<void> {
    await super.wake()

    // WebSocket connections survive hibernation
    const sockets = this.ctx.getWebSockets()
    console.log(`Woke with ${sockets.length} active connections`)

    // Notify clients of wake
    for (const ws of sockets) {
      ws.send(JSON.stringify({ type: 'server:wake' }))
    }
  }

  async prepareHibernate(): Promise<void> {
    await super.prepareHibernate()

    // Notify clients before hibernation
    const sockets = this.ctx.getWebSockets()
    for (const ws of sockets) {
      ws.send(JSON.stringify({ type: 'server:hibernate' }))
    }
  }
}
```

## Error Handling in Lifecycle

Handle errors gracefully in lifecycle hooks:

```typescript
export class MyDO extends DOCore {
  async wake(): Promise<void> {
    try {
      await super.wake()
      await this.restoreExternalConnections()
    } catch (error) {
      // Log but don't fail - DO should still be usable
      console.error('Wake error:', error)
      await this.set('_lifecycle:wakeError', error.message)
    }
  }

  async alarm(): Promise<void> {
    try {
      await this.processWork()
    } catch (error) {
      console.error('Alarm error:', error)
      // Reschedule for retry
      await this.setAlarm(Date.now() + 60000)
    }
  }
}
```

## Best Practices

### Keep initSync() Fast

```typescript
// Good: Quick initialization
private initSync(): void {
  super.initSync()
  this.cache = new Map()
}

// Bad: Slow initialization blocks all requests
private initSync(): void {
  super.initSync()
  // Don't do heavy work here - use alarm or first request
}
```

### Clean Up in prepareHibernate()

```typescript
async prepareHibernate(): Promise<void> {
  await super.prepareHibernate()

  // Flush buffers
  // Close connections
  // Save checkpoints
  // Clear caches
}
```

### Use Alarms for Scheduled Work

```typescript
// Good: Use alarms for delayed/scheduled work
await stub.setAlarm(Date.now() + 60000)

// Bad: setTimeout doesn't survive hibernation
setTimeout(() => this.doWork(), 60000)
```

## Next Steps

- [State Management](/core/state) - Persist lifecycle state
- [WebSockets](/core/websockets) - Hibernatable WebSocket connections
- [DOWorkflow](/workflow) - Advanced workflow scheduling with `$`
