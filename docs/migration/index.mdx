---
title: Migration Guide
description: Move from your current stack to dotdo. Your existing skills transfer. Gradual migration is possible.
---

# Migration Guide

You've built apps before. Express, Next.js, Supabase - you know these tools. Good news: that knowledge transfers directly to dotdo.

## The Core Idea

dotdo isn't a rewrite of everything you know. It's a new runtime for the skills you already have.

| What You Know | What It Becomes |
|---------------|-----------------|
| Express routes | Hono routes |
| Next.js API routes | Hono routes |
| PostgreSQL queries | Same queries, DO-backed |
| Supabase client | @dotdo/supabase (drop-in) |
| Environment variables | Wrangler bindings |
| npm packages | Same packages (mostly) |

## Why Migrate?

Three reasons teams move to dotdo:

### 1. Scale Without Ops

Traditional infrastructure crumbles under AI agent load. Connection pools exhaust. Memory balloons. Containers restart.

dotdo runs on Durable Objects - single-threaded JavaScript isolates with persistent storage. No connection pools. No locks. No coordination overhead. Each tenant gets their own isolated environment.

### 2. Edge by Default

Your Express app runs in one region. Your Next.js app runs in one region. Your database runs in one region.

dotdo runs in 300+ cities. Zero cold starts. Data lives where your users are.

### 3. AI-Native Architecture

Retrofit AI into Express? You're fighting the framework. dotdo was built for AI agents from day one.

```typescript
// This is natural in dotdo
const spec = priya`define the MVP for ${hypothesis}`
const app = ralph`build ${spec}`

do {
  app = ralph`improve ${app} per ${tom}`
} while (!await tom.approve(app))
```

## Migration Strategies

### Strategy 1: Gradual (Recommended)

Keep your existing app running. Add dotdo alongside it. Migrate routes one at a time.

```
┌─────────────────────────────────────────────────────┐
│                  Your Domain                         │
│                                                      │
│   ┌──────────────┐         ┌──────────────┐        │
│   │   Express    │         │    dotdo     │        │
│   │  (existing)  │         │   (new)      │        │
│   └──────────────┘         └──────────────┘        │
│          │                        │                 │
│          ▼                        ▼                 │
│   /api/v1/*              /api/v2/*                 │
│   (legacy routes)         (migrated routes)        │
└─────────────────────────────────────────────────────┘
```

This approach:
- Zero downtime
- Test in production safely
- Roll back if needed
- Move at your own pace

### Strategy 2: Full Migration

For smaller apps or new projects, migrate everything at once.

```bash
# Export your data
pg_dump my_database > backup.sql

# Create dotdo project
npx dotdo init my-app

# Import into dotdo
npx dotdo db:import backup.sql
```

### Strategy 3: Compat Layer

Use our compat SDKs to keep your existing code working with minimal changes.

```typescript
// Before
import { createClient } from '@supabase/supabase-js'

// After - one line change
import { createClient } from '@dotdo/supabase'

// Everything else stays the same
const supabase = createClient(url, key)
const { data } = await supabase.from('users').select('*')
```

## What Stays the Same

Your code patterns transfer directly:

| Pattern | Express/Next.js | dotdo |
|---------|-----------------|-------|
| Request handling | `req.body` | `c.req.json()` |
| Response sending | `res.json()` | `c.json()` |
| Middleware | `app.use()` | `app.use()` |
| Error handling | `try/catch` | `try/catch` |
| Async/await | Yes | Yes |
| TypeScript | Yes | Yes (required) |

## What Changes

The runtime model is different:

| Aspect | Traditional | dotdo |
|--------|-------------|-------|
| State | Stateless (use DB) | Stateful (DO memory) |
| Scaling | Horizontal (add servers) | Automatic (per-tenant DOs) |
| Cold starts | 100ms-2s | 0ms |
| Connections | Pool management | None needed |
| Deployment | Container/VM | Edge (wrangler deploy) |

## Common Concerns

### "Will my npm packages work?"

Most do. Pure JavaScript packages work perfectly. Packages that need:
- Native binaries - Use WebAssembly alternatives
- Filesystem - Use `fsx` (SQLite-backed)
- Child processes - Use `bashx` (sandboxed)

### "What about my database?"

Three options:

1. **Compat SDK** - Use `@dotdo/postgres`, `@dotdo/supabase`, etc. Same API, DO-backed storage.
2. **External connection** - Connect to your existing database via HTTP/TCP.
3. **Full migration** - Import data into dotdo's tiered storage.

### "How do I handle auth?"

Same as before, but easier:

```typescript
// Middleware works the same way
app.use('/api/*', async (c, next) => {
  const token = c.req.header('Authorization')
  const user = await verifyToken(token)
  c.set('user', user)
  await next()
})
```

### "What about testing?"

Your test patterns transfer:

```typescript
// Same testing approach
import { describe, it, expect } from 'vitest'

describe('User API', () => {
  it('creates a user', async () => {
    const res = await app.request('/api/users', {
      method: 'POST',
      body: JSON.stringify({ name: 'Alice' })
    })
    expect(res.status).toBe(201)
  })
})
```

## Migration Guides

<Cards>
  <Card title="From Express" href="/docs/migration/from-express">
    Express/Node.js to dotdo. Routes, middleware, and database access.
  </Card>
  <Card title="From Next.js" href="/docs/migration/from-nextjs">
    Next.js API routes and server components to dotdo.
  </Card>
  <Card title="From Supabase" href="/docs/migration/from-supabase">
    Supabase to @dotdo/supabase. Drop-in replacement.
  </Card>
</Cards>

## Getting Help

Migration questions? We're here:

- [Discord](https://discord.gg/dotdo) - Real-time help from the community
- [GitHub Discussions](https://github.com/dotdo/dotdo/discussions) - Longer-form questions
- [Migration Examples](https://github.com/dotdo/migration-examples) - Real-world migration code

---

**Your skills transfer. Your code (mostly) transfers. Only the runtime changes.**
