---
title: Presets
description: Ready-to-use worker configurations for common deployment patterns
---

# Presets

Presets provide pre-configured worker deployment patterns for common use cases. Instead of manually wiring routing, sharding, and replication, use a preset to get started quickly.

## Available Presets

| Preset | Use Case | Description |
|--------|----------|-------------|
| `single` | Simple apps | One DO per namespace (tenant) |
| `typed` | Type isolation | Separate DO per resource type |
| `sharded` | High volume | Consistent hash distribution across shards |
| `replicated` | Read heavy | Primary + read replicas |

## Creating a Preset

Use `createWorkerPreset` with your configuration:

```typescript
import { createWorkerPreset } from 'dotdo/workers'

const worker = createWorkerPreset({
  type: 'single', // or 'typed', 'sharded', 'replicated'
  config: {
    rootDomain: 'api.dotdo.dev',
  },
})

export default {
  fetch: worker.handleRequest,
}
```

## Single Preset

The simplest deployment - one DO per tenant:

```typescript
import { createWorkerPreset } from 'dotdo/workers'

const worker = createWorkerPreset({
  type: 'single',
  config: {
    rootDomain: 'api.dotdo.dev',
  },
})
```

### Routing Behavior

| Request | DO Name |
|---------|---------|
| `acme.api.dotdo.dev/customers` | `acme` |
| `acme.api.dotdo.dev/orders` | `acme` |
| `bigco.api.dotdo.dev/products` | `bigco` |

### When to Use

- Small to medium applications
- Simple multi-tenancy
- Development and prototyping
- When tenant data fits in one DO (~1GB SQLite limit)

## Typed Preset

Separate DOs for different resource types:

```typescript
import { createWorkerPreset } from 'dotdo/workers'

const worker = createWorkerPreset({
  type: 'typed',
  config: {
    rootDomain: 'api.dotdo.dev',
  },
})
```

### Routing Behavior

| Request | DO Name |
|---------|---------|
| `acme.api.dotdo.dev/customers/123` | `acme:customers` |
| `acme.api.dotdo.dev/orders/456` | `acme:orders` |
| `acme.api.dotdo.dev/products` | `acme:products` |

### When to Use

- Different access patterns per type
- Type-specific optimization needed
- Isolation between resource types
- Large datasets split by type

## Sharded Preset

Distribute data across multiple DOs using consistent hashing:

```typescript
import { createShardedWorker } from 'dotdo/workers'

const worker = createShardedWorker({
  rootDomain: 'api.dotdo.dev',
  shardCount: 16,
})

// Or using createWorkerPreset
const worker = createWorkerPreset({
  type: 'sharded',
  config: {
    rootDomain: 'api.dotdo.dev',
    shardCount: 16,
    virtualNodes: 150,
  },
})
```

### Routing Behavior

| Request | Shard Selection |
|---------|-----------------|
| `acme.api.dotdo.dev/customers/123` | `hash('acme:customers:123')` -> `shard-7` |
| `acme.api.dotdo.dev/customers/456` | `hash('acme:customers:456')` -> `shard-3` |
| `acme.api.dotdo.dev/orders/789` | `hash('acme:orders:789')` -> `shard-12` |

### Configuration Options

| Option | Default | Description |
|--------|---------|-------------|
| `shardCount` | Required | Number of shards |
| `virtualNodes` | 150 | Virtual nodes per shard for distribution |

### When to Use

- High volume applications
- Data exceeds single DO limits
- Need horizontal scaling
- Even load distribution required

## Replicated Preset

Primary DO with read replicas:

```typescript
import { createReplicatedWorker } from 'dotdo/workers'

const worker = createReplicatedWorker({
  replicaCount: 3,
})

// Or using createWorkerPreset
const worker = createWorkerPreset({
  type: 'replicated',
  config: {
    rootDomain: 'api.dotdo.dev',
    replicaCount: 3,
    readPreference: 'replica',
  },
})
```

### Routing Behavior

| Request | Target |
|---------|--------|
| `GET /customers` | Replica (round-robin) |
| `POST /customers` | Primary |
| `PUT /customers/123` | Primary |
| `GET /customers?consistency=strong` | Primary |

### Configuration Options

| Option | Default | Description |
|--------|---------|-------------|
| `replicaCount` | Required | Number of read replicas |
| `readPreference` | `replica` | Where to route reads |

### When to Use

- Read-heavy workloads
- Need read scaling
- Can tolerate eventual consistency
- High availability requirements

## Production Preset

Combine authentication, sharding, and replication:

```typescript
import { createProductionWorker } from 'dotdo/workers'

const worker = createProductionWorker({
  rootDomain: 'api.dotdo.dev',
  shardCount: 16,
  replicaCount: 3,
  authenticate: async (request) => {
    const token = request.headers.get('Authorization')
    if (!token?.startsWith('Bearer ')) {
      return false
    }
    // Validate token
    return validateToken(token.slice(7))
  },
})

export default {
  fetch: worker.handleRequest,
}
```

### Configuration Options

| Option | Description |
|--------|-------------|
| `rootDomain` | Root domain for subdomain routing |
| `shardCount` | Number of shards for distribution |
| `replicaCount` | Number of read replicas per shard |
| `authenticate` | Authentication function |

## Accessing Configuration

All presets expose their configuration:

```typescript
const worker = createShardedWorker({
  rootDomain: 'api.dotdo.dev',
  shardCount: 16,
})

const config = worker.getConfig()
// {
//   type: 'sharded',
//   rootDomain: 'api.dotdo.dev',
//   shardCount: 16
// }
```

## Custom Presets

Build on presets for custom behavior:

```typescript
import { createWorkerPreset } from 'dotdo/workers'

function createCustomWorker(options: {
  rootDomain: string
  shardCount: number
  rateLimitRps: number
}) {
  const baseWorker = createWorkerPreset({
    type: 'sharded',
    config: {
      rootDomain: options.rootDomain,
      shardCount: options.shardCount,
    },
  })

  const rateLimiter = new Map<string, number>()

  return {
    async handleRequest(request: Request, env: unknown): Promise<Response> {
      // Rate limiting
      const clientIp = request.headers.get('CF-Connecting-IP') || 'unknown'
      const count = rateLimiter.get(clientIp) || 0

      if (count >= options.rateLimitRps) {
        return new Response('Rate limited', { status: 429 })
      }

      rateLimiter.set(clientIp, count + 1)
      setTimeout(() => rateLimiter.delete(clientIp), 1000)

      // Delegate to base worker
      return baseWorker.handleRequest(request, env)
    },
    getConfig: baseWorker.getConfig,
  }
}
```

## Preset Comparison

| Feature | Single | Typed | Sharded | Replicated |
|---------|--------|-------|---------|------------|
| DO per tenant | 1 | N (by type) | N (by hash) | 1 + replicas |
| Scaling | Vertical | Type-based | Horizontal | Read |
| Complexity | Low | Low | Medium | Medium |
| Best for | Simple apps | Type isolation | Volume | Read-heavy |

## Migration Path

Start simple and scale up:

```
Single → Typed → Sharded → Sharded + Replicated
```

### Single to Typed

When you need type isolation:

```typescript
// Before
const worker = createWorkerPreset({ type: 'single', config: {} })

// After
const worker = createWorkerPreset({ type: 'typed', config: {} })
```

### Typed to Sharded

When you need horizontal scaling:

```typescript
// Before
const worker = createWorkerPreset({ type: 'typed', config: {} })

// After
const worker = createShardedWorker({ shardCount: 16 })
```

### Adding Replication

When reads become bottleneck:

```typescript
// Before
const worker = createShardedWorker({ shardCount: 16 })

// After
const worker = createProductionWorker({
  shardCount: 16,
  replicaCount: 3,
  authenticate: validateToken,
})
```

## Next Steps

- [Routing](/workers/routing) - URL patterns used by presets
- [Sharding](/workers/sharding) - How sharding works internally
- [Replication](/workers/replication) - Replica routing details
