---
title: Escalation
description: Triggers, roles, and SLAs for human escalation
---

# Escalation

Define when AI hands off to humans, who handles it, and how fast they need to respond.

## Defining Escalations

Use `HumanFunction` to create explicit escalation points in your workflow:

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000 OR audit_risk > 0.8',
  role: 'senior-accountant',
  sla: '4 hours',
})
```

## Triggers

Triggers define the conditions that cause escalation. Combine multiple conditions with `AND` and `OR`.

### Dollar Thresholds

```typescript
// Single threshold
trigger: 'refund > $10000'

// Multiple thresholds
trigger: 'amount > $5000 AND amount < $50000'

// High-value transactions
trigger: 'transaction_value > $100000'
```

### Confidence Scores

```typescript
// Low confidence escalation
trigger: 'confidence < 0.8'

// Very uncertain
trigger: 'confidence < 0.5'

// Confidence with amount
trigger: 'confidence < 0.9 AND amount > $1000'
```

### Risk Scores

```typescript
// Fraud risk
trigger: 'fraud_score > 0.7'

// Audit risk
trigger: 'audit_risk > 0.8'

// Combined risk
trigger: 'fraud_score > 0.5 OR audit_risk > 0.6'
```

### Compound Triggers

```typescript
// Complex business logic
trigger: 'refund > $10000 OR (confidence < 0.8 AND amount > $5000)'

// Multi-factor
trigger: 'customer_tier == "enterprise" AND contract_value > $50000'
```

## Roles

Roles define who handles the escalation. Map roles to actual people in your organization.

### Built-in Roles

```typescript
import { legal, ceo, cfo, cto } from 'humans.do'

// C-suite decisions
const approved = await ceo`approve ${partnership}`
const funded = await cfo`approve ${budget}`
const architected = await cto`review ${design}`

// Legal review
const reviewed = await legal`review ${contract}`
```

### Custom Roles

```typescript
import { createHumanTemplate } from 'humans.do'

const seniorAccountant = createHumanTemplate('senior-accountant')
const complianceOfficer = createHumanTemplate('compliance-officer')
const supportManager = createHumanTemplate('support-manager')

const approved = await seniorAccountant`approve ${refund}`
```

### Role Configuration

```typescript
roles: {
  'senior-accountant': {
    members: ['alice@company.com', 'bob@company.com'],
    channels: ['slack:#finance', 'email'],
    escalateTo: 'cfo',
  },
  'compliance-officer': {
    members: ['carol@company.com'],
    channels: ['email', 'sms'],
    escalateTo: 'legal',
  },
}
```

## SLAs

Service Level Agreements define response time expectations.

### Time Formats

```typescript
sla: '4 hours'     // 4 hours
sla: '30 minutes'  // 30 minutes
sla: '1 day'       // 24 hours
sla: '2 days'      // 48 hours
```

### SLA Actions

What happens when the SLA is breached:

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000',
  role: 'senior-accountant',
  sla: '4 hours',
  onSlaBreached: 'escalate', // Options: 'escalate', 'notify', 'default', 'fail'
})
```

| Action | Behavior |
|--------|----------|
| `escalate` | Escalate to the role's `escalateTo` target |
| `notify` | Alert operations but keep waiting |
| `default` | Apply a default decision |
| `fail` | Fail the workflow |

### Escalation Chains

```typescript
escalation = this.HumanFunction({
  trigger: 'contract_value > $100000',
  role: 'legal',
  sla: '24 hours',
  escalationChain: [
    { role: 'legal', sla: '24 hours' },
    { role: 'general-counsel', sla: '12 hours' },
    { role: 'ceo', sla: '4 hours' },
  ],
})
```

## Channels

How escalations are delivered to humans.

### Channel Types

```typescript
channels: ['slack', 'email', 'sms']
```

| Channel | Best For | Latency |
|---------|----------|---------|
| `slack` | Real-time collaboration | Seconds |
| `email` | Non-urgent, documented | Minutes |
| `sms` | Urgent, after-hours | Seconds |
| `pagerduty` | Critical incidents | Seconds |

### Channel Configuration

```typescript
escalation = this.HumanFunction({
  trigger: 'fraud_score > 0.9',
  role: 'fraud-analyst',
  sla: '15 minutes',
  channels: {
    slack: {
      channel: '#fraud-alerts',
      mention: '@fraud-team',
    },
    sms: {
      enabled: true,
      afterHours: true,
    },
  },
})
```

## Context

Provide humans with the information they need to decide.

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000',
  role: 'senior-accountant',
  sla: '4 hours',
  context: {
    include: ['customer', 'order', 'refund_reason', 'previous_refunds'],
    format: 'summary', // 'summary', 'detailed', 'raw'
  },
})
```

### Context Template

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000',
  role: 'senior-accountant',
  sla: '4 hours',
  message: `
    **Refund Request**: $\${amount}
    **Customer**: \${customer.name} (\${customer.tier})
    **Reason**: \${reason}
    **Order Date**: \${order.date}
    **Previous Refunds**: \${customer.refund_count} totaling $\${customer.refund_total}
  `,
})
```

## Actions

Define what actions humans can take.

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000',
  role: 'senior-accountant',
  sla: '4 hours',
  actions: [
    { id: 'approve', label: 'Approve Refund', style: 'primary' },
    { id: 'deny', label: 'Deny Refund', style: 'danger' },
    { id: 'partial', label: 'Partial Refund', style: 'secondary', requiresInput: true },
    { id: 'escalate', label: 'Escalate to CFO', style: 'secondary' },
  ],
})
```

## Full Example

```typescript
import { DO } from 'dotdo'

export class RefundProcessor extends DO {
  largeRefundApproval = this.HumanFunction({
    trigger: 'refund > $10000 OR (refund > $5000 AND customer.refund_count > 3)',
    role: 'senior-accountant',
    sla: '4 hours',
    channels: {
      slack: { channel: '#finance-approvals' },
      email: { enabled: true },
    },
    context: {
      include: ['customer', 'order', 'refund_reason', 'previous_refunds'],
    },
    actions: [
      { id: 'approve', label: 'Approve', style: 'primary' },
      { id: 'deny', label: 'Deny', style: 'danger' },
      { id: 'partial', label: 'Partial Refund', requiresInput: true },
    ],
    onSlaBreached: 'escalate',
    escalateTo: 'cfo',
  })

  async processRefund(request: RefundRequest) {
    if (request.amount > 10000 || this.shouldEscalate(request)) {
      const decision = await this.largeRefundApproval(request)

      if (decision.action === 'approve') {
        return this.executeRefund(request)
      } else if (decision.action === 'partial') {
        return this.executeRefund({ ...request, amount: decision.input })
      } else {
        return this.denyRefund(request, decision.reason)
      }
    }

    return this.executeRefund(request)
  }
}
```

## Response Handling

When a human responds to an escalation, the response flows back to your workflow.

### Response Structure

```typescript
interface ApprovalResult {
  /** Whether the request was approved */
  approved: boolean
  /** ID of the person who responded */
  approver?: string
  /** Reason provided for the decision */
  reason?: string
  /** When the response was received */
  respondedAt?: Date
  /** The original request ID */
  requestId?: string
}
```

### Handling Responses

```typescript
import { ceo } from 'humans.do'

// Destructure the response
const { approved, reason, approver } = await ceo`approve partnership with ${company}`

if (approved) {
  console.log(`Approved by ${approver}`)
  await proceedWithPartnership(company)
} else {
  console.log(`Rejected: ${reason}`)
  await notifyRejection(company, reason)
}
```

### Response Actions

When you define custom actions, handle each possibility:

```typescript
const decision = await this.escalation({
  message: `Approve refund of $${amount}?`,
  actions: [
    { id: 'approve', label: 'Approve' },
    { id: 'deny', label: 'Deny' },
    { id: 'partial', label: 'Partial Refund', requiresInput: true },
  ],
})

switch (decision.action) {
  case 'approve':
    await this.processRefund(amount)
    break
  case 'deny':
    await this.rejectRefund(decision.reason)
    break
  case 'partial':
    await this.processRefund(decision.input) // User-provided amount
    break
}
```

### Response Channels

Humans can respond via multiple channels:

| Channel | How Humans Respond |
|---------|-------------------|
| **Slack** | Click interactive buttons, submit modals |
| **Discord** | Click buttons, react with emojis |
| **Email** | Click approval links in the email |
| **SMS** | Reply with keywords (yes/no/approve/reject) |
| **MDXUI Chat** | Submit forms, click buttons in chat UI |

```typescript
// Slack: Button click payload
{
  action: 'approve',
  userId: 'U123ABC',
  requestId: 'req-456',
  channel: 'slack'
}

// SMS: Text reply "yes" or "approve"
{
  action: 'approve',
  userId: '+15559876543',
  requestId: 'req-456',
  channel: 'sms'
}

// Email: Click approval link
{
  action: 'approve',
  userId: 'alice@company.com',
  requestId: 'req-456',
  channel: 'email'
}
```

## Timeout Behavior

When humans don't respond within the SLA, the system takes action.

### Timeout Actions

Configure what happens when the SLA expires:

```typescript
escalation = this.HumanFunction({
  trigger: 'refund > $10000',
  role: 'senior-accountant',
  sla: '4 hours',
  onSlaBreached: 'escalate', // 'escalate' | 'notify' | 'default' | 'fail'
})
```

| Action | Behavior | When to Use |
|--------|----------|-------------|
| `escalate` | Automatically escalate to next role in chain | Most situations - ensures someone responds |
| `notify` | Send alert but keep waiting | When you want visibility without action |
| `default` | Apply a default decision | Low-risk decisions with safe defaults |
| `fail` | Fail the workflow with error | When human approval is mandatory |

### Timeout Error Handling

When a timeout occurs, catch the `HumanTimeoutError`:

```typescript
import { ceo, HumanTimeoutError } from 'humans.do'

try {
  const result = await ceo`approve partnership`.timeout('4 hours')
  // Human responded in time
} catch (error) {
  if (error instanceof HumanTimeoutError) {
    console.log(`Timed out after ${error.timeout}ms`)
    console.log(`Request ID: ${error.requestId}`)

    // Handle timeout - maybe escalate or apply default
    await escalateToBackup(error.requestId)
  }
  throw error
}
```

### Default Timeout Values

The system provides priority-based default timeouts:

| Priority | Default Timeout | Use Case |
|----------|-----------------|----------|
| `critical` | 1 hour | Security incidents, outages |
| `high` | 2 hours | Customer escalations |
| `normal` | 4 hours | Standard approvals |
| `low` | 24 hours | Non-urgent reviews |

### SLA Warning Notifications

Get notified before the deadline is breached:

```typescript
import { createSLAWarning, DEFAULT_SLA_CONFIG } from 'humans.do'

// Check if warning should be sent (30 min before deadline by default)
const warning = createSLAWarning(request, new Date())

if (warning?.shouldWarn && !warning.breached) {
  // Send reminder notification
  await slack.send({
    message: warning.message, // "15 minutes remaining until deadline"
    channel: '#urgent-approvals',
  })
}

if (warning?.breached) {
  // SLA already breached - escalate immediately
  await escalateToManager(request.requestId)
}
```

## Escalation Chains

Define multi-level escalation for complex approval scenarios.

### Simple Chain

```typescript
escalation = this.HumanFunction({
  trigger: 'contract_value > $100000',
  role: 'legal',
  sla: '24 hours',
  escalationChain: [
    { role: 'legal', sla: '24 hours' },
    { role: 'general-counsel', sla: '12 hours' },
    { role: 'ceo', sla: '4 hours' },
  ],
})
```

### How Chains Work

1. **Initial Request**: Sent to first role in chain (legal)
2. **SLA Breach**: If no response in 24 hours, escalate to general-counsel
3. **Second Breach**: If no response in 12 more hours, escalate to CEO
4. **Final Level**: CEO has 4 hours; after that, `onSlaBreached` action applies

### Tracking Escalation Progress

```typescript
import { calculateTimeAtEscalationLevel } from 'humans.do'

// Get time spent at each escalation level
const timeAtLevels = calculateTimeAtEscalationLevel(request)

// {
//   0: 1800000,  // 30 min at initial level
//   1: 3600000,  // 60 min at level 1 (manager)
//   2: 600000,   // 10 min at level 2 (director) - where it was resolved
// }

// Calculate total escalation time
const totalTime = Object.values(timeAtLevels).reduce((sum, t) => sum + t, 0)
```

### Manual Escalation

Humans can manually escalate instead of approving/rejecting:

```typescript
escalation = this.HumanFunction({
  actions: [
    { id: 'approve', label: 'Approve' },
    { id: 'deny', label: 'Deny' },
    { id: 'escalate', label: 'Escalate to Manager' },
  ],
})

const decision = await this.escalation(request)

if (decision.action === 'escalate') {
  // Human chose to escalate - send to next level
  await this.escalateToNextLevel(request, decision.reason)
}
```

## Escalation Policies

Configure organization-wide escalation behavior in the Human DO:

```typescript
import { Human } from 'dotdo'

export class ApprovalManager extends Human {
  async onStart() {
    await this.setEscalationPolicy({
      rules: [
        {
          afterMinutes: 60,
          escalateTo: 'team-lead@company.com',
          notifyChannels: [
            { type: 'slack', target: '#urgent', priority: 'high' }
          ],
        },
        {
          afterMinutes: 240, // 4 hours
          escalateTo: 'director@company.com',
          notifyChannels: [
            { type: 'sms', target: '+1-555-0199', priority: 'urgent' }
          ],
        },
      ],
      finalEscalation: 'ceo@company.com',
    })
  }
}
```

### Escalation Policy Options

| Option | Type | Description |
|--------|------|-------------|
| `rules` | `EscalationRule[]` | Ordered list of escalation levels |
| `rules[].afterMinutes` | `number` | Minutes after request before escalating |
| `rules[].escalateTo` | `string` | Email/ID of escalation target |
| `rules[].notifyChannels` | `NotificationChannel[]` | How to notify the target |
| `finalEscalation` | `string` | Ultimate fallback if all levels fail |

## Audit Trail

Every escalation is automatically logged for compliance.

### Audit Record Structure

```typescript
{
  id: 'apr_123abc',
  workflow: 'refund_approval',
  request: {
    requestId: 'req-456',
    role: 'senior-accountant',
    message: 'Approve refund of $15,000',
    amount: 15000,
    customerId: 'cust_789',
  },
  escalations: [
    {
      level: 0,
      role: 'senior-accountant',
      assignee: 'alice@company.com',
      requestedAt: '2024-01-15T10:00:00Z',
      slaTarget: '4 hours',
    },
    {
      level: 1,
      role: 'cfo',
      assignee: 'bob@company.com',
      requestedAt: '2024-01-15T14:00:00Z',
      respondedAt: '2024-01-15T14:30:00Z',
      decision: 'approved',
      reason: 'Customer is high-value, approved as goodwill gesture',
      slaTarget: '2 hours',
      slaMet: true,
    },
  ],
  finalDecision: 'approved',
  completedAt: '2024-01-15T14:30:00Z',
  totalDuration: 16200000, // 4.5 hours in ms
}
```

### SLA Metrics

Track SLA compliance across your organization:

```typescript
import {
  calculateTimeToFirstResponse,
  calculateTimeToCompletion,
  checkSLABreach,
} from 'humans.do'

// Time from request to first human interaction
const ttfr = calculateTimeToFirstResponse(request)
console.log(`Time to first response: ${ttfr / 60000} minutes`)

// Time from request to final decision
const ttc = calculateTimeToCompletion(request)
console.log(`Time to completion: ${ttc / 60000} minutes`)

// Check if SLA was breached
const breached = checkSLABreach(request)
if (breached) {
  await metrics.increment('sla.breached', { role: request.role })
}
```

## Technical Details

For implementation details and channel adapter documentation:

- **[lib/channels README](https://github.com/dotdo/dotdo/blob/main/lib/channels/README.md)** - Multi-channel notification adapters (Slack BlockKit, Discord, Email, MDXUI Chat), shared types, channel registry, and integration with human escalation
- **[lib README](https://github.com/dotdo/dotdo/blob/main/lib/README.md)** - Overview of all lib modules including humans/, channels/, executors/

### Channel Adapters

| Channel | Class | Features |
|---------|-------|----------|
| **Slack** | `SlackBlockKitChannel` | BlockKit blocks, interactive buttons, forms |
| **Discord** | `DiscordChannel` | Embeds, action buttons, reaction responses |
| **Email** | `EmailChannel` | HTML templates, SendGrid/Resend providers |
| **MDXUI Chat** | `MDXUIChatChannel` | Real-time, forms, MDX content, typing indicators |

### Key Implementation Files

| File | Purpose |
|------|---------|
| `lib/humans/templates.ts` | Role templates with template literal syntax |
| `lib/humans/sla.ts` | SLA tracking and metrics |
| `lib/channels/slack-blockkit.ts` | Slack BlockKit interactive messages |
| `lib/channels/discord.ts` | Discord webhooks and embeds |
| `lib/channels/email.ts` | Email via SendGrid/Resend |
| `objects/Human.ts` | Human DO with escalation policies |

## Next Steps

- [Human Roles](/docs/humans/roles) - Define and configure human roles
- [Notification Channels](/docs/humans/notification-channels) - Set up Slack, Email, SMS channels
- [Approval Workflows](/docs/humans/approval-workflows) - Build multi-level approval chains
