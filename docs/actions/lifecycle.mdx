---
title: Action Lifecycle
description: Understanding how actions are created, executed, and completed in dotdo
---

import { Callout } from 'fumadocs-ui/components/callout'

# Action Lifecycle

Actions in dotdo follow a well-defined lifecycle from creation through execution to completion. Understanding this lifecycle is essential for building reliable, durable workflows.

## Overview

Every action transitions through distinct phases:

```
Creation -> Pending -> Running -> Completed/Failed
                 |         |
                 v         v
              Paused    Retrying
```

The workflow runtime manages these state transitions automatically, with persistence at each step to ensure durability across restarts and failures.

## Action Creation

Actions are created when you invoke them through the `$` workflow context. The runtime generates a unique step ID and initializes the action state.

### Creating Actions

```typescript
import { createWorkflowRuntime, createWorkflowProxy } from 'dotdo'

// Create a runtime with storage
const runtime = createWorkflowRuntime({
  storage: durableObjectStorage,
  retryPolicy: {
    maxAttempts: 3,
    initialDelayMs: 1000,
    backoffMultiplier: 2
  }
})

// Create the $ proxy
const $ = createWorkflowProxy(runtime)

// Actions are created when invoked
await $.Customer(customer).signup()  // Creates action with unique stepId
await $.Order(order).process()       // Creates another action
```

### Step ID Generation

Each action gets a deterministic step ID based on its path and context. This enables replay and deduplication:

```typescript
// The runtime generates step IDs like:
// "Customer.signup:{"id":"cust-123","email":"alice@example.com"}"

// Same inputs = same step ID = replay from cache
await $.Customer(customer).signup()  // First call: executes
await $.Customer(customer).signup()  // Second call: replays from storage
```

### Action Metadata

When created, actions store metadata for tracking and observability:

```typescript
interface StepResult {
  stepId: string           // Unique identifier
  status: 'pending' | 'completed' | 'failed'
  result?: unknown         // Output value
  error?: string          // Error message if failed
  attempts: number        // Retry count
  createdAt: number       // Unix timestamp
  completedAt?: number    // When finished
}
```

## Execution Phases

Actions progress through execution phases based on their durability level.

### Phase 1: Pending

Action is created and queued for execution:

```typescript
// Action enters pending state
const stepResult: StepResult = {
  stepId: 'Order.process:{"orderId":"ord-123"}',
  status: 'pending',
  attempts: 0,
  createdAt: Date.now()
}
```

### Phase 2: Running

Action handler is invoked:

```typescript
// Define handlers that will run
const OrderDomain = Domain('Order', {
  process: async (order, args, $) => {
    // Handler executes during running phase
    await validateOrder(order)
    await chargePayment(order)
    await fulfillOrder(order)

    return { success: true, orderId: order.id }
  }
})
```

### Phase 3: Completion

Action finishes successfully or fails after retries:

```typescript
// Successful completion
{
  stepId: 'Order.process:{"orderId":"ord-123"}',
  status: 'completed',
  result: { success: true, orderId: 'ord-123' },
  attempts: 1,
  createdAt: 1705312200000,
  completedAt: 1705312201500
}

// Failed after retries
{
  stepId: 'Payment.charge:{"amount":100}',
  status: 'failed',
  error: 'Payment gateway timeout',
  attempts: 3,
  createdAt: 1705312200000,
  completedAt: 1705312230000
}
```

## Completion States

Actions can reach several terminal states.

### Completed

The action executed successfully:

```typescript
$.on.Order.processed(async (event) => {
  // Handler completed successfully
  console.log('Order processed:', event.data)
})

// Use completion callbacks
const runtime = createWorkflowRuntime({
  onStepComplete: (stepId, result) => {
    console.log(`Step ${stepId} completed with:`, result)
  }
})
```

### Failed

The action failed after all retry attempts:

```typescript
import { WorkflowStepError } from 'dotdo'

try {
  await $.do('Payment.charge', { amount: 100 })
} catch (error) {
  if (error instanceof WorkflowStepError) {
    console.log(`Step ${error.stepId} failed after ${error.attempts} attempts`)
    console.log('Cause:', error.cause?.message)
  }
}
```

### Paused (Workflows)

Workflow actions can pause while waiting for external events:

```typescript
class OrderWorkflow extends WorkflowRuntime {
  async execute(order: Order) {
    // Process order
    await this.step('process', async (ctx) => {
      return processOrder(ctx.input)
    })

    // Pause and wait for payment confirmation
    await this.step('awaitPayment', async (ctx) => {
      // This pauses the workflow until event arrives
      return ctx.waitForEvent('payment.confirmed', {
        timeout: '24 hours'
      })
    })

    // Continue after payment
    await this.step('fulfill', async (ctx) => {
      return fulfillOrder(ctx.previousStepOutput)
    })
  }
}
```

## Cleanup Patterns

Proper cleanup ensures resources are released and state is consistent.

### Handler Cleanup

Use try/finally for resource cleanup within handlers:

```typescript
const Database = Domain('Database', {
  transaction: async (data, args, $) => {
    const connection = await pool.acquire()
    try {
      await connection.beginTransaction()
      await connection.execute(data.query)
      await connection.commit()
      return { success: true }
    } catch (error) {
      await connection.rollback()
      throw error
    } finally {
      // Always release connection
      pool.release(connection)
    }
  }
})
```

### Context-Based Cleanup

Clean up handlers when their context is destroyed:

```typescript
import { clearHandlersByContext } from 'dotdo'

class MyDO extends DO {
  private cleanupFns: (() => void)[] = []

  async setup() {
    // Register handlers with context
    const unsubscribe1 = $.on.Customer.signup(handler, {
      context: this.ns
    })
    const unsubscribe2 = $.on.Order.placed(handler, {
      context: this.ns
    })

    this.cleanupFns.push(unsubscribe1, unsubscribe2)
  }

  async destroy() {
    // Option 1: Unsubscribe individually
    this.cleanupFns.forEach(fn => fn())

    // Option 2: Clear all handlers for this context
    const removed = clearHandlersByContext(this.ns)
    console.log(`Cleaned up ${removed} handlers`)
  }
}
```

### Storage Cleanup

Clean up old step results to manage storage:

```typescript
import { StepResultStorage } from 'dotdo'

const storage = new StepResultStorage(state)

// Clear completed steps older than 7 days
await storage.clearOlderThan('7 days')

// Clear all failed steps
await storage.clearByStatus('failed')

// Clear specific step
await storage.clear('Order.process:{"orderId":"ord-old"}')

// Get summary before cleanup
const summary = await storage.getSummary()
console.log(`Total: ${summary.total}, Completed: ${summary.completed}, Failed: ${summary.failed}`)
```

### Workflow Cleanup

Clean up workflow state after completion:

```typescript
class OrderWorkflow extends WorkflowRuntime {
  async cleanup() {
    // Cancel any pending waits
    for (const eventName of this.pendingEvents) {
      await this.waitForEventManager.cancelWait(eventName)
    }

    // Clear step results if not needed for audit
    await this.storage.delete('workflow:state')

    // Emit cleanup event
    this.emit('workflow.cleaned', {
      instanceId: this.instanceId
    })
  }
}
```

## Lifecycle Callbacks

Monitor action lifecycle with callbacks:

```typescript
const runtime = createWorkflowRuntime({
  onStepStart: (stepId, pipeline) => {
    console.log(`Starting: ${stepId}`)
    metrics.increment('actions.started')
  },

  onStepComplete: (stepId, result) => {
    console.log(`Completed: ${stepId}`)
    metrics.increment('actions.completed')
  },

  onStepError: (stepId, error, attempt) => {
    console.error(`Failed: ${stepId} (attempt ${attempt})`, error)
    metrics.increment('actions.failed')

    if (attempt >= 3) {
      alerting.send(`Action ${stepId} exhausted retries`)
    }
  }
})
```

## Best Practices

### 1. Design for Idempotency

Actions may be replayed - ensure handlers can run multiple times safely:

```typescript
const Payment = Domain('Payment', {
  charge: async (payment, args, $) => {
    // Check if already processed
    const existing = await db.payments.findByIdempotencyKey(
      payment.idempotencyKey
    )
    if (existing) {
      return existing  // Return cached result
    }

    // Process payment
    const result = await stripe.charges.create({
      amount: payment.amount,
      idempotencyKey: payment.idempotencyKey
    })

    // Store for future replay
    await db.payments.insert({ ...result, idempotencyKey })
    return result
  }
})
```

### 2. Use Appropriate Durability

Choose the right execution mode for each action:

```typescript
// Fire-and-forget for non-critical actions
$.send('Analytics.track', { event: 'pageview' })

// Single attempt for fast operations
const valid = await $.try('Schema.validate', data)

// Durable for critical business operations
const result = await $.do('Payment.process', payment)
```

### 3. Handle Partial Failures

Design workflows to handle failures at any step:

```typescript
class OrderWorkflow extends WorkflowRuntime {
  async execute(order: Order) {
    try {
      await this.step('reserve', reserveInventory)
      await this.step('charge', chargePayment)
      await this.step('fulfill', fulfillOrder)
    } catch (error) {
      // Compensate for partial completion
      await this.compensate()
      throw error
    }
  }

  async compensate() {
    // Reverse completed steps in order
    for (const result of this.stepResults.reverse()) {
      if (result.status === 'completed') {
        await this.reverseStep(result.name)
      }
    }
  }
}
```

## Related

- [Actions](/docs/actions) - Reusable action definitions and execution patterns
- [Concepts: Actions](/docs/concepts/actions) - The Noun.verb pattern
- [SDK: WorkflowContext](/docs/sdk/workflow-context) - The $ proxy for durability
- [Observability: Logging](/docs/observability/logging) - Structured logging for tracing
- [Observability: Tracing](/docs/observability/tracing) - Distributed tracing and debugging
