---
title: Functions
description: Serverless function primitives and execution patterns
---

# Functions

dotdo provides multiple function execution patterns for different use cases. Functions are created using the `createFunction()` factory or by using the executor classes directly.

## Function Types

dotdo supports four function types, each optimized for different execution patterns:

| Type | Description | Use When | Executor Class |
|------|-------------|----------|----------------|
| `code` | TypeScript/JavaScript handlers | Deterministic logic, calculations | `CodeFunctionExecutor` |
| `generative` | Single LLM completion | Text generation, classification | `GenerativeFunctionExecutor` |
| `agentic` | Multi-step AI with tools | Complex reasoning, research | `AgenticFunctionExecutor` |
| `human` | Human-in-the-loop tasks | Approvals, judgment calls | `HumanFunctionExecutor` |

See [Function Types](/docs/functions/types) for detailed documentation of each type, including when to use them, code examples, and workflow integration patterns.

## Creating Functions with createFunction()

The `createFunction()` factory creates function instances based on type:

```typescript
import { createFunction } from 'dotdo/functions'

// Code function
const calculateTotal = await createFunction({
  name: 'calculateTotal',
  type: 'code',
  handler: async (input, ctx) => {
    const { items } = input as { items: Array<{ price: number; quantity: number }> }
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0)
  }
}, { env: {} })

// Execute
const result = await calculateTotal.execute({ items: [...] })
```

### Generative Functions

```typescript
const summarize = await createFunction({
  name: 'summarize',
  type: 'generative',
  model: 'claude-sonnet-4-20250514',
  prompt: 'Summarize the following text in 2-3 sentences: {{text}}',
  temperature: 0.7,
  maxTokens: 500
}, { env: { AI: aiBinding } })
```

### Agentic Functions

```typescript
const buildFeature = await createFunction({
  name: 'buildFeature',
  type: 'agentic',
  agent: 'ralph',
  tools: ['code_search', 'file_edit', 'run_tests'],
  maxIterations: 15,
  systemPrompt: 'You are a senior software engineer...'
}, { env: { AGENT_RUNNER: agentRunner } })
```

### Human Functions

```typescript
const approveContract = await createFunction({
  name: 'approveContract',
  type: 'human',
  channel: 'slack',
  prompt: 'Please review and approve contract: {{contractId}}',
  timeout: 14400000, // 4 hours
  escalation: {
    timeout: 7200000, // 2 hours
    to: 'ceo-channel'
  }
}, { env: { NOTIFICATIONS: notificationService } })
```

## Using Executors Directly

For more control, use the executor classes directly:

```typescript
import { CodeFunctionExecutor } from 'dotdo/executors'

const executor = new CodeFunctionExecutor({
  state: ctx.state,
  env: env,
  services: { ai, kv, db, queue, fetch }
})

const result = await executor.execute(
  async (input, ctx) => {
    ctx.log.info('Processing', { input })
    return processData(input)
  },
  { data: 'example' },
  { timeout: 5000, sandboxed: true }
)
```

## Function Composition

Functions can be composed using `chain()`, `map()`, `if()`, and other combinators:

```typescript
const pipeline = validateInput
  .chain(processData)
  .chain(formatOutput)
  .catch(handleError)

const result = await pipeline.execute(input)
```

See [Function Composition](/docs/functions/composition) for details.

## Related

- [Function Types](/docs/functions/types) - Deep dive into Code, Generative, Agentic, and Human function types
- [Concepts: Functions](/docs/concepts/functions) - Function abstraction with four types and cascade patterns
- [SDK: DOFunction](/docs/sdk/functions) - Generic function type reference
- [createFunction Factory](/docs/functions/create-function) - Creating function instances with validation and composition
- [Function Executors](/docs/functions/executors) - Comprehensive guide to all executor types and the cascade pattern
- [Function Composition](/docs/functions/composition) - Pipe, parallel, conditional, retry, and fallback patterns
- [Function Middleware](/docs/functions/middleware) - Logging, metrics, auth, caching, and tracing
- [Function Registry](/docs/functions/registry) - Discovery and management of functions
- [Code Executor](/docs/functions/code-executor) - Detailed CodeFunctionExecutor documentation
- [Agents](/docs/agents) - AI agents for agentic functions
- [Humans](/docs/humans) - Human-in-the-loop functions and escalation
