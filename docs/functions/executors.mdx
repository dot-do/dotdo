---
title: Function Executors
description: Deep dive into the four function executor types - Code, Generative, Agentic, and Human
---

# Function Executors

Function executors are the runtime engines that power dotdo's four function types. Each executor provides specialized execution semantics, error handling, and lifecycle management for its function type.

## Overview

| Executor | Purpose | Use Case |
|----------|---------|----------|
| `CodeFunctionExecutor` | V8 isolate execution | Deterministic business logic |
| `GenerativeFunctionExecutor` | LLM model calls | AI-powered text generation |
| `AgenticFunctionExecutor` | Multi-step AI with tools | Autonomous task orchestration |
| `HumanFunctionExecutor` | Human-in-the-loop | Approvals, manual input |

All executors share a common base class (`BaseFunctionExecutor`) that provides:

- **Retry logic** with configurable backoff strategies
- **Event emission** for observability
- **State management** via Durable Object storage
- **Middleware pipeline** for cross-cutting concerns
- **Timeout handling** with cancellation support

## BaseFunctionExecutor

The abstract base class extracts common patterns used by all executor types.

### Common Configuration

```typescript
interface BaseExecutorOptions {
  state: DurableObjectState    // DO state for persistence
  env: Record<string, unknown> // Environment bindings
  logger?: Logger              // Optional custom logger
  onEvent?: EventHandler       // Event callback
  middleware?: ExecutionMiddleware[]  // Middleware stack
}
```

### Retry Strategies

All executors support configurable retry logic:

```typescript
interface RetryConfig {
  maxAttempts: number           // Total execution attempts
  delay: number                 // Base delay in milliseconds
  backoff?: 'fixed' | 'exponential' | 'exponential-jitter' | 'linear'
  increment?: number            // For linear backoff
  maxDelay?: number             // Cap maximum delay
  retryIf?: (error: Error) => boolean  // Custom retry predicate
  retryOnTimeout?: boolean      // Retry after timeout errors
  onRetry?: (info: RetryInfo) => void  // Retry callback
}
```

**Backoff Strategies:**

| Strategy | Formula | Use Case |
|----------|---------|----------|
| `fixed` | `delay` | Consistent wait between retries |
| `exponential` | `delay * 2^attempt` | Backing off for rate limits |
| `exponential-jitter` | `delay * 2^attempt * random(0.5, 1.5)` | Distributed systems |
| `linear` | `delay + increment * attempt` | Gradual increase |

### Middleware Pipeline

Add cross-cutting concerns to any executor:

```typescript
import { BaseFunctionExecutor } from 'dotdo/executors'

const executor = new CodeFunctionExecutor(options)

// Add middleware
executor
  .use(loggingMiddleware)
  .use(authMiddleware)
  .use(rateLimitMiddleware)

// Middleware signature
type ExecutionMiddleware = (
  ctx: MiddlewareContext,
  next: () => Promise<unknown>
) => Promise<unknown>
```

---

## CodeFunctionExecutor

Executes TypeScript/JavaScript handlers in a controlled V8 isolate environment with sandboxing, timeouts, and resource limits.

### Features

- **Context injection** - env, state, services, logging, events
- **Sandboxed execution** - restricted globals for security
- **Timeout handling** - configurable execution limits
- **Retry logic** - exponential backoff, fixed, or linear strategies
- **Streaming output** - async iterator support
- **Resource limits** - memory, CPU time, output size

### Basic Usage

```typescript
import { CodeFunctionExecutor } from 'dotdo/executors'

const executor = new CodeFunctionExecutor({
  state: ctx.state,
  env: ctx.env,
  services: {
    ai: { generate: aiGenerate },
    kv: { get: kvGet, put: kvPut },
    db: { query: dbQuery },
    queue: { send: queueSend },
    fetch: globalThis.fetch
  },
  logger: console,
  onEvent: (event, data) => console.log(event, data)
})

const result = await executor.execute(
  async (input, ctx) => {
    const { items } = input as { items: Array<{ price: number; qty: number }> }
    return items.reduce((sum, item) => sum + item.price * item.qty, 0)
  },
  { items: [{ price: 10, qty: 2 }] },
  { timeout: 5000, sandboxed: true }
)
```

### Execution Context

Every handler receives an `ExecutionContext`:

```typescript
interface ExecutionContext {
  functionId: string
  invocationId: string
  env: Record<string, string>  // Read-only environment
  state: {
    get: <T>(key: string) => Promise<T | null>
    put: <T>(key: string, value: T) => Promise<void>
    delete: (key: string) => Promise<boolean>
    list: (options?: { prefix?: string }) => Promise<Map<string, unknown>>
  }
  services: {
    ai: { generate: (opts) => Promise<{ text: string }> }
    kv: { get, put }
    db: { query }
    queue: { send }
    fetch: (url, init?) => Promise<Response>
  }
  log: { debug, info, warn, error }
  emit: (event: string, data: unknown) => Promise<void>
  signal: AbortSignal
}
```

### Execution Options

```typescript
interface ExecutionOptions {
  functionId?: string           // Custom function ID
  timeout?: number              // Execution timeout (default: 30000ms)
  sandboxed?: boolean           // Enable sandbox (default: true)
  exposeEnv?: string[]          // Whitelist env vars in sandbox
  retry?: RetryConfig           // Retry configuration
  signal?: AbortSignal          // Cancellation signal
  streaming?: boolean           // Enable streaming output
  resourceLimits?: {
    maxMemory?: number          // Memory limit (default: 128MB)
    maxCpuTime?: number         // CPU time limit in ms
    maxOutputSize?: number      // Output size limit (default: 10MB)
  }
  inputSchema?: JSONSchema      // Validate input
  outputSchema?: JSONSchema     // Validate output
}
```

### Sandbox Security

The sandbox restricts access to dangerous globals:

**Restricted (blocked):**
- `require`, `process`, `global`, `globalThis`
- `eval`, `Function` (dynamic code execution)
- Prototype modification (`__proto__`, `Object.prototype`)

**Allowed:**
- Standard JavaScript: `JSON`, `Math`, `Date`, `Array`, `Object`, etc.
- Async primitives: `Promise`, `setTimeout`, `queueMicrotask`
- Web APIs: `URL`, `fetch`, `Response`, `Request`, `Headers`
- Typed arrays: `Uint8Array`, `ArrayBuffer`, `TextEncoder`
- Crypto: `crypto`

### Streaming Execution

For long-running operations:

```typescript
const stream = await executor.executeStreaming(
  async function* (input, ctx) {
    for (const item of input.items) {
      const processed = await processItem(item)
      yield { type: 'chunk', data: processed }
    }
  },
  { items: [...] }
)

for await (const chunk of stream) {
  if (chunk.type === 'chunk') {
    console.log('Received:', chunk.data)
  }
  if (chunk.type === 'result') {
    console.log('Final:', chunk.value)
  }
}

// Get final result
const result = stream.result
```

### Error Types

```typescript
import {
  ExecutionTimeoutError,
  ExecutionSandboxError,
  ExecutionResourceError,
  ExecutionRetryExhaustedError,
  ExecutionCancelledError,
  ExecutionValidationError
} from 'dotdo/executors/CodeFunctionExecutor'
```

| Error | When Thrown |
|-------|-------------|
| `ExecutionTimeoutError` | Function exceeded timeout |
| `ExecutionSandboxError` | Accessed restricted globals |
| `ExecutionResourceError` | Memory, CPU, or output limit exceeded |
| `ExecutionRetryExhaustedError` | All retry attempts failed |
| `ExecutionCancelledError` | AbortSignal triggered |
| `ExecutionValidationError` | Input/output schema validation failed |

---

## GenerativeFunctionExecutor

Calls LLM models (Claude, GPT, etc.) with prompt templates, structured output, and streaming support.

### Features

- **Multi-model support** - Claude, GPT, and other providers
- **Prompt templates** - Variable substitution with `{{variable}}`
- **Structured output** - JSON Schema validation
- **Streaming** - Real-time token streaming
- **Tool calling** - Model-driven tool execution
- **Conversation history** - Persistent context across calls
- **Rate limit handling** - Automatic retry with backoff

### Basic Usage

```typescript
import { GenerativeFunctionExecutor } from 'dotdo/executors'

const executor = new GenerativeFunctionExecutor({
  state: ctx.state,
  env: ctx.env,
  aiService: {
    generate: aiGenerate,
    stream: aiStream,
    generateWithTools: aiGenerateWithTools
  },
  onEvent: (event, data) => console.log(event, data)
})

const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Summarize this article: {{text}}',
  variables: { text: 'Long article content...' },
  temperature: 0.7,
  maxTokens: 500
})
```

### Execution Options

```typescript
interface GenerativeOptions {
  model: string                 // Required: model identifier
  prompt?: string | ((input) => string)  // Prompt template or function
  messages?: Message[]          // Chat messages (alternative to prompt)
  systemPrompt?: string         // System message
  variables?: Record<string, unknown>    // Template variables

  // Model parameters
  temperature?: number          // 0-2, default: 1
  maxTokens?: number            // Max output tokens
  topP?: number                 // 0-1, nucleus sampling
  topK?: number                 // Top-k sampling
  stopSequences?: string[]      // Stop generation sequences
  presencePenalty?: number      // -2 to 2
  frequencyPenalty?: number     // -2 to 2

  // Structured output
  schema?: JSONSchema           // Output schema validation
  coerceTypes?: boolean         // Coerce string "true" -> boolean true
  lenientParsing?: boolean      // Handle trailing commas, etc.
  schemaRetries?: number        // Retry on schema failure

  // Tool calling
  tools?: ToolDefinition[]      // Available tools
  parallelToolCalls?: boolean   // Execute tools in parallel
  maxToolIterations?: number    // Max tool call rounds (default: 10)

  // Reliability
  timeout?: number              // Request timeout
  maxRetries?: number           // Retry attempts
  retryDelay?: number           // Base retry delay
  retryBackoff?: 'linear' | 'exponential'
  retryOnRateLimit?: boolean    // Retry on 429 errors
  retryOnTimeout?: boolean      // Retry on timeouts

  // Conversation
  conversationId?: string       // Persist conversation
  loadHistory?: boolean         // Load previous messages
  saveHistory?: boolean         // Save to conversation history
}
```

### Prompt Templates

Variable substitution with `{{variable}}` syntax:

```typescript
const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: `Translate the following from {{sourceLang}} to {{targetLang}}:

{{text}}`,
  variables: {
    sourceLang: 'English',
    targetLang: 'Spanish',
    text: 'Hello, world!'
  }
})
```

**Nested access:**
```typescript
prompt: 'User {{user.name}} from {{user.address.city}}'
variables: {
  user: {
    name: 'Alice',
    address: { city: 'New York' }
  }
}
```

### Structured Output

Validate and parse JSON responses:

```typescript
const result = await executor.execute<{
  sentiment: 'positive' | 'negative' | 'neutral'
  confidence: number
  keywords: string[]
}>({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Analyze sentiment: {{text}}',
  variables: { text: 'Great product!' },
  schema: {
    type: 'object',
    properties: {
      sentiment: { type: 'string', enum: ['positive', 'negative', 'neutral'] },
      confidence: { type: 'number' },
      keywords: { type: 'array', items: { type: 'string' } }
    },
    required: ['sentiment', 'confidence', 'keywords']
  },
  schemaRetries: 2  // Retry with feedback if validation fails
})

// result.result.sentiment === 'positive'
```

### Streaming

Real-time token streaming:

```typescript
const stream = await executor.executeStreaming({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Write a story about {{topic}}',
  variables: { topic: 'a robot' }
})

for await (const chunk of stream) {
  if (chunk.type === 'text') {
    process.stdout.write(chunk.text)
  }
  if (chunk.type === 'done') {
    console.log('\nTokens used:', chunk.usage)
  }
}

// Convert to full text or JSON
const text = await stream.toText()
const json = await stream.toJSON<StoryOutput>()
```

### Tool Calling

Enable model-driven tool execution:

```typescript
const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: 'What is the weather in {{city}}?',
  variables: { city: 'Tokyo' },
  tools: [
    {
      name: 'get_weather',
      description: 'Get current weather for a city',
      inputSchema: {
        type: 'object',
        properties: {
          city: { type: 'string' }
        },
        required: ['city']
      },
      execute: async ({ city }) => {
        const response = await fetch(`https://api.weather.com/v1/${city}`)
        return response.json()
      }
    }
  ],
  parallelToolCalls: true,
  maxToolIterations: 5
})
```

### Error Types

```typescript
import {
  GenerativeModelError,
  GenerativeValidationError,
  GenerativeRateLimitError,
  GenerativeTimeoutError,
  GenerativeAbortError,
  GenerativeSchemaError,
  GenerativeToolError
} from 'dotdo/executors/GenerativeFunctionExecutor'
```

---

## AgenticFunctionExecutor

Orchestrates multi-step AI tasks with tool access, iteration control, and loop detection.

### Features

- **Agent loop** - Think -> Act -> Observe cycle
- **Tool orchestration** - Discovery, validation, and execution
- **Iteration limits** - Prevent runaway agents
- **Loop detection** - Detect stuck or cycling agents
- **Step callbacks** - Observe each agent step
- **Parallel tool calls** - Execute independent tools concurrently
- **State management** - Persistent memory across steps

### Basic Usage

```typescript
import { AgenticFunctionExecutor } from 'dotdo/executors'

const executor = new AgenticFunctionExecutor({
  state: ctx.state,
  env: ctx.env,
  ai: {
    complete: async (params) => {
      // Call your AI provider
      return { text: '...', toolCalls: [], stopReason: 'end_turn' }
    }
  },
  tools: {
    search_code: {
      name: 'search_code',
      description: 'Search for code patterns in the codebase',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query' }
        },
        required: ['query']
      },
      execute: async ({ query }, ctx) => {
        return searchCodebase(query)
      }
    },
    edit_file: {
      name: 'edit_file',
      description: 'Edit a file in the codebase',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string' },
          content: { type: 'string' }
        },
        required: ['path', 'content']
      },
      execute: async ({ path, content }, ctx) => {
        return editFile(path, content)
      }
    }
  },
  onEvent: (event, data) => console.log(event, data)
})
```

### Execution Options

```typescript
interface ExecutionOptions {
  goal: string                  // What the agent should accomplish
  model: string                 // Model to use for reasoning
  input?: unknown               // Additional input data
  systemPrompt?: string         // Custom system prompt
  tools?: string[]              // Which tools to enable
  maxIterations?: number        // Iteration limit (default: 10)
  authorizedTools?: string[]    // Pre-authorized tools
  integrations?: Record<string, Integration>  // External integrations

  // Callbacks
  onStep?: (step: AgentStep) => void | Promise<void>
  onToolCall?: (call: ToolCall, ctx: AgentContext) => ToolCall | null | Promise<...>
  onToolResult?: (result: ToolResult) => void | Promise<void>
  onComplete?: (result: AgentResult) => void | Promise<void>

  // Reliability
  signal?: AbortSignal          // Cancellation
  detectLoops?: boolean         // Enable loop detection
  loopThreshold?: number        // Repeated calls before error (default: 3)
  parallelToolCalls?: boolean   // Execute tools in parallel
  maxConcurrency?: number       // Parallel tool limit
  aiRetry?: RetryConfig         // AI call retry config

  // Context
  maxContextTokens?: number     // Limit context window
  conversationHistory?: Message[]  // Pre-seed conversation
  outputSchema?: JSONSchema     // Structured final output
}
```

### Agent Steps

Each iteration produces an `AgentStep`:

```typescript
interface AgentStep {
  iteration: number
  type: 'thinking' | 'tool_call' | 'tool_result' | 'final_answer'
  thought?: string              // Agent's reasoning
  toolCalls?: ToolCall[]        // Tools being called
  toolResults?: ToolResult[]    // Results from tool execution
  answer?: string               // Final answer (if complete)
  timestamp: Date
  duration?: number
}
```

### Tool Definition

```typescript
interface ToolDefinition {
  name: string
  description: string
  parameters: {
    type: string
    properties?: Record<string, PropertySchema>
    required?: string[]
  }
  execute: (params: Record<string, unknown>, ctx: AgentContext) => Promise<unknown>
  requiresAuthorization?: boolean  // Needs explicit authorization
  retryConfig?: {
    maxRetries: number
    delay: number
  }
}
```

### Agent Context

Tools receive an `AgentContext`:

```typescript
interface AgentContext {
  agentId: string
  invocationId: string
  currentIteration: number
  maxIterations: number
  state: {
    get: <T>(key: string) => Promise<T | null>
    set: <T>(key: string, value: T) => Promise<void>
    delete: (key: string) => Promise<boolean>
    getAll: () => Promise<Record<string, unknown>>
  }
  ai: AIService
  log: Logger
  emit: (event: string, data: unknown) => Promise<void>
  signal: AbortSignal
  integration?: { provider: string; credentials?: Record<string, unknown> }
}
```

### Example: Code Review Agent

```typescript
const result = await executor.execute({
  goal: 'Review the pull request and provide feedback',
  model: 'claude-sonnet-4-20250514',
  input: { prNumber: 42 },
  systemPrompt: `You are a senior code reviewer.
Check for:
- Code style and best practices
- Potential bugs or security issues
- Test coverage`,
  tools: ['get_pr_diff', 'get_file', 'list_files', 'add_comment'],
  maxIterations: 20,
  onStep: (step) => {
    if (step.type === 'thinking') {
      console.log('Agent thinking:', step.thought)
    }
    if (step.type === 'tool_call') {
      console.log('Calling tools:', step.toolCalls?.map(t => t.name))
    }
  },
  detectLoops: true,
  loopThreshold: 3
})

console.log('Review complete:', result.result)
console.log('Iterations:', result.iterations)
console.log('Tool calls:', result.toolCallCount)
```

### Loop Detection

Prevent agents from repeating the same actions:

```typescript
const result = await executor.execute({
  goal: 'Find and fix the bug',
  model: 'claude-sonnet-4-20250514',
  tools: ['search_code', 'run_tests', 'edit_file'],
  detectLoops: true,
  loopThreshold: 3  // Error after 3 identical tool calls
})

if (result.error instanceof AgentConvergenceError) {
  console.log('Agent got stuck in a loop')
}
```

### Error Types

```typescript
import {
  AgentMaxIterationsError,
  AgentToolExecutionError,
  AgentConvergenceError,
  AgentToolNotFoundError,
  AgentToolAuthorizationError,
  AgentCancelledError
} from 'dotdo/executors/AgenticFunctionExecutor'
```

---

## HumanFunctionExecutor

Queues tasks for human input with multi-channel delivery, escalation, and approval workflows.

### Features

- **Multi-channel** - Slack, email, in-app notifications
- **Escalation chains** - Automatic timeout escalation
- **Approval workflows** - Sequential, parallel, or conditional
- **Form validation** - Structured response collection
- **Reminders** - Send reminders before timeout
- **Audit logging** - Track all decisions

### Basic Usage

```typescript
import { HumanFunctionExecutor } from 'dotdo/executors'

const executor = new HumanFunctionExecutor({
  state: ctx.state,
  env: ctx.env,
  channels: {
    slack: {
      name: 'slack',
      type: 'slack',
      send: async (payload) => slackBot.postMessage(payload),
      waitForResponse: async ({ timeout }) => slackBot.waitForAction(timeout),
      updateMessage: async (id, payload) => slackBot.updateMessage(id, payload)
    },
    email: {
      name: 'email',
      type: 'email',
      send: async (payload) => sendEmail(payload),
      waitForResponse: async ({ timeout }) => pollEmailResponses(timeout)
    }
  },
  notificationService: {
    send: sendNotification,
    waitForResponse: waitForResponse,
    getDeliveryStatus: getStatus,
    cancelPending: cancelPending
  },
  onEvent: (event, data) => console.log(event, data)
})
```

### Task Definition

```typescript
interface TaskDefinition {
  prompt: string | ((input) => string)  // Message to send
  channel: string | string[]    // Delivery channel(s)
  timeout: number               // Response deadline (ms)
  input?: unknown               // Template variables
  actions?: ActionDefinition[]  // Quick action buttons
  form?: FormDefinition         // Structured form

  // Channel options
  channelOptions?: Record<string, ChannelOptions>
  updateOnResponse?: boolean    // Update message after response

  // Timeouts
  defaultOnTimeout?: { action: string; reason: string }
  escalation?: EscalationConfig
  reminder?: { before: number; message: string }

  // Approval workflows
  approval?: ApprovalWorkflow

  // Reliability
  delivery?: {
    maxRetries: number
    retryDelay: number
    backoff?: 'fixed' | 'exponential'
  }
  fallbackChannel?: string
  confirmDelivery?: boolean

  // Validation
  responseSchema?: JSONSchema
  validateResponse?: (response) => boolean | string
  transformResponse?: (response) => HumanResponse
  applyDefaults?: boolean

  // Cancellation
  signal?: AbortSignal

  // Callbacks
  onSend?: (payload) => NotificationPayload | void
  onResponse?: (response) => HumanResponse | void
}
```

### Example: Approval Request

```typescript
const result = await executor.execute({
  prompt: (input) => {
    const { customerId, amount, reason } = input
    return `**Refund Request**
Customer: ${customerId}
Amount: $${amount.toFixed(2)}
Reason: ${reason}

Please approve or reject.`
  },
  channel: 'slack',
  timeout: 4 * 60 * 60 * 1000,  // 4 hours
  input: {
    customerId: 'CUST-456',
    amount: 150.00,
    reason: 'Product defect'
  },
  actions: [
    { value: 'approve', label: 'Approve', style: 'primary' },
    { value: 'reject', label: 'Reject', style: 'danger' }
  ],
  form: {
    fields: [
      {
        name: 'notes',
        type: 'text',
        label: 'Notes',
        required: false
      }
    ]
  },
  escalation: {
    timeout: 2 * 60 * 60 * 1000,  // Escalate after 2 hours
    to: 'ceo-channel'
  },
  reminder: {
    before: 30 * 60 * 1000,  // 30 min before timeout
    message: 'Reminder: Refund request still pending'
  }
})

if (result.success) {
  console.log(`${result.response.action} by ${result.respondedBy}`)
  console.log('Notes:', result.response.data.notes)
}
```

### Multi-Channel Delivery

Send to multiple channels, first response wins:

```typescript
const result = await executor.execute({
  prompt: 'Urgent: Server down. Acknowledge?',
  channel: ['slack', 'email', 'in-app'],
  timeout: 15 * 60 * 1000,  // 15 minutes
  channelOptions: {
    slack: { slackChannel: '#oncall' },
    email: { to: 'oncall@company.com', subject: 'URGENT: Server Down' },
    'in-app': { userId: 'user-123', priority: 'critical', pushNotification: true }
  }
})

console.log(`Responded via ${result.channel}`)
```

### Approval Workflows

**Sequential Approval:**
```typescript
const result = await executor.execute({
  prompt: 'Approve large purchase: $50,000',
  channel: 'slack',
  timeout: 24 * 60 * 60 * 1000,
  approval: {
    type: 'sequential',
    levels: [
      { name: 'manager', users: ['@alice'] },
      { name: 'director', users: ['@bob'] },
      { name: 'cfo', users: ['@carol'] }
    ]
  }
})

// result.response.approvals = [
//   { userId: 'alice', action: 'approve', timestamp: ... },
//   { userId: 'bob', action: 'approve', timestamp: ... },
//   { userId: 'carol', action: 'approve', timestamp: ... }
// ]
```

**Parallel Approval (quorum):**
```typescript
const result = await executor.execute({
  prompt: 'Vote on proposal',
  channel: 'slack',
  timeout: 48 * 60 * 60 * 1000,
  approval: {
    type: 'parallel',
    users: ['@alice', '@bob', '@carol', '@dave', '@eve'],
    requiredApprovals: 3,  // Need 3 of 5
    failFast: true         // Stop early if impossible
  }
})

console.log('Approval count:', result.response.approvalCount)
console.log('Rejection count:', result.response.rejectionCount)
```

**Conditional Approval:**
```typescript
const result = await executor.execute({
  prompt: 'Approve expense: ${{amount}}',
  channel: 'slack',
  timeout: 8 * 60 * 60 * 1000,
  input: { amount: 5000 },
  approval: {
    type: 'conditional',
    conditions: [
      {
        when: (input) => input.amount < 1000,
        users: ['@manager']
      },
      {
        when: (input) => input.amount < 10000,
        users: ['@director'],
        sequential: true
      },
      {
        when: (input) => input.amount >= 10000,
        users: ['@director', '@cfo'],
        sequential: true
      }
    ]
  }
})
```

### Form Validation

```typescript
const result = await executor.execute({
  prompt: 'Complete the order review',
  channel: 'slack',
  timeout: 60 * 60 * 1000,
  form: {
    fields: [
      {
        name: 'status',
        type: 'select',
        label: 'Status',
        required: true,
        options: ['approve', 'reject', 'need-more-info']
      },
      {
        name: 'quantity',
        type: 'number',
        label: 'Approved Quantity',
        required: false,
        validation: (value) => value >= 0 || 'Must be non-negative'
      },
      {
        name: 'notes',
        type: 'text',
        label: 'Notes',
        required: false,
        default: ''
      },
      {
        name: 'categories',
        type: 'multiselect',
        label: 'Categories',
        options: ['electronics', 'clothing', 'food', 'other']
      }
    ]
  },
  applyDefaults: true
})
```

### Error Types

```typescript
import {
  HumanTimeoutError,
  HumanChannelError,
  HumanValidationError,
  HumanEscalationError,
  HumanApprovalRejectedError,
  HumanCancelledError,
  HumanNotificationFailedError
} from 'dotdo/executors/HumanFunctionExecutor'
```

---

## Choosing the Right Executor

| Scenario | Executor | Why |
|----------|----------|-----|
| Calculate totals, validate data | Code | Fast, deterministic |
| Generate text, summarize | Generative | Single LLM call |
| Research task, multi-step problem | Agentic | Tool-using agent loop |
| Need human approval | Human | Notification + wait |
| AI with fallback to human | Agentic + Human | Cascade pattern |

### Cascade Pattern

Combine executors for complex workflows:

```typescript
const codeResult = await codeExecutor.execute(validateInput, input)
if (!codeResult.success) return codeResult

const aiResult = await agenticExecutor.execute({
  goal: 'Analyze and recommend action',
  input: codeResult.result
})

if (aiResult.result.confidence < 0.8) {
  // Escalate to human
  const humanResult = await humanExecutor.execute({
    prompt: `AI recommendation (${aiResult.result.confidence} confidence):
${aiResult.result.recommendation}

Please verify and approve.`,
    channel: 'slack',
    timeout: 60 * 60 * 1000
  })
  return humanResult
}

return aiResult
```

## Related

- [createFunction Factory](/docs/functions/create-function) - High-level function creation
- [Function Composition](/docs/functions/composition) - Chain and combine functions
- [Function Middleware](/docs/functions/middleware) - Cross-cutting concerns
- [Agents](/docs/agents) - Named agents (Priya, Ralph, etc.)
- [Humans](/docs/humans) - Human escalation patterns
