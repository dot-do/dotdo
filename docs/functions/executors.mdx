---
title: Function Executors
description: Unified execution patterns for code, AI, and human-in-the-loop functions
---

# Function Executors

Function Executors are the core execution engine for dotdo's function system. They provide a unified interface for running functions across four distinct execution strategies, each optimized for different use cases.

## The Executor Pattern

The executor pattern in dotdo follows a consistent architecture:

1. **Unified Interface**: All executors share common patterns for initialization, execution, and result handling
2. **Durable Object Integration**: Executors operate within Durable Object contexts for state persistence
3. **Retry and Timeout**: Built-in retry logic with configurable backoff strategies
4. **Event Emission**: Lifecycle events for observability and debugging
5. **Metrics Collection**: Duration, resource usage, and execution statistics

```typescript
// All executors follow this pattern
const result = await executor.execute(input, options)

if (result.success) {
  console.log('Result:', result.result)
  console.log('Duration:', result.duration, 'ms')
  console.log('Metrics:', result.metrics)
} else {
  console.error('Error:', result.error)
}
```

## Executor Types

| Executor | Best For | Speed | Cost | Use When |
|----------|----------|-------|------|----------|
| `CodeFunctionExecutor` | Deterministic logic | Fastest | Lowest | You have explicit rules or transformations |
| `GenerativeFunctionExecutor` | Content generation | Fast | Medium | You need AI for single completions |
| `AgenticFunctionExecutor` | Complex reasoning | Medium | Higher | You need AI with tools in a loop |
| `HumanFunctionExecutor` | Judgment calls | Slowest | Highest | You need human review or approval |
| `CascadeExecutor` | Automatic escalation | Varies | Optimized | You want fallback between types |
| `ParallelStepExecutor` | Concurrent steps | Fast | Varies | You have independent parallel work |

## CodeFunctionExecutor

Executes TypeScript/JavaScript handlers in a controlled, optionally sandboxed environment.

### Features

- Sandboxed execution with restricted globals
- Timeout and cancellation via AbortSignal
- Retry logic with four backoff strategies
- Resource limits (memory, CPU, output size)
- Input/output schema validation
- Streaming output support

### Basic Usage

```typescript
import { CodeFunctionExecutor } from 'lib/executors/CodeFunctionExecutor'

const executor = new CodeFunctionExecutor({
  state: this.state,           // Durable Object state
  env: this.env,               // Environment bindings
  services: {
    ai: this.ai,               // AI service
    kv: this.kv,               // KV storage
    db: this.db,               // Database
    queue: this.queue,         // Queue
    fetch: fetch,              // Fetch API
  },
  logger: console,
  onEvent: (event, data) => {
    console.log(`[${event}]`, data)
  },
})

const result = await executor.execute(
  async (input, ctx) => {
    ctx.log.info('Processing order', { orderId: input.orderId })

    // Access services through context
    const order = await ctx.services.db.query(
      'SELECT * FROM orders WHERE id = ?',
      [input.orderId]
    )

    // Persist state
    await ctx.state.put(`order:${input.orderId}:processed`, true)

    return { order: order[0], processed: true }
  },
  { orderId: 'ORD-123' },
  {
    timeout: 5000,
    sandboxed: true,
    retry: {
      maxAttempts: 3,
      delay: 100,
      backoff: 'exponential',
    },
  }
)
```

### Execution Context

Handlers receive a rich execution context:

```typescript
interface ExecutionContext {
  functionId: string          // Function identifier
  invocationId: string        // Unique invocation ID
  env: Record<string, string> // Read-only environment variables
  state: {
    get: <T>(key: string) => Promise<T | null>
    put: <T>(key: string, value: T) => Promise<void>
    delete: (key: string) => Promise<boolean>
    list: (options?: { prefix?: string }) => Promise<Map<string, unknown>>
  }
  services: {
    ai: { generate: (opts) => Promise<{ text: string }> }
    kv: { get, put }
    db: { query }
    queue: { send }
    fetch: typeof fetch
  }
  log: { debug, info, warn, error }
  emit: (event: string, data: unknown) => Promise<void>
  signal: AbortSignal         // Cancellation signal
}
```

### Streaming Execution

```typescript
const stream = await executor.executeStreaming(
  async (input, ctx) => {
    for (const item of input.items) {
      // Emit progress chunks
      await ctx.emit('stream.chunk', { data: `Processing ${item.name}` })
    }
    return { total: input.items.length }
  },
  { items: products }
)

for await (const chunk of stream) {
  if (chunk.type === 'chunk') {
    console.log('Progress:', chunk.data)
  } else if (chunk.type === 'result') {
    console.log('Final result:', chunk.value)
  }
}
```

### Retry Strategies

Four backoff strategies are available:

```typescript
// Fixed delay between retries
{ backoff: 'fixed', delay: 100 }           // 100ms, 100ms, 100ms

// Exponential backoff (doubles each retry)
{ backoff: 'exponential', delay: 100 }     // 100ms, 200ms, 400ms

// Exponential with random jitter (prevents thundering herd)
{ backoff: 'exponential-jitter', delay: 100 }  // ~100ms, ~200ms, ~400ms

// Linear increase
{ backoff: 'linear', delay: 100, increment: 50 }  // 100ms, 150ms, 200ms
```

Full retry configuration:

```typescript
const result = await executor.execute(handler, input, {
  retry: {
    maxAttempts: 5,
    delay: 100,
    backoff: 'exponential-jitter',
    maxDelay: 10000,           // Cap at 10 seconds
    retryOnTimeout: false,     // Don't retry timeouts
    retryIf: (error) => {      // Custom retry condition
      return error.message.includes('transient')
    },
    onRetry: ({ attempt, delay, error }) => {
      console.log(`Retry ${attempt} after ${delay}ms: ${error.message}`)
    },
  },
})
```

### Sandbox Security

When `sandboxed: true`, the executor restricts access to dangerous globals:

```typescript
// These are blocked in sandboxed mode:
// - require, process, global, globalThis
// - eval, Function
// - __proto__, Object.prototype modifications

// These are allowed:
// - JSON, Math, Date, Array, Object, String, Number
// - Promise, Set, Map, Symbol, Proxy, Reflect
// - Error classes, RegExp, typed arrays
// - URL, URLSearchParams, fetch, Response, Request
// - crypto, TextEncoder, TextDecoder
// - setTimeout, clearTimeout, setInterval, clearInterval
```

## GenerativeFunctionExecutor

Executes AI-powered generation with language models.

### Features

- Prompt template substitution with `{{variables}}`
- Structured output with JSON schema validation
- Streaming support
- Tool execution
- Conversation history management
- Retry logic for rate limits

### Basic Usage

```typescript
import { GenerativeFunctionExecutor } from 'lib/executors/GenerativeFunctionExecutor'

const executor = new GenerativeFunctionExecutor({
  state: this.state,
  env: this.env,
  aiService: this.ai,
  onEvent: (event, data) => console.log(event, data),
})

const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Summarize this article in 3 bullet points: {{text}}',
  variables: { text: articleContent },
  temperature: 0.7,
  maxTokens: 500,
})
```

### Structured Output

```typescript
const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Extract entities from: {{text}}',
  variables: { text: 'John works at Acme Corp in New York' },
  schema: {
    type: 'object',
    properties: {
      people: { type: 'array', items: { type: 'string' } },
      organizations: { type: 'array', items: { type: 'string' } },
      locations: { type: 'array', items: { type: 'string' } },
    },
    required: ['people', 'organizations', 'locations'],
  },
  schemaRetries: 2,      // Retry with feedback if schema validation fails
  coerceTypes: true,     // Coerce string "123" to number 123
  lenientParsing: true,  // Handle trailing commas, markdown code blocks
})

// result = {
//   people: ['John'],
//   organizations: ['Acme Corp'],
//   locations: ['New York']
// }
```

### Streaming

```typescript
const stream = await executor.executeStreaming({
  model: 'claude-sonnet-4-20250514',
  prompt: 'Write a story about {{topic}}',
  variables: { topic: 'space exploration' },
})

for await (const chunk of stream) {
  if (chunk.type === 'text') {
    process.stdout.write(chunk.text)
  } else if (chunk.type === 'done') {
    console.log('\n\nTokens used:', chunk.usage)
  }
}
```

### Tool Execution

```typescript
const result = await executor.execute({
  model: 'claude-sonnet-4-20250514',
  prompt: 'What is the weather in {{city}}?',
  variables: { city: 'San Francisco' },
  tools: [
    {
      name: 'get_weather',
      description: 'Get current weather for a city',
      inputSchema: {
        type: 'object',
        properties: {
          city: { type: 'string' },
        },
        required: ['city'],
      },
      execute: async (input) => {
        return { temperature: 65, conditions: 'sunny' }
      },
    },
  ],
  maxToolIterations: 5,
  parallelToolCalls: true,
})
```

## AgenticFunctionExecutor

Orchestrates multi-step AI agents with tool access and iteration limits.

### Features

- Agent runner with tool loop
- Tool discovery and execution
- Iteration limits and convergence detection
- Step callbacks for observability
- Parallel tool execution
- Memory/conversation history

### Basic Usage

```typescript
import { AgenticFunctionExecutor } from 'lib/executors/AgenticFunctionExecutor'

const executor = new AgenticFunctionExecutor({
  state: this.state,
  env: this.env,
  ai: this.ai,
  tools: {
    web_search: {
      name: 'web_search',
      description: 'Search the web',
      parameters: { type: 'object', properties: { query: { type: 'string' } } },
      execute: async (params) => searchWeb(params.query),
    },
    file_read: {
      name: 'file_read',
      description: 'Read a file',
      parameters: { type: 'object', properties: { path: { type: 'string' } } },
      execute: async (params) => readFile(params.path),
    },
  },
  onEvent: (event, data) => console.log(event, data),
})

const result = await executor.execute({
  goal: 'Research TypeScript best practices and summarize key points',
  model: 'claude-sonnet-4-20250514',
  tools: ['web_search', 'file_read'],
  maxIterations: 15,
  systemPrompt: 'You are a senior software engineer conducting research.',
  onStep: async (step) => {
    console.log(`Step ${step.iteration}: ${step.type}`)
    if (step.thought) console.log(`  Thought: ${step.thought}`)
    if (step.toolCalls) console.log(`  Tools: ${step.toolCalls.map(t => t.name).join(', ')}`)
  },
})
```

### Agent Steps

The agent emits steps as it progresses:

```typescript
interface AgentStep {
  iteration: number
  type: 'thinking' | 'tool_call' | 'tool_result' | 'final_answer'
  thought?: string
  toolCalls?: ToolCall[]
  toolResults?: ToolResult[]
  answer?: string
  timestamp: Date
  duration?: number
}
```

### Loop Detection

Prevent agents from getting stuck:

```typescript
const result = await executor.execute({
  goal: 'Complete the task',
  model: 'claude-sonnet-4-20250514',
  tools: ['search', 'read'],
  detectLoops: true,      // Enable loop detection
  loopThreshold: 3,       // Fail after 3 identical tool calls
})
```

### Tool Authorization

Control which tools can be executed:

```typescript
const result = await executor.execute({
  goal: 'Send a report',
  model: 'claude-sonnet-4-20250514',
  tools: ['email_send', 'slack_post'],
  authorizedTools: ['slack_post'],  // Only allow Slack
  integrations: {
    slack: { provider: 'slack', credentials: { token: '...' } },
  },
})
```

## HumanFunctionExecutor

Queues tasks for human input through notification channels.

### Features

- Multi-channel support (Slack, email, in-app)
- Structured forms for data collection
- Timeout and default responses
- Escalation chains
- Approval workflows (sequential, parallel, conditional)
- Response validation

### Basic Usage

```typescript
import { HumanFunctionExecutor } from 'lib/executors/HumanFunctionExecutor'

const executor = new HumanFunctionExecutor({
  state: this.state,
  env: this.env,
  channels: {
    slack: slackChannel,
    email: emailChannel,
  },
  notificationService: this.notifications,
  onEvent: (event, data) => console.log(event, data),
})

const result = await executor.execute({
  prompt: 'Approve refund of ${{amount}} for customer {{customerId}}',
  input: { amount: 150.00, customerId: 'CUST-456' },
  channel: 'slack',
  timeout: 14400000,  // 4 hours
  actions: [
    { value: 'approve', label: 'Approve', style: 'primary' },
    { value: 'reject', label: 'Reject', style: 'danger' },
  ],
})

if (result.success) {
  console.log(`Decision: ${result.response.action} by ${result.respondedBy}`)
}
```

### Form Fields

Collect structured data from humans:

```typescript
const result = await executor.execute({
  prompt: 'Review and classify this support ticket',
  channel: 'in-app',
  timeout: 3600000,
  form: {
    fields: [
      {
        name: 'category',
        type: 'select',
        label: 'Category',
        required: true,
        options: ['billing', 'technical', 'general'],
      },
      {
        name: 'priority',
        type: 'select',
        label: 'Priority',
        required: true,
        options: ['low', 'medium', 'high', 'critical'],
      },
      {
        name: 'notes',
        type: 'text',
        label: 'Notes',
        required: false,
      },
      {
        name: 'escalate',
        type: 'boolean',
        label: 'Escalate to manager',
        default: false,
      },
    ],
  },
})
```

### Escalation

Automatically escalate if no response:

```typescript
const result = await executor.execute({
  prompt: 'Approve contract renewal',
  channel: 'slack',
  timeout: 28800000,    // 8 hours total
  escalation: {
    timeout: 7200000,   // First escalation after 2 hours
    to: 'manager-channel',
    next: {
      timeout: 14400000,  // Second escalation after 4 more hours
      to: 'vp-channel',
    },
  },
})
```

### Approval Workflows

Three workflow types for complex approvals:

```typescript
// Sequential: Each level must approve before the next
const result = await executor.execute({
  prompt: 'Approve large purchase order',
  channel: 'slack',
  approval: {
    type: 'sequential',
    levels: [
      { name: 'manager', users: ['manager@company.com'] },
      { name: 'director', users: ['director@company.com'] },
      { name: 'vp', users: ['vp@company.com'] },
    ],
  },
})

// Parallel: Any N of M must approve
const result = await executor.execute({
  prompt: 'Approve policy change',
  channel: 'slack',
  approval: {
    type: 'parallel',
    users: ['alice@company.com', 'bob@company.com', 'carol@company.com'],
    requiredApprovals: 2,  // 2 of 3 must approve
  },
})

// Conditional: Route based on input
const result = await executor.execute({
  prompt: 'Approve expense',
  channel: 'slack',
  input: { amount: 5000 },
  approval: {
    type: 'conditional',
    conditions: [
      { when: (input) => input.amount < 1000, users: ['manager@company.com'] },
      { when: (input) => input.amount < 10000, users: ['director@company.com'] },
      { when: (input) => true, users: ['cfo@company.com'], sequential: true },
    ],
  },
})
```

## CascadeExecutor

Automatically escalates through function types on failure.

### Cascade Order

The cascade tries handlers in order of speed/cost:

1. **Code** - Fastest, cheapest, deterministic
2. **Generative** - AI inference, single call
3. **Agentic** - AI + tools, multi-step
4. **Human** - Slowest, most expensive, guaranteed judgment

### Basic Usage

```typescript
import { CascadeExecutor } from 'lib/executors/CascadeExecutor'

const executor = new CascadeExecutor({
  state: this.state,
  env: this.env,
  handlers: {
    code: async (input, ctx) => {
      // Try deterministic logic first
      if (canComputeDeterministically(input)) {
        return computeResult(input)
      }
      throw new Error('Cannot compute deterministically')
    },
    generative: async (input, ctx) => {
      // Fall back to AI
      return await this.ai.generate({
        model: 'claude-sonnet-4-20250514',
        prompt: `Process: ${JSON.stringify(input)}`,
      })
    },
    human: async (input, ctx) => {
      // Last resort: ask a human
      return await requestHumanInput(input)
    },
  },
})

const result = await executor.execute({
  input: { query: 'complex decision' },
  handlers: executor.handlers,
})

console.log(`Resolved by: ${result.method}`)  // 'code', 'generative', 'agentic', or 'human'
console.log('Cascade path:', result.cascade.steps)
```

### Explicit Type Override

Skip the cascade and use a specific type:

```typescript
// Force human review
const result = await executor.execute({
  input: { contract: 'important-contract' },
  type: 'human',  // Skip code/generative/agentic
  handlers: { human: humanHandler },
})

// Start from generative (skip code)
const result = await executor.execute({
  input: { query: 'creative task' },
  startFrom: 'generative',  // Skip code, try generative -> agentic -> human
  handlers: allHandlers,
})
```

### Event Context (5W+H)

Track the full context of execution:

```typescript
const result = await executor.execute({
  input: { orderId: 'ORD-123' },
  handlers: myHandlers,
  eventContext: {
    actor: 'system',
    object: 'order',
    type: 'Order',
    verb: 'processed',
    ns: 'commerce',
    location: 'us-west-2',
  },
  emitEvent: true,  // Emit 5W+H event on completion
})

// result.event contains:
// {
//   actor: 'system',
//   object: 'order',
//   type: 'Order',
//   verb: 'processed',
//   ns: 'commerce',
//   method: 'code',  // HOW it was resolved
//   cascade: { steps: [...] },
//   timestamp: Date,
//   recorded: Date,
// }
```

## ParallelStepExecutor

Executes multiple workflow steps concurrently.

### Basic Usage

```typescript
import { ParallelStepExecutor, step } from 'lib/executors/ParallelStepExecutor'

const executor = new ParallelStepExecutor([
  step('fetchUser', async (ctx) => fetchUser(ctx.input.userId)),
  step('fetchOrders', async (ctx) => fetchOrders(ctx.input.userId)),
  step('fetchRecommendations', async (ctx) => getRecommendations(ctx.input.userId)),
])

const result = await executor.execute({
  input: { userId: 'user-123' },
  workflowInstanceId: 'wf-456',
})

// result.results = {
//   fetchUser: { status: 'completed', output: user },
//   fetchOrders: { status: 'completed', output: orders },
//   fetchRecommendations: { status: 'completed', output: recommendations },
// }
// result.merged = { fetchUser: user, fetchOrders: orders, ... }
```

### Execution Modes

```typescript
// Fail fast: Stop on first error
new ParallelStepExecutor(steps, { mode: 'failFast' })

// Wait for all: Collect all results regardless of errors
new ParallelStepExecutor(steps, { mode: 'waitForAll' })

// Allow partial failure: Continue even if some steps fail
new ParallelStepExecutor(steps, { mode: 'allowPartialFailure' })
```

### Custom Output Merger

```typescript
const executor = new ParallelStepExecutor(steps, {
  merge: (results) => ({
    combined: {
      user: results.fetchUser,
      orders: results.fetchOrders,
    },
    hasRecommendations: !!results.fetchRecommendations,
  }),
})
```

## Creating Custom Executors

Extend `BaseFunctionExecutor` for custom execution patterns:

```typescript
import {
  BaseFunctionExecutor,
  type BaseExecutorOptions,
  type FunctionType,
} from 'lib/executors/BaseFunctionExecutor'

interface CustomExecutorOptions extends BaseExecutorOptions {
  customSetting: string
}

class CustomExecutor extends BaseFunctionExecutor<CustomExecutorOptions> {
  private customSetting: string

  constructor(options: CustomExecutorOptions) {
    super(options)
    this.customSetting = options.customSetting
  }

  getFunctionType(): FunctionType {
    return 'code'  // or 'generative', 'agentic', 'human'
  }

  protected async executeCore<TInput, TOutput>(
    input: TInput,
    options: Record<string, unknown>
  ): Promise<TOutput> {
    // Custom execution logic
    const result = await this.customLogic(input)

    // Use inherited methods
    await this.emit('custom.completed', { result })

    return result as TOutput
  }

  private async customLogic<T>(input: T): Promise<T> {
    // Your logic here
    return input
  }
}
```

### Inherited Utilities

`BaseFunctionExecutor` provides:

```typescript
// State wrapper for DO storage
const state = this.createStateWrapper()
await state.put('key', value)
const value = await state.get<T>('key')

// Event emission
await this.emit('event.name', { data })

// Retry with backoff
const { result, retryCount } = await this.executeWithRetry(
  () => riskyOperation(),
  retryConfig,
  signal
)

// Timeout handling
const result = await this.executeWithTimeout(
  () => slowOperation(),
  5000,
  signal
)

// Middleware pipeline
const result = await this.applyMiddleware(ctx, () => coreLogic())

// Template interpolation
const prompt = this.interpolateTemplate('Hello {{name}}', { name: 'World' })
```

## Error Handling

Each executor has specific error classes:

```typescript
// CodeFunctionExecutor errors
import {
  ExecutionTimeoutError,
  ExecutionSandboxError,
  ExecutionResourceError,
  ExecutionRetryExhaustedError,
  ExecutionCancelledError,
  ExecutionValidationError,
} from 'lib/executors/CodeFunctionExecutor'

// AgenticFunctionExecutor errors
import {
  AgentMaxIterationsError,
  AgentToolExecutionError,
  AgentConvergenceError,
  AgentToolNotFoundError,
  AgentToolAuthorizationError,
  AgentCancelledError,
} from 'lib/executors/AgenticFunctionExecutor'

// HumanFunctionExecutor errors
import {
  HumanTimeoutError,
  HumanChannelError,
  HumanValidationError,
  HumanEscalationError,
  HumanApprovalRejectedError,
  HumanCancelledError,
  HumanNotificationFailedError,
} from 'lib/executors/HumanFunctionExecutor'

// CascadeExecutor errors
import {
  CascadeExhaustedError,
  CascadeTimeoutError,
  CascadeSkippedError,
} from 'lib/executors/CascadeExecutor'
```

## Integration with Workflows

Executors integrate with the `$` workflow context:

```typescript
import { $ } from 'workflows'

// Use $.do for durable execution with retries
const result = await $.do(
  async () => executor.execute(input, options)
)

// Use $.try for single attempt
const result = await $.try(
  async () => executor.execute(input, options)
)

// Use $.send for fire-and-forget
$.send({ type: 'function.executed', result })
```

## Related

- [Functions Overview](/docs/functions) - Function types and createFunction factory
- [createFunction Factory](/docs/functions/create-function) - High-level function creation
- [Function Middleware](/docs/functions/middleware) - Logging, auth, caching
- [Workflows](/docs/workflows) - Orchestrating function execution
- [Agents](/docs/agents) - AI agent configuration
- [Humans](/docs/humans/escalation) - Human-in-the-loop patterns
