---
title: Code Function Executor
description: Execute TypeScript functions in a controlled, sandboxed environment with timeouts, retries, and resource limits
---

# Code Function Executor

The `CodeFunctionExecutor` runs TypeScript/JavaScript handlers in a controlled V8 isolate environment with context injection, sandboxing, timeouts, retries, and resource limits.

## Overview

Code functions are the fastest and most deterministic function type. They execute synchronously or asynchronously in a sandboxed environment that provides:

- **Context injection** - env, state, services, logging, events
- **Sandboxed execution** - restricted globals for security
- **Timeout handling** - configurable execution limits
- **Retry logic** - exponential backoff, fixed, or linear strategies
- **Resource limits** - memory, CPU time, output size
- **Streaming output** - async iterator support

## Basic Usage

```typescript
import { CodeFunctionExecutor } from 'dotdo/executors'

// Create the executor with required dependencies
const executor = new CodeFunctionExecutor({
  state: ctx.state,        // Durable Object state
  env: ctx.env,            // Environment variables
  services: {
    ai: { generate: ... },
    kv: { get, put },
    db: { query },
    queue: { send },
    fetch
  },
  logger: console,
  onEvent: (event, data) => console.log(event, data)
})

// Execute a handler function
const result = await executor.execute(
  async (input, ctx) => {
    const { items } = input as { items: Array<{ price: number; quantity: number }> }
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0)
  },
  { items: [{ price: 10, quantity: 2 }] },
  { timeout: 5000 }
)

if (result.success) {
  console.log('Total:', result.result)
} else {
  console.error('Error:', result.error)
}
```

## Sync vs Async Execution

### Synchronous Functions

Simple computations that return immediately:

```typescript
const result = await executor.execute(
  ({ a, b }) => a * b,
  { a: 3, b: 4 }
)
// result.result === 12
```

### Asynchronous Functions

Functions that need to await external resources:

```typescript
const result = await executor.execute(
  async (input, ctx) => {
    const { userId } = input as { userId: string }

    const cached = await ctx.state.get<User>(`user:${userId}`)
    if (cached) return cached

    const users = await ctx.services.db.query<User>(
      'SELECT * FROM users WHERE id = ?',
      [userId]
    )
    await ctx.state.put(`user:${userId}`, users[0])
    return users[0]
  },
  { userId: 'user-123' }
)
```

## Execution Context

Every handler receives an `ExecutionContext` with access to:

```typescript
interface ExecutionContext {
  functionId: string
  invocationId: string
  env: Record<string, string>      // Environment variables
  state: {                          // Durable Object storage
    get: <T>(key: string) => Promise<T | null>
    put: <T>(key: string, value: T) => Promise<void>
    delete: (key: string) => Promise<boolean>
    list: (options?: { prefix?: string }) => Promise<Map<string, unknown>>
  }
  services: {                       // Platform services
    ai: { generate: (opts) => Promise<{ text: string }> }
    kv: { get, put }
    db: { query }
    queue: { send }
    fetch: (url, init?) => Promise<Response>
  }
  log: { debug, info, warn, error }
  emit: (event: string, data: unknown) => Promise<void>
  signal: AbortSignal
}
```

### Using Context Services

```typescript
const result = await executor.execute(
  async (input, ctx) => {
    const { orderId } = input as { orderId: string }
    ctx.log.info('Processing order', { orderId })

    const order = await ctx.services.db.query(
      'SELECT * FROM orders WHERE id = ?',
      [orderId]
    )

    await ctx.emit('order.processing', { orderId })

    const response = await ctx.services.fetch(
      `${ctx.env.PAYMENT_API}/charge`,
      {
        method: 'POST',
        body: JSON.stringify({ amount: order[0].total })
      }
    )
    const paymentResult = await response.json()

    return { success: true, transactionId: paymentResult.id }
  },
  { orderId: 'order-123' }
)
```

## Error Handling

### Error Types

The executor provides specific error types for different failure scenarios:

```typescript
import {
  ExecutionTimeoutError,
  ExecutionSandboxError,
  ExecutionResourceError,
  ExecutionRetryExhaustedError,
  ExecutionCancelledError,
  ExecutionValidationError
} from 'dotdo/executors/CodeFunctionExecutor'
```

| Error Type | Description |
|------------|-------------|
| `ExecutionTimeoutError` | Function exceeded timeout limit |
| `ExecutionSandboxError` | Attempted to access restricted globals |
| `ExecutionResourceError` | Memory, CPU, or output size limit exceeded |
| `ExecutionRetryExhaustedError` | All retry attempts failed |
| `ExecutionCancelledError` | Execution was cancelled via AbortSignal |
| `ExecutionValidationError` | Input or output validation failed |

### Handling Errors

```typescript
const result = await executor.execute(
  async (input, ctx) => {
    const { data } = input as { data: unknown }
    try {
      const processed = await processData(data)
      return { success: true, result: processed }
    } catch (error) {
      ctx.log.error('Processing failed', { error: (error as Error).message })
      throw error // Will be caught by executor
    }
  },
  { data: someData }
)

if (!result.success) {
  if (result.error instanceof ExecutionTimeoutError) {
    console.log('Function timed out after', result.error.timeout, 'ms')
  } else if (result.error instanceof ExecutionSandboxError) {
    console.error('Sandbox violation:', result.error.message)
  } else if (result.error instanceof ExecutionResourceError) {
    console.error('Resource limit exceeded:', result.error.resource)
  } else if (result.error instanceof ExecutionRetryExhaustedError) {
    console.error('All retries failed after', result.error.attempts, 'attempts')
  }
}
```

### Custom Error Recovery

```typescript
const result = await executor.execute(
  async (input, ctx) => {
    const { query } = input as { query: string }
    try {
      return await ctx.services.search(query)
    } catch (error) {
      // Fall back to cached results
      const cached = await ctx.state.get<SearchResult[]>(`search:${query}`)
      if (cached) return cached
      throw new Error('Search unavailable and no cached results')
    }
  },
  { query: 'search term' }
)
```

## Timeouts and Resource Limits

### Configuring Timeouts

```typescript
const slowOperation = CodeFunction({
  input: { url: 'string' },
  output: 'Response',
  timeout: 60000, // 60 seconds
  handler: async ({ url }, ctx) => {
    return ctx.services.fetch(url)
  }
})
```

### Resource Limits

```typescript
const limitedFunction = CodeFunction({
  input: { data: 'Buffer' },
  output: 'ProcessedData',
  resourceLimits: {
    maxMemory: 128 * 1024 * 1024,  // 128MB
    maxCpuTime: 5000,               // 5 seconds
    maxOutputSize: 10 * 1024 * 1024 // 10MB
  },
  handler: async ({ data }) => {
    return heavyProcessing(data)
  }
})
```

## Retry Configuration

### Exponential Backoff

```typescript
const reliableCall = CodeFunction({
  input: { endpoint: 'string' },
  output: 'ApiResponse',
  retry: {
    maxAttempts: 3,
    delay: 1000,
    backoff: 'exponential',
    maxDelay: 30000,
    retryOnTimeout: true,
    onRetry: ({ attempt, delay, error }) => {
      console.log(`Retry ${attempt} after ${delay}ms: ${error.message}`)
    }
  },
  handler: async ({ endpoint }, ctx) => {
    return ctx.services.fetch(endpoint)
  }
})
```

### Conditional Retries

```typescript
const selectiveRetry = CodeFunction({
  input: { request: 'Request' },
  output: 'Response',
  retry: {
    maxAttempts: 5,
    delay: 500,
    backoff: 'linear',
    increment: 500,
    retryIf: (error) => {
      // Only retry on network errors or 5xx
      return error.name === 'NetworkError' ||
             error.statusCode >= 500
    }
  },
  handler: async ({ request }, ctx) => {
    return processRequest(request)
  }
})
```

## Sandboxed Execution

The executor runs code in a sandboxed environment with restricted globals:

### Allowed Globals

- Standard JavaScript: `JSON`, `Math`, `Date`, `Array`, `Object`, `String`, `Number`, `Boolean`
- Async primitives: `Promise`, `setTimeout`, `clearTimeout`, `queueMicrotask`
- Web APIs: `URL`, `URLSearchParams`, `Response`, `Request`, `Headers`, `fetch`
- Typed arrays: `Uint8Array`, `ArrayBuffer`, `TextEncoder`, `TextDecoder`
- Crypto: `crypto`

### Restricted Globals

The following are blocked in sandboxed mode:

- `require`, `process`, `global`, `globalThis`
- `eval`, `Function` (dynamic code execution)
- Prototype modification (`__proto__`, `Object.prototype`)

### Disabling Sandbox

For trusted code that needs full access:

```typescript
const trustedFunction = CodeFunction({
  input: { script: 'string' },
  output: 'unknown',
  sandboxed: false, // Use with caution
  handler: async ({ script }) => {
    return eval(script) // Only in non-sandboxed mode
  }
})
```

## Streaming Output

For long-running operations that produce incremental results:

```typescript
const streamingProcess = CodeFunction({
  input: { items: 'Item[]' },
  output: 'ProcessedItem[]',
  streaming: true,
  handler: async function* ({ items }, ctx) {
    for (const item of items) {
      const processed = await processItem(item)
      await ctx.emit('stream.chunk', { data: processed })
      yield processed
    }
  }
})

// Consuming the stream
const stream = await executor.executeStreaming(handler, input)

for await (const chunk of stream) {
  if (chunk.type === 'chunk') {
    console.log('Received:', chunk.data)
  }
  if (chunk.type === 'result') {
    console.log('Final result:', chunk.value)
  }
}
```

## Input/Output Validation

### Schema Validation

```typescript
const validatedFunction = CodeFunction({
  inputSchema: {
    type: 'object',
    properties: {
      email: { type: 'string' },
      age: { type: 'integer' }
    },
    required: ['email']
  },
  outputSchema: {
    type: 'object',
    properties: {
      success: { type: 'boolean' },
      userId: { type: 'string' }
    },
    required: ['success']
  },
  handler: async ({ email, age }) => {
    const user = await createUser(email, age)
    return { success: true, userId: user.id }
  }
})
```

## Cancellation

Support for cancellable operations:

```typescript
const cancellableOperation = CodeFunction({
  input: { taskId: 'string' },
  output: 'TaskResult',
  handler: async ({ taskId }, ctx) => {
    const steps = await getTaskSteps(taskId)

    for (const step of steps) {
      // Check for cancellation between steps
      if (ctx.signal.aborted) {
        throw new ExecutionCancelledError('Task cancelled')
      }

      await executeStep(step)
    }

    return { completed: true }
  }
})

// Cancelling execution
const controller = new AbortController()
const result = executor.execute(handler, input, { signal: controller.signal })

// Cancel after 5 seconds
setTimeout(() => controller.abort(), 5000)
```

## Best Practices

1. **Keep handlers focused** - One function, one responsibility
2. **Use context services** - Leverage injected services rather than importing directly
3. **Handle errors gracefully** - Provide meaningful error messages
4. **Set appropriate timeouts** - Match timeout to expected execution time
5. **Use retries for transient failures** - Network issues, rate limits
6. **Log important operations** - Use `ctx.log` for observability
7. **Emit events for monitoring** - Use `ctx.emit` for workflow integration

## Related

- [Concepts: Functions](/docs/concepts/functions) - Function types and cascade patterns
- [SDK: Functions](/docs/sdk/functions) - DOFunction type reference
- [Agents](/docs/agents) - AI agents for agentic functions
- [Humans](/docs/humans) - Human-in-the-loop functions and escalation
