---
title: Function Middleware
description: Pre-built middleware for logging, metrics, auth, validation, rate limiting, caching, and tracing
---

# Function Middleware

dotdo provides a comprehensive middleware system for adding cross-cutting concerns to function execution. Middleware wraps function execution to add logging, metrics, authentication, validation, rate limiting, caching, and distributed tracing.

## Overview

Middleware intercepts function execution to add behavior before and after:

```typescript
const loggingMiddleware = async (ctx, next) => {
  console.log('Before execution')
  const result = await next()
  console.log('After execution')
  return result
}
```

## Available Middleware

| Middleware | Purpose |
|------------|---------|
| `createLoggingMiddleware` | Log function invocations |
| `createMetricsMiddleware` | Collect execution metrics |
| `createAuthMiddleware` | Authentication and authorization |
| `createValidationMiddleware` | Input/output validation |
| `createRateLimitMiddleware` | Rate limiting |
| `createCachingMiddleware` | Response caching |
| `createTimeoutMiddleware` | Execution timeouts |
| `createTracingMiddleware` | Distributed tracing |

## Logging Middleware

Log function invocations with configurable detail:

```typescript
import { createLoggingMiddleware } from 'dotdo/functions/middleware'

const logging = createLoggingMiddleware({
  sink: (entry) => {
    // Send to your logging service
    console.log(JSON.stringify(entry))
  },
  logInput: true,
  logOutput: true,
  logErrors: true,
  level: 'info'
})
```

### Log Entry Structure

```typescript
interface LogEntry {
  level: 'debug' | 'info' | 'warn' | 'error'
  message: string
  timestamp: Date
  functionId: string
  invocationId: string
  functionType: string
  duration?: number
  success?: boolean
  error?: string
  metadata?: Record<string, unknown>
}
```

### Logging Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `sink` | `LogSink` | `console.log` | Where to send logs |
| `logInput` | `boolean` | `false` | Include input in logs |
| `logOutput` | `boolean` | `false` | Include output in logs |
| `logErrors` | `boolean` | `true` | Log error details |
| `level` | `string` | `'info'` | Default log level |

### Custom Log Sink

```typescript
// Send to external service
const logging = createLoggingMiddleware({
  sink: async (entry) => {
    await fetch('https://logs.example.com/ingest', {
      method: 'POST',
      body: JSON.stringify(entry),
      headers: { 'Content-Type': 'application/json' }
    })
  }
})
```

## Metrics Middleware

Collect execution metrics:

```typescript
import { createMetricsMiddleware, createMetricsCollector } from 'dotdo/functions/middleware'

// Simple metrics sink
const metrics = createMetricsMiddleware({
  sink: (entry) => {
    prometheus.histogram('function_duration', entry.duration, {
      function_id: entry.functionId,
      function_type: entry.functionType,
      success: String(entry.success)
    })
  },
  includeMetadata: true
})
```

### In-Memory Metrics Collector

For development and testing:

```typescript
const collector = createMetricsCollector()

// Use the middleware
executor.use(collector.middleware)

// Later, get metrics
const metrics = collector.getMetrics()

// Get summary statistics
const summary = collector.getSummary()
console.log(`Total: ${summary.total}`)
console.log(`Success rate: ${summary.succeeded / summary.total}`)
console.log(`Avg duration: ${summary.avgDuration}ms`)

// Per-function stats
for (const [fnId, stats] of Object.entries(summary.byFunction)) {
  console.log(`${fnId}: ${stats.count} calls, ${stats.avgDuration}ms avg, ${stats.successRate * 100}% success`)
}

// Clear metrics
collector.clear()
```

### Metrics Entry Structure

```typescript
interface MetricsEntry {
  functionId: string
  functionType: string
  duration: number
  success: boolean
  timestamp: Date
  metadata?: Record<string, unknown>
}
```

## Auth Middleware

Authenticate and authorize function calls:

```typescript
import { createAuthMiddleware, AuthenticationError, AuthorizationError } from 'dotdo/functions/middleware'

const auth = createAuthMiddleware({
  // Extract auth context from request
  provider: async (ctx) => {
    const token = ctx.metadata.token as string
    if (!token) return null

    const decoded = await verifyJWT(token)
    return {
      userId: decoded.sub,
      roles: decoded.roles,
      permissions: decoded.permissions
    }
  },

  // Optional custom validation
  validator: async (ctx, auth) => {
    // Additional validation logic
    return auth.roles.length > 0
  },

  required: true,
  requiredRoles: ['admin', 'operator'],
  requiredPermissions: ['functions:execute']
})
```

### Auth Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `provider` | `AuthProvider` | Required | Extract auth context |
| `validator` | `AuthValidator` | - | Custom validation |
| `required` | `boolean` | `true` | Require authentication |
| `requiredRoles` | `string[]` | `[]` | Require any of these roles |
| `requiredPermissions` | `string[]` | `[]` | Require all permissions |

### Auth Context

```typescript
interface AuthContext {
  userId?: string
  roles?: string[]
  permissions?: string[]
  token?: string
  [key: string]: unknown  // Custom fields
}
```

### Role-Based Access

```typescript
// Require admin role
const adminOnly = createAuthMiddleware({
  provider: extractAuthFromHeader,
  requiredRoles: ['admin']
})

// Require specific permissions
const canEdit = createAuthMiddleware({
  provider: extractAuthFromHeader,
  requiredPermissions: ['documents:write', 'documents:delete']
})
```

### Error Handling

```typescript
try {
  await protectedFunction.execute(input)
} catch (error) {
  if (error instanceof AuthenticationError) {
    // No valid credentials
    return { status: 401, message: 'Authentication required' }
  }
  if (error instanceof AuthorizationError) {
    // Authenticated but not authorized
    return { status: 403, message: error.message }
  }
}
```

## Validation Middleware

Validate inputs and outputs:

```typescript
import { createValidationMiddleware, ValidationError } from 'dotdo/functions/middleware'

const validation = createValidationMiddleware({
  inputValidator: (input) => {
    const { email, age } = input as { email: string; age: number }

    if (!email || !email.includes('@')) {
      return 'Invalid email address'
    }
    if (age < 0 || age > 150) {
      return 'Age must be between 0 and 150'
    }
    return true
  },

  outputValidator: (output) => {
    const { userId } = output as { userId: string }
    if (!userId) {
      return 'Output must include userId'
    }
    return true
  }
})
```

### Async Validators

```typescript
const validation = createValidationMiddleware({
  inputValidator: async (input) => {
    const { userId } = input as { userId: string }
    const exists = await checkUserExists(userId)
    return exists || 'User does not exist'
  }
})
```

### With Schema Libraries

```typescript
import { z } from 'zod'

const UserInput = z.object({
  email: z.string().email(),
  age: z.number().min(0).max(150)
})

const validation = createValidationMiddleware({
  inputValidator: (input) => {
    const result = UserInput.safeParse(input)
    return result.success || result.error.message
  }
})
```

## Rate Limiting Middleware

Limit function invocations:

```typescript
import {
  createRateLimitMiddleware,
  createInMemoryRateLimitStore,
  RateLimitError
} from 'dotdo/functions/middleware'

// In-memory store (for single instance)
const store = createInMemoryRateLimitStore(
  100,      // 100 requests
  60000     // per minute
)

const rateLimit = createRateLimitMiddleware({
  store,
  keyGenerator: (ctx) => {
    // Rate limit per user
    return `${ctx.functionId}:${ctx.metadata.userId || 'anonymous'}`
  },
  onLimit: (ctx, info) => {
    console.log(`Rate limited: ${info.remaining} remaining, resets at ${info.resetAt}`)
  }
})
```

### Custom Rate Limit Store

For distributed rate limiting (e.g., with Redis):

```typescript
interface RateLimitStore {
  check: (key: string) => Promise<RateLimitInfo>
  increment: (key: string) => Promise<void>
}

const redisStore: RateLimitStore = {
  async check(key: string) {
    const count = await redis.get(key) || 0
    const ttl = await redis.ttl(key)
    return {
      remaining: Math.max(0, LIMIT - count),
      limit: LIMIT,
      resetAt: new Date(Date.now() + ttl * 1000)
    }
  },
  async increment(key: string) {
    await redis.incr(key)
    await redis.expire(key, WINDOW_SECONDS)
  }
}
```

### Rate Limit Error Handling

```typescript
try {
  await rateLimitedFunction.execute(input)
} catch (error) {
  if (error instanceof RateLimitError) {
    return {
      status: 429,
      message: error.message,
      retryAfter: error.resetAt.toISOString()
    }
  }
}
```

## Caching Middleware

Cache function results:

```typescript
import {
  createCachingMiddleware,
  createInMemoryCacheStore
} from 'dotdo/functions/middleware'

const cache = createCachingMiddleware({
  store: createInMemoryCacheStore(),
  ttl: 300000,  // 5 minutes
  keyGenerator: (ctx) => {
    // Cache key based on function and input
    return `${ctx.functionId}:${JSON.stringify(ctx.input)}`
  },
  shouldCache: (ctx, result) => {
    // Only cache successful results
    return result && !result.error
  }
})
```

### Custom Cache Store

```typescript
interface CacheStore<T = unknown> {
  get: (key: string) => CacheEntry<T> | undefined | Promise<CacheEntry<T> | undefined>
  set: (key: string, entry: CacheEntry<T>) => void | Promise<void>
  delete: (key: string) => void | Promise<void>
}

// Redis cache store
const redisCache: CacheStore = {
  async get(key) {
    const data = await redis.get(key)
    return data ? JSON.parse(data) : undefined
  },
  async set(key, entry) {
    await redis.setex(key, Math.ceil(entry.ttl / 1000), JSON.stringify(entry))
  },
  async delete(key) {
    await redis.del(key)
  }
}
```

### Cache Hit Detection

```typescript
const caching = createCachingMiddleware({ store, ttl: 60000 })

// After execution, check if cached
const result = await cachedFunction.execute(input)
if (ctx.metadata.cacheHit) {
  console.log('Served from cache')
}
```

## Timeout Middleware

Enforce execution time limits:

```typescript
import { createTimeoutMiddleware, TimeoutError } from 'dotdo/functions/middleware'

const timeout = createTimeoutMiddleware({
  timeout: 5000,  // 5 seconds
  onTimeout: (ctx) => {
    console.warn(`Function ${ctx.functionId} timed out`)
  }
})
```

### Timeout Error Handling

```typescript
try {
  await timedFunction.execute(input)
} catch (error) {
  if (error instanceof TimeoutError) {
    return { status: 504, message: 'Function timed out' }
  }
}
```

## Tracing Middleware

Distributed tracing support:

```typescript
import { createTracingMiddleware } from 'dotdo/functions/middleware'

const tracing = createTracingMiddleware({
  sink: async (span) => {
    // Send to your tracing service (Jaeger, Zipkin, etc.)
    await tracingService.report(span)
  },
  extractTraceContext: (ctx) => ({
    traceId: ctx.metadata.traceId as string,
    parentSpanId: ctx.metadata.spanId as string
  })
})
```

### Trace Span Structure

```typescript
interface TraceSpan {
  traceId: string
  spanId: string
  parentSpanId?: string
  operationName: string
  startTime: number
  endTime?: number
  tags: Record<string, string | number | boolean>
  logs: Array<{
    timestamp: number
    message: string
    data?: unknown
  }>
}
```

### OpenTelemetry Integration

```typescript
import { trace } from '@opentelemetry/api'

const tracing = createTracingMiddleware({
  sink: (span) => {
    const tracer = trace.getTracer('dotdo-functions')
    const otelSpan = tracer.startSpan(span.operationName, {
      startTime: span.startTime
    })

    for (const [key, value] of Object.entries(span.tags)) {
      otelSpan.setAttribute(key, value)
    }

    if (span.tags.error) {
      otelSpan.setStatus({ code: 2 })  // ERROR
    }

    otelSpan.end(span.endTime)
  }
})
```

## Composing Middleware

Combine multiple middleware into one:

```typescript
import { composeMiddleware } from 'dotdo/functions/middleware'

const combined = composeMiddleware(
  createTracingMiddleware({ sink: tracingSink }),
  createLoggingMiddleware({ sink: loggingSink }),
  createMetricsMiddleware({ sink: metricsSink }),
  createAuthMiddleware({ provider: authProvider }),
  createValidationMiddleware({ inputValidator }),
  createRateLimitMiddleware({ store: rateLimitStore }),
  createCachingMiddleware({ store: cacheStore, ttl: 60000 }),
  createTimeoutMiddleware({ timeout: 5000 })
)

// Apply to executor
executor.use(combined)
```

### Execution Order

Middleware executes in order. The first middleware wraps the second, etc.:

```
Request -> Tracing -> Logging -> Metrics -> Auth -> Validation -> Rate Limit -> Cache -> Timeout -> Function
Response <- Tracing <- Logging <- Metrics <- Auth <- Validation <- Rate Limit <- Cache <- Timeout <- Function
```

## Middleware Context

Every middleware receives a context object:

```typescript
interface MiddlewareContext {
  functionId: string
  invocationId: string
  functionType: string
  input: unknown
  metadata: Record<string, unknown>
}
```

### Passing Data Between Middleware

Use `ctx.metadata` to pass data:

```typescript
// Auth middleware adds user info
const auth = async (ctx, next) => {
  ctx.metadata.userId = await authenticate(ctx)
  ctx.metadata.auth = { roles: ['admin'] }
  return next()
}

// Later middleware can access it
const audit = async (ctx, next) => {
  console.log(`User ${ctx.metadata.userId} executing ${ctx.functionId}`)
  return next()
}
```

## Creating Custom Middleware

```typescript
import type { ExecutionMiddleware, MiddlewareContext, MiddlewareNext } from 'dotdo/executors'

const myMiddleware: ExecutionMiddleware = async (
  ctx: MiddlewareContext,
  next: MiddlewareNext
) => {
  // Before execution
  const startTime = Date.now()

  try {
    // Execute the function (or next middleware)
    const result = await next()

    // After successful execution
    console.log(`Success in ${Date.now() - startTime}ms`)
    return result

  } catch (error) {
    // On error
    console.error(`Failed in ${Date.now() - startTime}ms`, error)
    throw error

  } finally {
    // Always runs (cleanup)
  }
}
```

### Middleware Best Practices

1. **Always call `next()`** - Unless intentionally blocking execution
2. **Handle errors** - Catch and rethrow, or handle appropriately
3. **Keep middleware focused** - One concern per middleware
4. **Order matters** - Auth before validation, tracing first
5. **Async-safe** - Use async/await consistently

## Related

- [createFunction Factory](/docs/functions/create-function) - Creating functions
- [Function Composition](/docs/functions/composition) - Composing functions
- [Code Executor](/docs/functions/code-executor) - Execution environment
- [Observability](/docs/observability) - Monitoring and tracing
