---
title: Function Registry
description: Discover, manage, and organize function definitions with tags, types, and metadata
---

# Function Registry

The `FunctionRegistry` provides a central place to register, discover, and manage function definitions. It supports lookup by name, filtering by type and tags, and metadata management.

## Overview

The registry enables:

- **Registration** - Store function configurations
- **Discovery** - Find functions by type, tags, or name patterns
- **Metadata** - Track versions, authors, deprecation
- **Validation** - Ensure function configs are valid

## Basic Usage

```typescript
import { FunctionRegistry, createRegistry, getDefaultRegistry } from 'dotdo/functions/registry'

// Create a new registry
const registry = createRegistry()

// Or use the default singleton
const defaultRegistry = getDefaultRegistry()
```

## Registering Functions

### Generic Registration

```typescript
registry.register({
  name: 'processOrder',
  type: 'code',
  description: 'Process an incoming order',
  handler: async (input) => processOrder(input)
}, {
  tags: ['orders', 'processing'],
  version: '1.2.0',
  author: 'team@example.com'
})
```

### Type-Specific Registration

Convenience methods for each function type:

```typescript
// Code function
registry.registerCode({
  name: 'calculateTotal',
  description: 'Calculate order total with tax',
  handler: (input) => {
    const { items, taxRate } = input
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0) * (1 + taxRate)
  }
}, {
  tags: ['orders', 'calculation']
})

// Generative function
registry.registerGenerative({
  name: 'summarize',
  description: 'Summarize text content',
  model: 'claude-sonnet-4-20250514',
  prompt: 'Summarize: {{text}}'
}, {
  tags: ['ai', 'text-processing']
})

// Agentic function
registry.registerAgentic({
  name: 'buildFeature',
  description: 'Autonomously implement a feature',
  model: 'claude-sonnet-4-20250514',
  goal: 'Implement the requested feature with tests',
  tools: ['code_search', 'file_edit', 'run_tests']
}, {
  tags: ['ai', 'development']
})

// Human function
registry.registerHuman({
  name: 'approveRefund',
  description: 'Get manager approval for refund',
  channel: 'slack:approvals',
  prompt: 'Approve refund of ${{amount}}?'
}, {
  tags: ['finance', 'approval']
})
```

## Retrieving Functions

### Get by Name

```typescript
// Returns undefined if not found
const fn = registry.get('processOrder')

// Throws FunctionNotFoundError if not found
const fn = registry.getOrThrow('processOrder')
```

### Check Existence

```typescript
if (registry.has('processOrder')) {
  // Function exists
}
```

### List All Functions

```typescript
const names = registry.list()
// ['processOrder', 'calculateTotal', 'summarize', ...]
```

## Finding Functions

### Find by Filter

```typescript
// Find by type
const codeFunctions = registry.find({ type: 'code' })

// Find by multiple types
const aiFunctions = registry.find({ type: ['generative', 'agentic'] })

// Find by tag
const orderFunctions = registry.find({ tags: ['orders'] })

// Find by name pattern (string contains)
const processors = registry.find({ name: 'process' })

// Find by name pattern (regex)
const handlers = registry.find({ name: /Handler$/ })

// Find non-deprecated only
const active = registry.find({ deprecated: false })

// Combine filters
const activeOrderCode = registry.find({
  type: 'code',
  tags: ['orders'],
  deprecated: false
})
```

### Find by Type

```typescript
const codeFunctions = registry.findByType('code')
const generativeFunctions = registry.findByType('generative')
const agenticFunctions = registry.findByType('agentic')
const humanFunctions = registry.findByType('human')
```

### Find by Tag

```typescript
// Single tag
const orderFunctions = registry.findByTag('orders')

// Multiple tags (all must match)
const financialApprovals = registry.findByTags(['finance', 'approval'])
```

## Function Metadata

### Metadata Structure

```typescript
interface FunctionMetadata {
  name: string                    // Function name
  type: FunctionType              // code | generative | agentic | human
  description?: string            // Human-readable description
  tags?: string[]                 // Categorization tags
  version?: string                // Semantic version
  author?: string                 // Author/owner
  deprecated?: boolean            // Deprecation flag
  deprecationMessage?: string     // Migration instructions
  createdAt?: Date                // Registration timestamp
  updatedAt?: Date                // Last update timestamp
}
```

### Update Metadata

```typescript
registry.updateMetadata('processOrder', {
  version: '2.0.0',
  tags: ['orders', 'processing', 'v2'],
  author: 'new-team@example.com'
})
```

### Deprecate Functions

```typescript
// Mark as deprecated
registry.deprecate('oldFunction', 'Use newFunction instead. See migration guide.')

// Find deprecated functions
const deprecated = registry.find({ deprecated: true })
```

## Tags

### Get All Tags

```typescript
const tags = registry.getTags()
// ['orders', 'processing', 'ai', 'finance', ...]
```

### Tag-Based Discovery

```typescript
// Find all functions with a specific tag
const aiPowered = registry.findByTag('ai')

// Find functions with multiple tags
const aiOrderProcessing = registry.findByTags(['ai', 'orders'])
```

## Statistics

```typescript
const stats = registry.getStats()

console.log(`Total functions: ${stats.total}`)
console.log(`By type:`)
console.log(`  - Code: ${stats.byType.code}`)
console.log(`  - Generative: ${stats.byType.generative}`)
console.log(`  - Agentic: ${stats.byType.agentic}`)
console.log(`  - Human: ${stats.byType.human}`)
console.log(`Deprecated: ${stats.deprecated}`)

console.log('Tags:')
for (const [tag, count] of stats.tags) {
  console.log(`  - ${tag}: ${count}`)
}
```

### Stats Structure

```typescript
interface RegistryStats {
  total: number
  byType: Record<FunctionType, number>
  deprecated: number
  tags: Map<string, number>
}
```

## Unregistering Functions

```typescript
// Returns true if function was removed
const removed = registry.unregister('oldFunction')

// Clear all functions
registry.clear()
```

## Serialization

### Export to JSON

```typescript
const data = registry.toJSON()
// { functions: [{ config: {...}, metadata: {...} }, ...] }

// Save to file
await fs.writeFile('functions.json', JSON.stringify(data, null, 2))
```

### Import from JSON

```typescript
const data = JSON.parse(await fs.readFile('functions.json', 'utf-8'))
registry.fromJSON(data)
```

## Validation

The registry validates function configurations on registration:

### Name Validation

- Must start with a letter or underscore
- Can contain letters, numbers, and underscores
- Examples: `processOrder`, `_internal`, `step2Handler`

```typescript
// These throw FunctionValidationError
registry.register({ name: '123invalid', type: 'code', handler: () => {} })
registry.register({ name: 'has-dashes', type: 'code', handler: () => {} })
registry.register({ name: 'has spaces', type: 'code', handler: () => {} })
```

### Type-Specific Validation

```typescript
// Code functions require handler
registry.registerCode({
  name: 'noHandler',
  // Missing handler - throws FunctionValidationError
})

// Generative functions require model and prompt
registry.registerGenerative({
  name: 'noModel',
  prompt: 'Hello'
  // Missing model - throws FunctionValidationError
})

// Agentic functions require model, goal, and tools
registry.registerAgentic({
  name: 'noGoal',
  model: 'gpt-4'
  // Missing goal and tools - throws FunctionValidationError
})

// Human functions require channel and prompt
registry.registerHuman({
  name: 'noChannel',
  prompt: 'Approve?'
  // Missing channel - throws FunctionValidationError
})
```

## Error Handling

```typescript
import {
  FunctionNotFoundError,
  FunctionAlreadyExistsError,
  FunctionValidationError
} from 'dotdo/functions/registry'

try {
  registry.register(config)
} catch (error) {
  if (error instanceof FunctionAlreadyExistsError) {
    console.log('Function already registered:', error.message)
  } else if (error instanceof FunctionValidationError) {
    console.log('Invalid configuration:', error.message)
  }
}

try {
  const fn = registry.getOrThrow('nonexistent')
} catch (error) {
  if (error instanceof FunctionNotFoundError) {
    console.log('Function not found:', error.message)
  }
}
```

## Default Registry

A singleton registry for convenience:

```typescript
import { getDefaultRegistry } from 'dotdo/functions/registry'

// Always returns the same instance
const registry = getDefaultRegistry()

// Register globally
registry.register({ name: 'globalFunction', type: 'code', handler: () => {} })

// Access from anywhere
const fn = getDefaultRegistry().get('globalFunction')
```

## Integration with createFunction

The registry integrates with the `createFunction` factory:

```typescript
import { createFunction } from 'dotdo/functions'
import { createRegistry } from 'dotdo/functions/registry'

const registry = createRegistry()

// Auto-register on creation
const fn = await createFunction({
  name: 'myFunction',
  type: 'code',
  handler: () => 'hello'
}, {
  env: {},
  registry,
  autoRegister: true
})

// Function is now in registry
const found = registry.get('myFunction')
```

## Use Cases

### Function Catalog

```typescript
// Build a catalog of available functions
function buildCatalog(registry: FunctionRegistry) {
  const functions = registry.list().map(name => {
    const fn = registry.get(name)!
    return {
      name: fn.metadata.name,
      type: fn.metadata.type,
      description: fn.metadata.description,
      tags: fn.metadata.tags,
      version: fn.metadata.version,
      deprecated: fn.metadata.deprecated
    }
  })

  return {
    functions,
    stats: registry.getStats()
  }
}
```

### Dynamic Function Loading

```typescript
// Load functions from configuration
async function loadFunctions(configs: FunctionConfig[], registry: FunctionRegistry) {
  for (const config of configs) {
    if (registry.has(config.name)) {
      console.log(`Skipping ${config.name} - already registered`)
      continue
    }

    registry.register(config)
    console.log(`Registered ${config.name}`)
  }
}
```

### Function Routing

```typescript
// Route requests to appropriate function
async function handleRequest(req: Request, registry: FunctionRegistry) {
  const { functionName, input } = await req.json()

  const fn = registry.get(functionName)
  if (!fn) {
    return new Response('Function not found', { status: 404 })
  }

  if (fn.metadata.deprecated) {
    console.warn(`Warning: ${functionName} is deprecated - ${fn.metadata.deprecationMessage}`)
  }

  // Execute function based on type
  return executeFunction(fn.config, input)
}
```

## Related

- [createFunction Factory](/docs/functions/create-function) - Creating functions
- [Function Composition](/docs/functions/composition) - Composing functions
- [Function Middleware](/docs/functions/middleware) - Cross-cutting concerns
- [SDK: Functions](/docs/sdk/functions) - DOFunction type reference
