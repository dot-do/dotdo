/**
 * Type Emitter - Generate .do/types.d.ts from schemas
 *
 * Converts MdxSchema and DOSchema into TypeScript declaration files.
 */

import type { MdxSchema, MdxEntity } from '../../../db/schema/mdx'
import type { DOSchema, DOClassSchema } from '../../../types/introspect'

export interface TypeEmitterOptions {
  /** Include JSDoc comments */
  includeComments?: boolean
  /** Module name for declare module */
  moduleName?: string
}

export interface EmittedTypes {
  /** The generated .d.ts content */
  content: string
  /** Entity names found */
  entities: string[]
  /** Method signatures found */
  methods: string[]
  /** Event types found */
  events: string[]
}

/**
 * Convert MDX field type to TypeScript type
 */
function mdxTypeToTs(type: string): string {
  // Handle array types [->Type]
  if (type.startsWith('[') && type.endsWith(']')) {
    const inner = type.slice(1, -1)
    return `${mdxTypeToTs(inner)}[]`
  }

  // Handle relationship operators
  const operators = ['->', '~>', '<-', '<~']
  for (const op of operators) {
    if (type.startsWith(op)) {
      return type.slice(op.length)
    }
  }

  // Handle code blocks
  if (type.startsWith('`') && type.endsWith('`')) {
    return mdxTypeToTs(type.slice(1, -1))
  }

  // Primitive mappings
  const primitives: Record<string, string> = {
    string: 'string',
    number: 'number',
    boolean: 'boolean',
    Date: 'Date',
    date: 'Date',
    any: 'unknown',
    object: 'Record<string, unknown>',
  }

  return primitives[type] || type
}

/**
 * Generate entity interface from MdxEntity
 */
function emitEntityInterface(name: string, entity: MdxEntity, includeComments: boolean): string {
  const lines: string[] = []

  if (includeComments && entity.description) {
    lines.push(`  /** ${entity.description} */`)
  }

  lines.push(`  export interface ${name} {`)
  lines.push(`    id: string`)

  for (const [fieldName, field] of Object.entries(entity.fields)) {
    const tsType = mdxTypeToTs(field.type)
    if (includeComments && field.description) {
      lines.push(`    /** ${field.description} */`)
    }
    lines.push(`    ${fieldName}: ${tsType}`)
  }

  lines.push(`  }`)

  return lines.join('\n')
}

/**
 * Generate state union type
 */
function emitStateType(name: string, states: string[]): string {
  const stateUnion = states.map((s) => `'${s}'`).join(' | ')
  return `  export type ${name}State = ${stateUnion}`
}

/**
 * Generate event type
 */
function emitEventType(entityName: string, events: string[]): string {
  const lines: string[] = []
  for (const event of events) {
    // Parse event like "Customer.signup" or just "signup"
    const [noun, verb] = event.includes('.') ? event.split('.') : [entityName, event]
    lines.push(`    '${noun ?? entityName}.${verb ?? event}': { ${(noun ?? entityName).toLowerCase()}: ${noun ?? entityName} }`)
  }
  return lines.join('\n')
}

/**
 * Emit types from MDX schema
 */
export function emitFromMdxSchema(schema: MdxSchema, options: TypeEmitterOptions = {}): EmittedTypes {
  const { includeComments = true, moduleName = '@dotdo/client' } = options

  const entities: string[] = []
  const events: string[] = []
  const entityBlocks: string[] = []
  const stateBlocks: string[] = []
  const eventLines: string[] = []

  for (const [name, entity] of Object.entries(schema.entities)) {
    entities.push(name)
    entityBlocks.push(emitEntityInterface(name, entity, includeComments))

    if (entity.states && entity.states.length > 0) {
      stateBlocks.push(emitStateType(name, entity.states))
    }

    if (entity.events && entity.events.length > 0) {
      events.push(...entity.events)
      eventLines.push(emitEventType(name, entity.events))
    }
  }

  const content = `// Auto-generated by dotdo introspect
// Source: ${schema.source}
// Do not edit manually

declare module '${moduleName}' {
  // ============================================================================
  // ENTITIES
  // ============================================================================

${entityBlocks.join('\n\n')}

  // ============================================================================
  // STATE TYPES
  // ============================================================================

${stateBlocks.join('\n\n') || '  // No state types defined'}

  // ============================================================================
  // ENTITY REGISTRY
  // ============================================================================

  export interface Entities {
${entities.map((e) => `    ${e}: ${e}`).join('\n')}
  }

  // ============================================================================
  // EVENTS
  // ============================================================================

  export interface Events {
${eventLines.join('\n') || '    // No events defined'}
  }
}
`

  return {
    content,
    entities,
    methods: [],
    events,
  }
}

/**
 * Emit types from DOSchema (runtime introspection)
 */
export function emitFromDOSchema(schema: DOSchema, options: TypeEmitterOptions = {}): EmittedTypes {
  const { includeComments = true, moduleName = '@dotdo/client' } = options

  const entities: string[] = []
  const methods: string[] = []
  const classBlocks: string[] = []
  const methodLines: string[] = []

  for (const cls of schema.classes) {
    entities.push(cls.name)
    classBlocks.push(emitDOClassInterface(cls, includeComments))

    // Extract methods from tools
    for (const tool of cls.tools) {
      const methodName = `${cls.name}.${tool.name}`
      methods.push(methodName)
      methodLines.push(`    '${methodName}': (input: unknown) => Promise<unknown>`)
    }
  }

  const content = `// Auto-generated by dotdo introspect
// Namespace: ${schema.ns}
// Do not edit manually

declare module '${moduleName}' {
  // ============================================================================
  // DO CLASSES
  // ============================================================================

${classBlocks.join('\n\n')}

  // ============================================================================
  // METHODS
  // ============================================================================

  export interface Methods {
${methodLines.join('\n') || '    // No methods defined'}
  }

  // ============================================================================
  // NOUNS
  // ============================================================================

  export interface Nouns {
${schema.nouns.map((n) => `    ${n.noun}: { singular: '${n.noun}', plural: '${n.plural}' }`).join('\n')}
  }
}
`

  return {
    content,
    entities,
    methods,
    events: [],
  }
}

/**
 * Emit DO class interface
 */
function emitDOClassInterface(cls: DOClassSchema, includeComments: boolean): string {
  const lines: string[] = []

  if (includeComments) {
    lines.push(`  /** DO Class: ${cls.name} (${cls.type}) */`)
  }

  lines.push(`  export interface ${cls.name} {`)
  lines.push(`    id: string`)

  for (const prop of cls.properties) {
    if (includeComments && prop.description) {
      lines.push(`    /** ${prop.description} */`)
    }
    const required = prop.required !== false ? '' : '?'
    lines.push(`    ${prop.name}${required}: ${prop.type}`)
  }

  lines.push(`  }`)

  return lines.join('\n')
}

/**
 * Merge multiple EmittedTypes into one
 */
export function mergeEmittedTypes(types: EmittedTypes[], moduleName = '@dotdo/client'): string {
  const allEntities = new Set<string>()
  const allMethods = new Set<string>()
  const allEvents = new Set<string>()
  const entityBlocks: string[] = []
  const methodLines: string[] = []
  const eventLines: string[] = []

  for (const t of types) {
    for (const e of t.entities) allEntities.add(e)
    for (const m of t.methods) allMethods.add(m)
    for (const ev of t.events) allEvents.add(ev)
  }

  // Extract entity blocks from content (simplified)
  for (const t of types) {
    const match = t.content.match(/\/\/ ENTITIES[\s\S]*?(export interface \w+[\s\S]*?})/g)
    if (match) {
      entityBlocks.push(...match)
    }
  }

  return `// Auto-generated by dotdo introspect
// Do not edit manually

declare module '${moduleName}' {
  export interface Entities {
${Array.from(allEntities)
  .map((e) => `    ${e}: ${e}`)
  .join('\n')}
  }

  export interface Methods {
${Array.from(allMethods)
  .map((m) => `    '${m}': (...args: unknown[]) => Promise<unknown>`)
  .join('\n')}
  }

  export interface Events {
${Array.from(allEvents)
  .map((e) => `    '${e}': unknown`)
  .join('\n')}
  }
}
`
}
