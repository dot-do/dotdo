/**
 * Deploy Command
 *
 * Deploys to multiple targets:
 * - Cloudflare Workers (default)
 * - Vercel Edge Functions
 * - Fly.io
 */

import { Command } from 'commander'
import { createLogger } from '../utils/logger'
import { loadConfigAsync, findProjectRoot } from '../utils/config'
import { spawn } from 'child_process'
import * as fs from 'fs'
import * as path from 'path'

const logger = createLogger('deploy')

type DeployTarget = 'cloudflare' | 'vercel' | 'fly'

interface DeployResult {
  success: boolean
  url?: string
  error?: string
}

/**
 * Deploy to Cloudflare Workers
 */
async function deployCloudflare(): Promise<DeployResult> {
  logger.info('Deploying to Cloudflare Workers...')

  return new Promise((resolve) => {
    const proc = spawn('bunx', ['wrangler', 'deploy'], {
      stdio: 'inherit',
      env: process.env,
    })

    proc.on('exit', (code) => {
      if (code === 0) {
        resolve({ success: true })
      } else {
        resolve({ success: false, error: `wrangler exited with code ${code}` })
      }
    })

    proc.on('error', (error) => {
      resolve({ success: false, error: error.message })
    })
  })
}

/**
 * Generate Vercel configuration
 */
function generateVercelConfig(projectRoot: string): void {
  const vercelConfig = {
    buildCommand: 'bun run build',
    outputDirectory: 'dist',
    framework: null,
    functions: {
      'api/**/*.ts': {
        runtime: 'edge',
      },
    },
  }

  const configPath = path.join(projectRoot, 'vercel.json')
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, JSON.stringify(vercelConfig, null, 2))
    logger.info('Created vercel.json')
  }
}

/**
 * Deploy to Vercel
 */
async function deployVercel(): Promise<DeployResult> {
  logger.info('Deploying to Vercel...')

  const projectRoot = findProjectRoot()
  generateVercelConfig(projectRoot)

  return new Promise((resolve) => {
    const proc = spawn('bunx', ['vercel', '--prod'], {
      stdio: 'inherit',
      env: process.env,
    })

    proc.on('exit', (code) => {
      if (code === 0) {
        resolve({ success: true })
      } else {
        resolve({ success: false, error: `vercel exited with code ${code}` })
      }
    })

    proc.on('error', (error) => {
      resolve({ success: false, error: error.message })
    })
  })
}

/**
 * Generate Fly.io configuration
 */
function generateFlyConfig(projectRoot: string, appName: string): void {
  const flyConfig = `
# fly.toml - Fly.io configuration
# Generated by dotdo CLI

app = "${appName}"
primary_region = "iad"

[build]
  builder = "paketobuildpacks/builder:base"

[env]
  NODE_ENV = "production"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0

[[vm]]
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 256
`.trim()

  const configPath = path.join(projectRoot, 'fly.toml')
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, flyConfig)
    logger.info('Created fly.toml')
  }
}

/**
 * Deploy to Fly.io
 */
async function deployFly(appName?: string): Promise<DeployResult> {
  logger.info('Deploying to Fly.io...')

  const projectRoot = findProjectRoot()
  const name = appName ?? path.basename(projectRoot)
  generateFlyConfig(projectRoot, name)

  return new Promise((resolve) => {
    const proc = spawn('flyctl', ['deploy'], {
      stdio: 'inherit',
      env: process.env,
    })

    proc.on('exit', (code) => {
      if (code === 0) {
        resolve({ success: true })
      } else {
        resolve({ success: false, error: `flyctl exited with code ${code}` })
      }
    })

    proc.on('error', (error) => {
      resolve({ success: false, error: error.message })
    })
  })
}

export const deployCommand = new Command('deploy')
  .description('Deploy to production')
  .option('-t, --target <target>', 'Deploy target (cloudflare, vercel, fly)', 'cloudflare')
  .option('--all', 'Deploy to all configured targets')
  .option('--dry-run', 'Show what would be deployed')
  .option('-n, --name <name>', 'App name (for fly.io)')
  .action(async (options) => {
    const config = await loadConfigAsync()

    // Determine targets
    let targets: DeployTarget[] = []

    if (options.all) {
      // Deploy to all configured targets
      if (config.deploy?.cloudflare !== false) targets.push('cloudflare')
      if (config.deploy?.vercel) targets.push('vercel')
      if (config.deploy?.fly) targets.push('fly')
    } else {
      targets = [options.target as DeployTarget]
    }

    if (targets.length === 0) {
      targets = ['cloudflare'] // Default
    }

    logger.info(`Deploying to: ${targets.join(', ')}`)

    if (options.dryRun) {
      logger.info('Dry run - no actual deployment')
      return
    }

    const results: Record<DeployTarget, DeployResult> = {} as Record<DeployTarget, DeployResult>

    for (const target of targets) {
      switch (target) {
        case 'cloudflare':
          results[target] = await deployCloudflare()
          break
        case 'vercel':
          results[target] = await deployVercel()
          break
        case 'fly':
          results[target] = await deployFly(options.name)
          break
        default: {
          const unknownTarget: string = target
          logger.error(`Unknown target: ${unknownTarget}`)
          ;(results as Record<string, DeployResult>)[unknownTarget] = { success: false, error: `Unknown target: ${unknownTarget}` }
        }
      }
    }

    // Summary
    console.log()
    console.log('Deployment Summary')
    console.log('â”€'.repeat(40))

    let allSuccess = true
    for (const [target, result] of Object.entries(results)) {
      if (result.success) {
        logger.success(`${target}: Deployed successfully`)
        if (result.url) {
          console.log(`  URL: ${result.url}`)
        }
      } else {
        logger.error(`${target}: Failed - ${result.error}`)
        allSuccess = false
      }
    }

    if (!allSuccess) {
      process.exit(1)
    }
  })

export default deployCommand
